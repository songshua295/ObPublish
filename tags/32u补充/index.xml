<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>32u补充 on</title><link>https://ob.tianzhongs.ml/tags/32u%E8%A1%A5%E5%85%85/</link><description>Recent content in 32u补充 on</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://ob.tianzhongs.ml/tags/32u%E8%A1%A5%E5%85%85/index.xml" rel="self" type="application/rss+xml"/><item><title>3201-单例设计模式【补充】</title><link>https://ob.tianzhongs.ml/3201-%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A1%A5%E5%85%85/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/3201-%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A1%A5%E5%85%85/</guid><description>3201-单例设计模式【补充】 单例必须将构造器私有化
单例：只需要一个对象即可
饿汉单例模式 使用情况：
在用类获取对象的时候，对象已经提前为你创建好了（提前创建所需要的对象）
设计步骤 定义一个类，构造器私有化 定义一个静态变量存储这个new的类的对象 1 2 3 4 5 6 7 8 9 10 /** a、定义一个单例类 */ public class SingleInstance { /** c.</description></item><item><title>3202-Calendar日历类使用【补充】</title><link>https://ob.tianzhongs.ml/3202-Calendar%E6%97%A5%E5%8E%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E8%A1%A5%E5%85%85/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/3202-Calendar%E6%97%A5%E5%8E%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E8%A1%A5%E5%85%85/</guid><description>注意，calendar不能直接new对象，需要通过懒汉单例
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 package test; import sun.</description></item><item><title>3203-Lambda表达式</title><link>https://ob.tianzhongs.ml/3203-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/3203-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid><description>3203-Lambda表达式 只能简化函数式接口的匿名内部类的写法
必须是接口，有且只有一个抽象方法 一般这个接口上会加函数式接口的注解@FunctionalInterface 作用
简化匿名内部类的代码写法（Java8的一个新特性)
书写格式 1 2 3 (匿名内部类的被重写的形参列表)-&amp;gt;{ 被重写的方法体; }; 书写格式进一步简化 括号的形参类型可以不写 如果只有一个参数，参数类型可以省略，同时()可以省略 如果Lambda的方法体只有一行代码，可以省略大括号不写，同时需要省略分号； 如果只有一行代码，且是return语句，可以省略return不写，分号也需要省略 实例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 package LambdaTest; import java.</description></item><item><title>3203-正则表达式</title><link>https://ob.tianzhongs.ml/3203-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/3203-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid><description>3203-正则表达式 用于匹配字符规则
1 2 3 4 5 6 7 8 9 10 11 12 package d6_regex; public class RegexTest01 { public static void main(String[] args) { System.</description></item><item><title>3204-二叉树、平衡二叉树、红黑树</title><link>https://ob.tianzhongs.ml/3204-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%BA%A2%E9%BB%91%E6%A0%91/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/3204-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%BA%A2%E9%BB%91%E6%A0%91/</guid><description>3204-二叉树、平衡二叉树、红黑树 二叉树，查找二叉树（可能会变成瘸子，导致一边高一边低）
平衡二叉树 左右子节点的度数不超过1,
[!faq]+ 平衡二叉树添加元素的过程中出现了不平衡怎么解决
左左：右旋 右右：左旋 左右：找到问题子树，将其左旋，然后将根树进行右旋 右左：找到问题子树，将其右旋，然后将根树进行左旋 红黑树 优点：增删改查性能都很好
规则 根节点必须是黑色，每一个节点是红色或者黑色 每一个节点没有子节点或者父节点，就将其设置为黑色的Nil（大致就是null） 红色节点的子节点必须是黑色，不能出现两个红色父子节点相连的情况 每一个节点，从该节点到所有子节点的简单路径上的黑色节点数是相同的</description></item></channel></rss>