<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>23集合 on</title><link>https://ob.tianzhongs.ml/tags/23%E9%9B%86%E5%90%88/</link><description>Recent content in 23集合 on</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://ob.tianzhongs.ml/tags/23%E9%9B%86%E5%90%88/index.xml" rel="self" type="application/rss+xml"/><item><title>2301_集合list概述</title><link>https://ob.tianzhongs.ml/2301_%E9%9B%86%E5%90%88list%E6%A6%82%E8%BF%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2301_%E9%9B%86%E5%90%88list%E6%A6%82%E8%BF%B0/</guid><description>2301_集合list概述 包类: java.util
概述 数组就是以一个集合，但是集合可以容纳不同数据类型的数据 是一个容器，可以一次容纳多个对象 集合存储的是java对象的内存地址，是引用，引用对象本身的内存地址。并不是对象本身。不能存储基本数据类型，也不能存储对象。![[../../../../assets/Pasted image 20220727164431.png]] 不同的集合，底层会对应不同的数据结构，往不同的集合中存储数据，相当于放到了不同的数据结构中 集合分类 Java中集合分为两类：
单个方式存储元素，超级父接口为：java.util.Collection 键值对方式存储元素，超级父接口为：java.util.Map</description></item><item><title>2302集合继承结构图1_Collection</title><link>https://ob.tianzhongs.ml/2302%E9%9B%86%E5%90%88%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84%E5%9B%BE1_Collection/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2302%E9%9B%86%E5%90%88%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84%E5%9B%BE1_Collection/</guid><description>2302集合继承结构图1_Collection 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 classDiagram class Iterable{ &amp;lt;&amp;lt;interface&amp;gt;&amp;gt; +iterator() 所有集合元素都是可以迭代的， 可以遍历的 } class Collection{ &amp;lt;&amp;lt;interface&amp;gt;&amp;gt; Collection } Collection--&amp;gt;Iterator:关联，has a Collection--|&amp;gt;Iterable:泛化，继承，is a class Iterator{ &amp;lt;&amp;lt;interface&amp;gt;&amp;gt; 集合的迭代器对象 +hasNext() +next() +remove() } class List{ &amp;lt;&amp;lt;interface&amp;gt;&amp;gt; 有序可重复 有下标 } %%有序说的是，存进去什么顺序，取出来还是什么顺序，不是大小的排序%% List--|&amp;gt;Collection:泛化 class ArrayList{ 非线程安全 数据结构：数组 } ArrayList.</description></item><item><title>2303集合继承结构图2_Map</title><link>https://ob.tianzhongs.ml/2303%E9%9B%86%E5%90%88%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84%E5%9B%BE2_Map/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2303%E9%9B%86%E5%90%88%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84%E5%9B%BE2_Map/</guid><description>2303集合继承结构图2_Map 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 classDiagram class Map{ &amp;lt;&amp;lt;interface&amp;gt;&amp;gt; } class HashMap{ 非线程安全 数据结构：哈希表 } HashMap.</description></item><item><title>2304_Collection中常用的方法</title><link>https://ob.tianzhongs.ml/2304_Collection%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2304_Collection%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95/</guid><description>2304_Collection中常用的方法 [!faq]+ java.util.collection中能够存放的元素
没有使用泛型，collection中可以存放Object中的所有子类型 使用泛型之后，collection中只能存放某种具体的类型 集合中不能直接存储基本数据类型，也不能存储java对象，存储的只是**java对象的内存地址 eg 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 import java.</description></item><item><title>2305_Collection迭代器的使用Iterator</title><link>https://ob.tianzhongs.ml/2305_Collection%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8Iterator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2305_Collection%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8Iterator/</guid><description>2305_Collection迭代器的使用Iterator [!tip]+ 迭代器遍历步骤
获取集合的迭代器对象itorator Iterator it=xxx.iterator(); 进行迭代器遍历 1 2 3 4 //判断是否有下一个元素，有的话就执行输出，没有就停止循环 while (it.hasNext()){ System.out.println(it.next()); } eg 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import java.</description></item><item><title>2306__Collection的contains</title><link>https://ob.tianzhongs.ml/2306__Collection%E7%9A%84contains/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2306__Collection%E7%9A%84contains/</guid><description>2306__Collection的contains 总结 contains底层调用的是通过equals方法去对内容进行比对，查看查看集合中是否包含，如果是String方法的话，因为已经被重写，所以是比较的字符内容是否包含。 放在集合中的内容，如果要使用contains()或者[[23.07.remove方法|remove()]]，那么必须要重写equals方法 源代码 ![[../../../../assets/Pasted image 20220729090025.png]]
eg 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import java.</description></item><item><title>2307_remove方法</title><link>https://ob.tianzhongs.ml/2307_remove%E6%96%B9%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2307_remove%E6%96%B9%E6%B3%95/</guid><description>2307_remove方法 和contains一样，底层也使用了equals方法去对比，然后删除集合中的对应元素，所以需要重写equals方法 在迭代器迭代的过程中，要使用 迭代器.remove()的方法去删除元，因为集合.remove()会改变集合结构，需要构造new迭代器，不然会出现异常</description></item><item><title>2308_List特有的方法</title><link>https://ob.tianzhongs.ml/2308_List%E7%89%B9%E6%9C%89%E7%9A%84%E6%96%B9%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2308_List%E7%89%B9%E6%9C%89%E7%9A%84%E6%96%B9%E6%B3%95/</guid><description>2308_List特有的方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 import com.</description></item><item><title>2309_ArrayList和Vector</title><link>https://ob.tianzhongs.ml/2309_ArrayList%E5%92%8CVector/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2309_ArrayList%E5%92%8CVector/</guid><description>2309_ArrayList和Vector 属性 ArrayList Vector 默认容量 10 10 扩容容量 1.5倍 2倍 底层 数组 数组 底层 非线程安全 线程安全 优点 检索快 增删快 怎么得到一个线程安全的List： Collections.</description></item><item><title>2310_LinkedList双向链表</title><link>https://ob.tianzhongs.ml/2310_LinkedList%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2310_LinkedList%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</guid><description>2310_LinkedList双向链表 特点 LinkedList没有初始化容量，最初的链表中first和last都是null 增删效率高 不能通过数学表达式计算被查找元素的内存地址，每一次查找都是从头节点开始遍历 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 import javax.</description></item><item><title>2311_LinkedList</title><link>https://ob.tianzhongs.ml/2311_LinkedList/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2311_LinkedList/</guid><description>2311_LinkedList 需要做的： 1. [ ] 手写linkedlist数据结构 2. [ ] 其优点与缺点 3. [ ] 转换成线程安全的方法colllections工具类里面的sync 4. [ ] 泛型机制 5. [ ] 类型自动推断：钻石表达式</description></item><item><title>2311_Vector</title><link>https://ob.tianzhongs.ml/2311_Vector/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2311_Vector/</guid><description>2311_Vector 底层是数组 默认容量10，扩容2倍（ArrayList扩容是1.5倍） 线程安全，但是效率会低 可以采用Collections.synchronizedList(ArrayList);的方法将ArrayList转换为Vector的线程安全 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import java.</description></item><item><title>2312_HashSet和TreeSet</title><link>https://ob.tianzhongs.ml/2312_HashSet%E5%92%8CTreeSet/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2312_HashSet%E5%92%8CTreeSet/</guid><description>2312_HashSet和TreeSet 两个set存入的数据都不会重复 TreeSet存入的数据会自动排序，可排序集合 TreeSet无序可排序，无序值得是存进去和取出来的数据顺序不一样 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import java.</description></item><item><title>2313_Map接口的常用方法</title><link>https://ob.tianzhongs.ml/2313_Map%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2313_Map%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</guid><description>2313_Map接口的常用方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 import java.</description></item><item><title>2314_Map的两种遍历方式</title><link>https://ob.tianzhongs.ml/2314_Map%E7%9A%84%E4%B8%A4%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2314_Map%E7%9A%84%E4%B8%A4%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F/</guid><description>2314_Map的两种遍历方式 Map的两种遍历 Created: July 30, 2022 4:56 PM Tags: 遍历 类别: Map
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 import java.</description></item><item><title>2315_HashMap</title><link>https://ob.tianzhongs.ml/2315_HashMap/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2315_HashMap/</guid><description>2315_HashMap HashMap Created: July 30, 2022 5:18 PM Tags: 实现原理 类别: HashMap
内存图
简述 HashMap：加载因子0.75，默认容量16，初始化容量必须是2的倍数
💡 HashMap类似于由**单向链表组成的数组 数据结构：哈希表** 哈希表的特点： 结合了数组和链表各自的优点，相当于由一个个单向链表组成的数组</description></item><item><title>2316_HashSet重写equals和hashCode方法</title><link>https://ob.tianzhongs.ml/2316_HashSet%E9%87%8D%E5%86%99equals%E5%92%8ChashCode%E6%96%B9%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2316_HashSet%E9%87%8D%E5%86%99equals%E5%92%8ChashCode%E6%96%B9%E6%B3%95/</guid><description>2316_HashSet重写equals和hashCode方法 HashSet重写equals和hashCode方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 import java.</description></item><item><title>2317_HashMap和HashTable的区别</title><link>https://ob.tianzhongs.ml/2317_HashMap%E5%92%8CHashTable%E7%9A%84%E5%8C%BA%E5%88%AB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2317_HashMap%E5%92%8CHashTable%E7%9A%84%E5%8C%BA%E5%88%AB/</guid><description>2317_HashMap和HashTable的区别 HashMap允许key为null，HashTable不允许key和value为null HashTable有线程安全，但是对线程处理效率低，使用较少 HashTable的初始化容量是11，默认加载因子0.75（加载因子：当使用的容量达到这个比率就会进行扩容）；HashMap的初始化容量是16，默认加载因子也是0.75，当链表节点数量大于8，变成红黑树，小于6，变回单向链表 Hashtable的扩容：原容量*2+1</description></item><item><title>2318_Hashtable的Properties属性类</title><link>https://ob.tianzhongs.ml/2318_Hashtable%E7%9A%84Properties%E5%B1%9E%E6%80%A7%E7%B1%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2318_Hashtable%E7%9A%84Properties%E5%B1%9E%E6%80%A7%E7%B1%BB/</guid><description>2318_Hashtable的Properties属性类 帮助文档： Properties
Properties是一个Map集合，继承Hashtable，Properties的key和value都是String类型 被称为属性类对象 两个基本的方法 setProperty()相当于put，getProperty()相当于get
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import java.</description></item><item><title>2319_TreeSet关于排序：实现comparable接口或使用比较器Compartor</title><link>https://ob.tianzhongs.ml/2319_TreeSet%E5%85%B3%E4%BA%8E%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0comparable%E6%8E%A5%E5%8F%A3%E6%88%96%E4%BD%BF%E7%94%A8%E6%AF%94%E8%BE%83%E5%99%A8Compartor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2319_TreeSet%E5%85%B3%E4%BA%8E%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0comparable%E6%8E%A5%E5%8F%A3%E6%88%96%E4%BD%BF%E7%94%A8%E6%AF%94%E8%BE%83%E5%99%A8Compartor/</guid><description>2319_TreeSet关于排序：实现comparable接口或使用比较器Compartor 💡 Comparable和Comparator怎么选择呢？ 当比较规则不会发生改变的时候，或者说**当比较规则只有1个的时候，建议实现Comparable接口。**因为这个要去实现，没下面那个方便，下面那个方便，但是每次都要作为参数传进去 如果比较规则有多个，并且需要多个比较规则之间频繁切换，建议使用Comparator接口。
第一种：实现comparable接口 关于TreeSet自定义类的排序，书写代码时需要注意 继承Comparable接口 override compareTo``方法 有必要的话，把toString方法也override compareTo的比较规则怎么写 通过对象的属性进行比较，比如是String，可以用它本身就实现了的compareTo去进行比较，返回的一个数值能够代表他的数值 通过数值大小比较 使用if结合起来比较 无论怎么写，返回的都是一个数值，通过这个数值进行比较，一般是升序 原因 TreeSet中存入的数据会默认的排序，因为String和Integer都是默认实现了Comparable接口，对排序的规则已经进行了一定，所以不用再写了。 但是，别的自己定义的类，没有定义规则，所以需要实现Comparable接口，不然无法排序，添加节点元素就会报错Customer cannot be cast to java.</description></item><item><title>2320_自平衡二叉树数据结构</title><link>https://ob.tianzhongs.ml/2320_%E8%87%AA%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2320_%E8%87%AA%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid><description>2320_自平衡二叉树数据结构 自平衡二叉树数据结构 原则：遵循左小右大
存放的过程就是排序的过程，取出来就是顺序
三种遍历方式 顺序说的是根的位置
前序遍历：根左右 中序遍历：左根右 TreeSet / TreeMap / Iterator迭代器 后序遍历：左右根 TreeSet和TreeMap采用的是中序遍历
中序表达式画图的例子
取出</description></item><item><title>2321_Collections工具类</title><link>https://ob.tianzhongs.ml/2321_Collections%E5%B7%A5%E5%85%B7%E7%B1%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2321_Collections%E5%B7%A5%E5%85%B7%E7%B1%BB/</guid><description>2321_Collections工具类 基本的使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 import java.</description></item></channel></rss>