<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>06继承 on</title><link>https://ob.tianzhongs.ml/tags/06%E7%BB%A7%E6%89%BF/</link><description>Recent content in 06继承 on</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://ob.tianzhongs.ml/tags/06%E7%BB%A7%E6%89%BF/index.xml" rel="self" type="application/rss+xml"/><item><title>061-继承基本概念</title><link>https://ob.tianzhongs.ml/061-%E7%BB%A7%E6%89%BF%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/061-%E7%BB%A7%E6%89%BF%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</guid><description>061-继承基本概念 重要 除了构造方法，其余的子类都继承，包括实例方法和get set方法都可以继承 在进行重新构造构造器的时候，可以通过super关键字快速完成，this.xx=xxx;的语句，比如
1 2 3 4 5 class A extends B{ public A(String name,int age){ super(name,age); } } 需要注意的是，super语句只能放在构造器内部的第一行</description></item><item><title>062-super关键字</title><link>https://ob.tianzhongs.ml/062-super%E5%85%B3%E9%94%AE%E5%AD%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/062-super%E5%85%B3%E9%94%AE%E5%AD%97/</guid><description>062-super关键字 在继承关系中，由于在子类的构造方法中，第一条语句默认为调用父类的无参构造方法（即默认为 super();，一般这行代码省略了）。
简单的来说，要想使用父类的那个构造方法，就super它的形参按顺序放进来
1 2 3 4 5 6 7 8 9 public class Person { public Person(String name, int age) { } public Person(String name, int age, String sex) { } } z</description></item><item><title>063-什么时候可以使用继承</title><link>https://ob.tianzhongs.ml/063-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E7%BB%A7%E6%89%BF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/063-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E7%BB%A7%E6%89%BF/</guid><description>063-什么时候可以使用继承 凡是可以用“is a”来描述的，都可以考虑采用继承
eg 猪是一个动物 信用卡是一个银行账户 [!注意] 即使两个类中有相同的代码，也不一定要采用继承 比如客户和产品中都有名字，不适合继承的，一是因为不符合常理，难以理解两者的关系，二是因为如果后续在父类中添加字段等等，那么子类也会受到奇怪的牵连</description></item></channel></rss>