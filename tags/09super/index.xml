<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>09super on</title><link>https://ob.doingnothing.online/tags/09super/</link><description>Recent content in 09super on</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://ob.doingnothing.online/tags/09super/index.xml" rel="self" type="application/rss+xml"/><item><title>091_suepr关键字</title><link>https://ob.doingnothing.online/091_suepr%E5%85%B3%E9%94%AE%E5%AD%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.doingnothing.online/091_suepr%E5%85%B3%E9%94%AE%E5%AD%97/</guid><description>091_suepr关键字 重要的结论： 当一个构造方法第一行：既没有this()又没有super()的话，默认会有一个super();表示通过当前子类的构造方法调用父类的无参数构造方法。所以必须保证父类的无参数构造方法是存在的。
super和this this() 通过当前的构造方法去调用“本类”中其它的构造方法 super() 通过当前的构造方法去调用“父类”中的构造方法（相当于把父类的构造方法代码部分复制过来），目的是：创建子类对象的时候，先初始化父类型特征，父类的构造方法是一定会执行的,所以object的构造方法一定会执行 由于this和super都只能出现在构造方法第一行，所以不能同时出现在一个构造方法中 都能出现在实例方法和构造方法中。 不能使用在静态方法中。 目的都是：代码复用。 super后面必须跟.，和this不同，super不保存内存地址，只是表示了父对象的一部分特征，this可以直接打印输出内存地址，而super不行，必须super.xxxx的方式使用，或者super()的方式使用。 [!super()] 表示通过子类的构造方法调用父类的构造方法。 模拟现实世界中的这种场景：要想有儿子，需要先有父亲。 父类的构造方法一定是会执行的</description></item><item><title>092_构造方法执行顺序</title><link>https://ob.doingnothing.online/092_%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.doingnothing.online/092_%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</guid><description>092_构造方法执行顺序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 /* 判断程序的输出结果 1 3 6 5 4 在java语言中不管是是new什么对象，最后老祖宗的Object类的无参数构造方法 一定会执行。（Object类的无参数构造方法是处于“栈顶部”） 栈顶的特点： 最后调用，但是最先执行结束。 后进先出原则。 大家要注意： 以后写代码的时候，一个类的无参数构造方法还是建议大家手动的写出来。 如果无参数构造方法丢失的话，可能会影响到“子类对象的构建”。 */ public class SuperTest02{ public static void main(String[] args){ new C(); } } /* class Object{ public Object(){ } } */ class A extends Object{ static{ System.</description></item><item><title>093_使用super调用父类方法</title><link>https://ob.doingnothing.online/093_%E4%BD%BF%E7%94%A8super%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E6%96%B9%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.doingnothing.online/093_%E4%BD%BF%E7%94%A8super%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E6%96%B9%E6%B3%95/</guid><description>093_使用super调用父类方法 super不仅可以调用父类的属性，还可以调用父类的方法。
super.属性名 访问父类的属性 super.方法名(实参) 访问父类的方法 super(实参) 调用父类的构造方法
eg 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 /* 判断程序的输出结果 1 3 6 5 4 在java语言中不管是是new什么对象，最后老祖宗的Object类的无参数构造方法 一定会执行。（Object类的无参数构造方法是处于“栈顶部”） 栈顶的特点： 最后调用，但是最先执行结束。 后进先出原则。 大家要注意： 以后写代码的时候，一个类的无参数构造方法还是建议大家手动的写出来。 如果无参数构造方法丢失的话，可能会影响到“子类对象的构建”。 */ public class SuperTest02{ public static void main(String[] args){ new C(); } } public static void main(String[] args){ /* Cat move!</description></item></channel></rss>