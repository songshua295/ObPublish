<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>21常用类的使用 on</title><link>https://ob.doingnothing.online/tags/21%E5%B8%B8%E7%94%A8%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/</link><description>Recent content in 21常用类的使用 on</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://ob.doingnothing.online/tags/21%E5%B8%B8%E7%94%A8%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/index.xml" rel="self" type="application/rss+xml"/><item><title>2111_String类</title><link>https://ob.doingnothing.online/2111_String%E7%B1%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.doingnothing.online/2111_String%E7%B1%BB/</guid><description>2111_String类 String基本 [!tip]+ 关于Java JDK中内置的一个类：java.lang.String
String表示字符串，属于引用数据类型，不属于基本数据类型。 在java中随便使用双引号括起来的都是String对象。例如：&amp;ldquo;abc&amp;rdquo;，&amp;ldquo;def&amp;rdquo;，&amp;ldquo;hello world!&amp;quot;，这是3个String对象。 java中规定，双引号括起来的字符串，是不可变的，也就是说&amp;quot;abc&amp;quot;自出生到最终死亡，不可变，不能变成&amp;quot;abcd&amp;rdquo;，也不能变成&amp;quot;ab&amp;quot; 在JDK当中双引号括起来的字符串，例如：&amp;ldquo;abc&amp;rdquo; &amp;ldquo;def&amp;quot;都是直接存储在“方法区”的“字符串常量池”当中的。因为这些字符串需要频繁的进行使用,垃圾回收器是不会回收常量的 不管是直接用双引号定义的字符串变量,还是new出来的字符串,双引号字符串都是存储在方法区中的常量池的,new出来的,会在堆中存放一个指向这个常量池的内存地址 eg1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class StringTest01 { public static void main(String[] args) { // 这两行代码表示底层创建了3个字符串对象，都在字符串常量池当中。 String s1 = &amp;#34;abcdef&amp;#34;; String s2 = &amp;#34;abcdef&amp;#34; + &amp;#34;xy&amp;#34;; // 分析：这是使用new的方式创建的字符串对象。这个代码中的&amp;#34;xy&amp;#34;是从哪里来的？ // 凡是双引号括起来的都在字符串常量池中有一份。 // new对象的时候一定在堆内存当中开辟空间。 String s3 = new String(&amp;#34;xy&amp;#34;); // i变量中保存的是100这个值。 int i = 100; // s变量中保存的是字符串对象的内存地址。 // s引用中保存的不是&amp;#34;abc&amp;#34;，是0x1111 // 而0x1111是&amp;#34;abc&amp;#34;字符串对象在“字符串常量池”当中的内存地址。 String s = &amp;#34;abc&amp;#34;; } } !</description></item><item><title>2112_String常用方法</title><link>https://ob.doingnothing.online/2112_String%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.doingnothing.online/2112_String%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</guid><description>2112_String常用方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 public class Test03 { public static void main(String[] args) { //charAt 返回字符串指定下标的字符 String a=&amp;#34;我是一个中国人&amp;#34;; System.</description></item><item><title>2113_字符串拼接StringBuffer</title><link>https://ob.doingnothing.online/2113_%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5StringBuffer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.doingnothing.online/2113_%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5StringBuffer/</guid><description>2113_字符串拼接StringBuffer 在java.lang中 帮助文档 : https://www.matools.com/file/manual/jdk_api_1.8_google/java/lang/StringBuffer.html
概述 [!tip]+ 使用原因
使用+号来对字符串拼接,会在方法区常量池中占用大量的内存,造成方法区的压力(每次拼接都会新建一个字符串在常量池中) 使用StringBuffer可以创建字符串缓冲区对象,缓解常量池压力 默认是创建16byte的数组作为字符串缓冲区对象![[../../../../assets/Pasted image 20220723102153.png]] ![[../../../../assets/Pasted image 20220723102210.png]] [!</description></item><item><title>2114_字符串拼接StringBuilder</title><link>https://ob.doingnothing.online/2114_%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5StringBuilder/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.doingnothing.online/2114_%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5StringBuilder/</guid><description>2114_字符串拼接StringBuilder 帮助文档: StringBuilder
StringBuilder和[[214.字符串拼接StringBuffer|StringBuffer]]的区别 StringBuilder没有synchronized关键字修饰,所以在多线程环境下是不安全的,而**[[214.字符串拼接StringBuffer|StringBuffer]]在多线程下是安全的** (StringBuilder非线程安全,StringBuffer线程安全) 1 2 3 4 5 6 7 8 9 public class StringBuilderTest01 { public static void main(String[] args) { StringBuilder s1=new StringBuilder(100);//初始化容量 s1.</description></item><item><title>2116_String_int_Integer之间的相互转换</title><link>https://ob.doingnothing.online/2116_String_int_Integer%E4%B9%8B%E9%97%B4%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.doingnothing.online/2116_String_int_Integer%E4%B9%8B%E9%97%B4%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/</guid><description>2116_String_int_Integer之间的相互转换 ![[../assets/7d832e5816d04e45b9b398ef72c9db4b.png]]
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class Test04 { public static void main(String[] args) { //String --&amp;gt; int String s1=&amp;#34;123&amp;#34;; int i1=Integer.</description></item><item><title>2121_java对日期的处理</title><link>https://ob.doingnothing.online/2121_java%E5%AF%B9%E6%97%A5%E6%9C%9F%E7%9A%84%E5%A4%84%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.doingnothing.online/2121_java%E5%AF%B9%E6%97%A5%E6%9C%9F%E7%9A%84%E5%A4%84%E7%90%86/</guid><description>2121_java对日期的处理 获取时间以及时间相互转换 包名:- java.util.Date 帮助文档:https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/Date.html
日期格式化SimpleDateFormat帮助文档:https://www.matools.com/file/manual/jdk_api_1.8_google/java/text/SimpleDateFormat.html
获取当前时间 对时间进行格式化输出 文本转换成Date格式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import java.</description></item><item><title>2131_关于数字的格式化</title><link>https://ob.doingnothing.online/2131_%E5%85%B3%E4%BA%8E%E6%95%B0%E5%AD%97%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.doingnothing.online/2131_%E5%85%B3%E4%BA%8E%E6%95%B0%E5%AD%97%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96/</guid><description>2131_关于数字的格式化 java.text.DecimalFormat 作用 对数字进行格式化,添加千分位,补位等等 包:https://www.matools.com/file/manual/jdk_api_1.8_google/java/text/DecimalFormat.html eg:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import java.</description></item></channel></rss>