<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>JDBC on</title><link>https://ob.doingnothing.online/tags/JDBC/</link><description>Recent content in JDBC on</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://ob.doingnothing.online/tags/JDBC/index.xml" rel="self" type="application/rss+xml"/><item><title>0000_总结基本要点</title><link>https://ob.doingnothing.online/0000_%E6%80%BB%E7%BB%93%E5%9F%BA%E6%9C%AC%E8%A6%81%E7%82%B9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.doingnothing.online/0000_%E6%80%BB%E7%BB%93%E5%9F%BA%E6%9C%AC%E8%A6%81%E7%82%B9/</guid><description>0000_总结基本要点 jdbc的作用，是啥 jdbc开发的步骤：导包jar， 开发6部分 为了避免sql注入，statement以及PreparedStatement使用的区别 使用资源绑定器，采用类反射机制等等，降低程序耦合度，可以通过配置文件来修改相应的设置等等 0007 通过资源绑定器获取属性文件 事物机制</description></item><item><title>0001_JDBC基本概念</title><link>https://ob.doingnothing.online/0001_JDBC%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.doingnothing.online/0001_JDBC%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</guid><description>0001_JDBC基本概念 Java DataBase Connectivity（Java语言连接数据库）
JDBC的本质是什么？
JDBC是SUN公司制定的一套接口（interface）java.sql.\*; (这个软件包下有很多接口。) 面向接口编程可以降低程序耦合度，提高程序扩展力，多态机制就是典型的抽象编程。（Animal a=new CAt();） sun制定JDBC接口的原因：
每一个数据库的底层实现原理不一样，每一个产品有自己独特的实现原理，所以就需要数据库产品自己去写jdbc中接口的实现方式，供用户调用。</description></item><item><title>0002_JDBC开发基本使用</title><link>https://ob.doingnothing.online/0002_JDBC%E5%BC%80%E5%8F%91%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.doingnothing.online/0002_JDBC%E5%BC%80%E5%8F%91%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</guid><description>0002_JDBC开发基本使用 开发前的准备 在对应的数据库官网下载jar包（这个jar中包括了的jdbc接口的具体实现方式） 如果是cmd窗口运行的话，就需要将其配置到 环境变量classpath中，一般需要设置两个东西，一个是.，表示当前路径，一个是jar包的具体位置，比如C:\Users\22305\Documents\MySql Connector Java 5.1.23\mysql-connector-java-5.1.23-bin.jar () 如果是idea的话，就需要导包，具体方法为两种 File&amp;ndash;&amp;gt;Project Structure&amp;mdash;Moudles&amp;ndash;&amp;gt;选择你对应的模块，然后在右侧的编辑窗口中点击+号，选择对应的jar包&amp;ndash;&amp;gt;导入之后，勾选上&amp;mdash;-&amp;gt;点击应用即可</description></item><item><title>0003_JDBC开发6步</title><link>https://ob.doingnothing.online/0003_JDBC%E5%BC%80%E5%8F%916%E6%AD%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.doingnothing.online/0003_JDBC%E5%BC%80%E5%8F%916%E6%AD%A5/</guid><description>0003_JDBC开发6步 注册驱动，两种方式 获取连接 建立SQL数据库操作对象 执行SQL语句 处理结果集 释放资源（java与数据库之间属于进程之间的通信）（一般在finally语句中，编辑的时候建议需要关闭的对象放在try外面设置为null，之后，释放资源代码写了之后再开始选择编辑）</description></item><item><title>0004_Statement和PreparedStatement的区别</title><link>https://ob.doingnothing.online/0004_Statement%E5%92%8CPreparedStatement%E7%9A%84%E5%8C%BA%E5%88%AB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.doingnothing.online/0004_Statement%E5%92%8CPreparedStatement%E7%9A%84%E5%8C%BA%E5%88%AB/</guid><description>0004_Statement和PreparedStatement的区别 Statement存在SQL注入问题，而PreparedStatement解决了SQL注入问题 Statement存在安全编译时的类型检查问题，而PreparedStetement因为是采用setxxx的方式，可以在编译的时候做安全检查 Statement每次执行都需要编译一次，PreparedStatement编译一次，执行多次。 PreparedStatement因为是先发送给DBMS一个sql语句架子，DMBS进行了编译，然后再通过setxxx进行传值，最后再执行。以后每一次执行，PreparedStatement就不会再编译了，传值就可以直接传值执行，所以PreParedStatement执行效率更高。 综合：PreparedStatement使用较多
使用PreparedStatement之后传值，值中的特殊符号都会转义，所以避免了sql注入
1 com.mysql.jdbc.JDBC4PreparedStatement@5ce81285:select*fromt_userwhereloginName=&amp;#39;z&amp;#39;andloginPassword=&amp;#39;z\&amp;#39;or\&amp;#39;1\&amp;#39;=\&amp;#39;1&amp;#39; 什么时候采用Statement，需要用户注入sql语句的时候就需要用到，或者不包括安全问题的时候也可以用，参数不用单引号引起来的也需要用到</description></item><item><title>0005_JDBC案例：给SQL数据库插入数据</title><link>https://ob.doingnothing.online/0005_JDBC%E6%A1%88%E4%BE%8B%E7%BB%99SQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.doingnothing.online/0005_JDBC%E6%A1%88%E4%BE%8B%E7%BB%99SQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE/</guid><description>0005_JDBC案例：给SQL数据库插入数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 import java.</description></item><item><title>0006_采用`Class.forName`方式注册驱动</title><link>https://ob.doingnothing.online/0006_%E9%87%87%E7%94%A8Class.forName%E6%96%B9%E5%BC%8F%E6%B3%A8%E5%86%8C%E9%A9%B1%E5%8A%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.doingnothing.online/0006_%E9%87%87%E7%94%A8Class.forName%E6%96%B9%E5%BC%8F%E6%B3%A8%E5%86%8C%E9%A9%B1%E5%8A%A8/</guid><description>0006_采用Class.forName方式注册驱动 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 import java.</description></item><item><title>0007_通过资源绑定器获取属性文件</title><link>https://ob.doingnothing.online/0007_%E9%80%9A%E8%BF%87%E8%B5%84%E6%BA%90%E7%BB%91%E5%AE%9A%E5%99%A8%E8%8E%B7%E5%8F%96%E5%B1%9E%E6%80%A7%E6%96%87%E4%BB%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.doingnothing.online/0007_%E9%80%9A%E8%BF%87%E8%B5%84%E6%BA%90%E7%BB%91%E5%AE%9A%E5%99%A8%E8%8E%B7%E5%8F%96%E5%B1%9E%E6%80%A7%E6%96%87%E4%BB%B6/</guid><description>0007_通过资源绑定器获取属性文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 import java.</description></item><item><title>0008_完成第五步，处理结果集</title><link>https://ob.doingnothing.online/0008_%E5%AE%8C%E6%88%90%E7%AC%AC%E4%BA%94%E6%AD%A5%E5%A4%84%E7%90%86%E7%BB%93%E6%9E%9C%E9%9B%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.doingnothing.online/0008_%E5%AE%8C%E6%88%90%E7%AC%AC%E4%BA%94%E6%AD%A5%E5%A4%84%E7%90%86%E7%BB%93%E6%9E%9C%E9%9B%86/</guid><description>0008_完成第五步，处理结果集 #书写注意点 在集合中的resultSet.getInt()等方法中的参数，select语句中有as的话，填写的是as之后的字段，而不是sql语句中的原有字段名称
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 import java.</description></item><item><title>0009_案例：连接数据库，验证用户登录(可被sql注入）</title><link>https://ob.doingnothing.online/0009_%E6%A1%88%E4%BE%8B%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E9%AA%8C%E8%AF%81%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E5%8F%AF%E8%A2%ABsql%E6%B3%A8%E5%85%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.doingnothing.online/0009_%E6%A1%88%E4%BE%8B%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E9%AA%8C%E8%AF%81%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E5%8F%AF%E8%A2%ABsql%E6%B3%A8%E5%85%A5/</guid><description>0009_案例：连接数据库，验证用户登录(可被sql注入） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 import java.</description></item><item><title>0010_解决sql注入问题的PreparedStatement</title><link>https://ob.doingnothing.online/0010_%E8%A7%A3%E5%86%B3sql%E6%B3%A8%E5%85%A5%E9%97%AE%E9%A2%98%E7%9A%84PreparedStatement/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.doingnothing.online/0010_%E8%A7%A3%E5%86%B3sql%E6%B3%A8%E5%85%A5%E9%97%AE%E9%A2%98%E7%9A%84PreparedStatement/</guid><description>0010_解决sql注入问题的PreparedStatement 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 import java.</description></item><item><title>0011_事务机制</title><link>https://ob.doingnothing.online/0011_%E4%BA%8B%E5%8A%A1%E6%9C%BA%E5%88%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.doingnothing.online/0011_%E4%BA%8B%E5%8A%A1%E6%9C%BA%E5%88%B6/</guid><description>0011_事务机制 事务机制的作用 JDBC中默认事务机制是：执行一条，提交一条。 但是在实际应用开发中，有时候需要多条DML语句共同联合完成或者失败来决定是否提交到数据库，所以就需要事物机制。 比如：转账，需要两个语句中的转出和转入都要成功，或者总共的钱就会有缺失或者多余
关闭事物提交：获取连接的对象.setAutoCommit(true); 进行提交：xx.commit(); 回滚：xx.rollback();一般写在异常中，用于DML语句中出现了异常就回滚事务
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 import jdbc.</description></item><item><title>0012_JBMC封装类</title><link>https://ob.doingnothing.online/0012_JBMC%E5%B0%81%E8%A3%85%E7%B1%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.doingnothing.online/0012_JBMC%E5%B0%81%E8%A3%85%E7%B1%BB/</guid><description>0012_JBMC封装类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 package jdbc; import java.</description></item><item><title>0013_MySQL数据库相关的基本使用</title><link>https://ob.doingnothing.online/0013_MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.doingnothing.online/0013_MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</guid><description>0013_MySQL数据库相关的基本使用 准备MySQL 安装MySQL，老是出现安不上的问题，nt软件，重新多安几次
Navicat的基本使用 没啥说的
设计数据库表 下载PowerDesigner工具 打开之后，选择create model&amp;ndash;&amp;gt;model types&amp;ndash;&amp;gt;physical data model 在下面的DBMS中选择mysql的对应版本，比如mysql5.0 ，点击ok 设计表 保存sql脚本,你可以将保存的sql脚本继续进行优化修改 cmd登录mysql后，可以采用source xxx.</description></item><item><title>0014_悲观锁（行级锁）以及乐观锁基本认识</title><link>https://ob.doingnothing.online/0014_%E6%82%B2%E8%A7%82%E9%94%81%E8%A1%8C%E7%BA%A7%E9%94%81%E4%BB%A5%E5%8F%8A%E4%B9%90%E8%A7%82%E9%94%81%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.doingnothing.online/0014_%E6%82%B2%E8%A7%82%E9%94%81%E8%A1%8C%E7%BA%A7%E9%94%81%E4%BB%A5%E5%8F%8A%E4%B9%90%E8%A7%82%E9%94%81%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86/</guid><description>0014_悲观锁（行级锁）以及乐观锁基本认识 悲观锁： select语句后面加上for update 比如
1 2 3 selectcnamefromdeptwhereno=12forupdate`那么查询出来的数据，就会被加锁，直到释放之前，都不能都被别的线程使用修改简单的理解就是：线程同步锁，嘎嘎好理解 查询出出来的语句会被锁上，别的线程无法修改其中的数据 事务需要排队执行，类似于同步线程，要修改的数据需要事务一个一个的排队
乐观锁 支持并发，需要修改的数据，每次读取都有一个版本号 事务不需要排队，每次读取都有一个版本号（比如1.1），提交的时候核对版本号是否和读取的一样（1.1） 一样就提交，并修改成新的版本号（1.2） 不一样就回滚，不提交，重新读取</description></item></channel></rss>