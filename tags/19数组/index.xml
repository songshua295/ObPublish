<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>19数组 on</title><link>https://ob.doingnothing.online/tags/19%E6%95%B0%E7%BB%84/</link><description>Recent content in 19数组 on</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://ob.doingnothing.online/tags/19%E6%95%B0%E7%BB%84/index.xml" rel="self" type="application/rss+xml"/><item><title>191_数组</title><link>https://ob.doingnothing.online/191_%E6%95%B0%E7%BB%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.doingnothing.online/191_%E6%95%B0%E7%BB%84/</guid><description>191_数组 概述 Java语言中的数组是一种引用数据类型。不属于基本数据类型。数组的父类是Object。 数组可以同时容纳多个元素。（数组是一个数据的集合。） 数组当中可以存储“基本数据类型”的数据，也可以存储“引用数据类型”的数据。 数组因为是引用类型，数组是存储在堆中的 数组当中如果存储的是“java对象”的话，实际上存储的是对象的引用（内存地址），数组中不能直接存储java对象。 数组一旦创建，数组长度不可变 数组的分类：一维数组. 二维数组. 三维数组. 多维数组&amp;hellip;（一维数组较多，二维数组偶尔使用！） 采用length用来获取数组中元素的个数。 java中的数组要求数组中元素的类型统一。比如int类型数组只能存储int类型，Person类型数组只能存储Person类型。 例如：超市购物，购物袋中只能装苹果，不能同时装苹果和橘子。（数组中存储的元素类型统一） 数组在内存方面存储的时候，存储的每一个元素都是连续的，内存地址连续。数组实际上是一种简单的数据结构。 11.数组中首元素的内存地址作为整个数组对象的内存地址。 数组中每一个元素都是有下标的，下标从0开始，以1递增。最后一个元素的下标是length - 1 存取元素都是通过下标来进行的。 [!</description></item><item><title>192_main方法上面的String_args</title><link>https://ob.doingnothing.online/192_main%E6%96%B9%E6%B3%95%E4%B8%8A%E9%9D%A2%E7%9A%84String_args/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.doingnothing.online/192_main%E6%96%B9%E6%B3%95%E4%B8%8A%E9%9D%A2%E7%9A%84String_args/</guid><description>192_main方法上面的String_args [!tip]+ 作用 这个数组是留给用户的，用户可以在控制台上输入参数，这个参数自动会被转换为“String[] args”
解释 JVM调用main方法的时候，会自动传一个String数组过来。 这个方法程序员负责写出来，JVM负责调用。JVM调用的时候一定会传一个String数组过来。 默认长度：0 ! [[../../../../assets/Pasted image 20220715192618.png|400]]
输入参数 输入会变成一个数组，空格分开各个参数，不是逗号 第一种： 1. 打开run的这个 !</description></item><item><title>193_引用数据类型数组</title><link>https://ob.doingnothing.online/193_%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%95%B0%E7%BB%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.doingnothing.online/193_%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%95%B0%E7%BB%84/</guid><description>193_引用数据类型数组 [!info]+ 总结 数组中可以将引用类型的类型实例作为元素 元素可以是这个元素的类本身的对象，也可以是他的继承对象，即子类型的对象 还可以通过遍历的方式去使用其中的方法
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 public class Test03 { public static void main(String[] args) { // 创建一个Animal类型的数组 Animal[] an={new Animal(),new Cat(),new Dog(),new DogSon()}; for (int i=0;i&amp;lt;an.</description></item><item><title>194_数组扩容</title><link>https://ob.doingnothing.online/194_%E6%95%B0%E7%BB%84%E6%89%A9%E5%AE%B9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.doingnothing.online/194_%E6%95%B0%E7%BB%84%E6%89%A9%E5%AE%B9/</guid><description>194_数组扩容 先新建一个大容量的数组，然后将小容量数组中的数据一个一个拷贝到大数组当中。
[!tip]+ 注意 如果数组的元素是引用，那么数组中存储的其对象的内存地址 所以，拷贝的时候实际是拷贝的内存地址
结论：数组扩容效率较低。因为涉及到拷贝的问题。所以在以后的开发中请注意：尽可能少的进行数组的拷贝。 可以在创建数组对象的时候预估计以下多长合适，最好预估准确，这样可以减少数组的扩容次数。提高效率。
[!bug]+ 数组拷贝方法：arrarycopy() arraycopy() 方法位于 java.lang.System 类中
语法格式
1 System.</description></item><item><title>195_二维数组</title><link>https://ob.doingnothing.online/195_%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.doingnothing.online/195_%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/</guid><description>195_二维数组 概述 二维数组其实是一个特殊的一维数组，特殊在这个数组当中的每一个元素是一个一维数组。 三维数组同理，每一个元素都是一个二维数组 初始化 静态初始化 1 int[][] array = {{1,1,1},{2,3,4,5},{0,0,0,0},{2,3,4,5},{2,3,4,5},{2,3,4,5},{2,3,4,5}}; 动态初始化 1 nt[][] array = new int[3][4]; [!</description></item><item><title>196_eg1_模拟压栈</title><link>https://ob.doingnothing.online/196_eg1_%E6%A8%A1%E6%8B%9F%E5%8E%8B%E6%A0%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.doingnothing.online/196_eg1_%E6%A8%A1%E6%8B%9F%E5%8E%8B%E6%A0%88/</guid><description>196_eg1_模拟压栈 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 /* 编写程序，使用一维数组，模拟栈数据结构。 要求： 1、这个栈可以存储java中的任何引用类型的数据。 2、在栈中提供push方法模拟压栈。（栈满了，要有提示信息。） 3、在栈中提供pop方法模拟弹栈。（栈空了，也有有提示信息。） 4、编写测试程序，new栈对象，调用push pop方法来模拟压栈弹栈的动作。 5、假设栈的默认初始化容量是10.</description></item><item><title>197_eg2_酒店</title><link>https://ob.doingnothing.online/197_eg2_%E9%85%92%E5%BA%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.doingnothing.online/197_eg2_%E9%85%92%E5%BA%97/</guid><description>197_eg2_酒店 思路 [!tip]+ 怎么个思路
搭建一个酒店，需要考虑其基本的组成 一个酒店的基本单位是房间，所以需要一个room类，房间有三个状态。 房间号，由层数和房间号组成 空闲与否，boolean 房间类型：单人间、标准间、豪华间 房间需要考虑是否是一个房间，以及如何进行输出。所以需要考虑重写equals和toString方法 hotel类由许多的房间组成，所以hotel的属性就是room类型的二维数组 需要的方法 打印房间情况的方法 订房的方法 退房的方法 一个主类对方法进行测试 建酒店，new 一个hotel if判断用户需求 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 public class Room { //test /* public static void main(String[] args) { Room r=new Room(12,&amp;#34;单人间&amp;#34;,true); System.</description></item></channel></rss>