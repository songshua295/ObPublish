<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>08遗留问题 on</title><link>https://ob.doingnothing.online/tags/08%E9%81%97%E7%95%99%E9%97%AE%E9%A2%98/</link><description>Recent content in 08遗留问题 on</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://ob.doingnothing.online/tags/08%E9%81%97%E7%95%99%E9%97%AE%E9%A2%98/index.xml" rel="self" type="application/rss+xml"/><item><title>081_静态方法不存在方法覆盖</title><link>https://ob.doingnothing.online/081_%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%8D%E5%AD%98%E5%9C%A8%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.doingnothing.online/081_%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%8D%E5%AD%98%E5%9C%A8%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96/</guid><description>081_静态方法不存在方法覆盖 对象之间，有了继承之后，才有方法的覆盖和多态。 方法覆盖只是针对于“实例方法”，“静态方法”没有方法意义，因为其与对象无关，只和类有关。
code
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 package a008遗留问题; import a007方法覆盖和多态.</description></item><item><title>082_私有方法无法覆盖</title><link>https://ob.doingnothing.online/082_%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95%E6%97%A0%E6%B3%95%E8%A6%86%E7%9B%96/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.doingnothing.online/082_%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95%E6%97%A0%E6%B3%95%E8%A6%86%E7%9B%96/</guid><description>082_私有方法无法覆盖 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package a008遗留问题; public class A { private void do(){ System.</description></item><item><title>083_关于方法覆盖时的返回值类型</title><link>https://ob.doingnothing.online/083_%E5%85%B3%E4%BA%8E%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96%E6%97%B6%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.doingnothing.online/083_%E5%85%B3%E4%BA%8E%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96%E6%97%B6%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B/</guid><description>083_关于方法覆盖时的返回值类型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 public class OverrideTest07{ public static void main(String[] args){ // 一般重写的时候都是复制粘贴。不要动。不要改。 } } class Animal{ /* public double sum(int a, int b){ return a + b; } */ /* public long sum(int a, int b){ return a + b; } */ /* public int sum(int a, int b){ return a + b; } */ } class Cat extends Animal{ // 重写 // 错误: Cat中的sum(int,int)无法覆盖Animal中的sum(int,int) /* public int sum(int a, int b){ return a + b; } */ /* public double sum(int a, int b){ return a + b; } */ //错误: Cat中的sum(int,int)无法覆盖Animal中的sum(int,int) /* public long sum(int a, int b){ return a + b; } */ } // 父类 class MyClass1{ public Animal getAnimal(){ return null; } } // 子类 class MyClass2 extends MyClass1{ // 重写父类的方法 /* public Animal getAnimal(){ return null; } */ // 重写的时候返回值类型由Animal变成了Cat，变小了。（可以，java中允许） /* public Cat getAnimal(){ return null; } */ // 重写的时候返回值类型由Animal变成了Object。变大了。（不行，java中不允许） /* public Object getAnimal(){ return null; } */ } 结论：学习了多态之后你会发现 方法覆盖的返回值类型在基本数据类型必须一样，而在引用类型中（就是你class的那些类的对象），可以是你class的子类树上的类</description></item></channel></rss>