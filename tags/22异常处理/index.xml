<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>22异常处理 on</title><link>https://ob.tianzhongs.ml/tags/22%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</link><description>Recent content in 22异常处理 on</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://ob.tianzhongs.ml/tags/22%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/index.xml" rel="self" type="application/rss+xml"/><item><title>221_异常</title><link>https://ob.tianzhongs.ml/221_%E5%BC%82%E5%B8%B8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/221_%E5%BC%82%E5%B8%B8/</guid><description>221_异常 帮助文档:https://www.matools.com/file/manual/jdk_api_1.8_google/java/lang/Exception.html
概述 异常是一种类,[[#eg2 new异常对象|可以new对象]] 通过处理异常,增加程序的健壮性 eg1 1 2 3 4 5 6 7 8 public class Test01 { public static void main(String[] args) { int c=10/0; /* 代码执行到此处,会出现异常,然后 就会new一个异常对象:Exception in thread &amp;#34;main&amp;#34; java.</description></item><item><title>222_UML_统一建模语言</title><link>https://ob.tianzhongs.ml/222_UML_%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/222_UML_%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/</guid><description>222_UML_统一建模语言 语法来源 使用Mermaid创建类图 帮助文档:http://soft.xiaoshujiang.com/docs/grammar/feature/mermaid/#e7b1bbe59bbe_36 建议博客版本:https://www.cnblogs.com/mybdss/p/14958781.html
[[使用Mermaid语法画UML类图]]</description></item><item><title>223_异常的继承结构</title><link>https://ob.tianzhongs.ml/223_%E5%BC%82%E5%B8%B8%E7%9A%84%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/223_%E5%BC%82%E5%B8%B8%E7%9A%84%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84/</guid><description>223_异常的继承结构 总结 编译阶段异常是不会出现的,编译时异常和运行时异常都是发生在运行阶段 因为异常需要new对象,只有程序运行才会new对象 编译时异常是因为必须在编写代码阶段预先处理,不然编译器就会报错而得名 Object下有Throwable(可抛出) Throwable下有两个分支: Error:错误,不可以处理,终止程序执行,直接退出JVM Exception:异常,可以处理 尽量避免Error,在Exception时就对其进行处理 编译时异常发生概率相对较高 继承结构图 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 classDiagram Object&amp;lt;|--Throwable Throwable:不管是错误还是异常,都是可以抛出的 Throwable&amp;lt;|--Error Error:所有的错误只要发生,java程序都会终止执行,退出JVM Error&amp;lt;|--IOError Error&amp;lt;|--VirtualMachineError Throwable&amp;lt;|--Exception Exception&amp;lt;|--ExceptionSubClass:编译时异常 ExceptionSubClass:不是编译时发生的 ExceptionSubClass:编写程序的时候事先对其进行异常处理 ExceptionSubClass:如果不处理,编译器就会报错 Exception&amp;lt;|--RuntimeException:运行时异常 RuntimeException:运行时异常, RuntimeException:你可以处理,也可以不处理 RuntimeException&amp;lt;|--NullPointerException RuntimeException&amp;lt;|--ClassCastException RuntimeException&amp;lt;|--IllegalArgumentException IllegalArgumentException&amp;lt;|--NumberFormatException %% 写起来还是挺简单的</description></item><item><title>224_异常处理的原理</title><link>https://ob.tianzhongs.ml/224_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E5%8E%9F%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/224_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E5%8E%9F%E7%90%86/</guid><description>224_异常处理的原理 [!tip]+ 强调 所有异常都是发生在运行阶段.
异常处理方法 java对异常的处理有两种方式: 上抛(上报)和捕获
[!tip]+ 异常的两种处理方式
在方法声明的位置上,使用throws关键字,抛给上一级,谁调用我,就抛给谁 [[#eg1 第一种异常处理 添加throws关键字]] 使用try{} catch{}语句进行异常捕获,异常发生了,谁都不知道,但是我抓住了. 相关: [[#第二种异常处理 使用try catch捕获异常]] [[225.</description></item><item><title>225_异常对象的常用方法</title><link>https://ob.tianzhongs.ml/225_%E5%BC%82%E5%B8%B8%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/225_%E5%BC%82%E5%B8%B8%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</guid><description>225_异常对象的常用方法 1 2 3 4 //获取异常的描述信息 String msg=excepiton.getMessage(); //打印异常的堆栈信息 exception.printStackTrace(); 使用printStackTrace不会让程序停止,只是输出堆栈异常信息,程序很健壮
eg1 1 2 3 4 5 6 7 public class Test05 { public static void main(String[] args) { NullPointerException e=new NullPointerException(&amp;#34;空指针异常~&amp;#34;); String msg=e.</description></item><item><title>226_finally语句</title><link>https://ob.tianzhongs.ml/226_finally%E8%AF%AD%E5%8F%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/226_finally%E8%AF%AD%E5%8F%A5/</guid><description>226_finally语句 finally语句通常用于释放资源,这非常有必要. finally中的语句是一定会执行的,除非你退出JVMSystem.exe(0); finally可以不要catch,只要try finally 即使try里面有return,finally中的语句依然会执行 try不能单独使用 ![[225.异常对象的常用方法#eg2]] eg第三点 1 2 3 4 5 6 7 8 9 10 public class Test07 { public static void main(String[] args) { try { System.</description></item><item><title>227_finally面试题</title><link>https://ob.tianzhongs.ml/227_finally%E9%9D%A2%E8%AF%95%E9%A2%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/227_finally%E9%9D%A2%E8%AF%95%E9%A2%98/</guid><description>227_finally面试题 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 package com.</description></item><item><title>228_final,finally,finalize()的区别</title><link>https://ob.tianzhongs.ml/228_finalfinallyfinalize%E7%9A%84%E5%8C%BA%E5%88%AB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/228_finalfinallyfinalize%E7%9A%84%E5%8C%BA%E5%88%AB/</guid><description>228_final,finally,finalize()的区别 [!faq]+ final,finally,finalize()的区别
final,finally是一个关键字, final用于修饰变量,类等等,表示最终的不可变的 finally是用于异常处理try catch,无论异常是否发生,finally中的语句都会发生 finalize是Object中的一个方法,是一个标识符,不是关键字,由JVM的GC垃圾回收器负责调用</description></item><item><title>2291_异常实际例子</title><link>https://ob.tianzhongs.ml/2291_%E5%BC%82%E5%B8%B8%E5%AE%9E%E9%99%85%E4%BE%8B%E5%AD%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2291_%E5%BC%82%E5%B8%B8%E5%AE%9E%E9%99%85%E4%BE%8B%E5%AD%90/</guid><description>2291_异常实际例子 总结 [!tip]+ 书写方法注意点
首先异常类 继承RuntimeException或者Exception 两个方法，一个无参，一个String 其次写栈类：主要用来new对象，以及对异常的抛出 在方法中throws抛出异常 判断if什么情况需要抛出异常throw new StatckOperationException(&amp;quot;异常信息&amp;quot;); 最后测试类 注意try对象的判断，异常情况抛出的e的堆栈信息、异常信息描述是否需要打印 [[225.异常对象的常用方法]] eg1 栈操作 栈操作异常类</description></item><item><title>2292_继承的方法覆盖和异常</title><link>https://ob.tianzhongs.ml/2292_%E7%BB%A7%E6%89%BF%E7%9A%84%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96%E5%92%8C%E5%BC%82%E5%B8%B8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2292_%E7%BB%A7%E6%89%BF%E7%9A%84%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96%E5%92%8C%E5%BC%82%E5%B8%B8/</guid><description>2292_继承的方法覆盖和异常 ![[../../../../asset/Pasted image 20220726163010.png]] 总结： 子类继承父类的时候，方法覆盖的异常不能大于父类的异常，不能比父类异常多。 简单的描述：子类的异常只能是父类异常的子异常或者同等异常，要么就不写 相关：[[../../爪哇基础/07方法覆盖和多态/01方法覆盖/071.方法覆盖override]]
没有异常&amp;gt;父类异常&amp;gt;子类异常 不写就是默认的父类的异常</description></item><item><title>229_如何自定义异常(自己编写异常)</title><link>https://ob.tianzhongs.ml/229_%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E8%87%AA%E5%B7%B1%E7%BC%96%E5%86%99%E5%BC%82%E5%B8%B8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/229_%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E8%87%AA%E5%B7%B1%E7%BC%96%E5%86%99%E5%BC%82%E5%B8%B8/</guid><description>229_如何自定义异常(自己编写异常) 步骤 定义一个异常,继承Exception或者RuntimeException 提供两个方法,一个有参数的,一个String参数的 eg 定义异常
1 2 3 4 5 6 7 8 9 public class MyException extends RuntimeException{ public MyException(){ } public MyException(String s) { super(s); } }</description></item></channel></rss>