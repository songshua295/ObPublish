<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>14接口interface on</title><link>https://ob.doingnothing.online/tags/14%E6%8E%A5%E5%8F%A3interface/</link><description>Recent content in 14接口interface on</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://ob.doingnothing.online/tags/14%E6%8E%A5%E5%8F%A3interface/index.xml" rel="self" type="application/rss+xml"/><item><title>141_接口</title><link>https://ob.doingnothing.online/141_%E6%8E%A5%E5%8F%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.doingnothing.online/141_%E6%8E%A5%E5%8F%A3/</guid><description>141_接口 语法格式 1 2 3 [修饰符列表] interface 接口名{ } 基础语法 接口等于常量+抽象方法 接口也是一种“引用数据类型”，编译之后，也是一个class字节码文件 接口是完全抽象的（抽象类是半抽象的），也可以说接口是特殊的抽象类 接口支持继承，且支持多继承 接口中只包含两部分内容：1. 常量；2.抽象方法 接口中的所有元素都是public修饰的 public abstract可以省略不写 接口中都是抽象方法，所以不能有方法体 接口中的常量 public static final也可以省略不写 接口的使用 类和接口之间叫做实现，可以看做继承 继承用extens关键字完成 实现用implement关键字完成 接口中不能有方法体 接口可以继承多个接口 当一个非抽象的类实现接口的话，必须对接口中的抽象方法进行 方法覆盖，同时进行方法覆盖的要求和继承中方法覆盖的要求一样，访问权限只能更高 ，不能更低，一般是public 接口可以继承接口，类可以实现接口，抽象类不可以继承接口 一个类可以实现多个接口（弥补了java中类和类只支持单继承的缺陷，类似于多继承） 接口与接口之间没有继承关系，也可以强制类型转换，编译没错，但是陨星的时候可能 会出现ClassCastException异常，建议接口转型之前进行instanceof进行判断 extends和implements可以共存，extends在前，implements在后 [[044.</description></item><item><title>142_接口eg1</title><link>https://ob.doingnothing.online/142_%E6%8E%A5%E5%8F%A3eg1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.doingnothing.online/142_%E6%8E%A5%E5%8F%A3eg1/</guid><description>142_接口eg1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class Test { public static void main(String[] args) { //调用接口中的常量, System.</description></item><item><title>143_一个类实现多个接口</title><link>https://ob.doingnothing.online/143_%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%B8%AA%E6%8E%A5%E5%8F%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.doingnothing.online/143_%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%B8%AA%E6%8E%A5%E5%8F%A3/</guid><description>143_一个类实现多个接口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public class Test01 { public static void main(String[] args) { D d1=new D(); d1.</description></item><item><title>144_extends和implements同时出现</title><link>https://ob.doingnothing.online/144_extends%E5%92%8Cimplements%E5%90%8C%E6%97%B6%E5%87%BA%E7%8E%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.doingnothing.online/144_extends%E5%92%8Cimplements%E5%90%8C%E6%97%B6%E5%87%BA%E7%8E%B0/</guid><description>144_extends和implements同时出现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 public class Test02 { public static void main(String[] args) { Flyable c1=new Cat();//创建对象，父类型指向子对象。多态 c1.</description></item><item><title>145_接口在开发中的作用</title><link>https://ob.doingnothing.online/145_%E6%8E%A5%E5%8F%A3%E5%9C%A8%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.doingnothing.online/145_%E6%8E%A5%E5%8F%A3%E5%9C%A8%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8/</guid><description>145_接口在开发中的作用 作用 将调用者和实现者解耦合。 调用者面向接口调用，实现者面向接口编写实现。</description></item><item><title>146_is_a、has_a、like_a</title><link>https://ob.doingnothing.online/146_is_ahas_alike_a/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.doingnothing.online/146_is_ahas_alike_a/</guid><description>146_is_a、has_a、like_a 凡是满足“has a”来描述的，表示“关联关系”，统一以属性的方式存在。 1 2 3 class A{ B b } `` 1 2 3 4 class Custer{ //每个顾客手里都有一个菜单，菜单就是另一个接口类，包含了很多的做菜方法 FootMenu footMenu;//顾客有一个菜单，所以设置为属性 } 凡是满足“is a”来描述的，表示可以设置为继承。 1 class A extend B `` 1 2 class Cat extends Animal{ } `` 翻译满足“like a”，表示实现关系，通常是类实现接口。 1 2 class A implements B{ } `` 1 2 3 4 class ChineseCooker implements FoodMenu{ //厨师像一个菜单一样，实现了菜单中的具体方法，所以可以通过类实现接口中的方法 public void cook(){} }</description></item><item><title>147_抽象类和接口的区别</title><link>https://ob.doingnothing.online/147_%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.doingnothing.online/147_%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB/</guid><description>147_抽象类和接口的区别 抽象：抽象类是半抽象的；接口是完全抽象的 构造方法：抽象类中有构造方法；接口中没有构造方法 继承：类与类之间只能单继承；接口与接口之间支持多继承。 实现与继承：一个类可以同时实现（implements）多个接口；一个抽象类只能继承（extends）一个类（单继承） 定义：接口中只允许常量和抽象方法 使用频率：一般接口比抽象类多，抽象类使用的少。接口一般是对行为的抽象，接口就是为了扩展能力。</description></item><item><title>148_接口实现eg2厨师炒菜</title><link>https://ob.doingnothing.online/148_%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0eg2%E5%8E%A8%E5%B8%88%E7%82%92%E8%8F%9C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.doingnothing.online/148_%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0eg2%E5%8E%A8%E5%B8%88%E7%82%92%E8%8F%9C/</guid><description>148_接口实现eg2厨师炒菜 书写接口方法，用来描写具体的做菜方法 1 2 3 4 5 6 //菜单 //用来描述具体的菜单做的东西 public interface FootMenu { void Yuxiangrousi(); void Fanqiechaodan(); } 用类去实现接口中的具体方法 1 2 3 4 5 6 7 8 9 //定义厨师类去具体实现菜单接口中的方法 public class ChineseCooker implements FootMenu{ public void Yuxiangrousi(){ System.</description></item></channel></rss>