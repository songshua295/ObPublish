<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>01铺垫 on</title><link>https://ob.doingnothing.online/tags/01%E9%93%BA%E5%9E%AB/</link><description>Recent content in 01铺垫 on</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://ob.doingnothing.online/tags/01%E9%93%BA%E5%9E%AB/index.xml" rel="self" type="application/rss+xml"/><item><title>010_符号定义</title><link>https://ob.doingnothing.online/010_%E7%AC%A6%E5%8F%B7%E5%AE%9A%E4%B9%89/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.doingnothing.online/010_%E7%AC%A6%E5%8F%B7%E5%AE%9A%E4%B9%89/</guid><description>010_符号定义 标识符 程序员有权利自己命名的单词 通常用于设置方法名、接口名、常量名、等等 一般采用驼峰命名 StudentName
关键字 具有特殊含义的单词，比如Public, static ![[../../../../assets/Pasted image 20220623184204.png]]</description></item><item><title>011_javadoc的使用</title><link>https://ob.doingnothing.online/011_javadoc%E7%9A%84%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.doingnothing.online/011_javadoc%E7%9A%84%E4%BD%BF%E7%94%A8/</guid><description>011_javadoc的使用 先在源文件中进行javadoc注释
![](asset/Pasted image 20220623190413.png)
使用命令javadoc执行生成文档 命令格式为
1 javadoc -d 生成文档放入的目录 -附件参数（比如作者author等等） java源文件 !</description></item><item><title>012_不同数据数类型占用大小</title><link>https://ob.doingnothing.online/012_%E4%B8%8D%E5%90%8C%E6%95%B0%E6%8D%AE%E6%95%B0%E7%B1%BB%E5%9E%8B%E5%8D%A0%E7%94%A8%E5%A4%A7%E5%B0%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.doingnothing.online/012_%E4%B8%8D%E5%90%8C%E6%95%B0%E6%8D%AE%E6%95%B0%E7%B1%BB%E5%9E%8B%E5%8D%A0%E7%94%A8%E5%A4%A7%E5%B0%8F/</guid><description>012_不同数据数类型占用大小 类型 占用字节数量 byte 1 short 2 int 4 long 8 &amp;ndash; &amp;ndash; float 4 doubl 8 boolean 1 char 2</description></item><item><title>013_接收键盘输入</title><link>https://ob.doingnothing.online/013_%E6%8E%A5%E6%94%B6%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.doingnothing.online/013_%E6%8E%A5%E6%94%B6%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5/</guid><description>013_接收键盘输入 接收方法 导包方式 1 import java.util.Scanner; `` 定义键盘扫描对象 1 2 3 4 5 6 7 Scanner s=new Scanner(System.</description></item><item><title>014_方法的调用</title><link>https://ob.doingnothing.online/014_%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.doingnothing.online/014_%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8/</guid><description>014_方法的调用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class Tmp { public static void main(String[] args) { Dayin.</description></item><item><title>015_break和return的区别</title><link>https://ob.doingnothing.online/015_break%E5%92%8Creturn%E7%9A%84%E5%8C%BA%E5%88%AB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.doingnothing.online/015_break%E5%92%8Creturn%E7%9A%84%E5%8C%BA%E5%88%AB/</guid><description>015_break和return的区别 break用于停止循环和switch return用于返回一个方法的返回值，用即停止这个方法，不会执行后面的语句
return 不负责运行程序，只负责讲道理。对于不能百分之百能够返回值的方法，都会编译错误</description></item><item><title>016_方法执行时内存变化</title><link>https://ob.doingnothing.online/016_%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E5%8F%98%E5%8C%96/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.doingnothing.online/016_%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E5%8F%98%E5%8C%96/</guid><description>016_方法执行时内存变化 基本 局部变量 只在方法体重有效，方法借宿之后，局部变量就释放了。局部变量一般在循环中或者方法函数中。 JVM中有三块主要的内存：栈内存、堆内存、方法区内存 堆
栈 栈：方法函数调用的时候，方法所需要的内存在栈中进行分配。!
![[../../../../assets/Pasted image 20220628094821.png]] 如图，由于栈是先进后出，所以在依次嵌套的方法函数调用的时候，最先调用的函数，最后结束，符合栈的先进后出
调用的时候在栈中分配空间，叫压栈push 结束的时候，内存释放，叫弹栈pop</description></item><item><title>017_方法重载overload</title><link>https://ob.doingnothing.online/017_%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BDoverload/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.doingnothing.online/017_%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BDoverload/</guid><description>017_方法重载overload 用途 主要用在多个具有相似功能的方法函数中 通过将方法函数名称设置为相同，由java自己通过参数列表去判断执行具体的哪一个方法 让代码更加美观
执行重载的条件 方法名称相同 参数列表不同 （也就是形参列表） 参数的个数不同 参数的顺序不同 参数的****不同
只要能够让java编译器能够区分具体执行哪个方法的参数列表就行</description></item></channel></rss>