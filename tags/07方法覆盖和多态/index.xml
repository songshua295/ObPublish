<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>07方法覆盖和多态 on</title><link>https://ob.doingnothing.online/tags/07%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96%E5%92%8C%E5%A4%9A%E6%80%81/</link><description>Recent content in 07方法覆盖和多态 on</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://ob.doingnothing.online/tags/07%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96%E5%92%8C%E5%A4%9A%E6%80%81/index.xml" rel="self" type="application/rss+xml"/><item><title>0711_方法覆盖override</title><link>https://ob.doingnothing.online/0711_%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96override/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.doingnothing.online/0711_%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96override/</guid><description>0711_方法覆盖override 什么时候使用 子类继承父类之后，当继承的方法无法满足当前子类的业务需求，子类有权利对这个方法进行重新编写，进行方法覆盖。override
语法格式 编写的结论 两个类必须要有继承关系 重写之后的方法必须满足的条件**（除了修饰符列表可以不同，其他必须完全一样）** 相同的返回值类型 相同的方法名称 相同的形式参数列表 子类的访问权限不能更低，可以更高，比如父类是public,那么子类就不能是protected受保护的，但是相反则可以 覆盖之后的方法不能比之前的方法抛出更多的异常，可以更少或者没有。 注意事项 方法覆盖只针对方法，和属性（实例对象的属性，就是你定义的那几个字段）无关 私有方法（private）无法覆盖 构造方法不能继承，所以构造方法不能被覆盖 方法覆盖只能针对实例方法，静态方法无法覆盖 相关： 017.</description></item><item><title>0712_覆盖eg</title><link>https://ob.doingnothing.online/0712_%E8%A6%86%E7%9B%96eg/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.doingnothing.online/0712_%E8%A6%86%E7%9B%96eg/</guid><description>0712_覆盖eg 举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 package a007方法覆盖和多态; public class Dongwu1 { public static void main(String[] args) { System.</description></item><item><title>0713_方法覆盖经典例子</title><link>https://ob.doingnothing.online/0713_%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96%E7%BB%8F%E5%85%B8%E4%BE%8B%E5%AD%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.doingnothing.online/0713_%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96%E7%BB%8F%E5%85%B8%E4%BE%8B%E5%AD%90/</guid><description>0713_方法覆盖经典例子 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 package a007方法覆盖和多态; public class Speak { public static void main(String[] args) { People p1=new People(&amp;#34;人&amp;#34;); p1.</description></item><item><title>0714_例子toString方法覆盖</title><link>https://ob.doingnothing.online/0714_%E4%BE%8B%E5%AD%90toString%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.doingnothing.online/0714_%E4%BE%8B%E5%AD%90toString%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96/</guid><description>0714_例子toString方法覆盖 要求 定义一个日期类 输出日期对象的时候，直接输出日期对象的值
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 public class ToString1 { public static void main(String[] args) { Date d1=new Date(2019, 12, 2); System.</description></item><item><title>0721_多态</title><link>https://ob.doingnothing.online/0721_%E5%A4%9A%E6%80%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.doingnothing.online/0721_%E5%A4%9A%E6%80%81/</guid><description>0721_多态 基本概念 多动态，就是多种形态，多种状态。
简单的来说，就是java程序在 编译阶段 和执行阶段 所真正参与的是不同的对象，所以叫多态。 父类型引用执行子类型对象，包括编译阶段和执行阶段 编译阶段 ：静态绑定父类的方法（方法区） ^jtbd 执行阶段：动态绑定子类的方法（堆内存）</description></item><item><title>0722_多态举例</title><link>https://ob.doingnothing.online/0722_%E5%A4%9A%E6%80%81%E4%B8%BE%E4%BE%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.doingnothing.online/0722_%E5%A4%9A%E6%80%81%E4%B8%BE%E4%BE%8B/</guid><description>0722_多态举例 eg 定义Animal、Cat、Dog类用来定义对象 动物
1 2 3 4 5 6 7 package a007方法覆盖和多态; public class Animal { public void move(){ System.</description></item><item><title>0723_向下转型</title><link>https://ob.doingnothing.online/0723_%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.doingnothing.online/0723_%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B/</guid><description>0723_向下转型 向上转型和向下转型 java中允许 向上转型，也允许向下转型（不要说自动类型转换和强制类型转换，那是基本变量类型转换，上图只是为了能够更好地理解） 不论是向上转型还是向下转型，都必须有继承关系（没有继承关系，那么不能转型） 向上转型： Anlimal a=new Cat() 向下转型：Cat b=(Cat)a
什么时候使用向下转型 不要随便做强制转换
当你访问的是一个父类中没有，子类对象中所“特有”的方法，此时必须向下转型 当然，你也可以在父类中补充这个方法，那样就是方法覆盖了，就不用向下转型了 原因是 虽然aa3运行是猫对象，但是由于底层是狗对象，而且Cat和Dog两个之间没有相互继承关系，所以无法向下转型，抛出异常，可以通过if判断和instanceof判断来避免这种错误 eg 在Cat类中增加猫抓老鼠的方法 1 2 3 public void catchMouse(){ System.</description></item><item><title>0724_instanceof运算符</title><link>https://ob.doingnothing.online/0724_instanceof%E8%BF%90%E7%AE%97%E7%AC%A6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.doingnothing.online/0724_instanceof%E8%BF%90%E7%AE%97%E7%AC%A6/</guid><description>0724_instanceof运算符 [!作用] 用于判断 某对象实例 是否动态指向 一个类 ，或者由一个类直接或间接创建的
重要结论 左边是实例对象，右边是类 只要左边的实际对象 是右边类的 继承树 以下的类或刚好一样的类，就是true 判断 判断方法： 可以通过判断是否与实例对象的底层对象在 同一底层类 上进行判断 实例对象 “蔡徐坤” 是否是某个类 直接或者间接创建的，比如 person cxk=new chinse，“人类”下有“中国人”和“美国人”两个子类，，那么 蔡徐坤 instanceof 中国人或者蔡徐坤 instanceof 人就为true，而蔡徐坤 instanceof 美国人就为false !</description></item><item><title>0725_多态例子a主人喂宠物</title><link>https://ob.doingnothing.online/0725_%E5%A4%9A%E6%80%81%E4%BE%8B%E5%AD%90a%E4%B8%BB%E4%BA%BA%E5%96%82%E5%AE%A0%E7%89%A9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.doingnothing.online/0725_%E5%A4%9A%E6%80%81%E4%BE%8B%E5%AD%90a%E4%B8%BB%E4%BA%BA%E5%96%82%E5%AE%A0%E7%89%A9/</guid><description>0725_多态例子a主人喂宠物 代码
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 package a007方法覆盖和多态.</description></item><item><title>0726_宠物养猫优化</title><link>https://ob.doingnothing.online/0726_%E5%AE%A0%E7%89%A9%E5%85%BB%E7%8C%AB%E4%BC%98%E5%8C%96/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.doingnothing.online/0726_%E5%AE%A0%E7%89%A9%E5%85%BB%E7%8C%AB%E4%BC%98%E5%8C%96/</guid><description>0726_宠物养猫优化 相关 类继承：猫狗与宠物之间的继承关系 向下继承：向下继承，如果需要调用子类独有的方法（pig的睡觉方法，在pet中没有），需要强制转换类型，前提是两个类继承关系，且[[077.向下转型|向下转型]]才必须强制转型 独有实例方法的调用 向上继承的创建对象：Pet p2=new Pig(); 多态：宠物的多个具体事物，有不同的吃的方法，主人通过调用喂养方法，去访问宠物的吃 方法覆盖override：由于子类有不同的eat方法，在实际调用的时候，会访问其具体对象的eat方法 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 package a007方法覆盖和多态.</description></item></channel></rss>