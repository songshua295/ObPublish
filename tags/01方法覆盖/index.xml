<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>01方法覆盖 on</title><link>https://ob.tianzhongs.ml/tags/01%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96/</link><description>Recent content in 01方法覆盖 on</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://ob.tianzhongs.ml/tags/01%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96/index.xml" rel="self" type="application/rss+xml"/><item><title>071-方法覆盖override</title><link>https://ob.tianzhongs.ml/071-%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96override/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/071-%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96override/</guid><description>071-方法覆盖override 什么时候使用 子类继承父类之后，当继承的方法无法满足当前子类的业务需求，子类有权利对这个方法进行重新编写，进行方法覆盖。override
语法格式 编写的结论 两个类必须要有继承关系 重写之后的方法必须满足的条件**（除了修饰符列表可以不同，其他必须完全一样）** 相同的返回值类型 相同的方法名称 相同的形式参数列表 子类的访问权限不能更低，可以更高，比如父类是public,那么子类就不能是protected受保护的，但是相反则可以 覆盖之后的方法不能比之前的方法抛出更多的异常，可以更少或者没有。 注意事项 方法覆盖只针对方法，和属性（实例对象的属性，就是你定义的那几个字段）无关 私有方法（private）无法覆盖 构造方法不能继承，所以构造方法不能被覆盖 方法覆盖只能针对实例方法，静态方法无法覆盖 相关： 017.</description></item><item><title>072-覆盖eg</title><link>https://ob.tianzhongs.ml/072-%E8%A6%86%E7%9B%96eg/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/072-%E8%A6%86%E7%9B%96eg/</guid><description>072-覆盖eg 举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 package a007方法覆盖和多态; public class Dongwu1 { public static void main(String[] args) { System.</description></item><item><title>073-方法覆盖经典例子</title><link>https://ob.tianzhongs.ml/073-%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96%E7%BB%8F%E5%85%B8%E4%BE%8B%E5%AD%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/073-%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96%E7%BB%8F%E5%85%B8%E4%BE%8B%E5%AD%90/</guid><description>073-方法覆盖经典例子 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 package a007方法覆盖和多态; public class Speak { public static void main(String[] args) { People p1=new People(&amp;#34;人&amp;#34;); p1.</description></item><item><title>074-例子toString方法覆盖</title><link>https://ob.tianzhongs.ml/074-%E4%BE%8B%E5%AD%90toString%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/074-%E4%BE%8B%E5%AD%90toString%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96/</guid><description>074-例子toString方法覆盖 要求 定义一个日期类 输出日期对象的时候，直接输出日期对象的值
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 public class ToString1 { public static void main(String[] args) { Date d1=new Date(2019, 12, 2); System.</description></item></channel></rss>