<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>02基本 on</title><link>https://ob.dongthing.online/tags/02%E5%9F%BA%E6%9C%AC/</link><description>Recent content in 02基本 on</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://ob.dongthing.online/tags/02%E5%9F%BA%E6%9C%AC/index.xml" rel="self" type="application/rss+xml"/><item><title>021_递归</title><link>https://ob.dongthing.online/021_%E9%80%92%E5%BD%92/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.dongthing.online/021_%E9%80%92%E5%BD%92/</guid><description>021_递归 递归方法必须有结束条件，否则就会栈溢出错误，因为没有结束的条件，递归会一直不断地执行新的自己的方法，导致栈溢出。 递归有结束条件，但也会发生栈溢出，因为递归太深了，自身的栈内存不够用了，一直不断地压栈。 递归不断的循环，可能会导致JVM死掉，非常耗费内存 能用for或者while替换，尽量不用递归 书写思路 如何进入循环的，比如阶乘，是根据此一个值去乘以-1之后的方法，然后再加上自己自己本身，sum(n-1)+1 更重要的是停止方法的条件，如何将自己停止，一般是需要返回值，特殊的条件是什么样的，返回什么值。 1 2 3 4 5 if(a!=0) { sum(a); } `` 如果栈溢出怎么解决</description></item><item><title>022_面向对象和面向过程</title><link>https://ob.dongthing.online/022_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.dongthing.online/022_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/</guid><description>022_面向对象和面向过程 常见语言 C是面向过程 C++是一般面向过程，一般面向对象 java是完全面向对象
面向过程 面向过程注重步骤，注重实现这个功能的因果关系，每一步之间的因果关系，联系形成子模块，耦合度高，扩展能力就差 对于小型项目，面向过程方便直接开发，效率高，快速开发 面向对象 面向对象符合人类的思维方式，将世界分割成不同的单元形成驱动，然后驱动各个对象，形成一个系统 耦合度低，扩展能力强 三大特征：封装 继承 多态 ^sandatezheng 有了封装才能说继承，有了继承，才能说多态 ^c344fe 当我们采用面向对象的方式贯穿系统，需要 OOA 面向对象分析 OOD 面向对象设计 OOP 面向对象编程</description></item><item><title>023_对象和类</title><link>https://ob.dongthing.online/023_%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.dongthing.online/023_%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/</guid><description>023_对象和类 简要 类是抽象的概念，好像一个模板 对象是一个实际存在的个体，对象的另一个名称就是**“实例”** 通过类创建对象的过程，称为**“实例化”** 根据多个对象的共同属性抽取形成的概念，叫做**“抽象”**
1 2 3 4 5 graph LR l1(对象) l2(类) l1--抽象--&amp;gt;l2 l2--实例化--&amp;gt;l1 举例 eg</description></item><item><title>024_对象的创建</title><link>https://ob.dongthing.online/024_%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.dongthing.online/024_%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA/</guid><description>024_对象的创建 创建对象 通过new来创建一个对象 对象存储在**“堆”**当中
堆内存中存储对象，以及对象的实例变量 实例变量就是对象变量，也就是对象的属性，例如student.name
局部变量存储在栈内存中
1 类名 变量名=new 类名(); Java中所有的类，都是一个数据类型，且都是引用数据类型 一般在进行调用的时候，是调用的对象的地址，而不是对象本身。 比如 在Student s=new Student();中，进行调用s的时候，是对其s的对象地址进行调用，而不是对象本身，所以类都是引用数据类型的。</description></item><item><title>025_空指针异常</title><link>https://ob.dongthing.online/025_%E7%A9%BA%E6%8C%87%E9%92%88%E5%BC%82%E5%B8%B8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.dongthing.online/025_%E7%A9%BA%E6%8C%87%E9%92%88%E5%BC%82%E5%B8%B8/</guid><description>025_空指针异常 基本 “空引用”访问实例（对象相关）的数据，都会出现空指针异常。 当一个java对象没有任何的引用指向该对象时，垃圾回收期GC就会将该垃圾数据释放回收掉。 垃圾回收主要针对与堆内存的数据进行回收
举例 定义一个垃圾类，创建垃圾对象l1，对l1进行引用置空，出现空指针异常
创建类Laji 1 2 3 4 5 package a001对象的创建; public class Laji { int id; String name; } `` 创建垃圾对象l1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 package a001对象的创建; public class LajiTest { public static void main(String[] args) { Laji l1=new Laji(); l1.</description></item><item><title>026_方法调用时的参数传递</title><link>https://ob.dongthing.online/026_%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E6%97%B6%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.dongthing.online/026_%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E6%97%B6%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/</guid><description>026_方法调用时的参数传递 形式参数 1 2 3 4 5 6 7 8 9 10 11 public class Cscd { public static void main(String[] args) { int i=10; add(i); System.</description></item></channel></rss>