{"/":{"title":"知识Cool😊","content":"我是**田中**\n这里是我的知识库。😊😊\n专门用于存放学习过程中做的一些笔记，目前项目的搜索功能似乎有点抽搐，所以做了目录方便自己查阅。\n\n# 目录\n\n\n\n\n\n\n\n\n\n\n\n\n\n## 相同知识库搭建\n此项目是基于知识库管理软件`Obsidian`的基础上，采用`Markdown`语法的**知识库**，通过将知识库推送到Github，再经过Vercel进行部署，全程只要域名费用，当然域名也可以白p（指路freenom）\n项目地址：[ObPublish](https://github.com/tianzhongs/ObPublish.git)\n\n此项目是由oldwinter的项目[dg3](https://github.com/oldwinter/dg3)修改得来。从其中删除了一些不必要的文件，并修改了一些奇怪的配置，算是轻量化了一下。\n\n如果你也需要创建一个这样的云知识库，可以参考以下地址中的教程或者原作者的文档\n[[部署Obsidian静态知识库网站]]\n\n致谢：\n    1. @oldwinter的[原开源代码](https://github.com/oldwinter/dg3)\n    2. @行者无疆的细致解答","lastmodified":"2022-09-20T05:41:07.266338579Z","tags":null},"/%E4%BB%A3%E7%90%86%E9%93%BE%E6%8E%A5":{"title":"代理链接","content":"## 基本\n如果您使用的机场暂时性故障|可以尝试使用Openit订阅。Openit订阅隶属于SC系列频道的 @ShareCentrePro 旗下|是一个全网抓取节点并自动筛选节点的自动化订阅系统|保持自动更新并配合故障转移即可无感保持链接。\nv2rayng\n```txt\nhttps://openit.daycat.space/long\n```\nclash\n```java\nhttps://openit.daycat.space/clash  \n```\n\n## 可查阅频道链接\n| Name            | tx链接                           | tg链接                                |\n|-----------------|--------------------------------|-------------------------------------|\n| ✈️ 机场观测 • 白嫖无罪  | https://tx.me/s/freemason6     | https://telega.one/s/freemason6     |\n| free347 免费资源分享  | https://tx.me/s/free347        | https://telega.one/s/free347        |\n| vpn【机场】         | https://tx.me/s/airport358     | https://telega.one/s/airport358     |\n| 黑洞资源笔记          | https://tx.me/s/tieliu         | https://telega.one/s/tieliu         |\n| 学习教程资源分享        | https://tx.me/s/longgu         | https://telega.one/s/longgu         |\n| 公益机场TG直连        | https://tx.me/s/olddrivercqdl  | https://telega.one/s/olddrivercqdl  |\n| ShareCentre Pro | https://tx.me/s/ShareCentrePro | https://telega.one/s/ShareCentrePro |\n","lastmodified":"2022-09-20T05:41:07.266338579Z","tags":null},"/%E4%BD%A0%E6%98%AF%E6%88%91%E4%B8%89%E5%8D%81%E5%85%AD%E5%BA%A6%E7%9A%84%E9%A3%8E":{"title":"你是我三十六度的风","content":"“你是我三十九度的风 \"\n\n- 01 -\n\n  \n\n  \n\n  \n\n世间两种罪恶：你笑是一种，你不笑是另外一种。\n\n  \n\n  \n\n  \n\n——@mokilmq\n\n  \n\n  \n\n  \n\n- 02 -\n\n  \n\n  \n\n  \n\n夜阑卧听风吹雨，铁马是你，冰河也是你 君问归期未有期，巴山是你，夜雨也是你，月落乌啼霜满天。\n\n  \n\n  \n\n  \n\n江枫是你，渔火也是你，玲珑骰子安红豆，入骨是你，相思也是你 山有木兮木有枝，心悦是你，不知也是你。\n\n  \n\n  \n\n  \n\n——@弹得一手棉花\n\n  \n\n  \n\n  \n\n- 03 -\n\n  \n\n  \n\n  \n\n你是我最爱的一杯酒，喝完我就走。\n\n  \n\n  \n\n  \n\n——@光距离历史编织\n\n  \n\n  \n\n  \n\n- 04 -\n\n  \n\n  \n\n  \n\n最后见你是我做的短梦，梦里有你还有一群冬风。\n\n![](data:image/jpeg;base64,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)\n\n  \n\n  \n\n——@莉莉崽儿\n\n  \n\n  \n\n  \n\n  \n\n  \n\n  \n\n  \n\n- 05 -\n\n  \n\n  \n\n  \n\n十几岁的时候，我遇到了一个风清明月般的人，我什么都没想，我只想爱她。\n\n  \n\n  \n\n  \n\n——@訓查\n\n  \n\n  \n\n  \n\n- 06 -\n\n  \n\n  \n\n  \n\n求你不要再出现在我的梦里，我已负担不起又一个失落的早晨。\n\n  \n\n  \n\n  \n\n——@遇见先生董二千\n\n  \n\n  \n\n  \n\n- 07 -\n\n  \n\n  \n\n  \n\n在脑海里把你意淫了几万遍，在现实里却不敢抬头看你一眼。\n\n  \n\n  \n\n  \n\n——@住在云端里的大儿童\n\n  \n\n  \n\n  \n\n- 08 -\n\n  \n\n  \n\n  \n\n大概就像陈粒说的，她一生只能写出一首这样纯的歌，我一生也只能用这样的方式去爱一个人吧。\n\n![](data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAMCAgMCAgMDAwMEAwMEBQgFBQQEBQoHBwYIDAoMDAsKCwsNDhIQDQ4RDgsLEBYQERMUFRUVDA8XGBYUGBIUFRT/2wBDAQMEBAUEBQkFBQkUDQsNFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBT/wAARCAHEAlgDASIAAhEBAxEB/8QAHgABAAEFAQEBAQAAAAAAAAAAAAcCAwQFBggBCQr/xABREAACAQMDAwEFBQUFBgQBCQkBAgMABBEFBiEHEjFBCBMiUWEUMnGBkRUjQlKhCWKxwfAWM3KC0eEXJEOiJSY0U2OSk6OywvEYNURFc4PS4v/EABwBAQACAgMBAAAAAAAAAAAAAAABAwIEBQYHCP/EADURAAICAgEDAgQFAQcFAAAAAAABAgMEEQUSITEGQRMiUWEHFDJCkXEVIzNSYoGhJDVDsdH/2gAMAwEAAhEDEQA/AP1TpSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApVP51bJ5NYtgvUqgeGqgyYPp+ZxWPUC9SlKgClKUApSlAKUpQClKUApSlAKUpQClKUApSqQc0BbpVM0vuU7iMqPJrjNd6h6Zp/Tq/3lYXUN7plvYSXsNwhzHIqqSMfTIA4NCp9jtaxIdRiluJ4Qf3kJAZfxzg/ng/pXFapvu9s91bO0aO2ilbWY7i4uGJwYEiiVsqB5yzouD/ADea0e0N6HcPUG4eGNRp19bSxRSMv+/e1l7Syk8dxMrcD0QHNSzHqJRn1OG2s3u5GAgRe8uP5cZq5FdxzMyqyllxkA5xketR2+tNFsufS2IW+S+OipF3YLEv2qRx5918f4c1a1XXpNI6hJDbuRF7uyjmUn4f30skYDD7wOApU+va2alMy7koUr53Vp9q6wdc0O2viAPedwyPXtYr3fge3P51iDc0q0GI8nIxj5c5x/WrtBoUpSgFWlmWXv7Dko3afocZ/wADWJq2r2+i6Zd6heP7q1tYmnlfzhFXuY4+gz+lR/0r3om4L7cNlcq9tqEV99qFtL9/7NKiNA4H8pUYyPXIPOaySIb6SQru/h0+H31zKsUXcq97EAAsQo5z9RWTNKIl7mPauQCflzUM9X93JqPTHqBbkCwvtHIV45JRnAZHilVscBgAQD6hvlWy1Pcd1uHaG7VtHL3+mTwzrAAQ4URwXCjt4POSPPp+VR4I6yWO8/MVVzjzUP7b6npubq4dFsMvp3+zcOqRM/BYSTHGV8g4GDwa3G5eoraXvWXbscSysuizan3Y+JWViFB5HntJ/SoJ6teTvLa/iu4++GQOmcZAxznGKygSflUJbE3K1/tPYOn2cokuNUupJ5CrhisMLu8p84I7iiZHz9aky/3B9m13TdKhHdc3XfLheeyGPt7nb6EsFGM8sPrhoJ7OipSlCRSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAvUpSrS0UpSgFKUoBSlKAUpSgFKUoBSlKAUpVPkVDegVVT5Fc9qe7dP0y7S1eRpbpx3iG2jeZ+3+YrGrMB9SAPPNYd/fatqlvKmnEaQ7DtF1eqsjqfTtjDYyfkzD6rWDloGzv9wR2MkMJikmvJs+7tYcGR8ecZIAxnkkgfWovj6gau3UlrG8X3SQW7GTT7KYXRZTnsbtUZ7iSTz24CtkDK57TTenWlQmR7p7rUribBmmurhyZcZwGAwMDJwMcVrbfYJ2ppclptR10+zeT3ksJjWR3B+92ys3LHJ+KTurXlPQLW7tb3AsAhtmg0ua47hBbFWluZfPfyoKxlQwwSHXu7ckg87jYsWt6Xo8UGuXb3V3lQHuMd+Co4JAx3dwbgZ9OTXI6NazX0bQahoGm6bPJlP8A4hO81xIox2t3+7UMxKqR2P5PGMV023L3UdOujo+rXKzuR7y1uVBImj8Mnb57lyDzyQ4I4U1hG2Mn2B3qjFVVZDfWrmVrYjJS8AqpVvu/GrlZEClKUJFKUoBSlKAUpSgFKUoBVPgVVVtqAB60mu30rbf1GWzbMqwylGHOGUEcfgRXOb13dNoizmEn3tjJbTtEfEsTydjc/IEg55xxnzX3TdYimn+zxTK1lqqPJAT90TEH3iE/iScefPHHLRU5aNxabljuINFWVR36nD3ooPBwqsw/IE/pXmPcbTRdPtydM48xJcb4i0KzC8MLSaWO7IB/kRC4LfJTwMV3OhjVtd6LWtxpCmXXNq38htI3Ha0hgcqYyPm0ZYY55xULw6jf9Y/aBKbSDpo9xaxa1LequGs557ZrZ3YEffQRyp2jnJ8c1KKpS34JP3ruW5g0DqP1LtYkNrbaedA20yqT3KD2SuoyvcGlbC4P/pH51l6HplzsjVttaWkvvINsQwJMsxwHiuAA7H8GOBnzgeOcbLrHolhZW/S3ZWnCK0spdwWqiCF+0mGBWkPP0IQ4x5I+XPRbcitdb60b3t5YYpEtdP06KVWIcO2XdQy4+EjCnGfX6VkYe5h7TsZ9Q6ubpuJSkunaZdi4jZQMLPJbIgy3dyVQscYyO/ya1205pNzPa63LGUvdd3BE6NEcd1taIQpxj7gZX4z/ABH5msno5dNqB6na4DIyXGvXMULMxLlYUVQVB/hJAOPHkYIrYdFbS01Pb2172zcPaado0NuqkEp72XDzkEHBbCpwckZOefMGejo90bzbbtru/UZGBTSrGMQoOC0rI7gDj1JQflV7Sbz/AGF2hpVhdvGby0tLdZiWwHdnEbEef4iT+dRnuq/fcPVNdvwrLNaasdK1mZvdssUcERmz3NgrhpIo1IyD8a/Pnr9y2ab71fe2jwuRJbaTbwRzK2O2djLKjL+YjPn0HmhYzK0LXrl+ue59Hlkzbro9jcQx+igPKGIHyLMP0rsdrbr0/eGjQarpkvv7OZnCMSAfgdkORn5q36VAWxt/jXesWxtxzobSfce27vSLyKRsCO+tLhWlhxj72WkI8fCo+YreeznqEunav1W0CSUtYaJuSZrZDgCGKUe9KgeMAknj5+KBk2WGsw6hcX8MXL2c/wBnkHnDdqt/g6n864XcO9JYul+oaykhNy8jwwBeGLG490uD9CwFaToZuL7T001Pdl7KvZqmo3upZU4KoZmVFHHGVQYHPkVy+6ddl0rYPT/T7iyub6S8uBqc1laRtI7LEr3CoqqCfjcxJnGB3c4NR4JOh66bnt9cmj6fwXht5ryNLvU7iOQBra194ERfP3pXIQefB45GMIbem3hcKLfUl231J2yogN5bRrJ71GGF96nAlgkK5x8Pa3Pw+DzO39u61pm8dCfdRSPde9dUk1bULdHDi0tLSPugtFbjhfgLEnBYcH7uJT3NoTbotrXc23ZxDrmnSSpazF/3N0A5VoXzxh2RcNg4YA1JXJbPP/W/d2sWU2p2er6KdM1DXdJi0y8jT47SZ4rlSJY5MhWUxysBk9ykgHtxzM1hLDsvq/c6bcAjT922kYtTLgg3lshWSEnkAtGysByD7t6iv2gO/rPpexRoto8eoDUpLK6t5j2SWbYBdJC485hOAB8RCEHFSh7vTeqPSe2k1Sae2ubF0BurbtWewvo3CrMhP3SDgkHgqxznJrEqj5I0k25qPS32oOnkbzpJt7VLW/0zTQGz7tQvvViZSP4XYAMD90LgferqN5yfaeve4Y1jLfYtkSySdgYn45JMD0H1zmoz9q3fWo6Btjad9uKH7NvXaWuw6jDPbxH7LqNqMiW4hJVuO0qWi7sp3YOR2sell6m6RZb36s7/ADKk8Fjo+n6Vas0nassksRlSNSB8QZ3GScELz8qyEuxldFN16dpuhXO99ZlFpoe19KXSYpHUhndj76UomB8R7lTg8nxx5kzpddX9+1luzWo/cajuse9ggyCtlZoryQxAc/EVYsxB5Z2rz10J6bXPU7S0sdTSa32fo9o02kWNwShv9Qct3ahKB/CGH7tQPGHJXPbU47f3D+0OlWyNfmjaO80u8gtLxACDEUZreVcc8KSSD/dBqPJZCWydKVoJdfjbV9It45QIr2CaYAckhezBB/5j+tba0u4ruITQussROFdTkH0OPzqC7Rk0pShApSlAKUpQClKUApSlAKUpQClKUBepSlWlopSlAKUpQClKUApSlAKUpQClK57cG5bPb1i1zdtgH7kS8vKfJCj1/wAPmQOawlNIG2v9RttLtnuLuZLeBPvSOcAVE2rdYH1d5RtyONraJuybUJeewkDHaq93cT3cd3bjBJwBzwfUTd2qbsvRBdd0GnxHJtojlSD5DA9vIwMg5A54PFcxbe+QSLBwhXt7V+6cMuCB5JPYB47mwAVCnsGtKwxb0TBtrdWj2O4b6UW0VpJchBdStEFeSYgEsPDNwxJBGTgleO4CUI542t0l7wUcZVgcg/UGvOMO3LzVNBuZr++i0nT4Ukkee4iPZGG85IOe45AYjliFB4q50Y3dqG8Nc1HR9TgkvtL02NR3d4dWlJUj3oA7TnDMVYjsOMgtzWvKzS3JmKW/BN8m8rc4Gm2d7q7lWIa2h7YuBnIkkKoQfmpP4Vpb2+3ZqiSiYadt+H73fHI11cAAgsuCqxggDkgtjjzXRhUjjiWVo0jXISOFcBB8gfUfgK12ua3ZRWMhSWIKkbkDu9ccHx6ZrrvI8vj0Y9jU11JG7VTOcktETRbnl0dxZy3d5uPTJsrdW9+ffSkEkh0bg8KwB9PgOCvFfI+qA0ZNW0q61BtUmsI01LSLpVBllgwe4E8ZKqxQ8fxDBJcLWTJH39wY9rrI3cvy5B/rg5/E1hT7atLwoZY1lMZ74w/3gf4ZA38wwSCc4ycECvBMb1vlY0pxb3vwdqfF1PW0SDbb8ursh4zFPEe0qQpDFcgk9uPw9fWuk0zekNwVW4RoyfUcr+Z4/wAKiCPTpYIQFHdbn/0BjtXC/wAvI9PmfyrNjee3BKStCSpPap+E49Cvj1+VaOH665TBu+La9xfsJ8VVKOkieLa6juI+5G7h545rJWoe21uyfT3xM/egwfxHq30qUtM1OPUIFkjIZSM5r3/056qxuer7dpfQ63lYc8V612NnSqQcrVVd7NAUpSgFKUoBSlKAUpSgFaDcutT6Jo09/Ba/bHgxI8CnDMgb4+3jlgoY4+lbxn7a1urTG3sZ5lRXkijeRVIz3YUnH50MWR11KtLbeOwbvV9FmV76Gzla2kXn3ikDujP0OBwfp8q0Rvbu6upLPUtNu7KbUI0v7OS1UTLHdgDLKyZ5YfF8SDgtVk3tvp1xq+m2bH9ia1H/AOWZeBHLJF7xVA+oBxwM5XHNbvXLfUNb6TafqOgyRxavYW6XNm3uu8LIi4btXnyuQMH+L61Pk1X3NZ0U1g3u5uotp9lFjLa6haySwMvYFd7WPuP8wBKFuRnJbxk1CvS3X7rpdrW4uob2cNvsXqFqkotpIkIbTmjeSOB3GfhinIZ1IPDOM/eFY+2up25Nz6LuZrexOnbl39caZo1rPApMQuY4mgv5EPHxRe7ZyGOQGXg9rV6W3Ts3QtH6Q3W25LKGfQ7LSTaC2mQFPdRx9oPb44wpGPUDHIFTogjvrfHeHXuie4IR7yaLW4rd/TCzRHu5/wCUjj6fOthsXWhoepda9zXU6ILTUXXBYKqJBaIyHPgZBHjPP41CHWO/3z0Z6Sben1CFt0be0nVNM1XTtwRnEunKkiEW90vJKkt2rIPOQGwx7h1eu6jcL7I2qagFDahvTUA0QfkzG6ulVATjwY19RnB858xsj3Jl9nTSBD0a0SG8Ky3d5E11dOh+885Mpwfr3itd0Y1qHQegNtqKQRW/7LtrxbhIgFAmgklR8/XKHJ8knzzXWdL2WG212zhiVItO1EWAC8LiK2gUkDHHOeM/nUNWNxFDb7o6c2xKNf74e0KpyVtXCXkz/UdgcMfQuOOOZLNlXVzUW6dbx6Q69cgg6hbyaDeXGQrF2WG5j7hgknut3HDfxNUr9F5JNZ0bWNyzRtG+varc3kIY5ItlYw25Hpho4w4/4/lWg9pbTLjcW1NL2vYy29vqOvan9lglaEuYcxSlpQgOWKqDyCPIzxXedP7S20PYO3rSP93bWWn29sp+YVFUEfjnihYeUevGha7013uvUTQrZrnQbfcUeoajBbg/+WmjjCzSBR/BLAzZz3ANGmfSsjQuoitsDr5uDSpzdza5uOTTtLMWD715Y47dGjPjnudge7wucYzn0btcWOtbQ3LdX0fvNMvby/8AtCTLjuhDNG2R9VB4+mK8h+wpsi73XocH7Rt+zQ9rahf3tn2sGN3dzBY4ZT6F44FHk8GRQMYrEqls9I6vp8OhdIun+3bERx2093pml4iIGEyvvMcjB+FvH51gWN1DL7Slpp6w/aNP0Lba20MxTLRTTSgqDyDgxoCePn8jWo6vbna06X7A1b3DXr225tOPuR2juKSuApzzkYOcHnBz5rS9B/f33VzUtTvWEmo6jfXrySTNiXECLDgLj7oZ5QOccnzWRh1HV+0Xf6rtTdW39Y0uBp77UtOvNAslRgvZdzPCUODxjCOcnx2ipXtbWy6cbKgg7u+10u0EeW8zMB2jPzZ2IHjlifFR1uuNeo3tA7Z0OKRpNP2fbtrOoKGwv2uTi2THq2A7Zz4B+db3qBqb7h3voe1bKSRorLOs6oE+6qRnuijb/ikA/So8Ga+pz3VvbKaC+299W5NlqFhqlp+0vdlQtzCT7lg57u3uQMQDk8Z81zPVmTWun97qemQ2k0ug7g1C3uYLxOwi0m94plQtjCDtXv8AB+QyM1KXVqz/ANoejGvkRnvm0v3ysfhYEYkOTzjlR8/FRt161SLcHT3pkBEwtNZ1XTlyJu3sR1zkeT3Du47c5wc5FSYmT1U0XSup1vvy+1GzivdD29oV3a2zzwCXF4YmaaSP++iqkePJIYZqCfYy6PQ9WunVtuDcaS3O1Z7s6iqvcFDf3IhihX3o8mNEj4DEfEzcYIr0P7TN1YdKfZe3sNMhEEcWmvawr7wgtJMfd9xYnPcS+e4nPg5rK9kLaU+w/Z02Jpd6piuhpaXc6uMCESZkCnn0Df4+KjRDRz/TndxvOvGqoqxRWssEmkRxxr2iM2wVwoXlcdrMQB4yQMisPcOvWWyte6p7Wldr2x1ZY7+xtwjdsN1MqLJETjC5JjlUnjBbnNcf0t79c27uXeVg0kt9pe4019LVV7pJbeRAZIifkyEnGOCpHNb+71O56iWqnb2oWr/7TbpL2ss8TFDZ20SlAB5K9y5PHOMcU2Sb+/3RN/tu+2dCuHvtW0+xg2/aSA593K3a9zcsV+6UQIMn1Bxn4szvtmG20/Q7S1tJWuba3QQJM5H70j4c5HzINQ5quzLXo5saQaWwud2a/dQ2VxqkhLSyT3MgDMFJJwPjwM+nOc1Jep6km1bzaej2qhI7u4FqfTKJGT4/SnguXdHb/dqmlKgyFKUoBSlKAUpSgFKUoBSlKAUpSgL1KUq0tFKUoBSlKAUpSgFKUoBSlcbvzeUWytHF66iWaWVYYYmk7AzH1J9FABJP/WoYKd47xTa9ohx7+/m7zBag9qv2L3MzvjCIox3MQcAgDLFcwnqeo3Gv3KarPOsodjAJwwEIwxysY7sEjIwFJI4yBWm3P+0dX1cTas4a9n7J/chSrJHlXQD4vAJPBPhyeDWTrEj3MVqsUsr+6tzFGEkKmOEyAYUD1LKcgn1rWl8xS56LE8KyJHF2Se494VKsmWZzjtGfHHBC44GOTjNd5tzY8d7a92oFzFOFMKR8Ki4yQD4bKtgkAAqSuOTWPsbacF3bQXE9qFuFV0SXuzKT8JQE/IEnj+vPHf6jbJHLaW7BjeXByXWQntQAFnPw/ewSF+ZIqqUexj17MI7c0/clqYJ7ZDokQZY7Yc+9dc9zsx54OcEfIHz24wrq6tNtg6RodjbWUMSqiR28QRUIznAGPmOfzxXaI8NjbhcqkUahMKQ2Ao5B4OW49POfpUS7ivLWTUdQgGoRC/tSJ3tYQJHWORsISv3gc9wyVGcLwM15v61vy8fDTxN7+xy+BCuU/nLmoXdxchmS4ZifEvcT+o4IrD7Taj3skYZyoJb+Ik5zz970FWvtiy2yNct3t3IEkkwpAYZ+LnwMVVLePPa8I8s0YAUx9pYjn04P618v3X33ScZTb+p3avpj4LazCZZmQZEcpj+WcBcEfQjP9flVceYfgeTJPPYeGA/HwfTxWAsz+7uEZsIp94RJ8JPBXGOT931xWKuoLFLE+BJLGMKGPwocZUg+mfl+fmuMljz9jcjNe5sbq/kSRFDEp3FQCSTwO04PgeMn8aqnvgzQTLhyQAw8cHzx59B5ArEvCEdo2dwneWRXwvDDHHd2/Mef86uKUhSRx+9QKD3dmRjgKAc855wRWDrti9FsXH9p8eftnRMkAMgZfJHdnn8Bipe6dTSz2HxNkKxQ59CPIqEBEb23dBG8Dx592xbu7l/h4+vP6VMHS6f3egQLIUTuPB78k8YOTj5nFeo+geqPIrv2OE5hbq2SZ6VXWBBcBQQ544xmssNk19aQkpraOiFylUM1fcrWZGyqlKUJFKUoBSlKAxbqBbqIxPyjcMPmK4/T9RvtFL219HNqFhGQsd5BH3ui8/DKgJbKgcsBg5HArtmrl9RWOTWoY1DQ3NxGzRS92QzJjKkfMZ4PkYbHrTRXIizYmiWGqrvPacc3uXgvvtFr3R5aGIsWhZfJHa6kgcYwuDya6foVrSaptW609oTBLYXEkMlvnIUF2IA8fNh+QrZa/s691G80/VbGSCz13TcrFcdmI7mMn4omXIPYwOBzlCMjuqMdqahdbO6qbhubqMWNheX8cF3EJUkSFp4xJG5bPCF/efEe04f7vIrIo8HFbr6f65pPtF7m1bT4JJdO0vSf9o9MljiV1gv5pIo7mMjI/eyQ20gQePjfJ5qVd470XX+im5NYtW+0QzxOsC5K5VyoC5Hg5bOSCefrWztNWjtN99SJ74RtaWdlaNI0gyFhEMrFR9Mk5HOe41Ce0rm90wxbDvGYRXGp2moQx+S9vK/eynHJVfeIoJBzjBIPNDEmLrttWTdHQPduh2qxnUDorSxozZDSIvegY8ZBZRz6/FURWd1bb22n7Pu3NOjBj97b6pcRQgN2C1RGJbKj/wCkYkjHOOK9H300UW+LOymAlXULGVGU8A9jg8j8GNeVPZn0U6F7Q2vbMu4Wjn2VZ3cFr75e5jBPKssTjB8GKRBxn7tRojyTx093HBoM/USW6/dkbtkgjiTw7Pb2pTH1ctn8W/KuC2zpKD2gN97lmk/+HfbF02xRfSVbKNr5z/OO6OKMsccgggkVxPU3empdOeueq7ce0kmtdVv4N22nul7UuJEt47dYh6lvtMUQ4PPvQR4NSFqWhSbCXRtCl1A3l7Zbc1PUL2RFJe4upSDNMfGe6WRmXJz5zkqCGx9jbX2vw691r2BonvI3TS9Oa+YR/F3TSRERqTxyEVnxj5ehroty62+xtgbvyvuzpbyywfAWCq494mOfIz5HA/KooTQtW2DBtzeGqwvaXs+67SJkLKrLZPE1rHkdxHI5wW9R9a672oXt7DR9OSOWRbrWr23spIO8KrwJIJZD8RA+6AuM/db8qJbM32Kerm5P/Cr2SNbu5pwmoDRWgUgYL3NzwRjPktIT+VdF7N21bHYvQjakcSQW4k09bu6nB/3jSKW72bHJwQP+lQx/aCa7Jq9tsXp9Zfv77WdQa6ktF5LxxgIoHH3maT4fqprsYd621r7H633YVa006PTpIJR2yJN70Q+6KHt+IEqADjJ8ipTK+o4XrML299nLdu4DKkFto8QOhxq3b3zC5V/eYK57jhUUY9GOcVq+hu8f/DjQ9i3u4n+z3MOyzqd0jJ2SGa4uiwDHleQQR8wefNVe1zeX2sdPtodKtNZzrWsfYopOxgBE8kqhO9s8xqolJAGcDjitj1t2nbf+Kmxtu2rSPDoeix3Wtw2YKlrK3YIqkgkgt3EqpXJ7PhHJrEgkvp/qtr0t6Z6rvvcbPNrW47v7ayOnbNM7lhBCqnnkZIXHdg4x3cDa9PNv6ltqafXtySMmr7vZjfJyy20gVTbQAk5QhWf08gcVqts6Vcdcdcj3tcJLZbU0uN4tsWigRtO/b2m7ZefhzlYlyMfETz2k9vuTV21/pNLqyL7u8sYxdOhPEMsJBZTxx90jGD5rIyLe2dRW/wChbm8LB4dJuLedJOWRo1ZO1j9O2vP25NyfbdC9mTS7q5lkkuNRtb2dpgR3iJR25OfvZK+c49PWpFt9zpoGt7129KAthr9jJrunr3DJ95CFniAx6OIxkDHxmop6S7dfrTb6DHb3iOu0NBaK1nRQpj1BpJQCCCwHaV+XPYPOKhhvR2nt56o+v7b2j0usl99qe8NYghMYOD7hGUOw49GK1IW5N1LtnaHU57U4ttvabFaW7ZwC62vCj8WdV8fxfWoZ6V6lc9ffbCu903dvHHZbG0kWoiY93ubyQdpV1z8LZEpH/AD+O71i8fcmrbn2lbOwn3B1Fgt3BGT9lgihnmKnOO0LEBx/Mfzkfc6foytv02211HvLuJok0aK1M0jjPf7vTIi/b8wMHA+tc17LOjTazuXTWd3e22ppZZ2ViqvqeolriVnGADIsTqpI/mH0riuue+xp3SDfsMcBlu91b3msY4o+4yzxQND3ZGfB92sfb/fPPNSp070XWtnbL0nYujTe43zuASapr2pI3GlRufif/jGVSNTnwT4FNkJ7M7qhuefeW4E1DT8NtPZOrW0l7cJg+/ue8LIFx5SJGJyv8TN6pz3k17Fr3WXTbKG5QjRdLmumXuAYvKyICFPoqAHuweWXnnnnW0zb20OlW+rGFmh0XT1mtveykgZEQ7nZ2wCxd2LMeOfNQD7NWna7rl9f9SWaK53nuq3TRtCnC9yWWkwgI92QeB3MqhcnDMoH1qNlq8nt/Ttet9TvNQtrbukNk6xSyY+EORkqDzyoK5/GtxXObR0a327pSaZbv9oNse2edhhpZCAzOw55OQa6OoLRSlKAUpSgFKUoBSlKAUpSgFKUoC9SlKtLRSlKAUpSgFKUoBSlKAttUWdTXtRuDbpvITLbxSmRk7sHllXJGPujyfnzmpTauI6naZFcaOb1v95bI+AB5yOOfxxWEjCR5/vL0pvy5nu8TwRrL7tMsZTjhO74cZDNGvPpV7SUfVAGihcZkyqyR9wQKCGLP8yTjgc5zwxxW51O0tJLm1ZIlL3UbK7SDK94IAB/Ekfr9KqsNOaLX7V7URwAJ72aOMsOOwqF7e3H3lZQSR90nyRVK8mnPsSBs1VwjOpxIisSRko/agYAfUkkc+rAY4rNM80+s3c0fd2W2LVQG7SvbyzkYP8AMvPzX6VkaGe6aOEAKigAEDIHOeD54PI+XpgcVj6Tkx6oGJhdL24RlOUZssGOfOcqQccfjVjW0QQX7ZPXqXov02BsLjt3JqVwLa3iQI0sUZGJpkTvzkJwQwPxMAK/OjoB7SO7emnUxdyyTT3+3dRu3j1NL2QyJdByA7Bi2HkXtHxHy3fj73Hef2iG+XuOvGq2t0HubXTdNisbMShlSOZ8vIEOfvK5GMo2SpOe0oKgTY+40uBZ6RrKzz6ZbobXKr2+5lAUqJAxZVGfeMWAySTlTmuOzKIZFMq7FvZbCyVcupH62aXuvTNa0mLUNIvY5bC4VZIWReSMZI+8fiIPaMnhvPr20yXNzeRmRljXs5klEY7mJ9Q/C4OPU14n6V9Wte6G3MdjBJJqmz7xnaSGJyQmce892WKIGyc8jtII4r2PsveG2+oWkrf6JcLequBNGytiIkcdynsKscYGQoPoPn85cx6TtptlbTHsdqxOSU/kkZNhBLbkzw3LuJGJ+MZ7s+QrBTzyMKRkZOS2TWTKxaNo5HjWOTuLBlC85Y/F5xnC/lkVXeW6RSypcJD8XC8ZYDyM8/dAIwc8ZGPArUG9e1vIoGhkVJFJjlt4SwGAxHf+BJBxnPpxXmuVi5Nc+8GdjhZCS3s2fvJ0RIQTiJDgRoUC48k4X7uD5HIz6540D3C2981gHwZlM0aSsOyIg/EA2PIJPCgD61euNSUyOElTIZWR0cMoxnIA85544+fzFa7Xla9aGSa5aK5tWWSOZAQ6vnzjB55HBIB4+OsKK3NbsLVNJ7NjqGqFbOK5MXckee9AuWPc/aARxx8ROPPH69ztfesGlwtbQys0YCzKrt90+qhv4fn4PBz55qP9NS57rppRBLA+S8kMqhct4LKzd6vx6g/5VsdPih+yQBz93tSO4HEnJ7SQ3kHBUcVyGLm2cZarcd6ZXdFZEelnfbg6/ptxrdBtvVtYRky9xZrGIk7eGUM7L3MMl8YA9M5rM0H2i4NbMv7O2jufUY0ZgZrW3hkiwMYIbvBOcngAnjx5xEl3ZvJHcwyN9sRozCYpGx71W/gDck+PnUaap0J2lorTX+2tu67BrU08RaDbmtm0OMjudUkPa+cjkYzzXt3p31xXkyWPk9pM6pmcfZD5qz3Ltff1vuHuibTtS0qZAxZNSt/c57cd3a33TjIzg8Zrq+/B+dfnVBc6Pti9jGvdUusnTeZVDd+p3cdxGoX0YmI9ykcpI0ZAQZIQnFdBqXUPau3Y1u7f2n933Mdx7tWa2tIL8dsgb3bFUhLBmGGDgY7e3jGDXtFdkbI9SZ1/qaeme+VfIq5XjXp31p3boO/tO0/XN032q7ZvJGQ3m5bTT9IBBjJSUEze9KlkYACPJPOSK9DdPusuz+pT3Y2vr9vrgtgnvTbI3YhfJT4sduGxlSCQwKkEggm0ujLqWyRKVTlaqoZClKp8igMDVL5dOt2uJFb3Scuw5wPw8/pWg3Nay6xoxudNMb3cOLqzcfEC6glQpHockE+OfWupKBsk/F6YNRzLcr041AWtwSu2bub9zcOfhsJGPb7th6I5z2nwDkHg0MJGXdy3G+tmR3mh3zadfnsngnYZEUynlJPGV4MbAHwW8HBEcbDYdTte6h2ut6f+ytQ7bG3u9Nlfve1uEhYrKhBBZCWJRgMMqjGPiFdr7yDZ+5WtLiNV2/rcrNFMZA0cd0Rk48dofDE4z8RH8xrjN/aTrOnawN46FaNe7l21+4urU4WTWNLPxmIHnukTBZDn74PIyc5GvM0el3Ooa51C3Nsi8RY9VnXTGvJgpKzWUQkZnA+Tdqx4J8s2MYFb3fUFvp6Nu73PcNF3AAz2r9r/AGdkjhcgBR9MqODxnIrn+km9NDuurW8NW0+6WbSLrbFjqscsrFpTGsly0gZfQr3DuXPBxxk8d3qujm86MavpEjtFf32k3F87qOFlfLnDfRiB24z8PisdGJfuN2QX/UDZBjDL9ojv1Lvw3wqOWHyxk+f5aivqzO/TH2q9mbzWAJp+4rNtGurt+E96mWUHGMHtKkZzlUbFUdI9xPubqHtJ5ZvewyaLIZYcqApaJEZwM5A74jxg8sa03tY6LrWn7EvdGvDcXenW0kep7Y1mOMvNY3sTMRaSkgD95EHSNzjlwh5ALzshnc7W0Cz357UW99c1BPff7KRWGn2KO3wLKY3kZmTAz2+9PaT64I5C4xuqNxc33VaHQ2LTvfWKafbxqB7to3ukeQkH7rLGuPhxkDnHNc37G++h1F3p1E1wImdVi067d1OSsgjKOpGOCCpIzyMrkZqV5LOy3D1+huo4/eR6PYND71WPa1yxyVBzjKpI3cPPxjzipBd9pHbcm7+i+8tP0hiNZs7Rb+3ELfvUnhKzxj8WMYGfw4NR7bzn2ktE1XW9KKNaW214otOfIwl9N+9myePjQxxJkcct5qatDf3u/t2wMVdQlsPiOcgx8ZH07j/WoZ9le0m6Vbk6hdKtVdEmsNQO4NJKHIl0+6wcIPvBYpFZD3AHJ+VR4LCJdj7lbrj7cOl3VwjfZtuaDDNJbyfEIZlUZBHHImkI48FB+W59o67m6Zb8XbDwqNp7117TtSV2cJFFNFKn2mI/y+8WNXOMZIJ8tWJ7LUGqaDBubrdNaLeaVunW79rq3gjUTWdmk7BJQQSWUFRlQeOXGVxUj9c5tG6jdbeiGlXENrqeiRLqG4bmaZlMIijgURsD6/EWb5YRsnxUlLWyKdN1qPU+vEvUDc7JaWG1bGfceorJHzbqcwWMSj59hdgucj4c9uTWT0D2PqvtE67uHqtvW4MG3dXv/skejspDSwxMixwu/lbfGS8eT7w45AzmCLzcmqe0f1D1DYG0IfdWO79wNqmqSuGWOPTbY+5t4sAFQgWOR1AABZ0zkjtr9H4du6fsPRttbTsYVttvyRHSECEoY290Sjdw47m7Wz82I+ZzjslLZgW1yvRq/NhdcbPvrlRYyrwLCaQsWiYcD3ZJBXHj4s1ZWBI5t97cYf8Alr+2l1K3I5UiVP3mD4OJCcgHjIx5Naved9dxa3tjamuKLi3n1GNYp5QGiu4ikgIkXHDDA8EHkH1FaHq1su/2Nop1nbWrXCw2EbxzWF3+9MME+EPaSc4BBPacn681kZHBdetL1Beh3T/qLbRyXF5tmOKLUFtwQ8llJ+6mPrkLgNjxjubyoxVsTqjonSv2U9zbk0m7gluo7y7s7W97QGmlZi0RYgfFgSF+c4z8sVM159m072b54rvNzANuupDjvWQPDhcKOSp94Bx6Gvz52zspt19WdO6E6HJM+0GvmvborOXa3Jhja4VM8EfC+GI9SBjihhI9QeyhsbVukvS/SN5ype6g+6QNQ3BbJCXkiRx3RTKuAAqISe3nKv4PArdeznbjd/W7qfutLlLvb2malLDpRMbAe/nSN5ZFOOQERFHGQGI+VTtZ3lvb9QotAgiWK2tNFWdFX/dqvvgEAHgYCeceleetr9Ro+n/TLrZuwD7XPNum9tLK2R+4z3biOKKNRj7xd1OMksPwNSEQp0ws9U6vdZNT3XY6S2o7f2drt5NaWt1gQz6pdzEJIW8kIkcatgZy6nkEV7i27t6LpdtrV9Z1W7F9q0w+26nflSQ8gXHanOe0EdoGc/riuB6XdHrfol0R29oPf77V5L62utWuhw0t3JMrSMDjwCQoJH3EGa3HXXe9lp9jJBqcgg2/pSi91WYnt7ipUw24bkZkYpkEeGGfBrFGfghTrvqt3uvRtndGdEuDHubet59v1IwhS1jYF1eTvIIK9ykYH8XJ9RXpvYPT3T+nelQr79XmtLaO3a57OxYreJO1I1XwiALnHPqc55rz17GGzNV3puTdXWvc0SNqeuytbaUAzOI7QdpDKGIPbhURf7qsPGKlbrBuW9jbcG27Fwl5f2UFlZJnhpZ5GBIH0Tu8Z8/WpMl9Tt+k+p3GubZbW543Q6rdSXcUUj9xWIsFXnx91Qf0rvCcVG3RvUvtdtrFjZye80jSLpdLtGC4H7mNFkx9O8mpKasTZiXaUpQyFKUoBSlKAUpSgFKUoBSlKAUpSrQKUpQClKUApSlAKUpQCtbq+nQ6raPbTqXiccqGK55z5H4VsqttUMhnnPVdFexu9RtpY5Rc28vdBIFypj784ABLZII5IwPXzVnTL9E1S27Rn3a9ixDgR5KkEf8AMzfrxjAqSd+6fHaapa6k9v76AKY51Vc4TBH+DA48cD5ZqN5LODTby7TvDzQMCcuIzIgVFDkYPlT8/XPk1Ul3NKxEtaG8UjynHvO3B+X+vFYEFvFLuHULKVFAwl1CQ3a2RgMyjyAMIrMeckgmrmxtUttb0qGWGdXf7kqFFicMPJ7M+ufnWdrsAspLfUHBD2kgPvATloicyBgOCMBX5zz6VZLwEtn4v+3GJtM9oDqLp1yZlt59Zs5Gac+8ZokjYKAD8fb2sMLnABUAVGu04ILywuoFeN3nn99AiocugLOApz8BHw/Ccr2n71e4v7UPotFcDTeolpcrNDfNDYXTkq8SzBSY5GY8BCoxkZIMaZDdxrxZtGOFrOwRYWa8h74o5IyOwgsQcDPejJkgqyjIQjIHnUsDR2gZkgnu0MV29r2s8DBsKvf2qVY4UAKEOCVDY8ipa6ZbasNzXbvo+5NQ2TuKIgpDbxCKUOoV3R489ygqS3egcdpUsATiou22TbyX6SLJbkQoVuo1LPEe4EADyPeZGAx/jBJPg+s06cbI3pp+laPuq3udm7oeJBY3IxDBdFY1KTWV6MR9pGCI3JKsQAAcY15UQuWpoqjJxe0Rrc9YetHTLcsEO6tQ1a42W86qt5Dp8UpYDPvGVwiq0ihWIcjuOBkA/DXd6N1W2Xue2uJ9O6garLqUHJt9VYxBixynYqAqSct2ju47Rnt5rq4tkdR+kGmX9prWlTdRduSkm4nsSk172IAGEtvLlZO3APxd/qO5c8dRtjph0c63vb3emWWjTzTwknS5rWXT71O0YBMUUmDhiwMir2rgdrCus5/pvGzXvWjkqs2cDk9vb80DdTGBJma7gRDKbmIRnJJGWZ3CkceQcn6V0up7hn1mK0toVj00e8yXBZiFxngAME5VhyD5+pxzU3sUx6Lr8urabr19ae4DmNople4Hcv3A3aO4FSDkj0HqWx1HSv2e9uQWW49V1F7y5i0lzIgkvXYdyJ7w45Kt3EkgdowCDjJro2T6I8ut/wAnKVcm32kzYaf7mGQSTlS/wO3exVu7JUnHIxwDkfPx4rbW8UNxIrQHsdMn3U3HcCcnI58DPxeP71RXr43Bse5a53joMunaMIxdJq8HxQMWXCIyxt3eQQVIye1iPlViz9rLpnp9+bO63JqEU0Ri7ori1clACDyQC4yC3LD0HzNeYcj6U5GmbVdbf9Dn8bOplrreia4tOhkhldV7WjADxnkKAcPntyVKnHx5I+nyuWFhHJIVWb3aAksxkyFOTgFcZIGT4rldudaNj7wNn+w9bW9muJPdRiKzm5bPPawUgnjyGA+/XaXuoabodnFf6jq9pp0TMFW4uZliDuCQQvcM95yuFBycnAaus0cVyNeTGLqaZu230fDepo4HqB0o1Pe+rPqWqXNrabZt7d5dQ3Bqd4ZTEVdS0cNuQY1RguWkk7j3lvhx241+y/ZZ9nK7tyZNUs9WeZUbMmsRxxkkdzECIoCG+HPbkcKGBAAPe6nvDeW57SFdj/7J3+jLagXlhrhYy3QfKksEZhEpKhQH+9j4s4CvzN3tXdFnpttb6t0B23fGMuWi0a/h9w5y2HijPawLALlcMc+uPhr7I4eu2ODUrfOjze6cZWtxOx2n7M3QXaG4NM1q207S5L3Tgy2z6nqP2oKCMjAldgCmSV44B9ARU4aBu/bmu3Mun6HrOl3tzbJ/830+6jlMUfcF5VT8KgjH1xxXj8jYNp72PcHs16/Zwx/ELmzs/tMUgQFiwZXReCxQ5OMOMntVgPTvR3aW0dA28NU25sZNiyaiD761lsI7W5kCkqDIqsTjgsFJzg+M+Obb0WQJTB5qseDVmqh5NSWl6lUjwaqoC21crb31jvPTLq1niDplra8sZTlkYjlHGPBBBzyCCCPIrfzzJZNH7zhZHEYP94+P1P8AX8a4rd9jNoupw7o06JpHj7INTt0zme1D/fA9Wj7i34dy/ShhI0NvbR6EH2hutxqGj3jsun6hcMSzJgYidsffTPDEgnAOM5rF1vQrrYOoaHq8erXN5p8M62Li7He4gkIXDOB8XxEEZ/XPNSS32Dc+lgjsvNPuF5K8rICPQ/L4v1H0qFeoEl/tbaG5dtX94bm1htDeaZJcKDLJCkqFgGHlou4AgnJGCPBrI159yA7HTrzZXtl6lt3SoGttpbuhubNVMZ9zDc5juLqNeVVcsHZUHkO4+efTXWTX20C2MFsypcX+l3FjBEwDYlZ4kXK59C/JznHjnmua37sWDSeiFvuPQQ0ut6JPFu6O4clpbiVf3k3JycvE0kWfQHAxVzrbrOl6zr3SKRrvFjqGrJOGUnDxFVkRuB90yGEAnjuZajRiaLpPaP0/6mwbOfvWOziuYrcAnsmgbEsYxlufhJxn18mpy1PSdJ6h7Tu7HUrEXOnX8bQXMM4ADYz3A/LtKjDcngVxnU/T4LXqP031CJQl5Lqb28zeSy/ZpTgn8ABmt9YX6bc3/NpLEra6rG97ABgD34AL4bGSWVc4PyPzNEDx30Q0y69knrrv3p4/vNXbXbOK/wBtyvGEN3K7MgWRR/EpLBiM592DxkV6ug2zPsu02rGLwXV8964vrhhzdTTfFJJz6j4guRkKDUT+3ns2/wBP2tt/q7twNFuPp/ei/Z4vvPYv2x3K49R29pIyPhU1KEe/rHfHSrQt6aZJFd2sscGpx9jAsGCZILYx3hgVxkcE+aIg3ewpDd7+3pdKytC80ESsrZ5RAD/gtedP7Q29uumui7e6jaLqEOm60xn2xPJKSDNa3a5JUAE5jZC6nwPiJ+vpHo7pUthsuxublMXd+ovJu4nu7nAOCp+7wRwCfNQNdRWXtIe1JcpqKC92NsO1ksbfOTFf6q+PtKeMYRQiEcnORnkU0WInvo7snQti9Nds6Ht33J0e0sIUgkgOUnUgOZfr3Els/wB4/Ovzt9qbqZY9JeuG9dK2hHcvdXOjRbfsrKOYyJbSXMyy3AgUH4FICRlCfh94SML8NelunPVG29mG73R0w3zrMVlpmiRtqO1dUvWIF1prOf8Ay5f+J4XPb2gZ7MYHAryX7KW0dS649cN+dctU06C+stG1A6tFaXMbuk8rvlAhx5VFJBI89vcq4qCs9GdD+gsfsz7f6Y6zq6RJrepaoy61LH8S2puI3WCIH+VB2qx/nYHwa9O9Yr5dO2zZagexHs9VspUd2ChSZlj5OP75/DGfSs/fm3NI6g7LvdH1B1js9ShCxySfAYnYExug57WBweR6fjUQa3uy41vonf6HrZQbl0e9s9MuonbDzOt1EFkHHPegJzgfED6YqfBJvetc9rrm+dv7fuIkngs9NvtbmHf2GNVHbGw4JPx9vgenpX06/q22tZtdM3LYXWu6JqWmtAt5Z/8AmZCgAbE0XEhwGf4wCPiHzrXbhca7uLqjuFGPutJ0tNv2bRknDH97MOBx8bRLgDjnNdxucvperdO2eX3Ti4awdM47++AhlB+Y7SRx/CfUCpfcHnbrF1bbpb0l3BtLUYr2FbuZDt570GN5rBp+1lb+Me67R3ZYOVdSBhTUd+wbpc9z1w1LcGp2UsV3f6HcLC8quwLpdD3jIGXBycqW9CgGCMVl+2prt51t667P6XbVgW/m0qdpLrtYBZJWGZUZ+cBVVUbJ8uwGSDUl7b3ttbS+qnSmewP7GNjpt/omraXfr7mawdE96ocH7x70Zi4GCPiHyoYE7bYvf291k3lqCIrQ6TZ2ukCVeO58vK6k/RnA/M15n9k3ZWu9U5dN13XbF7XZOga5qGr2iNNk6vqrTui3JAOPdQoAYy2D3ljyMZlXQN8y9POlv7Te0a63bvO5vNXt9Nj5IMhJErEjKwxwqjkkDxgHmtx7IZTRvZU2XPLJns0qW9aXt7cpI8kvdjj+b0oEdZ1m1AptC0jseLy81K2ht41K5kcn4M5I44/QV5j6taTqPXLqlp3RXQbiSXTtKuY9X3rrMchVY5GVu2FiOCzKCQB5LHPg56vr91Wk0Dp107stCu5JeoutFW29pka9wyy4e6mXHEUasx7+B8Y89pzMHs2dBIOhmzJ7ae6/a+59VmF5rWsMADdTkYAHGQqAkAEfxH5mo8lqWzqNBS20vXrXa2jwfZdL0OyQyRxHtRWbAjjb58KTn61F3VrcMek771WRNPGpa6bGxi0W3WTBe9klkRCV+mS2CMdoGfvZHcdLbn7RPvzXp37kl1eZI2HAEECBVXHoR8WcepOMVH93qFhe7917qLcfvZbCeLb+i2Uq9y3F0492Gx/MC7jx4LijM12ZNHSnZEXTzZOmaHGxmkt4gZ52OWlmPMjE+pLE/pXX1bgQpAAfPmrlQbEfBkUpSgFKUoBSlKAUpSgFKUoBSlKAUpSrQKUpQClKUApSlAKUpQCrbVcpQGk3RpP7Y0a4tgQHYZUnxUH72067nsnFuUS8iUB1XgyAhvhQ+AwAJAPHcjD1FeiG5qM+ou2ZWY6hAO+DBEyKPiXz2kfPJY/hxjnFVFE478EddL93XFteu3vkhDlVuVBwrjkBgv8A6YHAOfDeePM9pb2+p2YE0STRSAHtcZBFeXLHTJrDU5WiTJVy8BMZUshJzkn6qVcAHlfocS5pfUGDT9PutMusytDHkXQcBZAcY7fnww58fPHrO9lUezI43bYbV6udQn6cajaRXG2tPs7po4QoES3hxGAp8B40966EfdAZvTB8e9cfZGvOk00GsaLa3F9tNpUjneCNpJ9NnV2XtlC/fiOcrJhQcjhO4d3pjpTr2ny7y3NpGpzNBBqptnsdWC491cRMwgwc4Rx+7xk8t8HBOG9C2FzLLdT3E0KftS3EUep2kZyk64+GVPRgQD28/MH4lxWLWyd7PyA07dsOkztCe24SZhbStJgxyxh1kePkjgOgYZbgAZ/mr3F0m1XQLjadhsrXpNO3BsTVXkl27fahcBWt5CWeS1aXuzFJGcDI7sllIyG4lndHs39It0Xcm5L7ZenXlhdMzXNxGZEaFsgmQ9rDALZ71/hI7jghiOF1n2SrnQr/AFY7VuFk2jqCpKmj3MpY28i47Ah+MuBgFSrKwBwGxkVXrQcDu9N2HuzZE9pa6Xqjbk0GPCJp2sjN5arz2mGdnVXKkn4lK4UjzxXP9QNxW3T+eLVTaWW3bu6ZormD3avesjN2hgqAhg2PiYRyYKkFwcmszpZ1gu9s3Frs/qDBHb3Yj7bXWp51KXMecAOePiQntP8Axc9vHdm7p3PtSfeum2GiwWWoa3fPNaw38svba27lcmFpcPhiqyK0SjkkjCk1E9GPSYG1d+L1Y2bfx7a1IGezgK2puJVSYuWyZGiGRGoYjtGF7gcYAC1j9ONa/aembl2gNt6tt6S2kJmnZY7mXUXkRg0jFSR38DLFuAEHIBB3Gl+yrt62A1CW8nN6J5JobW0kMNghw2AsRySQc5buDMfUD4alLpnuix3RobJEkUF/pxaxu7JPuxSL6EfI4OM/WteUlssjXs8ge1rZb/6hxbe2tYbU1Kyt47cXk/v/AHJS7lLhCvvO8qjKxAAZiR7zJCjOPOF/7CXWBnmvl21cp7j4oo1+yFlTJwVCzIe4KcYK8/w5PFfpp171Ww03pZuCS71O00do7Z5Ibi5uFhVpUUuqqx4YntIwMn6fPQdI/ad6bdS20nQtI3lo97uSS0WRtLSTslYgKJAqnhyMt8KEkD5jJrBrqlot0l2PyK0TYe4dm73ltdwR6v7jTJsXj6dE8d3HGxHxCFlJwCB94gZ7gcZyJw2xe7W1zSL3SdN6padLaX6e9l/2j0GSynZUdGCy3IDAoGBUkMnkAj5/oVsDQtM1XfPUW21LTrW9dNQjkUXEYlHu2jLIQCO0eo8nxUQdQfZW0nUurJGzrqPbN8+nvetbe7L20sgaNHJRWBUOpUMVLZ7I8q2BjV+HS7OucFsrnGbXynm6y6Y7huZQ22V0u7sIl9wr6dvFF7W92VTtZcHvYMWOU5QAlTgmu02lf7pXdUu3Lnf+6emN+Immhm1e6t7+xnmYqFiye3IclVBbOUIx2552Ou6Hs7Q9bbb3U7aY2bqscZtk1SzYNYXKd3eCsoTGO8EYdQe8kZ8k3tI0jozpOoS7f3JptluOwZUlh1aykkV8OpIJAf3cg5bmNsnDjDHPby0JxkuxrKEovuTRoOv+0Fs6S2gudv7V35allkOoaTdtZtIrDBDrL4wD3d4BUrjB8Z9P6e5ktomKJE7AMyI3cBn64FeZdpdKtz7dsbZ+k/UKCTal2vfBputQ/boI+30imDdwLOQWyp+IM3cSCDM3S/Vt8aja3se+NG07TL2FwsNxpVz76C7XnLqD8S44GDSXk24eCRAfyqoDNWgnj/Cr2cVmnsuKqUpWQNbqmnRatZvbTFgj89ynBB9CK5SLck2g3MenbhVYhMwjgvyO2CcnwHJ8SEZ+E+a7nt/GtZr2lQ6xplzZzRRzJMhQrKoYEH6UIZwB1ROmmutDctIu2b8tLDcFe6OylJ5Rj5VXOSDjHOKq6y7Vbe+y7uOxOdYswbi0KP25cD7hyp+F1yue0+eK09vomq/sq70+wjXWrKDNvfbb1Z8/DlSDbTeVDKcju7lOfKY5xtB18dLILW0urDVrLaDER/aNUAf9lueFVnDN+5OB8X3U/mqfBVo7Xp6+l650/wBH+whpNNks1i93Nhm7cdrxv9QwZSM54qGenHTu23Z033NsW8upl1/bc8m37e5MgLwRRES2U0fyVk9y+DnJU5zgY7jYepnaXU7c+0ZDiw1ADWtKOCsfxkiaFOScgqrgcZ7mIGKwd6gdOOtOi7s/3Gh7rjj25qykdwS7GXsp254yWkhJYYy0WcU8mGyJ9qdRdU3Re6Fea7F361oe49Sjv4FwnabezjDsvoUy4PHPxcYqd+qtomvbW07W7Je+4snS6hkQ4ZYnQ9xB54IKknHgGoi6fbOMXtTdTNMuuxbJrVNZsLZlwWN2iQ3EmQeVHuuO3BywqbemkjnQ7jbupkNeaS5ieIjkxZ+DtHqhXipKzld4a3a7o6G3gnT7RFfounyQyp3LN3TBGQDIBGA2cjxmvLXs9303SjqLvH2cdRkuF0a+vVuNAu7nCAw/E00SDLAkdhOQzf7twQDnHoyeVfdvthkRHi3HcXT4jyiW0WJXYDPB7HIHP3lxx6wz7VnSHWtX6BWPUXbEJ/2y0CV9cb3PErRPKJpO1vPehQPkeR3jju4hmLWyf/aL6mt0n6YPBoqfaN16uV0XbtjH/vZryUe7Rl9QI1YyM2PCfUZ5Tovtm26QaBs/ZUERS506YLqF13Bhd3UqyCU5x6yIrcjwQ3gCof8AZH6ka97VPUmLqlujSvsNnt6xh0bRbLDGI3bxCS8u1yPVFUDBY9rKODzXoHrDaT7N1iw3PaD31hc31r+0LWKMmYGMgCaNeO8hCyMoxkdn97LySQD/AGuW3dMv+hGh6nJbRtrVprUUNjclsPHG6OJFzj7rYXuyfQV1PsEbCXYXSKx21eYY7i0iPX3SRe6QtIWjYsBwf3fugeefzyeT/tENX07fmzelOn6RNDqkep7sijHu27iAFZGAXxlS6EqSO3uzjFeldTuLDZ3U/alhG0dtBeaRc2VvaqewKsJWRUVAAOFDjjz28imiE9kN9fNn3nVT2WNLs7KW4tt06cr3GiXUXcjvc2/f2x4Ug9zxRsCD6j1rU9Ntz6b7Ru0ek+9Ypnttev8AUY9K3JZ9pHvprVPey+8XICsCiPkg8MtSbotm2mdMNjX0hLStuhLn4Rkn313MDgfQOT+X1qC+ge3bjpl7cu8en879uiPJc7h0mIp2pmeFe4K3Pcyhyvnwq1Bkenuoe19N2fsCx2/olqtnBqGt2cbRIWd52kmT3hZmJLMQGLEnPFcd7Z3VGz6TbG0bXP3Uus2mrRz6ZbS8+/kVHzgZBwAwJYH5/M1IHUq4sp95bLtr2dUtrCa51y4LHAjSCMqrsfHaGlXOT6jzXiyC7X2v/aHv9f1qWOy6fbQdZb37ex+zxop+GJSxVfj7GZjgYJPLrgVLIJi9iHo7dWdrqPVPdFsJ9y7jJltpnHdJ7liS0jDgdzMW+HzgE8knOi68a9Z677QuxNO2vpWj65vdNbube6t7gBkSEWhCNdOEZlAAkcRtyezjzUqbW1HdPUrR7/StvXL7R25FfSRtrwt+65uImIKJaxf+mQjKGkYZGfhUDxwu39B0y06+9JNIsbaJIdL07XdwzF27i4dktkkdgBkkjHewOSM/CT21JJ33VnbsfSP2f+pO5dQv21rdF3o88d5q0oCd0jr7pIYlHCIGZQqevHcSea4DdXXJ9pdJ06YbC0yXdu8NF23Fa6o1v3Cx0dUtwjNcS4C+8GCRGpyWz3do8arrLrure2/qOpdJun94bDYNlcQHcO7UjPZKyOrfZ7fu/lKjOAO5lPhQTXc6vonTrZPQvqL0/wCmn7Pim27ai31Wzs1/fLK2MGfAHczjuYsBjn9Q/ocb0L6FQbH1jaGq6zrcu7t/7vsILi9vLpu5LLT4kR/s8MYyFjBKr3Hzk9oXJr1bLuoXGobk+zt3waPbgSkf/T9rOU/JSn61536Q73g1bdutbvkUJoWj6d+xtLnnUdi29pEpuZFOMDvmYJleD2dv8PPX6dqOp6H7NGra9elrTV9ZtZr2YzHt/fXTsqknHACugGcYwM/WESpa7GJtLUJrXo/sfRYg76ruaZ9QPY4UunvGuZTzxntCDB4ywGRkVrPZ00a/6hXmn61eqRtfbdzcrZIzKwv9QZ297cZBPckWSiEcFizCr3TnYcXWWK+1i6vbyw2rbWUe3dKWzYRyXVpFxcSdxBZY5ZFXBUgsqDJIxXo3QtA0/bGlWWlaTax2OnWcQhgtol7UjQcAAVBals3FKoHiq6F5XSlKAUpSgFKUoBSlKAUpSgFKUoBSlKtApSlAKUpQClKUApSlAKUpQCsa4tknieOQBkcFWB9QayattQhkI9QNvCw1MSe+MQuXVO5lyEYD43+mQVbt8ZJP48ZqBZpoFkfvRuyMKVAK9rcLjyASzKM5IDFhkZzP+8ttrubR5rQkCQjKk8j/AF4qDtX02aTUbJ5DIG977i6l7h3q4GEdeeGOO049AM9vdzVM15R79iLdbGrbJ3FDrlhtyPcGmRQ3Nvqug20n7+6hYc9gbjKsAxy3ccnA841GzPbr2tfPbSahpO6dCtO5hZa9dWH2trPtZRJDP7r4pYwF+LADqGAYd/xVNO+dLt59MvXKmaVbSZEJ4Qr7plOB8l+HAJ4wARkGuA9n3SU1HZu7elN5fSQ3JSPXNLupCELQThJM55yFcEEAeO4NXF2ZLhLSMox2SPpXXDY+qadcbh0jeu0rmd4u68sF1pPsl0jAYLK47oXbJ5YDPce4EfENAfal21okVpNtSPU92aVdSPGscFlN9m02YjJQ3KoY2jyrAIpYjB7SUK1selFhsnceu6joO5tnaDZdRNMkMd3JLpkJku1VvhnRiuXLAByw/mJz94DV7V27adO+oO4+lmqKX2huZZLrSXdv9xIQA8OfXwpGPkvGSaqllyfuW9Bqd89N9c3tPpm5Ooc0qbXmkIu9M0aQRPaZGFcyKzdqEs2VVsnK5YkVMerdJ9qbt2JZW23IbewS1jSfSb+zz3QSRNmJlYeQD3ZHzY+tc90u1m82bq9z0x3VcC4YK50u5lQhbq3IJKHnGR3HAxwFAOTWuv7vUfZt14XDe8vOmmoTFiEyX0mVj8KgYz7kk/eJ8nBxwTU8lvvvsT0JEldL99tvfRpUv7VtO3Dpc4tNUsT5imBwMfNGBLD6f1iTr91AtPZn1u56hAQPa6zaNbXNiHCo90iF4mAA8Nz3McknABGa6zfjNtbU7HqhtX/4jbFBFrEFt8S3lizdxlUeskWGIPy+GvAf9oN1ok6j3ttDpcktxo81x9l02Nl7e6NcSTuFyS3eWX+H7oTOOamFqskox8mMn0x2ec9+dTN2+0Fva73Zu68OqTtG0tvp9w7pDBCXXsRI1RgEbjtbu9W4NbPT7WLWNGaV7TT9Hu9PEckeo6bEkE1p2AvG4KKBle3gh/4frXOrYi0YG1VTBN2wRh+7uyVyGBxnIwQCDgY4zmuw0nVLWzvbeBkjEVzAbK7aMgHu7xhu4j0YOB2hu4H04rlXHa2zRlNyPVPsQe2LuC73Xrey99v+2r/El0uqKvdeTIi9sg8t70IFaTBycBsZwc+8dK0i11jdA3VZTw3dpc2KQQzQt3DhwwP45zjPjjI4r8a9Rt22vaDem07/ANzura91Ff28sK5eSJB8QeMjlUCnx/BwcE1+o/S3dNxu3p3oHUjZcEctnrlqt5qeiLIEVZCB71k54kVw4+HGR21p2w6Vs26rNrRst2bK0fqV1J1jQNXs/f2p09DFcdwDwkgEFPUYLH4T8PJ+EnJrzXvb2StNTcZ0C11tNl7iuAJNKvyAdM1UqykpJGcmC4GO34SM9xKqcYPrLp+I9y741fdkE6y2NxbRW8KswEsThU94jr/CwZWGD8hgkVpOqOh6dunq5tbQNRtxNZ32n3Ychu1h29jKynGQQcMMHyuc8VxsJuC64+foXtbPKWw5upnsqahKd0Wd1FaSXIQukqy6ZqCAYZJGJbskOF7ZCV+TIRXtzpb1k0DqbZZtEuNO1SFR9q0jUEMd3A31Uj41/wDrASvjmtDpeqXG1tQt9q72lTULHUJe3SNWuB8N2cf7i5jzxKADgsSJD8n4qVobC2+0NOLaISE9pfsBOPTB+ua5em74nlGCjo2RkxX3LVT2Z9KVuxMi7VdUVXWQFWJ5OyNnxntGcVfq2wyKA4Hd8M6Na7i0iJ728sHBlt4/M9uxAcAeO9RlgeDwy/xVuYNU0rdWhmce7vNLu4SJEkHwup++rqfGBnINa3Vb+fbN4t97l7vTJpQbqONMtASR+9Qfy5wWAxyWPLEg4Em2nuZJdQ23qFuljqCZurRsNbz5XHvAR4Yj0UDPByOKGB5y6s7Y3T0K1bQNyaRDe7h2lo8rG3nt1aS90q2cgy2zqMl7ftYshJBjwQcqBU7aodB9o3ozfR6PqUEul65ZN9lv4GEvuLhQGjkH1R1Rhj+UHit1svct3DPHtncCpBr1rGSkin4L2FeBNGfUnI7l8557cHiIdk9BNsNrO510e51XZOs2V88Y1Lbl81tJcRModBKMGObABx3J4X5VkYnMbT3pqGqddel2q6va/Y9zXFlqmzNy2igqEu4Y1u4XYE5KSJEJYzzlZB6la9B7x0C40/WLbdekRmW7hAjurZOGuYjwcf3lBLf8orz51E6G7n2V1I2z1ivt23G8bPajtJqFj+zYre5ltPdyoZWaMhZWiWWRh8CsRnB4FerdN1KHWLOK8gf39pOokilRcK6sMqwOeQVIII+Y9aFRBOlawm4tT35Bpqm7n1G6SC3uBFxHAyBpVJxlVCAnznuxx8uk6+bih2b0B3XqNmVWJdHdLUgEGT3idgyfmxk8Y85Oc186I2MC7r6pzRJH9nk3Eyx+7PntiQMT9e4Nz5+tRF7XO7EtvZbeMxt9ml1UWMsiEOFWOSR1ORkEExKvn+L60MDeexttRdoezhsKYRqrTXMk9wqAYf3jvGT82wQgGT4A+dTF1Pa4lbQLa2h+0TnUBcLEHALCONmwP1Ufl691aHpftySx9mvaWlxH/wA1b6HavEQMFpEVWB9fJGc+ua6DTnj3DvLT7whZ0sNM963HdmaRu09p45+A/rUjR5B9pDStB371/wCh2n7SEFnuK516e91C1uARHHNbIGDzQ5+8ckErglSMH4anLrto28tz7Xi/+APDuHSroXmnahpM3vIhIAc/DyyZyfKnyfxriN97UbqX7cdjHo+oPo93tHbJvpLyzhV2S6mlCxiRSva+UDjBZcDGD8XE9W+5t96GzQ61ty1162RF/wDPaLeIrkk890MpHxYweCR8qx0FHZyN3rOl7j6cdNP2SssFne6tpwS3dMSQCI5dXP8ACwZME/M+PNQp7bc//hb166H9V7RBCE1R9J1Nl7Q0kLgBeT/xN/8AZHzrt9ClutO62aJtuTTLzSNI1XV5dyWUV/EsIikFuwlhUdxDEs6sPPPePQEcf/axxN/+7jpt1bskd3Z7htJomaMNk9sijH1yy/pzxmmhps4z2terWr7y6p3nT7ZX/mb6/W3tJrqFgUtbZGEsrOPHuy5UMWIGIx6cidvZ99l7TunO1tGs9eYahPbSG7W2iciAzl8tNOc5uJRlh3vwqgKmRlm4r+z+6UhumU3UHccMV9uTd3czOR8K2gHb2DntRWcOSFzn4T5zXoLRr6XYl1FoOrsRYyyGHTdSf7snJCQuf4WVQqhjkcD5Cp0YpGottafQz1OjSNjLaTiRO/4STJCioo/u/CSMnnu4xjjwzv2/1bq71q11NAv5dO6eaNpNrt/WdxW8bj3kSd8txDbtj4jI7BXZSfhjbPw8GVfaC3Br/VD2gtT6PdMtWMQ1qG3O6dWhdmj09I+/McZQ4EhTHcMdwwv1x33V/pfoPS7oe/T7aVjCsFho13qczsPjmKIFeWWTyXc5yxHOMeMio0ZE89Itn6Ls/p/omn6Fp8Wl2H2aOVbeIAEllViX+bMSSSck4HJwK8MaXuiPUetPtB6Btt1m3VvncEG3bGJu0iBY4nNxdsQ33Ik8gZ5K17p2tumz07pDpG5biQLpsehQag0g5AQW6uCD+AJ/MV4+9ifY2g7D2lrfXnd+oxxXOt3d1Jp32nCLFFLPlvdLjuaSZ07MMA2UAA5AowdxDsnSrvcw6daXIsG0NDt4YtSdh8P2eJjLJ3SEgdzyq0jHnlD47Tjqt3xv7T9pZ6bp4Ok9IbKVbnUNccmJ9YCHuWG2JI/cFgA8px3chMgh65fp9s07w2Ve7t6gzxba2hql7Lq13oaTKJNUkZygN82cle0KBAh5bHeWPw12eo6lLvWGw1jc1tLo2xlkSLQdmRRYutXxxHJImQAgHaREBhVyzlQAagyj5Jr2Rq2nant61bSLKWy0qEe4tEeP3QMKYUMq5yE4GM8/SutKDitJoH2ltJtpLu0jsZ2XLW8JBVPpn5/X+tb2hsx8CqB5NV1QPJoZFweDVVUjwaqoBSlKAUpSgFKUoBSlKAUpSgFKUq0ClKUApSlAKUpQClKUApSlAKUpQFmo43/tiS4ZpLYdpuTmQgchgMgr9QVUjPyHyqR61uu2Bv8ATp4k+GVlPY48qfpVEiryQLb6sl3ZvDeJJGF/38nYG4ZzG+D4+Ilj9/1OQOM8BBDPsnb2yN/Qon2vZtzc7f1qKBQyixMjKCR3ZGMpJ6j94PxEh6pPHDZ6vfSgWZ05TNJ74MPQo4Y9vklc+M/vODwKi/2VN7nTtNsbDet93nfsbXsUl5zAbtw5FsH4X4oBH2qCM+7ZBniuGvrbltEx8kz9XNiPvrR9L3js65VNzaVF7/TrqFsfaoPvGEH1DDHbnwx5x3Guf3DqNv1/6S2+4tFieDcmisLiK3IKSxzoQXi5zgMARj+YAZ4rO27Jc9At0w7ev3abZeozE6bezsSbJ3JzE5wfJ8c88evdjD6maVc9Ft2v1J2/DINFvJ1Tcun20YI7GJH2sLxntZiWPzyfBNaTWk37l5TqdsPaI6UaZr2iyrZ7psR722mYDuWZWy8bfJJAgw3pwTgqcdd0q6kWPV3atxp2q2wTVLNfsmrWFwvxBzlHDL8iwZCPXnHBFR5o+u2HSfqVBqkFwqbC3rC9xDMZCYra47u5jxyAe9mLNjAbGODjnOpXtD7G21vG+1PaL2kW4byBYL7XGaRkEYPDLAgLysFBAfsIAUDDCsa49e39fYjeizuW53T0c13WemO2yuuaZrUbT6dKshM2jROMOsuQ3AUMVbHjBxkZr86esetanrPUA6La3VvJtrbsktvp9pBgxDABmw3GXfLHtwOFKDkE1+pnSHR9syaPFuDTL1dfk1JEu5temmLXF27oAPiJ4ABJCDlexe4gfCPBftt9Mbbp3uVtyWdkU0PWLw3EysvwxzqGDxgeMOhkIyeMn72TnexanXPqZRZ3j2POUl1NbXMU7RrLp6M9qC2B7s/eVcJkr68EHxya2V1fJdyzXEYd7ssly0ZJ73yFjPacecqCykcnjLEk1xU1xM0V8nvhftGnvY1VlYFIz3AkY5XtYkqcn4T5yc0Puq4jtrS7srdTcRQvPLCvcE91jtZGz5HGcDwCR4rmE9nH99kzyS/su+0a8igNxDeRtGQ8gZT29uFYJ3HJyuVKjOPhU5Neyf7OnqbbaPrGr9LbiVXgd31HRoO/uBQgGQKPGAGz68oM9tfnhF1B1HS9o6DDcabBqFory3ETrIVCqS8ZR27cRsOGB7iPGakDop1Ug2j1M0bXbGU217ot2A1vI7MzwiQvIjJjwO50yD4UZwKiUFI2a+z2fsvr+y59P1obh28qRamiNHNbZ7UvEUDCt8sEA5A81yCLc796obT3Nb209tbada3EN7DOoDW8xIJjY5+vgA8DPrUxaZfR6pptpfW7+9guYVmR18MGUsCP6Vxe79l3kGoDcm2mWHW4wVkgbiO9j4JSQ/UjPd9BXD3UuM/lN7yazrZpNtra7V067jL211q8aMAcEYjbGD+X9au6BuabZGpWm1dzXSssh7NL1WUhftK4I93IPCuoGASfiXHhsA8z1H3da7u0TQbu1d7efT9bgjvrPt7preQ9ykMvHAJ4Yea6ndtpp+u78stvajbi4tbrTppvdyMSuQxU4HoSGGSOTgVpq1wsbRKJPV2wMkH14quoK2hq249sXmsQWCvr+39P1N7FrWSTuvLYABu+Nv4h8fCyY8j46lXbG9NL3jZvdaXcCZYnMUsbApLE/GVdDyp+hFc7TfGxGPg6Wq6oqutwgVQwyKrpQGIyK+QwyPkRkfmKje82jqWl3cmqbJvodOaZmkm0m7TusppSSXYqvxRvg+Y8Zx8Wak2uV1jT9Q0qeTUNHCSl+Z7F+BKfmh9GPk/PHNDA4rWbfdm77L7Fq2xo7S5hlMltqVprMYe3kHiWJ+3vU8fy8jOfOK0myJdd6S3es3m9LR79NYuEnbW9M7p4kCRBR7+MKGVuCSyKQc548V37dToYkZbjQdwQXKqG9yNMkcHPjDgFfT1I/KtWslz1HiWzv9PNhYW05aaCYqbmR0I92wALKirw+e4kkYAxyQOx0vW9J3VYtPpt9a6nbnKu0EiyqMryrYyB5PBqFtrbstPZ21N9g7illg2tI8k+1tVkRjEsJIY2Dv8A/SozERjHxJ2jyprtI9oaTe67Lb6nF9n1xY2aHUrEtbTXEfABZk7e5lAGQRWp6mdD9S6iben2/ebunk0qb3bIdQ0+GWe3ZGDK8Uye7ZZAQO1iSfOSec5GJn9AdC1LTNq6pqGqwPbXWtaxd6oIJVKukcsncoYehIHdz/NXmT2rZrhvZp0+O2X3kU26byGRo178R+8ulBU9o7G4UjIOCQPFeleiO7da91qOyt3XBu94bbWOOa8Ydv7TtW7hDeIDj7/YyuP4XRvQgnyZ7VJe/wDY12VqazYdNfnkkZBnud5bnuB8fefPPzI+dGUS9j3P0z7ZOnW1SpznSrQ//gpWo2Ppi6LujckHxBEaLtDHOEIyMfQlmP5Vk9FbtL/pPsu4SQSLLotnIMemYEz/AFB5rkvaQ3m3SbY2v75jjdxbaZPbyBBkM7Li3yByf3rBRj+fn0qNFiRHvsd2z713f1i6mzmSdNf3I+nWE8h7g1nZ5hUI3kp393B/k+tepnQBQBwBx+FQ/wCyh07k6Yez/sfQLhVS7h06Oa7Qfw3EuZZPXz3OB+VTNUFkURV1u0cpounbmgAGobZvE1OIjPc0Q+CdMjkBomccevbnjOfL39qvqBvOh+0LC2JZ9V3DAsbcr4iZgccHnIHOPIr3JqWnW+rafcWdyglt542jdG8MCCCD+RINfn712nn1Hqj7PnTaab7Xe6Put4u/JMkkMLK8UrKeP92F7h8ySPhqfBVPsexuiugJtPpPtLRYwAtlpVtGe1lIDdgyMgleD9ahj2sesutLq+l9GunsMNz1D3bEQ83bldItAwD3bjBGeW7cn4ewscjAqQ/aY6/2Xs/dOpdaaBdQ12+lGn6PpoYBrm6cN2gnyEUAsxA/hI8kVynso9CdX2RFqnULfl8NY6l7sPv7+bkR2EGQY7aJSfhAVVLYX7y48LkykVmv6d+z3p/s07b0OSz1BdQc6rb3Oq6nNCRPe3EimKR5Je5sqcjtXHHceT3HMinbke/NH3rrM8fdJrGm3GjWcflxbiNwePVmYk+niuq6t6Eut9PtbhMaSOluZ0WQZUlMPyM/3f6V5+69+1FJt21sNg7EtZb/AHprljEbRLcEpaoyjLZ/mClWCgE/ECQRjuPsF2IZ0nqzfdeuj/SvoTtK9MN5qukxRbi1KMhmsbSHKNCpLHDnsBOc4Tjy3E8706H2O2dmaZp8c02s7gitU0nRLUhYrbT4uBI9tCMhGKZVpW7j8f3gKjb2WNi6b0I0210jbK/+Im/dXeSXVtTjf3VlbBAGeM3JBUr3Mv3CxJ8g+s3S9Mr/AKg7/ik3jqp1i00uzxNpNlEbexLT8rH2gs8oCr3MzPg5AwATWI1s0lnYJqOt2UdssW9N0WUIt7Szt5GGgaIoJVXc+Hfgg8mRu1h8AIIlfYXTb/Z6Z9Z1u/8A9od2XUfZc6tIgRY1PPuYEGPdQg848n1J4x2unaJYabaR2tnaQ2lvEAEggQIiDAGAo4HAxj5ceK2QGKFyWirsUeABTtb5197fxp2/jQvPtKUoCulKUApSlAKUpQClKUApSlAKUpQClKVaBSlKAUpSgFKUoBSlKAUpSgFKUoBVDr3Liq6oYZFUghHqZtyC4vdRtpIwba/t3WYHkSK4KOuPmQwxyf4a8p7f3dpeibevOk/UZIrGKzjFjbarqHw27+6kkW3minDYhnjKkL39pBjJB7Tke2up+nXD2drqELKI7T3glRvDK4A8fTHkc8nHmoJ6N6RpfVDd/UbVtX0pNR06+1D7BDFPEJFKwQhGPb47iz88nBVcnJNali76K2cT051Hqf1R6dXGkxb10S7k05pdL1TT9yaW803v4Wyk8dzFIgAeP3cik9xUMvNZUll7RbbOfQot27SS1WNrf3sOkT3MwQKFWORZCe34chyEftBPgDuqx022tcdCvaX1/ZmnQ3C7P3RY/tDT3ly6QXMCAtF7z+URYwzEcRAYIqW979VtqbI3BYWL237Z3BdMZLXRNMhWW4aNTzI69w93GnBDSELk4zWpKtMzPNmz/Zu31umdLLdWtLpW3U7JbWxtLo3EzEgYkRmXshU933sBu2ReeGrE6zdNNe6LS20vTnS9U0vS4rA3d3uK3aF5mvS3i4llKlYygJY5+Ig8kAkeh9Sv+oeqpejR7DSdplC0kX7Ql+2T4bAKssPwqBxyrNwcEeKw9O6Frudk1ff+4NQ39coy3Ftauph06Ag5ZkgQkMUZVwzFjx5NRGtQ8GEjgPZLvtxybS1Wya2nu9t2UyT6ZqbxFY5pZFJuIogTloVkDuHwAQ7YHHxdh1X6Ux9Stp6vtvUo4pZbm0xbLISe2bnskBwR8J7EBxkdzY8DEy2MSWUQggt4oIMjtEUaoQAV4GPGFRVB9McetW9QjQy2qNP297KxErZGAwY4HHA7Rjn1rYXZjW0fhZtHp9cWuuOL0R2kNperp99BISkyFiVBJ+6obDKSTjHdx8POrm0t9v65dWk/dPDZztbKp5LRyBiMOMjwFHj+LjPr6z9tbpnNsnr1JdKxstM3inZN3cJ9owVDn+bDIATkEZOPIz5c3LFc2U5urtc3LlrGX0HvY8qzMeeTksTj54xxW3CWzWcdFiyia50q4025j9zLpo7xLImWCljjByG7Wyvp6c55qxNDMpvLokRZIYJ5Pd2kk5+QVWOcev0rM0PUv2luK3+0xoIbyB4DGY8IZMP2r254w5VWB+f0q9qujQQ2iW0twYrV5ixMh90yMc5UEeVGR5+a/Os5Fblo/aj2H9/R749m7Z0/vlubmwtv2fOwYEho/hVCc+cdtT4Tn/X9Pw+lfmj/AGV3Uu50vXN0dPr2YJ2Il3BblgWDA+7dRluSSFPj18V+lwfOa15LZvVPcSOd/dNP2rfRa9o7RwazBjuSUForpVJZUkH05AOMjPHIribrekOr9R9jXCo9vq8Ynsb2wb4gncU78NgdwDEL3AcdxDdpqfOceP8AQI/6VxHUDYFtuX7Lq9nFFa7j0mQ3NhelcHuCkGNz/I4JQg+h8cCuLvo0+uJcYHSSTOob8hYYeLcc58/wtFCV/pzWHouxrXXGvtUguZ9I1oXs8ZubU89iysAjochxkHhs1R0quIhundUs0y2OoalNFPPpUxxLDOqBJCDwGU4TBA9DW96WiWKTc1vKwKRazc+6HgqhYEAj8zVEI7fSDB0rfO5tOkv4NT00axBZTmA3unDEjAYyWi/m+L+HArqdD33o+5HMdhqcLXSD4raRgJVPnlPJ8ehrQ7D1ttQ3TvXT2DBLC+TtDcffXJ/wA/IVbbbmibxvdwWOt6PZ3rQXDdryxgt2MowQ2AQeCMg1yELZwfd7IJGWTvGRyPn/AJ/hV9ST6YqJ7HTtx7ItpX0Sb9uaOqmUWOo3DGeMBQcRyHgjz94n+tZlv1bS0ivH1/T59sG2iEpfUWQROCcYV1Jzzx4FbayIvyRok+rZTFajStYg1OzgvIZ45baeNZI3DeQR+fz+dbcc+a242Rn4ILJHxAenzrkNy7VuLrU4dZ0e7FnqkKdhSQ5huYx4WQeoGSQc8E5rs8c5pUFRFutbvt5II4tfV9ratbS91vdzoRbO59Vk4AVvUMQfxrbaP1L0S50wS3up21rdRhhJC8ihsqSD2jPOcZH4/WuyvNPtr6P3dzbxTpnPbIgYZ+Yz61j6dtrStJJax0+2sy3k28KxH/2gUMn3Ij6qbRu9+tY65tJ5NJ3dpHe2n6rMfs8E8ZPc9tOhBdonUD4gvwEo4zggwH1o1Tbm/vZB3Ft3Q7E6Vqe0mtra/wBv3x7rnTpllCYctnvBLOwk8PkMAMmvc7xKqgAYH+NeLfb89ms712xq3UfaU9zpm7tMsu68FgSo1WzUgujqPvsichjkdoK+gxKK5Im32QNWh1j2bOndzDM0+NJjgkZu74ZIyY5FGf5WRh+VRv7ZOsSbu1vpf0ntCQ+6dwW91fe7b4zY2ziRsDBBUsBkegTnGa1n9mhvmHdXQe909ZoppdK1e4USRP3I0cuJVbwMAln4x6Gtjo8L9Rvb412+lZbnTtgbahsYm4zDd3bd7L58lBz9MDmp2SesFQIgVVwB9au0AzSsS1FL+K8AdYNc23t/+0C0zc2tXUNro20dqXOtajcNwIZfd+7UkfxOVkjVR95veBRyFz74mfJ4PH+s/wBM1+SGzOl+pe2h7Y+/dRS6ZNgabrIn1C7BYCeKNsQwRtxnJjDdp8Z7h9RVJbPTnQTp3rntHdSI+vHUrTfsmkW/fFsrbFzybKAOcXMijjucknGD/D/Kuex9v3dWu7H6KWG4tvand6Vf6duDT5ZJ7OUxkwlyrIx9VbuXIP0PkCvTFnYRadZwWtuiw20EYiijQYVUCgAAegGK8jf2mG6odE6D2mmM9utzqmswRwrcv2qTFlzng/IH8OfNT5MWiQPac9oay6MdNLeY2Y1XXtbEdta6cFA7jIuGZx5IALEDHxEAZwGI8xex50o1jfu89x7l1XUpImnSBmvIVdLmWD4kW3gkdR2QkRt3le5iFIGCeeL2PsrdnXbT9w9Wd93+dNtrhdM0m1VmQ3szsESNQcERjuVSRywUqQoDAe4d06bY9DdN21r1haCLTNJtU0S8t7ZMGe3bAjYKP5X7T5ziR+DgVKKi9tyTRtn7v3fqMcdvpG3ds2EGmQhF7VjY5mlGfXPegBxk/Oruzd1XmjaNaWdzYrdbp3BdT6gmlA/HBC7gB7gj7gAKA59fg5aoU3g+pajo2laXcWlwdwajqB1n9i9nd3sXzLc3AUuwRV92qYHIUkKc9wmHp7Z6jpNuqpb3Muqam6/tDc2vwiKW4kPKxR257XwoLkKQoUKT8RznHYXdk3WnvzaxG4ZTP2DvKLgZ9cA1lDxWPaxPBBGjyNKyqAXbyx9SayAMVLNj2L1KUqC0VQHzVdW+38aAuUpSgFKUoBSlKAUpSgFKUoBSlKAUpSrQKUpQClKUApSlAKUpQClKUApSlAKUpQGBqlhHqdhPaSjuimQowNec/Z00Ftqba1nTrqD3LR6/qKRl1+IxtMGIB+92nIGB/KK9MkZri9ZsPdRuqoq5dpFKjGQSCWPP8JIPHoR8jWtOHfYPz76hzx2uh7wttSS9TrjJuaJdIAkkWdUkmT3TWw5VrdYAwK5XGWz2fDmR9l2c117Tm/Lu7lzLZ7Z0893exMZMo95gjHw5DNj5c16o060hm1G1aeOOT9yymR1BK5zkjjye45J85Oc815uuTDtD2tZrd3MFjvPQzBbzLg4ubY5AY4+8VYH1z7wA+tUa2VN6ZM9/2w6s3dMp7snLHJJIOSSR55HP0rcRnssIx6qvfn+YlgCPwOKxdV0cyyxTe/7Wm7GV18gMQQCPp2tzn9KzrzRytobaKR3libuMgYAMmVVQAcD4nZiKq0gu5jtqPuEMkpxHHGzBn+gYKSfmflj0bnirclpNNq1p71AVjt+8s3le5S3I+hbt8/w1sVtIIGQTSqyxqkpYeFVFOQT8yc4+eRnyc5mlRpL7+/ciSebtYsAVKkK4GMj545xQtPNXt3dJD1L6RS3WnxH7fYobuN05cduO9fmQw913Z+Rz5r8vd130e5tEvbg2/unntY9RlAAHuriHME+E8sCcA4PPdn+av3Yv9LTWtKv7OSIu7KX7AM9wI+6f7rZbP+sfid7RmyLnox7Q9/oE8Zl0O6uXuLZRgE2tyWVwGJwQGJXuxx7sHAPm6BTNEPfant7K01RAwmguwO4I7AjIlHeMAnkEkg88fSu23ZbwTG67WZo4Pc3sbxIWQRTIGVlA/h7QBx6g1p9L6XXq9Pt4akbkDVNvala281h7rJeNiyLIrDnBZlGO3wc554yNtT6pa67Bp27VuZ7a70cWULp7tykTRFrfu+IcBR4znBxWxI1ZJEm+yP1Vj2N7Rm3tXa9SG0vo5ba6klZlTBQMpByR3l1QeP4q/cXb+px61pFpqULB4bmNZFK+DkZz+Br+emSyh2xNtbclsXW6SYC7hC9iLMrFR2H04VW5H8XGa/cn2at1f7Q9M9NmaTuj+zxMpGMYK8kDz8v+1Us2KpJR0TF2jA+fzokGM8+PpX2N8gUMrj+L+lIrZtbOY3TsPTN0tHNMrW2oQkGHULbCTxY9A45x44J9K5PStQu+mcl1Hr9q93bXlwZJNbs0LL3HjMyDlAAoORxzUqovdnNWZLSMo69oIcFSD8j/AJfSqrMb98fIIp6dOZ+om9NQtGW90q+ME8N3E3dHJ+7U/C3KkjuIxn0FbbbN4X3/AL1sHbDgQSxt/MGQ+n0Ix/0rJvthXGj3T3u05odKlkPdNZEEW0pyeSo8E5I4I+lafSdeist6Pc67ZvoWo3Vr9nUMe+2nbuyojlxgnGfhIB+nFcc1KHdok3O2779r9PJz79p3WGVGZvQgNx/Ss23hXXNo2iLBb3Uc9vGJLe7TvjdCMkY8HOcA/Q1oumVqw0TWrFmQAahcxiNDkdvdzhfIyCeCCPxqvpGIdU6d29s0c8MOZrdh7w5Kh2X4T5XA9AePSstpoEY7O2bFo+m3H2KDXdpXVrcXFuZ9vXBmtu5JSF7rf4l5BXwvzrudI3DuS4Pu7ffOjXrI/b7rUtNNvM344kXLcHgLjx5qnRbLcmj6vuePRtXh1GOO9WRrbVFyU7oUJxKoBz5+8Pw9avahuuIgw7q2FeCNeGu4Ldb6H15DICcjPjH+FIOUX2ZDO/0Q6772Q6rNp0owAoso3VvXghif8fnW/wDNcNtHdGzw37O0q9ijaQlhBIXQ/kr/AOVdyBj6iuYrl1R87KmfG7vQgfjSlKsMRVl7dZFdGGUcEFfT6/rV6lAeDPZbiTof7WXUTprK0S6dqVsb+zUjDBYizqW/FJG5/u/SpG9hWdd26H1H6hSpGb7c+7LyUOOCYIm7IAfpwf8AQqIv7QLb2pdN+q2zeq+3y9vLNG9hcyJ6sqkY+WGiaUDPlgOfFTB/Zq28cHsobblAxNcXd9JKvyb7S6EZ9cduCfmDWRB6qpVQFU1iSQb7X3VgdG+g+6dbgm91qMsJsbA5wTcygqrDPnHJ8/wmtJ7C/RuDpH7PW27WS391q+rRjVNRcqA7TSDOG/BAi/TkDFQd7Y2oXHW/2oOm/RnT5GksLKWLU9ThTHcMuWc5+SwoT/zEY5Fe8obeK1hjggUJDEoRFHgAeMUJ2XgmPWvy79qncF77WvtTaH032o7Xej6SptFuAO6FZzg3M5PzRF7Rnkkg+OR6c9r32jpNuQR9NtkM+qb61wi1aC0IZ7WGVcBjwR3NkYB5wSePI0vQ3o5pXQ3cu2rK/e0ttR0zSLzcGu6rcSfC0soSAZkwAERe4ZPnyGxkUK5PZI249vWOhan0t6a6VEltY2UiX8ygdjJbWaq3cR/9ZKYy2T6MckitPrO4tw9Yt82lxtq0e82xplwBpt7KuLOW6GVlvWY57hCQViQBm7yXICAGovffsvXzqxu680uPUr/Yxhi0sJo9uxn1a1XmVFlkCJDA8jAOQxdlVQFwST6E07S+pOtafBYWFvofTrQ44VhgihU394kaghQq/BCgA4wQ9ZGOtl+SbbPQ3Qby+1a+luL+8kMkl1IpuNQ1OUsQqIidzMFLEIqj4QwJ57ydhsHSdxazqcu6d3QxWdzymlaRHybCFvLyHwbh8fF2jCg9g7sEm9sfozo+09WOt3N3qO5NxspVtX1u49/MufIRRhI1OB8KKvr8zUkKuKjZmo6PtKUqDIvUpShaKUpQClKUApSlAKUpQClKUApSlAKUpQClKVaBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAVrb3T0vIyjnPJIPy/1yPwJFbKqGHrVL7ghrcd3daRDqx920upRWs89tB7vu72EbsO0D4nX4T8Kgnn7prwNqvVPde+rG01zU30m/u9qNYa2b/TkaIW0VzK0dxbyL3sSV7YzlgpAQ93Z28/pVv7TpILaHWLUATWJaSVVGA0WPjJHrgZNeaeplroEO3t37fW707S7/X9Ona3S47Fa+mMeVIGCzP3YAIy2R5qlrXgqmTRpm5LbWNJtJHtxdL2JJDNGwR2U4KnJ88NnBP8AjW8e1WZUFvcCUHLOh7jJ4YPgY4wSPd8+T9Khf2Zt0JunodtpZVEr2lrHp1xHKP8A1ISqkkeefh5+nrUqxkm+juInVQwJwq45KIcE59GBNVEp6NhDHPPE1xLbmIO5tmhPIAJ4x+XH4kGsyD90qQ9gUsGQH1+HLDB+R4H5/Wq7gpNYXIVs+8VG/Agpg/kGx+C4qy1yQBKoAZ+1gTzjw2P1bH5fSqzNPZlWcqxXkDlspKCo+ee4nJP07x+h/Lx3/aDdArbe21LjcllbBtc0AF7eXs+Nrcrl42+Du4yWUA4zn8vXUEEsohf3TKFLt8X1PgfpXNb50obk0W5jugZYJ42gmD8he7wfTwSOalPRjLuj8XOn+qWl0dWkuVaUXlj7i4t1fs9+BkxkjkKOFByGx8XjAqz1I0WWyl23qdtHJdxzIWyThm93z8XyPYCxB5yfHmt3uLTpelvVLUbJ4WUxX0jp7hy6ZEhDRrjJAAJPaMcsa2eqoy7f1iV2jntrDVe+NJnUOque0SAsFBJJA5yThvz24PZpT7HGbr9xufppPqUCMJ5rv3jHGe3BQqzH73Pc4r9Kv7O/e8uodHdpyXkxfLz2MkzHIJBwuW48BR6fxfr+cuo6ek/T/VgEZVtZoFDKhcMS8iq3BGAT3AA4yeR8Ir1X/Zx7j1NemutaQsEhgstQW5t3C4EwdQSIz/EVA5Xjknmpa0TXLTP1KU9ueOR86uoufrWp2/qQ1PSrebIZ+3DEfh5rbpUxSN6MjIr596vtKvMvJbC4rW6tt3T9csntL60hu7d/vRyr3DPz/H61saVryhGfkkjSDpbfbXMh2tr01hC7mT7DcIJYF+eA2SPy9aw9safvLZ9u1sdPstSSa5e4Ywz+7Kh3ZiFBDYGMVK5OaMC1a0sVS8PRJBFppe5Nz7w16STRxZSpbwe6nuJGidW+L4EkjKtxnhypH0qu6ut6bcJMtzrVtHnJc20eqQ9v1OUlX1HIPlflU6AEDzX2NcZzVDwv9RiyJNi7q1zXtaiW7fSNTiQFnmSzntbqIemA4KnnI4apcAxVIiVfuqB+AAqut2qt1rTK5HylKVcYilKUBCHtddJJOsPRDXtFs4xLqkAGoWIIGDNFlgp+jAsPX7w4rx5/ZUddY7OTX+kOsyS29x9pk1PQ0uGHxrwk8Y+TL2q/aTn/AHh84r9M2QOMHkV+Mnth7A1T2Zfabj3bt/Npb/tFNxaTKcooZn/fQ49RkMoPyYc81kwfs33N8qwNU1KHSbO5vbpxHa28bTTSE4CIvLE/QDJ/I1zHSnqZpXVrp/oO79HlEmn6tapcqndkxEgF0Y/NGyp4HKmoL/tCeprbJ6C3+g2Dsdf3ZPHo2nxRuFcs7qXYDnOF9Bz8Y4qNESnpHA+w5ay9XurXVDrvqERePUbw6TpayRkPEkZ+MqCSRlPdDAOKlv2q/aq0noDoi2NoY9R3dqCFLDTu4ZU+FZ1847jgZ4JI/LQtu/afsP8As96DoE08Z11bFnt9NZwJJ7nBeSRjzhFZgCxzwFGScVEHQn2X999Yd7x9Zupes3GiXOoMLvTNJijAu7VSSElVpO5Lc9vaVCKZEDE5VzkPBUpNm96D7Fbo1drvHfUVzvXrduRJLqLbmmJ7y5sRJk4cZKw5Vj3yuVxllBcly8y2Hs7jqDuZt69UEivr+e3jgj2zZTE6bbxoSVSY/wD8ywZi2WATOD25HdUt7G6d6B0+0+a10LT0tTO3vLm5ZjJPcyZOXllYl5GyTy7E/WurCYPzp4LIo12laBp2i2MVnp1lBY2kQASG3jCIoGMAAfQCtkRmqlOK+s1QWdJRSqu2qaGIpSlAXqUpQtFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKtApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQGHe263NvLEyhldGQg+oIwa8Kddehu4uouvw6RpkmnRWoSK1eO7hJeBluYpTNHIiEu590UKsq+eGJfFe82qN9+6J2yC+jTDQuL0kcD4O1ZOP+EA/8oqiZVNbPOnsmY0Fd96AHWWCy16dI0zy6OgI5+6pPbkDyM4PNTzZx/uJUH3kkLL9Rxg/nwcVA/S3TBoftBdWNCiRBDcPb6xGWcAOrICWIx8TYcnjnu58VPGlQyG97kkdrftjibu5HcoaMMfwCgt+NakyF5M+S8CoiKnexkEQGcZJAI/xFVaXHJcW9t7mJizhV7X8csVJP4BlOfrVMWmRKTLL++lce/RR8IEkbE9vr/CGz+VdHYhIPfQwJiPuM6L4GGUEgfhmsC1eC+8HubKKPuLmPjuP/AE/KtNBYi/ilgx+5njKZP3gRjH9SK3V3LlHOMZHvMZ9a5iPVe9ZhC3u2VRKGXLMpLE5YcfIfrQk8F+3P0FXXtGm3lp1sDc2sga7JXLiUMFZyR6nJ5UE/DXjDdNtqU95qNvp10zab9ntLqOYBUDDtVMs4OPhYsS4Hq2QCa/YbeW1Ita21uLT2iFxb6nDKskTcKzNGSAfqc4z/AENfktokMcGk/sbUY5Uu7C5ubVsfEVWOQFS7cA9pZUwDkefDVsRejStW3tHB6fr2tWm2tV0uzniVbyH/AM/AoAJETsE7Wz/Axx35+EMvCg161/sx7mS80HekckhK272yqC+B2BJCygccNgZz/EajPaB0uy0oR3VqWe8kklKcmVGVWUcD+YRq/B8g1K39muvud5dTbKR/dJ/5VljD9veWdwSo/lGRjmrN6Kk+5+jXT/XY7V3s5ZFcP2lWB8H14x68VJcS4zUGpO+k3yT5xgpGx8DHGOfm3aefoeakzbu4FZVSVsowyrfQ+KyXc2490dZVdUVXWReKtP4q7SgFUFRjmq6UBQFGOKBRjiq6UApSlWgUpSgFKUoCivKf9oB0IPWXozc32mWgudzbdb9oWKhe55FUZePPnlTnAr1ZVieFZUKuO5W9KFLWz8sf7Mr2lbXZ+6NT6VavOlpousym+0RpndRBcMMNb4YkASAZUZz3KQcls1c9pDrjoe9fa2gutXv0vdndPo2ltbJn7XkvIiXlEaZPezOqDvUfCqHu8VEHt19Ab/oV1Uvr7SLIxaLrs8upaNNCSBE/DTQ+hR1Zu4AZyCmPjbA4L2L+l3/jt1h23tm/kabS45Df6tC4JEsEDs4QPnC5LBCcfx1i3opls/QzoP0k1r2jOoMHXHqhYBNPKq+2tszgskAySLmRScYBwEHkkF+AAK9rJaqn3f6jOfPn9aosbSKxt0ggjWKKNQqpGAqqAOMD9KzFrAujFHwDFKUoSXqpIzVVKFopSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpVoFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAs1od2/ZbfRLu4vCsdvbxSTSO2fhQIe84HJ+HPArfVTLGJYyh5B4PrVRV5Pz66IdXJOoHtY2V0YrW1ttV0Ca3shFcmaWSOKV1DzL2qEldVJUqxAVcFsZFewdM+GF17WU/A2WGPIUEDn0IIz9K88dZNqaP0t9oPp/u7T9H0/She6h9mu5YYUQziRTkkgcsuJAOPBI4FelHH7+b6uT/XI/pj9a1rAZMq+77pbcL+7kaTCjtyrYYDjH8LsOc+P1yY07IEJPwL7yFm+gzj9QRWBC3v1aMDBKgfPwcD/ANpX9OfJr79tWGxLd+Oxe5oseSO1B8Xj0PrVBaX9WnaA2aDGArKPqOO0/wCP61qLGwdbu/gZiPePLH3P8RPcAwBz9UAwPnWbc3UlxHbOD2pj3aj1PbnGf0H6elWrR2gucq2PiDMD+CBm/HzzQGlmi7wRFNj3kafw+MZz/i9fk77RCWmz/aP3vocYNlDPdjVbUBCYj3xly2eAO5cgnBByfixxX66Sr7v7/H71lf8Auqc4H9TX5Y/2k+jrpvXbStwyJmKfRbeaOceQ0MjBgD4/jA+7/F61ciiyPucbo26oNtaVZapNqZu7K1v4mnj9yWHu3OcdvGMqx8E/dPyNd1/Z87ztJvaO3tE6TOmr2rTQpJEqlUjkLMWXuwp4PA9efFeWta3Tqm49JvLl5IFia6to44rdFjSKOPuCOuAAuMBSw85ckVM/sq6xFtP2rtjESqUvLqfTZiMFQJI3UFDnjLnHjwV+Rq9LZppdz9UpbBpJblJHLKzBgGfvGOCB4H3SRgf8Vbja90LK47GaQLGTE7uCRnjtf814YehwQD6XL3S/s0s0qtmIdskY9SVUYUDxnk+c5y2fpgSv2wJeRK3vbZyWRh2l0PhSR5LKeTjymf4iDDejaiySdDv5UX3Msvd8XwuRk8+AeTn15HH4evSB81FNhqIXT4nhTvT/AHlupOJCq/fXt9O3PjNdxomuLq1okyBkDejEcH1z5/Gsk9lvUdDSqFOarrIzT2KUpQkUpSgFKUq0ClKUApSlAUV8IzVyqfIoCB/ax6Gw9eulGpaNGBFrljnUNJue0Fo7uMEoBz4c/Dn6/MV+S/sy9Y7z2bOscWtXWnq727vZ6lbTKFb3TENLEW/nBHevA5XtOcCv3akXJB+dfl1/adezP+xtWXqzoVm32C9/ca5FAuVWcD93Mw8r3nIJOfiC85aoKJn6PbY3zo+69u6dr+n6jBc6PqCJLaXSkhZAw+Hzjnhsr6YrpI5GcnODj1H+vwr+dzUN/ao+39I0e5vNROm2be8sYFm93ApyO8lO49zY7gwGO317s8/ur7M9/d6r0I6f3t83vLyfRrZ5HY5Y/AMAn1wMVgIS2StVdWR4q9UF4pSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKVaBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUqGDzD7ZOktqWx70wxu9xZ241KIxYDI0UqEhQfUgtzUibN1uHW9maPqfvkf7TbxXRKHPcXBySP4fu85J9K1ftBWX27bGuvEvv+3SZlIzjGQxH9UBrUdCQb3oZthbgoxgsY42KMCg90DggZx47/AB8h860rSoka2uorS9PeWYxzHlVz8JLBP1Kn9axNLK3huYWdlliWQOqH4CGJZCB9Of1qu8sEglM6sQJY5JCP4QEIIAPzywPp4porLb6xKxdS0gVu1eRkYQ5P4AVQWl+B/eaVD6Yf8c5Q4P45IrCbEM5LZCuoYH5kswP9SP1qrTJG+yxKTlVuEUD6Bhj/APKKybkZCfIxEf8AvLD+qCgPkkX2uGbHwsQsgHnPwk+f86/PL+1U2vcx6PsjWVQG3aS9tPf+7yVDe6ljAOfDGM4H0Pjmv0RZeyUuPiT0bxntbux+YYV5G/tNtujUPZ5geSH3yafrVqpdB8SiTvjXtPIwe8j1xhfNWldneJ+WccNtd2sGnw9ii4gSQqzYBkVCFb64BOB9TXTaBrEW1upGx9bsrpQ+n6ha3DzE9h7ll+LALD4cgjzn4gR5Nclc23urHR5FT7TjT3ZVBwX7ZGTAAz/CoHNWreJJJ9NmaRrY3JlUsZGyzq6sO0gDnAUDP1q6Pg0Uu5/QfEHu4HYufj7ZWUjkNwHQ/I4Kn/KsQ2Qkjl/iZVDKDwDGMDtP55fHzBP0rj9m7od9qaRfe5Mq6hpsEkzlynY/u1UFc55yue71yK6ifWZYLe3vLePB7vdSJIv3fAXB8c9zHOf+tSWLejBsVj0+aW2nDfZpH7lJ4ERIyWC88cKMZxz9MVm2dzLplysqhliYdsyoMk48sCOFyAeQPK4zggVoRZPPfNNdFvsyK0fvGYmNSFQqrKCT8SlWySMkrzw2d1pJ+z2xTLD3S4aQtiNsgKUZf5SoUBhwCO41Jb7kj2N4LiFCpDBlV1ZTkMpHwnP1xWYp7xUd6LraacRA0ge1dpGh7RjA7shR8+4H6Y+HFd3ZXkV/AssTBlP9PoazT0W+TPpVPkVVQsFKUoBSlKtApSlAKUpQClKUBRXK782PpPUHaWr7a1qAXemanbPazI3JKsMZz8wQCD6ECuqqllzj0xQpa2fz37n2dqeyN5bs2P7xbm40TVntkZs/wzDLE9wzlFViAee45+v7ydMtvja2wtt6MAR+z9MtrU5GB8ESrx+YNflTu7p1Fub2+tV0+6soby31PeCK8cqhsRA5kYHPlVB5I9P0/YJVwKqMILuVVXVFV0NkUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKtApSlAKUpQClKUApSlAKUpQClKUApSlAKUpUAUpVPkUYPK/tg9S9Y6e6bpC6etpbQaxDPbz6nf2T3UFv2RMyK4Rl7e/vCd5bGWXg1znsO9QLjcfTWLa+sWB0jXrOBbgW00bIzQSuxDoCfXuYA49QPFept3aN+0tPDqFE1v3SxyFclGA4I5Hy/XB8gVC+qbauNQ6x7S3DpCJFNYe/03WGLgD3bKgjBXJLZYntcH5cCtGwqJVx7zToSeHaFk44BPumUYH/+M/OtRbI0d/asHwhhck4zjhT/AIk1tJrqKzsbZpW7e5iAPC/x4/Dhx+lcraazFeXGnRd+QqnkenAA/wAB+lUlpupj22t2A2Oy7JY48ENkH+hrI9772JZQDnBBPgMuXOVH4Ec1pTfn3k0TsFX30jEkZJP3s8enxj9KvwStezLGvee5pBlOACFwBj5En+lAbC51XBjCBjGmWIxgNjgAn6Et3HHgZ9Khb214o9Y9mHqCLlfjt7NbhDz2xvHMjDK4IQqO4HzgKSOam2S0c27wSfu37mBA5C/d8D69tarVrG01G1msb6JJrCRAWgkQMjdwK4KnjHJyMc4/CpRDWz8m+hfsrbl62WelDT9uvqukQ2ctrNqVxIbW3tXkuC4CzfF7wiNlPaoY/EuQCDXpEf2VEt/oi2txr2iaP3zrLIbW2mnZA3DjvdhklT47QM/SveOwNNsdF2ZolvZmKCxht07Qq9igBSSQPxJ/LnzzXQ/tC3ijeVpEEQ+PuU5GPVs/p61cml5K+giXbnT+fprtyDQbi/uNR0u1AgsbuSJUKp2oiI5zgMAp+LHxdygYYYrpLBMTiGbuFtOpjYEYwWbuDHnwC5/VPnXUSarp2rwxRBkvLS7EkPvE+KLIIBVj/N54+asPNcpDqUclvIVka4jjDKjkGN3j5KsykqcqqhWyP4BVikmS4mQlswle2f4WBEQK/eSVRww/u4Jyf7w4rSXDSadJA3dhwO2ZSuWDA85IHaVIHb2n88Zrp7qVJbl5yexHx58jgFsj6ZHnPn6DGBqdtFcl0VwzT/E0SjAZhgs4H3c5BJP8uMDziU9mJpxbQSXKTLK8drIrAquQSTgA4IB7QSqnxjIxjArprPU5NBvUjKgRSKG7CfQfeGfHcOeM+nmuV0+SJ/fxXICESAsZzg4DEPkN247lJbB+ny50l51f2iuqDSpdTWULcMhuEUtHbup4Vyc47uRnnz8RBArjLuRx8aXTZLTLoUzlHq0T3DMsyK6kFWGQR9ayq4DQtROmwREyNPZSo0quTkgMcqT9OeK7W2uUuIUlRg0bqGVvmD4rkabo3wUoPaI04vTMqlKVcSKUpVoFKUoBSlKAUpSgFUN94VXVB80MZeD8ttQvm0r+0NgnBI/+UIUtnHcJEVCD9CP/AHDFfqMPFfmH1f0aVPbaX3XbDONx6dOrscAK3u2UH8WYcfSv0/HiqiuHkrpSlC4UpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKtApSlAKUpQClKUApSlAKUpQClKUApSlQwK+ZFD4r7VYFfD4r7Xw+KewNdrIzpV2PGY2H615b6OzMvWjrRfLBJ9mfWLGEBQAhlW2jaQj17z8Oc+T57scendwTe602TI70IbuQeSoBJx+QNea/ZySbW9jXe7GRDPuXW7zWn7j3MEMwRFY/MIqfkR5xWvMEoGO9lgEYQs7XIwkkfCBlbzz6Vzui6HPdbkcP7wJFCoYcnuZmbwe3jAC8HFSBBHG86Oqsj+8B+Lx90KxI8n7x8VoNrjF5uGXCjsGMYz3ZUnnGfBJ/rWAMu32/HcQLDJPJIxeQFkcBg2FHcVx4wPu5xWdbWMNlMGRwrpKBk57z8XcOB9fnWfp1uy2tojADtZh/8AVnxWO6M1w+RjLBufTHmgLtwcTscZDNjH4kgf1IrW3kDPAeMyhCD/AMqkgf0bn6VuzAk0U5YZKoG/Eh1J/XFa7UBFbT3JBA9xKJSp5HDgnI+eGb9aA0AV77Ye5dMjleKW2DzR+pRWBkUk+GUkMnHoCDzUWQ71vNgagYJ5fte0ZHikltwhK2bO/ahTI/3ZfIZfTKkEA8SQ0GqG4nuNMCLfqHCQNj3d1Aexmj7yQAGGO1iD2uzZBBNcftLp5b3FnNZapassHwxvBcBZT7tXb3cLY4btUqGAx4P5dO5zNlW6qKn80n/wbmNXGbbl7EmWVmdBk1RHmjWFLyLUowzZCxuwEvH8veJWHIwWGfNRtom59S0ncM+mCy77ue4advdp2p7ppG94hCZyQGjbPg5bH3qkT/Y0WJRn1K+u0jgFusErkj3SnKqx7e7PBzknOFz5rlYLiWS/1GSVQJ2iZTJ5IZmRewH+U9yr+Yx4FanJ8jZi349cX3b019i2upTrlJnfWFhDqWQF7Hl7HwPK4JJwfwK849fpVc2kJ2yqziWR++OLIHcGDHDefIBOD6E48cD7YOlv79EidJncIY248hQTn6fF+QFbGBjAhIViSpVHIyQM8s/yBxn19a77A4xx0Q31J27fXuji1t739nXnartLCpDFQxQEfjlR/wAPPnJqH7XpHeNfvA2rQ2SfC8MFtHkISpUqXLBsEeAoxwa9Ubo06a90+b3S98picN6d0Zxz/TxUQ3umJc2cq6ozHEYSYMxAXtJAI5xG3cfmfFeEevfzGHcrYPs+x2ziOmyLhJG+23rsmk6LFBb3EmrRwqsbsSoK9pCnHjIwSOPJwRgeJC2LumG8iEWAkMjloUPwtGfLRMvnKjBz9ahKPUb6C5WNkKXtw/ayMxeGMJgEkj7uRjtyT8QC/Aea30WoWxcBo1R2x8cPwMW/h55+vmum8T62zOFio2/NH/k5HI4qF0W4noxZkfwwNXQR6YqAbbfi6bqcNg2tiO9uEZ4bWSQOx7fv+R5yD5z5rs9K37PCEF0FnHjvj4Y/lzn8q9W4/wDEPCvnCN8HBy8N+DrdnG21+O5JmAKqrV6bq0GpQJJFIrqwyCK2C16tj5VWVDrpltHEyTg9MuUpSttPZApSlSBSlKAVQT6VXVB80MWfmX1jlZ/b/tZO4pFa3+nzMmfJEUZUkfQkfqcYwK/TQeK/LnqleKvtxanLOMRPrFjGZI+w9jCKEoc+eTnjycnxX6jDxVRVDyyulKULxSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUq0ClKUApSlAKUpQClKUApSlAKUpQClKUBRSlKqB87fxr7Sqe38KewOS6lX66TtDWLt27Ft9PurguPK9sLcj82/rUX+zXp8el9AdmRIDEq6ZFIYAckhipZiPJJBB5P8X057vrlA1x043UiDDtoWoKr+gPusjP49uK57oqY7nors6aM4RtEtmH/AN2pI/XNa8/IOgaf3l993GCR3A/Fx9f+1aTS5njlvZEIAuJpVaPPOOwjg/8AMK2Ud17i8K9jP7tgcj1xn/p/Wtft5ZbnT4sxNEounkJbyMckEfd5Cnx/+3AHVRPi1RDyO98fhkAf4GrK4uzel18P8/x/6VVD2x9gYdxTKA+PI/8A+j+lY0rAQXUgHa6v8OfIOM8ioIb0bYD47wDlPcOQ3z+FCRj8j+v0rntZv0uGkmi91LFcR4DAg5UKzcjA84H+hzlfbGEt+FPYVt5F7ZJMkDKgEt4/h5HpzjitTq9pc3RtAsDPAIe7uXnkRnAx+JbmpJLdwjrFPH9oWN4W7wwCt7p1Xs7yc8EALyKubWCPpYMrYa5kdpHxgMezHPPzPP4elfLv/wDgYwxKtEr9wOCRjlj9eBVnZV9FNYRSuje4hMhcFsDh2xxjwe09vz58V5vluNnNVxs/TBbOVrh047l7s3uuagbGweQHAHp865DQvd3N7C0q8yyCRmPjtTuxk/VsD9TzgVc16/uNWvkso51MYXLCPJ7cg5OPXtX4vyxxWckH2TSwikfvf3eCOVj5BYj0YsGJ5/iNa+LGfMcv8ZforM5SWPR8N+Wb/TSZpB3FW7e5mLHubJPwgDAI9ByfSsprmeVzFbr3qrBWVHAIGCCCSuD2nPAHOTn66iwvhqebM4WBCoLyshMpBYsQvdjgAD8xXQyp9nQoJmAbwjAqox9D2j19TXqyWjhG9mPDbOI5Qsjd8q9rNEneCDn7qjI/X6VHu49Mht9UljZfeoMLmdlLMAuQzNnAyCRz6jNSZKnv8EKJUGSrFO4OD4yxwPT51ptz6XJf2kTCXPYpjkaJmwV7sD5eDz+vpjPSPVHELlsGdaXzR8G/hX/BsTI1uoViTuRFTHovFYCx/vHfg+GUD07fH+Jrd6hA8Es1tImJFUuCDkFfQg/XnitTGnZ3ceTn8q+MszGtwrHVau6PTse1W19jntd6baFuneOk7kvkuDfaeC0WbhkRsHA7lx9SfrmuwiD2soYSsYh/C/PZ8OeD9f8AKsOLMUa5HwDIMg+/4xxWYvCAmte/PuuUYyltR8fb+hi6orwbjQdzS6Tc+9QEwMefJB+hwOD/AE+tSzpOrxahZxzRsHVx3Aj6/Tz/AErzbvC2jvoLexlRZEvZkidWGWMQOWUt5xwBjPrV7Y1xN003RBdW9/Mdn3iyC602VmnhtJPhKyxE8qoIZceO3BwSCa9u9CepvyMo4+XP5ZfVnV+SwHOPxILueow+arrWWl7DfQiaGRZY25VlOQeKzlevqGm6F8FOD2jpz3F6ZdpSlXkilKUAqgn0quqD5oYs/M7rfa2un+2M9vJCsT3Op286SdoZTI8MYOQDkksCARzyf5ef0xHivzU9ouJbb2yYzNF76zXUNJZXhwGw0aqwJ7fhOBweRyniv0rHiqiuHZldKUoXClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpVoFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoCilKVUC1V2qSceKpDk44xRA47q83uen+v3BGUhspmYecjsYHj8Ca4DofKF6PbM+JCp0q3TBYnIKjA/IEn8qk/f8f2jaOsRAj95aSx9voe5Co5+hINQV7OF++p9GtMtRbvBPpXvLBopAT8MbtGoOTy3ulUnHHHGQM1q2PUgSi0BEEohH74n3UeGYKH7+3BPb6/EV/4hVrTopYdAhbsxLHdqe3OAvDDAH5/0rZafCILKASIC3cJVI4ySpAHr4NXy3bbOOSO9WDfMANn/EVAMLVIWtZZY0DyuACrfwjKYPPjyfnWHPbyQWJ7G7y6McnyMEquT6+VHp5rdTSN7pu+NlQee7GPGfA+vNU3zqVQcIiRqowMclu7/wDRWHSVyNXDcxQwS/Dj30ihu/DKpUjuPPz7sn55NbGFirDt+4BIQvyVV45/EisKP3qmCOLIjyxwD/KSf8Eq9JH73TbiTHa6wuPmWMjjgDjjCj9ayZBpdaPbo06Y4CoT9AO3J/8AcK5was9joEsNwhilk75WViQe3uJi+LOB8JJODxjjHNb/AFlg1tMeB2nP/wCJ2j9O0Vxeq+91nULLTkw8crgShu4KFIOVCjkcqeD/AHvnXhfPZN0uZjjY/mS0/sjtGIofl+qfsdVtXTI7nTrW9TvUzYy0i5JB5AB/mA+LHz5roIrSJ4Hu52wV7h2kKSgAwMsfP3jjAHrWRY6etvbxxq7iOEYLD7wJ9VHAz5zj6VTqUkFiHKRhHftbvf4pADnDMcYyOeBzzz6V65xPHw47HjVHz7nAX2Ox7ZjaC2dUeJlijJjQp2qSSQXHJ+74Iyq5PjJFdXEvu8n4Eb0Z/hY/gOS308VrdHh+ywD3R75f/WKdqgkfdwfBx+NZ6u75wSHfgEKGyfTuZSR+H51z6+5ro+pIquCoZ8eXiRv6sT/gKSxrPkOO9O0hmk+MFTjPnPyH8NXRZSh1cvG7jye3tz/Un/Grzx9mOHJ5/wBymP1z/n9anW/JBHu4tI7o8pLmeJmEasFPf4zk93yAI/GuIEXnnwxUj6jz/jUwalo6JcNNIVCSoy5U5w5Hk+OCoYf1881HWu6Slo7TRqsamVlcMvYQWB5I58f6Ir51/EH0r1L8/jLv7pHbuIzlFfCsNTEAgPrnFXguUK+MgjPyqw4YKGdWV0xkn181dLMvhC2fl6V82dDU+mXk7n5WzUr/AOd1cu3L2cYj7vQu2S2D+AU/8wq7dWyy20vf8bdhBLchm/lI+X0+rZ8msbRp1uYZrhQy+/mlkKMMEHuK8/ko/StrE3bj61yM7JQsSXsQ49jcbM3Zc6YlrJATLp0oBe3RclOTkqc+njt88fpMGl6rbalCktvIHRhmoB2zF2WFzCOFWeSMKBgAdzNkD/mH6VvbXW59uLJcwyGOKJHkkUx94bAyOAQc+fFewel/XV3GXLEyu8Pr7nVs3jo2t2QWmTopyKqytRxs7q3pW5rMSQTK5HBwG4PPkYJH513NtqMN0oZHBB+tfSWDz2BnR6q7Fv6HU7KLK33Rmd3407vxqx79f5xVXvk/nrmPzdH+dfyVaf0MmqCc1jm4j9T+lfDPH86w/O4/+dfyiHGX0Pzi9rPUZdM9rPT405W6fTbiQHgEgBcEeq/D4PPB+Qr9IoX94gbGM1+ZXt2302ge1FoE0MSgXOl28iyspADJM4HacYzgHPy7xjPNfpPo0nvdMs5MjMkKMR557Rnmro3VzW1JfyV6afdG1pVpWB9aryDUqUX7lhVSqQc1VWQFKUoBSlKAUpSgFKUoBSlKAUpSgKTwKsR3CyEheTVUx7a5XaUxvJtT1HvYxXNwViU8qFT4Mr/xFWPj1rTtv6LowROu2zr/ACKqpStwgUpSgFKUoBSlKtApSlAKUpQClKUApSlAKUpQClKUApSlAKUpVQKKobiq6pagOL6kailptu8BdkmkiKx4XuB+Jck+Dxx6jzXD9NLqGKzutMjjSF7e6Y+5iwQI5FLqRz8QbLE+OSM4wcdR1OtodS1DbemzxpPFeXTxyxuMgoFDtkf8oH51Ces6hoW3eq9nqVzfPoqzwmH3GGCOyeEdgcHA7uD/ADD510blORniZ9de+zNqunqg5E6xEvCqCX40J7jj0PxD19CCKrntwbAMWYYkVvh4ySAx/wAq1tleR38ayxshhkcMPjJBBJPB5Hkk8VvpoUlse9hkmNGI+vd8X9Qa7TXYpx2jVMJg1up+LvAOArAgjIx4qid0PvpCO88McfDn4ZOOfqT+tZMpDWuFJId1HceQPPrWsvU75I4iXKySsT3/ANcc/wB4/rVpXISye7MxUZlRCV/un7pz9F8n8q+ajqKpYA9zCWSVIwAMnKBTnz/MCcfX6VQzItrPcF1VGYRhc4BC/EUI+oHJ+pHjNanWbtY07g3PYUQeMM4yfH0AwPXj5mhBa1AZ0m5fu5LphfXLMMZ/ME180DSUS8llyy9/azvCmO3IyEI+YcknOPvHFUa5ObfbsskqyILYRyyv2ZwQGAJHkjA8Dn5HzXzpj33+1bK8csryxLIyvwVJBPcct6d4PHPyNeZ04UL+enZrwcz1NY2kdsjoHYg5GPjDdx59MngfP1Xxxn0xdRjS7wGHbbMyqXBwjMSO458tgA+gxx5q5G9rB7v3gebt8d3wqPH3QcD+nyrFsoU1KaY/F2DiRpD2uzjwCTlcecZIxgYr1GMdHD9RvdMuEuII5Iv3luVABVe9D+CKW+f81bWeOK6j7Jo1kQMGCv4yDkHFWQPdoq5Z8ert3Zz8/wBKudneB6f4VaNmO083vjFDCwYf+oAAoz9c1dWExRsZl70/iyQM+fOTz+dXcqmXeVj2gntHA/zrEtr2a5AMERnByPeu/C/iCAf/AG1I8lvXD7uyEqRFGhYy5JAwOcjz/ePFcZqQSS5MkJyHVeZUwCCe5R+JGRj6fWu4lmSS1eOR0mZ42OPAAP8ADn5cHn+lcO99Bf29on2jHv8AtjWQrlgRwe1eCy5wF8etaeTjV5VbqsW0yYzcJbRoLvQJrW2imXuNq4I+M93ZhgAC3r5JyBWOV7FJzx5rrTYzSyWkdrDh4pWMveO2TyfBLL8vu/hzzWfuXZEUsMk1piKVY24Pgjjgmvm/1N+HtkbJZWF4O2YXK/tsIZ208k+jWjvwHT3gA5OWPdx+orZws0QJd1deB8PlfxH1rVbHu477Z2lTwN3JJCrRtjypUBT+gFbfuxnivDMuLryJwfbR3CE+uOy1t6T3dzqkGMj3yzdw8HvjA4/SrG9Lx7XaGszZVmFpJGpY4OWBAyfXggfjVnSZXi3NqFqTlZreOUHxjBKD9R21oeserrY7XW0BIub6UQRkDgEfeBPyBIGa26aZSzIJfY17Vpdj50R93Ft2WVE5MgQknDNjAJJAHhmIwfl9alOC5lj/AN3K8ZPntbGfxqM+k+nXNhs+1Fzcy3KPlgr8D5sQPTLFwAR47T5ruEuSpyMir+Qy78fKlKmetfQojSp+Ubp9SvsjF7P/APeN/wBapfVr4gA3kx/58VqDfE+GzVL3PfgJLIW+XditL+2s/X+I/wCWFhV/5EbGW/upCM3j5/8A7x/6VjHU7oyFffzYHr7w81a7fm8hz82zXxAAapXMZqf+I/5ZZ+Xh4cURl1U6caR1F3BBd63D9ua20qYRySfE0Xa4lTtOc+T6eeMk85mLTN8apJp1k0d2WQwIQexRnj8PpXA7pvpYL27FsFk7NIncqW7VXt+JT3YOQ2Cvgf1rbbSRhtPRGbA77OJsKc4yoP8AnXbp81yePhqyNzX+5Q8WmT7wR3lvvrUznukQj5BcVsIOoFyjZniUj0H3f0PNcWhxVTzLCRnyc/n/AKzWnR625mjxczXnxtEvEdEkW/UO1MgSWJ4s+M8/69K6Gy1m2u1DRyq4PqPH4VDUcwbBxgVWL2W0dXhcow9R/nXe+L/FLOpahlx619Ucbbw8X+gnJZA9Xqh7TeoF/Yzj3ym5iPBGcEfhxXb6DvKx1oYjlCuMZjb4WH4g817pwvrLjeXilGepfRnB34N1H6l2OqpVpJM1cJxXfYtSXUvBxx9pSlZAUpSgFKUoBVOVp96tbqWpQ6faSXFxIsUUYyzMeAPnVF18KIdcyUnJ6Rpd16nKIVsLUkX96DFBj+DPDOR/d81tdCsE0ywtrVAAkUaxj64HP9TXP7UsptSvJdbvA6zTDEMT/wDpxnxj8ea65OCAK4nCTvslkz9/BnP5flRkjwaqqkeDVVc6VilKUApSlAKUpVoFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlUnwKApWjV8H3mo1VAj3ct4ku/tMi4AsrKa4dv4QXIAyfQ/Cagjrjp43Lsgw9qif7UJO9lz8P3Fwc8ZYY8HzUkHVYtU3duec/uzG32RQOfhQdpOfoWk4+n1rC1jTkmtYLDUEe9sBEGMcSHvRcHHCE8YAxj614N6xzZw5CuX0Oew4bh3MzZVzB+w7SC3iCN7kMEVgqlu09+MP6EHz81qSZSU04jPdmPI9MZ7SB/U15p6Ey/sDeG5dGa6ne3klEtlBNMXYJh2+DIBOQUZsDwFzXpD7Uk9ngN5GMDyK9R4bIWTjKaOJvh0S0Y8ErNalgofMyBVUYBAGScH8K1lvcK800sn7qKFZJCncpfIOACc4wTx+PHkVslYiIZGP3zefwz/nWqlhW590Yr0m3SbtmSMlT3rhgSP5sksw+fOc81zprlEre9jiQw96ghpEDYU8d+PX7wVWJ8YbtrFsrNtUu/tVwnvFiuAsSkMFkLEnz2+hAH5VkRWgVZAHZu7ILE9wIZhlR9ORx9PNW9VMNjJF7mQFxID2hO5gMnOU4OeSBg/eyDg/DQGPuaPu0+6LH4zJGctx2nBI7h6EZNY+wZp5Nn6ZcXMMcEQiQSyunYUPulGQH5Gfpzx5q5qzCXTLlvud0sY7W4JyHxgeTgYfn0xjya53Yk9toW19HjnnlnvY48JDGYwVIZsso7Sc5JOePPmuhYT1zdkfsclJ/9Kd1I00+CIf3PIM8zMYyC2CFIwOcZU47Tzz8txpMlu1kkaH3Rz3ASfA34r2+PHHkjJzzWm0+DV9XnJbS5LCEP3+9mwjj5cZ7go9PhGK3ul7Xki72kdYHbtJeLh3PqXPnPIzzz6+BXoyOI7mzW4SMqo9eQBk//pHmrUutWlvEzhskY+BeSfwwP8ayrbbVhASxjaZz6zuX/oeP6VsRbxqchVB/CsidGhOuJFIWaA/Fj70bnH4fDWs1L3+pPB9nhlmQZyXQrGPHBU+px68V2nYv8o/SvgiQfwgUIOKudB1nUQlvKUigx8ZB4JHjn5cnjH51es9l+5ZeEiKZw/aCf6H0xx4xxjGK7IDH4VVWXSDW2Wk22nQ+7hTC/wCv6fSrl4gNpMPmjf4VneatS/7oVrZL6qZL7FkO0keWel8OOnegR9zN7q2T43IJIx4JB9K3cimJyCPr+Na3p1pn7J299hd1lfT7u6tA/aVACyuuPJ4x28/3TzxW/li70KH7ref618B838vI3L/UenYc+qtHMQyf/LO1BGUl090K+PusrA/+7xXDb61Bdw7v0rQ7Ygtdu+ZO0sYkVWwwGc92Vb4j/MMjgVpuuG8tQ2VdhbBs6m1rLBZE5JDyEHJB+SxOwBwSQAFbIr70K0OZdFtNxahaql/cW4jgLqe7sP35WHzkPaST6Dn74rtlOCsbEXIWP20v6mUpfEn0Q7k2QQpY2sFtbosUUSCNQB5AAAJ+vAq3PMcD51iTXizF5FH5f5/j9f6VRJclscV0Fpzk5P3OSqpcfJda6kTHjFfV1EgZ7VP/AD81g4Nw5Yh4vzAz/WvhlaJCzBD9FbP68Vl0Jm04RaNzHqKkAHOaykuFXJc9i/Pzj8vP9K52K4SUcFc/IHJFYkeoXGpahOkFy1tbQ4VhbgGV5DjCg4IAGT3H0NWVYis232RrWwS8GVr4ifWtQ96codGmhK/zEvyufnyOKz9lLJDtHQ4pT8UdjCP/AG4/yrm9et5NP0PX7838l8U0yaOKKZAGhAQs3cy5PcCByyg8gHJ8b7QkZNHsgyuP3EY+P6AZx+hrlsyDjgqKfyt/+jSjBtnRD4VY+cL3Y+dfWmWIDP8AEQKw1PwAZzhu7/tVTv7wgEYUHkfOuofDki3pZkd6+UOQfWjEtjNWndQhYHux6V8aTMQTHI9f+3/asFHTMdaPhXOMHj6VjGZoGSWM+7dV+GZOCoPgsecjjyM/hVmW4eNCw/rVMD+8D8Y+H+p/i/GuUxbrMaXxK5NP7GbqU1pnfba6kywyxW+or3o3BuFUDtAx8TADHbz6H8sc1KEFyJgCOQRkH0rzaAyeOCf0/ED5/Wu16bblm0mEaffTyvG0pEP2mQPIuWwF7vqcdoIzjyTX0V6O9by3HF5CXb2Z1DlOLVf97V/BNAOR8qqrCiuVlwRjB5zWUrdwr6HquhdHqg00dU0V0qnJqksBVzaXkg+18P3asvOFFc9rG9LLSyFMnfJz8Cc/qfT+tcXl8pi4UHO6aSX8mcYOfg2mp6tBpdtJPM4SNASSeK4u1ju97ailzcK0ekxN8EBGVm+rHPI48YrAsdN1Ded8Li/LJYI2Sg4V/mMfLx/SpHtLdLeJERQiKMBRwABXUsO3J5252NNVLx9zYajXHt5MlIVXBUCr3Z9K+AYFXa79GMYRUY+DV8ilKVmQKUpQClKUApSlWgUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoC32/jWJMzRRO4PhS2PqTx/n+tZ9a7U7Y3llPAD2mWNkBPoSP1qohnjPW9xXOnxmWw1KZJZi1wXSMMpLy+8IbnLLz5XHk81nbO9pnStXij1nXtOuNFto5prKPUVjkksnkjJRiZApCYwuM/CSx+LHjI649JJtsba1DUodRtcRwCEHOJJZiyRxKF/4+xiM8/EORXX9O+ht1s3Zem6TBYw28K2sZupZMGWeRlJk7znAwzDnuYZXxXReY4Gnk7Or3NqjJlWulnA3+qbHt7nSN6yalZS3treJBHcpMSATH6nIGCAc5xnAB7hxUv7W3adUsTCHZ4sr2TLlu4N5wM8KVIZTnkZrht9dBtuX2lXoXQ7GG5Zu2a5gjVZe9fjUuq4B+JgmS2MMax+nt3BLp6W6iO2RcqluiALGVZYyhXxj7wB+6AowRxje4fBnx9PwpswyLVOXYl3UtXa3aCJThQ3YzngoGUlCW8c5XgDyc1dN9CB2lsqeW9Dgeuf8AHOc5P5R/vrddnt6MatNc20Onxtl5ZpFDqAmGBckDu4GO0eMgcVwFz7SdtcmNdF0u8vXdcrczL2R5Iye1c97DBDZYKP5c+a5W7Jqp/UzUW2TzqGqW+mWS3NzKtrbBlIkJ4xxgAjOO7A/hBwAAGNaPbFlq+8p5buyt/wBnaTK6r9uvIjJKxGc+7Qnzzw7ZA5wBxUSbX17c8mrWmva2sdyjsgW3ki7CEUBhGo8lpAG8KwBGSc+fVW292aXuuxS70u8gu4Gxn3UgZkb1VwPBHjBqujNqvek9f1Mkjl907atdG0B2jaae4eRO64mkLSHyAc5484+HHHGcVvtj6LYWukxyW9pbwSSJ8UsUQVmJznJ/Ovu+k79DmOcdmG+ecVVsCb3ugwcYx3D555NdKqs+H6kcfZxOVffF/wBzqvdrjxmq8UU5FV16gcZoUpShIpSlAKUpVoFY785FZFU/eBrXnHqi0Sux5xEH2Lcu5bVo/cut+0vZ3BsrIVKsCDwD3A4P1Hg1nuvj6en5Ef51e6laem1t522shSlrqcRt7mVFyDMjKU7j4HcpK9x9VH56vUtSSw0uXUHRnijXKLGuWkZiFRAMfeZmCY4JLADu+Gvif1NwuSucnRXDabO8YeVBUbIh3J0b/wDFvf8Aret3xkj0XRBBaLBEpRrlu0ySBjhh2qcKR58AkdvMlpaJHbxwphUjAAAGP4AR/wC0D9Klrp5s39ibYS0vIlN1O7XF0OCDM57mCn+VSQo4HCiuD1/Sm0PU5bcglMBlP0J8fkMD/pXZPUvDZmHxtNuvlS019CcDLg7nE52SJUUlcD6cnNWR3ynle3x4Oc1tLkLJHhhnBJBz5Azj9cVYnsEmTGMV5CppeTt0ZbWzCW3l7gpwc1kRjHpj/mH/APtVxrdkx2sTn+ZgMfhxTvU+e4f8Xip60Z9WzGmgRX7lxk+cetcWdWTaN9frq6lNOu7g3EN+Iy8SO/afduPKZIUgnPdk/d7TXcyIcdwGUPhqxLi2ilQI0auhJ7kkVWVhznII/vH9TXKYOXXRuNsdplbTkcLqev6bvhodA0q5/aMdw8ZvJbfvWK3iVwQGYgfGSrdoHrnkY+LvYwsQHdI33e34ufRv+tWo7H3QChUgXgdsaBUOcd3d9Tk5BPPGQcDGUWZfur35/ukf5VdnZdV0Y1Ux1EwhHXkq7ynKswb0DElv0/71c97KjllRwG9G5q2TJ5MeWPk8/wDSqz3R+e8fmP8ApXCNJlvT3EeoOzBSjD9DWZFeI/aRwJF4I8j8DWBIBkyAjxjHiqBkKWKgY/lFVOC+hLrTRsZIFeNgea1twzQSJIp44U8fp/nRZ2Ugg9pq8LgSDDLk/MetWRj0hRcSq2naeMs2KuRTdj9vYrd3qRnGKstBypBxk44+VVJxkj748H5fOsoykpKUfKMJ1xmtM6fQtw6nd3CW1iXIhYSYkc4kIz3BT+mfyxjJrthvq6gjCXdjPHJ/dAJ/yqLLO9fTbq3u4uHhZHRfoWPeufqBjx61Oelvb6zYQXSgPHIvcvOeCK989FzzeRplXTkOM0dC5Squi3qcexzn/iG/aAbQ8f3mz/8AlrBn6iXbyFYkT4fJznPyrt32vp0gGbOE/wDKK+222NOtWDxW0SP8woBrvFvCeorZdP5jscWr8VfsI8t59e3G+cSe6+uFHPzIH0rodJ2HFEitdETyjBwchQfoP+tdqluijHaKrVMD5CudwPSNdUvi5djnL7+Ci3Lcn8i0jFjso41ChQAPQD/XFZmAKqpXoNNMKIKEFpGi5ORXSlKvIFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFW2WrlctvzdMGztranrM47ls4GdUXy7/wACj6lselV2TUFtgjzcsKdTuqdjt9kkl0LbTR6jflh+7ku2BNvAD80wJDzjwPNTAlsD94A45FcR0q2tNoe2oLi9yNV1BjfXzNyzSyfEQfquQPy+fJ75a1qo/vfkjRwW/wDbYuLEyW3ane8aOpGQR3jyPX1FeXNb1pOlmo6yNQiuUtp+26tIEUhblWUIFiGFV2LqAygMe5wRgefZW4rNr7S54UIDsvwZ/myO39cY/Oon2xpNxvbd6ahcN9o03Q7hh7xcNFc3qjtCpjysQwO4H73d4wawsW5aRjrueJd37E6q63uJL3qIZLhHUXljo1zOixxFiCUKg/vWUgdy47lVWbHBFSZtzS7HTYYZVZby4ijaOMyHtVAuD2gHtyMgjkj6V7f17a+n7msXs9Us4by2b/05l7h+P48A1C+tezmNul5dqrDc2RcyLpd9k+6PZ2Zim++pIJJyccZ5OK6nn4GTOTnDui2PY4ZtcgGnxSK9sLqNDIbeM9iKhAYuB5JywGRheRXJ2NjdXmo6hqcUl1psduvcsFv91mA+NgqkMe7+HBQj14xjD1HRZ9k7hvP2zHcWme1rf7QM+7cNk8erHuAB7+GxkheKydA3ZaarfTyyWDK9uyxR2oZvg7+3tZufI7gDx5NdakrK5dL7Mv7MkvafU3U0RdJ1KaTU9NeNES4kDtNHIyuyKWXJfu7WHxcDjL+KmjpncI2mTIhz2yZz+IFeNLG6mvt3X95KkU7upWGMnBj7XICqvk/D3MwOPB+fHpLaG+4du3dgt+nurK+Kx+/RfgjYgFe4/wB7z+Rrg68idHNU2z8Pts3orqokidI/FXKtI2RVwjNe7RkpR2jiD7SlKyApSlAKUpVoFUnwKpasS7ulgiZ24VRkmtS++NFbsl4RKW3o5ffDxajEukFEne6+ExSL3KV9cjxjzWr210b2vt+5s7m30wCWzk97bCaaSZYGKspZFdmVTh2GQAfiPzNbDa9tJq+rXOrz5aIn3duDwAg9R+Oa6/PbyeBXSuPxK8u6fJ5KWn42bcpygvhxPjAAfLFRj1EuLW9YJFzOnBccgfSt3u3df2WM21qcyZ7ZCD90Hzg/So5klaWQsxzmvJPxA9W0Tg+NxVte79jm+Lw7HL4suyMSS2VsuSfgAOF4wB/+2rzQ4A4/OvvlUPgk5/CrjuOwnGcV83ubl5O5qUjGCKmQTg+nrmsaftUjuOBz/r+tX0X3hJJ+I+BVg2wZiXbvz4GMY/rWxE2Iy15MdpUX7gznzVDJ7zDBEbtOVZTjBHzFZBhViMPn6Y4H5eaxyFTGJcfgKvRfvZVLCpA+EOn8OUB/1xj9KxlDZJC5A8mriKg5Rcv6FU7j+Q4qswSv/OcP28R/1rJvRKkl5LRfx8IH1FWh3HPbIU/4nPNbCOxbPxHtx9P+9XlsFUfFGBn5Ln/OpU9PutmE7oR8mqKpHGoRveD+YnJP41cMciRO3ZlMd/cD/QDzW6GhK6grFkH6/F+n/etZf29zYyurR9mF7s58fMd36elbHwrWutxaX3MYXQm+mLLCRLMrowyucY+eBVubvtiDlexs/FnLDHz/AFq7az+9mDduEALd2c5OD6VlyxCd3U+OK1+rT0W9XfRj28wdwrBkxxyPX5VWYfdXBGc92ef1/wAiKx5Q0TH42P8AM7c/0+nP6VWzt3qxOcen5A/4gUY1vuZQix6flmpR6R38kmjT2chz9lmKoPUKTkf5/pUawSCWPu7cH5ea7PphdLBrdyh/9aMN8iCvBJH1yP0r0f0ByDxeXjX7S7f7nWuaq+LR1fQltx24xyau+BVqPLoC64z6ZzV+vsw86FKUqQKUpVoFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFUVXVFYN6ALcVEmsq/UjfsWlqH/YG35VuLs9uVurn+CPPgqpyWGP4cetbTfG7LiWd9taBJ73cE8QMhXBWzibj3sh4AyO4j548Hiug2RtK22Vt+00m1Z5EhXLyynLyuTl5GPqSa0ZTVs+leAdGAFHHAFUrNk+PNfai/W9d1HqNfXGh7YvmsdIgl9zqeu25y2R96C3PrIP4n5C8j7wxWxKWuyBRufcmpb31aXa22J3igRgNX1hVJS0TwYY28NMSQSAcKoznJrvdD27Z7f0q202wiW2tLdAkcaDAA9f1OSc5ySSck1829tjT9s6ZDp+nW6WttHz7tBgE+pJ8kk+SSSfUmt0niqqq5L5pAdq0H3mqqlbjW1ozOM39060zf+kyWGoQqSVIjuEGJI2IwSp+RHBB81493Ns2+6e+/wBA1I+61RJvtNpcxxgJdQg5BB8s3ByDk58ZPFe9a4jqR07seoegz6fcfubkI32W9UfHbuwwWU/UcGuvcnx8bouda7kp6PEFvq8Wqa/BPauyPMwaSQn4i648t5wQDnnnFSpcW024unkEUUfZhTIrdxbsCfdf8OD+vyrhIdh3XT/dWoaNqKlLpAxUxriKVO0tE0b5/jAdWGOCDyakrpvJ7/bElo0sffBNLF7tVPcgJyAx9W8kKMjg/OvEedrlj2Qsl+1nK4j2pIkz2f8AqUu5dAh0+4maW5tgY4pJDl5FXAYn8Dn8h9KmZfWvAO0NZ1XpnvJbm3MgsEuGlZC4VWxyyh8BQCvqTj05AxXt7bW57HdOj2up2Epmtrhe4YHxKfVWHoR/38V7Jwmb8ehKT7nF2x6ZaOkpSldoKhSlKAUpVDHANWN6B9J4NcTvDUGuZYNIhBaS6PxEeQmfP+vlW63DrUej2EsznwDgE+a0m2tPkaWfVbsFJ7jBVCc9g9BXQuY5FX2LCrf3b+xs1waXWzobC2TTrNIox2oigKK4/cm8/et9ntG7gh+Nx5/BR6msfcm6WuHeGBsQrwc+v+sVxk82cccV4r6r9bOqv+zePekuzf8A8OfwcDrfxrSu6l945PjPJJOSfxrDc9mMYrZ6botxqspEC96D+P8Ah5+v5V12ldNkB7rmYkfyIoA/1+VeZ8X6a5TnJddcW0/dnN25tGKulPZwS2c8zKqws4/u8f4lf61bB93I8Tgqy8Mp/mOfh/HjxU4WehWligSKJQBxnHP61wXUnanuwNRtY8g8Sovjn+ID513bk/w4ycDj3k76pL2RoUcxGyz4clpHEMMYHIbxz6n0H+NZkVmr5Dlip8qpxn8TWHas0nMh7nGATjGcev8AWtij5A4ryCEHTkRrn49zsdj+XZ1dt00gljWaNgAwBwVz/wBau/8AhYccTgfXt/711W17xLzTkdD4GD9DW+C5zX1xxfo3hM7ErvUPKOh2cjk1za6iNv8AwtkHi74+sYP+dfP/AAxmxxdL/wDd/wDepNOa+YWuTn+H3DS/ZoqfJ5L/AHEcW/TZ1YiW4VgfBCeK2tvsGzQHhiDj+Mj/AKV2fZn0qkpj6VuY3ofh8b/x7KZZ+RPzI0UO37PT7duyFc45Lck/iahHcrNe6vcCJvdvJIex15JAUgsp/Ic/Wpu3bK8Oi3RU4fsOD9fQfnUGyT9+pShB2pGrKjfIjtyMfkK8f/Eb8vh2V4uNBRSW2dh4Xqm5WSZQE5ZRhEQ4LearZe1iBxj7v0+dfThs4buAB49fTxVQc96qpwWGcfP5/wDN4rwTq9zuLkYF6MMeeDw38w/L/vWHCzM2D8ZJAGMghsYGD4+7g+fSttMqzAo/aXXgnu84zzjFYLQr2EsO9SQ3b6ZPz/AgmtiE013LYPaNhp47mKYwD/r/ADrq9iKkW4YlC494knOfoD/l/Wub01e9WbGM8/4102yuNwWxA5KsM/iM1z/pexw5elL6o4TkXuiaJkTwKuVZT7o/Cr1feNf6EeaPyKUpVhApSlWgUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBVhZO4fw/kc1FHUbqTq22NfstIL2m3rG/j7odx6gry2yyd3aYSvwiN8YYGRgvoCx+GtjHsG910RHWd4atqMLjLRWLpaQyfgYl7gvy+PPnk1qTsalpA6TcfUDQNqiIatqcFpNL9y3Y5mcf3Yxlm8jwDXGNujeO+yItE019q6QzfFqWsp23cqcZMNv4H/FIR58ea7bb2xdD2sXfS9MgtZX5aftLSt/xSNlj+ZNdCqBRx5+fzrHU5eWDl9p7J07aNrLFao0txOwkuLqU5knfHLMfnxn863UtylqjuzKiqpJZmwBjySecAepP0qu6mW1iZyVjAVmZ3bAUAckn5D/pUUj9pdXbyJllm0rY6lWRQSk+scsMngmK3OBjnMnngY78elR7IGRdazf9WbqfT9EvJ7Da9s4W71qBcNqB9Y7WQ+FBGGlUeQQuMZMj6RoljoWn29jp1rHaWkC9sUMQwqD5D/vV2x0y30+COC2iSCCNQqRRrhVA4GB+FZ+MgVZGLfdgUpSrQKUpVxmWqqy1U0qoEYda+mz7v0F73TSsGuWSs1vLjmQH70TH+VuQfxqB+k2si6N9ZzRtHdqEnlUKFAk4VsLnyvBI8gEfSvYzrmvLPVDQ12P1007Uo4VXTtyKyTsFwIrhe1SQPHxBwzZ8/FnivOvVfFRuxZW1rubmLPplr6mt3Xt7T5f23PcxTQ/Z4WkzCC7MoBYhg2D2hRk4+f51sfZNub+5a8aykmn0NiWY3CEKoP8Au1XnlyBg4+7g5HIrXb9dYGmHuUWWT3ZLLwXiQ9rZPqe0j5Z/Kp16GaVBp3TrRBDbRW6tEWZYlCh37iC5AH3iAM/hWj6Zavikn4KshamSUPBqqqfIqqvUzVFKUoCnwKxrm4WJCc4xVyWVY1JJAA+dcLrupTa3qH7IsvBXM0vooJ9Pqa4LluRjiQUI/rfgzjHfkxo7V93aubh//mFvJgAjHeR6D6H/ACrbbr1T9mWSwxjDyhgG/lHqf6is+Wa32/pgGFWONcBRx+VR7uHWjql2Xx4x+SjOfz5rxj1HytXC4E0pdWRZ5+xzOLQ8ia7fKjS3M3vpML49T863G29sy6xKHYlLYeWH/Ssfa+hTazdhgvbCrAsx/wAqlzTbGPT7VIY1CqoxxXSvRXpGzmr1m5i+T7+5yvIZyx4fBqZ807SrfT4lSKNUQeAoxmtgBigbjjihPdX1bi4lOFWq6YpI6k5OT2z4U544qzcWqXEbI4DKwwQfBFXaE5q62qF0Oia7EeO6Ic3htGTQZpL23Um08tjnt+v5c1o/foocg57eOPrmp0v7JL6ExyBSpBGG5BqHd1bek0C+cxqVtpWLKTzz6j8s/wBa+WfXXo6eFa87Dj8vvr2O38bnq1Kqx9zp+n+r9oaBjjx8J+Z4H+dSKj934VBGj3/2K4PczIGxyDj1zzUx6Dqa6haI/HdgA4+eOa75+HfOq/HWDbL5o+Di+UxZV2ua8G78iqqpHg1VXue9I4EVT5FVVSfArAHL74fs0WYeTx/iKgyN/wDzkuOMs7f/AGuQP0x+tTV1Dbt0gH5OKhiBW940hBGSpA9eAAP+tfJH4lTcuV0/ZHe+CilTKRdWHtcMDkD8vy/D6ePpVdtD76LKIUc8dvdkdx+7z4OfmP8AKrsSe77s89zZX6LnA/zqQNnbMHuRcXEWHHKD5Hnn/Cuh8HwOVzd3wqo9vqcjl5sMaO/cjmVu8jPJ+fzrDm4Tt85ctn8/H9a7Lfe1J9Jujewp3WrnEgUY7DzyBXH3Q7VQsQB3AjBzn/Wap5Xhsjh7nTfFpI28PLhkQ6kbDSXXBjIwcAg/6/Gup2SM67CceCw/9v8A3rkdPjMcysDjuKk/Qev/AOX+tdnsqLu12M/Lub8eMU9M/wDeKf6o4/kZf3U0Syn+7/Kr1Wo/uD8qu196V/oR5w/IpSlWgUpSrQKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQCqfIqqlAYN1ZQ3ttLBPGk0UqlGjkUMrA+QQfP51Hd70Y03T5ftG1dRv9nXWCOzTJC1s3/FbMTGQOcYUY5qUqtlMVTKtSBGEOudQtrxAanpdru60Hi70c/ZroD1LW8jFX/FWB/uVi7t6w6to+g6jqVhsjWpWsbaSeRr4RwIvbz47i7j/AIFP1xxUrBCKPCsi9rAMPka13XZ9QQffb3k6mx6Nt3Sr2GaS7SK71+504ma3tbYoC0TSfdBkbAXB7u0EsoGTUy29pHbxLHEAkKABIwMBfTAHoPpWDt/ZuibVa4/Y+kWemfaJTNL9mhVO9z5Y49TW+9DWUYSX6gfKrqgjFV1eCilV0oCilKVaZilKUIa2fG8VAvtT6Gus6BoOJvs063zRx3AODH3Quc/PyqjI/mqeVrzf7U+4ZxbaVp9sTmzY6jO4yoGSYo1J9O8u+Af5RXBcr3xpRMo9maKey/2v2nBeXIkXVgrRdqdzIs6Rgc9pOcqVJx/ex4GPRmztM/Y+3dMsTgNb2scZUcgELg8/r+lQ10D2FJe6Feavq8XfFfFmto3+6CxPeyj5DCqp+QPzqSLPV7nal3HZ3ivLYn4YLhVyV+jV0Hiqp8Hd12rcJ/8ABtWyV6WvKJABxVdaqz1i1vFzBPHJnnCtkj8qzTcL259a9Khl0WLamjS6ZLyXO6rcr4+XFYF5rVvYrmWRVPOO44zjH/WuLv8Acd9uGUwadbyJF/FM3jnxx+RrguR56jDXRV88/oi2FTb+bwbXcG4Xmm/Z+nnvu2wC45CD5msvQNDi0K0P8Uz4LueSfzq3omixaLbmWXmV+Wlb/M+lc7uDdE1xIYYPhRWZfeA5DePA+n410TOz/wCzqpchyC/vH+lfQ2qqfiy6Ymr3Vq8uo6kxD/uUJCqPFamytZNSvVhU4Z8/WvtraT3d0YIw0z4z8IP9eaknaW0k0qNZ5finYHJ+WfQV45xXC5/qzlPj3p/D3ttnP221YdPRB/MbTRdHi0mzjhjUAKADitsi5IPmgTjxVajAr62wsGrApjRUtJHUpzc31MHwBX2vjV9rlV4MRXxa+18WjAC49a0e49Dg1iye3lHEg4b1U/Ot+fFWpFDAZGa43NxK82mVFi7MyjJwltHn/UtMlsbl4Jl7HRiD9VB810uxtyPBOIveZQn1ro9+7ea/szc26d08flfmPUVF1jc/YrqNs47j6D+8B/nXyVyuHk+keVVtXaKe1/Q7rVKHIY/TL9R6Et5xMgYHg81lZFcRs3WvtEZjdwRxjNdmH7gK+oOC5WHLYkb4M6ffS6JdLLtKVR6V2MoOO383vLAQAfFIwVf1/wC1RbcxBVyMF8gAY85//ZUjb5ul97bIRgoTI34Af481xXb2kEffOWDfLOfT8q+PvXlzy+c+Glv2O4cbN10aR0+ztoQyRxXc5Z5MAL3cgdp/7f1qREjWNQFwAPlWBpFs1pYQRtyyLjPitkhIHIr6O9M8VTx2FX0R02jreTfK6zcmWLq3S4TtkAIORyM/0qP91bBQmS50+IBm5eMcBsfIfOpJJwKode7z4ra530/i85Q4Wx+b6+5GPk248uqDIGWIRt29hRl4IPAB+prfbdvv2ZqcUrcoQVYjk44ro93bUEqtd2qD3gyWUcAiuHRwjMgbLKCcHg5HgfnzzXyRncRl+leWjbr5U+z9mdrjdHPqa9ybbaYTRgg54yD86yQc1weztWdpDaySF0Chombzj5E/Su3UZzX136e5WHL4Ub4HUbqnVPpZfpSldlNcUpSrQKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAU4WqqUoCnC1VSlAKUpQClKUBRSlKAUpShOzCupJjbTm3RWnC/ApPBOMjNQpo/RXVt2azea1v++tboXc6z/srT8mEBFIiVnPxOFDEgDAyc4J5qdgMGnauScDPzrVtoV3aXgeDFtrKOBI1jQKqAKqqMBVwPhA+XAqm706G5QqyKQeCCMg/lWdSlmLTbX8KcdolNx8HJvsezVgYHlt3HI925H9M/hVP+xOf/6len8ZQf8AKuupXCS4DDfiOixWyOStNjWMMwkkVpmHn3rdwPyIFdBFZpAgWNQoHGAMVm0rbo4jFxu8I9yHOTMWe1S7t3ikGVYYIrn22TpjH/dEfL4m/wCtdVVHbimZxOJna+PBMKco/pZrLDRLPTkAggSMD0UVs1UYr72/hXwDFbeNh04tarqikl9DCUpS/UXfxr7SlbRiUUpSrQKUpQFdUnHrVVKqBizwh4ip5BGOahre+3DpOoiWBMwSEyfIB/P6Hmps81zu7NJGq6XNFgFyp7T8jjg1576y4KvlcCdn7orsclgZHwLk2RftvVGtbtQeB9D/AK8VMem3i3tpHKvhxnHnFQMubeRWHBBqUtkXvdZMgGBw3nxn0ryT8OeXnjZL4+yXb2Od5jHUkrYnbHzVmWQIpJ807sKecD5muR3Pr7Qj7LAQJWwGfOezPjj9fUV79zPLU8biytnJb9l7s6vVU7JaRzm4rttS1Y9nK5Eefk3y/pW40PZxE8UshHaMFhjyRnB/qaxtqaSZ5UmKkRgEd2c+MZPn1zz+FSFGiqoAGAK8s9P+nK+VvfKZq7t7RyV+S6ofCr8FUaBRirlKV7hGKhFRj4OGK6pK8VVSsgWWQOuDyPrUa7922La5TUoB2g/DMAOPo35c/rUoVrtQs0u7eSJ1DK4IIPIrp/qbhKuZwZ1yS6vZ/Q2sa+VFikiMdvyrBqdpMH7HZhE4xnPw5Pr/AKzUsRcqKh0wm0vJbJuRHIEDHyD88/hzUraf3NbL3t3sAAW8Z/KvP/w5tlR8XBku8WbvId2rF7mzpVI8Gqq9wOIFKUq0ClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUBRSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoD6Twa0mu3kUVnIJHEYZSAScfQ/41uHz2nGM1Gm7NE1jUNRk90nvrccKAQoHw+Oc+Sa6R6ozbsbClGitylJG5iwjOxdT0jhbpw00qL5Dcn6HOfz8V1fT54hcz95JkRAVVmz3Ic5x+g+dYdv031OZyrvHDjGOc54x8x8v6132jbRstKtpoo4wDOoWVz5Yc4BP0yf1rwn0x6Y5RZjzXHp9+52POzKZUquD2zR6vvSaSYRWnasbZ+PGT6evj1rB0fRrnV7kSMxER+Jm8lvl/nXSJsS2iVUjkkCL4Vz3D9OK6K2sY7ZAqqMj5cV36n0zyPI5qv5Kfyp9kcM8muuvVS7n2ys0tYljjUKoGOKyhxXxciq28V7Fj0Qxq1XDwjipv3LlKUrYIFKVbZ+2gLlWX+IVWrd30rm9yTapA8TWKrKhHayn0OfP+vlXHZ2SsWl2OLf2RnBdT0clvC3FtrIkJ7fejOfngDP+vrXeaLIXsLcnklAf1FcVdaBqusTpLdCIe7yFRsgjPBzjI+Xr6V2+kQSW1nFHMwd1UAsOAcfSvMPS2JfHk78nocYy8bOQyZKVUY77o2g8GqqpHg1VXsBxgpSlWgUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgKKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKoaJe4nHNKVr3JNdyUfewV9Kj5UpRJJLQkU0pSsykuKBVVKULRSlKAVafxSlB7lFVmNflSlNJruSz57tVHAxVJ+EjFKViklrRkXh4NVUpWRgKUpVoFKUoBSlKAUpSgFKUoD/9k=)\n\n  \n\n  \n\n  \n\n——@言萩\n\n  \n\n  \n\n  \n\n  \n\n  \n\n  \n\n  \n\n- 09 -\n\n  \n\n  \n\n  \n\n写歌的人断了肠，听歌的人湿了心。\n\n  \n\n  \n\n  \n\n——@我是一个没有感情的可乐杀手\n\n  \n\n  \n\n  \n\n- 10 -\n\n  \n\n  \n\n  \n\n枕头里藏满了发霉的梦，梦里住着无法拥有的人。\n\n  \n\n  \n\n  \n\n——@白茶青欢了无事i\n\n  \n\n  \n\n  \n\n在梦里，我们并不觉得梦到的一切都是幻象，也会因为遭遇的不同而生出各种喜怒哀乐，只有在醒来之后才恍然大悟。\n\n  \n\n  \n\n  \n\n那么，清醒之后的世界难道不会是更大的一个梦吗？祝大家都成为逐梦人。\n\n  \n\n【音乐：种种 】","lastmodified":"2022-09-20T05:41:07.270338644Z","tags":null},"/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6":{"title":"","content":"# 反射机制\n\nCreated: August 8, 2022 9:23 PM\nDate: August 8, 2022\n类别: 反射机制\n\n包类：`java.lang.reflect.*`\n\n作用：**操作字节码文件**\n\n- 相关的重要类\n    1. java.lang.Class 代表整个字节码，整个类型\n    2. java.lang.reflect.Method 代表字节码中的方法字节码\n    3. java.lang.reflect.Constructor 代表字节码中的构造方法字节码\n    4. java.lang.reflect.Field 代表字节码中的属性字节码，代表类中的成员变量\n    \n\n## 获取字节码文件的三种方法\n\n1. 使用静态方法`Class.forName()`\n    1. 参数是包名字符串 ，比如`java.lang.String`\n    2. 赋值给Class对象\n    3. 这种方法会导致类中的**静态代码块**执行\n2. 使用`对象.getClass()`方法获取\n3. 使用`类型.class`获取，包括基本类型也可以采用这种方式\n\n```java\nimport java.util.Date;\n\npublic class Test01 {\n    public static void main(String[] args) {\n        Class c1=null;\n        Class c2=null;\n//Class.forName()静态方法获取字节码文件\ntry {\n            c1=Class.forName(\"java.lang.String\");//String的字节码文件\nc2=Class.forName(\"java.util.Date\");//Date类型的字节码文件\n} catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n\n//java对象的getClass（）方法\nString s=\"abc\";\n        Class s1=s.getClass();\n        System.out.println(s1==c1);//所指向的都是String字节码文件，同一个内存地址，返回true\n\nDate time=new Date();\n        Class t1=time.getClass();//获取time对象所指向的class字节码文件 java.util.Date\nSystem.out.println(t1==c2);\n        int i=3;\n\n//任何一种数据类型，包括基本数据类型，都有.class属性\nClass c3=int.class;\n        Class c4=Date.class;\n        System.out.println(c4==c2);\n        System.out.println(c4==t1);\n    }\n}\n\n```\n\n![Untitled](../../../../asset/Untitled%204.png)\n\n## 反射机制的灵活性：通过修改配置文件实例化不同类型的对象\n\n创建配置文件\n\n![Untitled](../../../../asset/Untitled%201%202.png)\n\n通过修改配置文件，可以实例化不同的对象，为了方便查看结果，配置文件放了两个类包名\n\n```java\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.util.Properties;\n\npublic class Test {\n    public static void main(String[] args) throws Exception {\n//读取配置文件,获取要创建的对象类型包名\nString name, name2;\n        FileReader reader = new FileReader(\"ReflectTest/src/com/reflect/test/配置.properties\");\n        Properties p1 = new Properties();\n        p1.load(reader);\n        reader.close();//关闭字符流\nname = p1.getProperty(\"classname\");\n        name2 = p1.getProperty(\"classname2\");\n        System.out.println(\"所创建的包类---\" + name);\n//获取字节码文件\nClass c1 = Class.forName(name);\n        Class c2 = Class.forName(name2);\n\n//无参数 反射机制创建对象\nObject o1 = c1.newInstance();\n        Object o2 = c2.newInstance();\n\n        System.out.println(o1);\n        System.out.println(o2);\n\n    }\n}\n\n```\n\n## Class.forNmae()会导致静态代码块执行\n\n```java\npublic class Test03 {\n    public static void main(String[] args) throws Exception {\n        Class.forName(\"Test03Test\");\n    }\n}\nclass Test03Test{\nstatic {\n    System.out.println(\"静态代码块执行了\");\n}\n}\n```\n\n![Untitled](../../../../asset/Untitled%202%201.png)\n\n## eg1 常用的使用方法\n\n```java\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Modifier;\n\npublic class Test06 {\n    public static void main(String[] args) throws Exception {\n        //    获取整个类\n        Class student = Class.forName(\"com.reflect.test.Student\");\n        System.out.print(\"\\n完整类名:\" + student.getName());\n        System.out.print(\"\\n简单类名:\" + student.getSimpleName());\n\n        //    获取类中public修饰的字段Fields\n        Field[] fields = student.getFields();\n        System.out.print(\"\\n\\npublic修饰的字段：\" + fields.length);\n        System.out.print(\"\\n各个public修饰字段名称是：==================\");\n        for (Field f : fields) {\n            System.out.println(f.getName());\n        }\n\n        //    获取所有声明的字段Fields\n        Field[] fields1 = student.getDeclaredFields();\n        System.out.print(\"\\n\\n已经声明的字段个数：\" + fields1.length);\n        System.out.print(\"\\n已经声明的字段===============\");\n        for (Field f : fields1) {\n            System.out.println(f.getName());\n        }\n\n// 更多的方法\n        System.out.println(\"常用方法的使用==========\");\n        for (Field f : fields1) {\n            // 字段修饰符\n            //    获取修饰符标识数字\n            int modifyInt = f.getModifiers();\n            //    转换修饰符数字为本来的字符串，比如public private等等\n            String modifyString = Modifier.toString(modifyInt);\n            System.out.print(modifyString);\n            System.out.print(\" \");\n\n            //    字段返回类型,也就是对象的属性，比如int，Student类\n            Class fieldType = f.getType();\n            System.out.print(fieldType.getSimpleName());//获取简单类名\n            System.out.print(\" \");\n            //    获取字段名称\n            System.out.print(f.getName());\n            System.out.print(\" \");\n            System.out.println();\n        }\n\n    }\n}\n```\n\n![Untitled](../../../../asset/Untitled%203%201.png)\n\n## 反射机制 反编译 字段\n\n源代码\n\n![Untitled](../../../../asset/Untitled%204%201.png)\n\n```java\nimport com.reflect.test.Student;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Modifier;\n\npublic class Test07 {\n    public static void main(String[] args) throws Exception {\n        // 用来保存代码的内容\n        StringBuilder s = new StringBuilder();\n\n        //    获取类字节码文件\n        Class studentClass = Class.forName(\"com.reflect.test.Student\");\n\n        //    首行的类声明\n        s.append(Modifier.toString(studentClass.getModifiers()) + \" class \" + studentClass.getSimpleName() + \"{\\n\");\n        // 获取各个字段Fields\n        Field[] fields = studentClass.getDeclaredFields();\n        for (Field f : fields\n        ) {\n            s.append(\"\\t\");\n            //                           修饰符                 变量类型           变量名\n            s.append(Modifier.toString(f.getModifiers()) + \" \" +f.getType().getSimpleName()+\" \"+f.getName()+\";\\n\");\n        }\n        s.append(\"}\");\n        System.out.println(s);\n    }\n}\n```\n\n![Untitled](../../../../asset/Untitled%205.png)\n\n## 使用反射机制访问设置字段Field属性\n\n注意：打破封装，可能会留下安全问题，黑客等可能会通过这个制造一些问题\n\n```java\nimport com.reflect.test.Student;\n\nimport java.lang.reflect.Field;\n\npublic class Test09 {\n    public static void main(String[] args)throws Exception {\n//不使用反射机制\nStudent s1=new Student();\n        s1.no=12;//设置属性\nSystem.out.println(s1.no);//访问属性\n//使用反射机制,会增加复杂性，但是能够增加灵活性\n//获取类\nClass c2=Class.forName(\"com.reflect.test.Student\");\n//创建无参构造方法\nObject s3=c2.newInstance();\n//获取no属性字段\nField noField=c2.getDeclaredField(\"no\");\n//给s3对象no字段赋值\nnoField.set(s3,45);\n//获取s3对象nno字段的值\nSystem.out.println(noField.get(s3));\n\n//访问私有属性，无法直接访问，需要打破封装，但是打破封装之后可能会出现安全问题\nField nameField=c2.getDeclaredField(\"name\");\n//打破封装\nnameField.setAccessible(true);\n        nameField.set(s3,\"蔡徐坤\");//赋值\nSystem.out.println(nameField.get(s3));\n\n    }\n}\n\n```\n\n![Untitled](../../../../asset/Untitled%206.png)\n\n## 可变长度参数\n\n```java\npublic class Test10 {\n    public static void main(String[] args) {\ndy(\"我\",\"是\",\"大\",\"帅\",\"比\");\ndy2(\"蔡徐坤\",1,23,53,63);\n    }\n    public static void dy(String... strings){\n        for (String s:strings\n             ) {\n            System.out.println(s);\n        }\n    }\n//可变参数只能有一个，而且只能参数括号中的最后一个位置\npublic static void dy2(String s,int... ints){\n        for (int i:ints\n             ) {\n            System.out.println(s+i+\"岁了\");\n        }\n    }\n}\n\n```\n\n![Untitled](../../../../asset/Untitled%207.png)\n\n## 反编译方法和字段\n\n原代码\n\n```java\npackage com.reflect.test;\n\npublic class Person {\n    private int age;\n    public  short longs;\n    protected String name;\n    String address;\n\n/**\n     *登录方法\n* @paramname用户名\n* @parampassword密码\n* @return true表示登录成功，false表示登录失败！\n*/\npublic boolean login(String name,String password){\n        if(\"admin\".equals(name) \u0026\u0026 \"123\".equals(password)){\n            return true;\n        }\n        return false;\n    }\n\n//可能还有一个同名login方法\n// java中怎么区分一个方法，依靠方法名和参数列表。\npublic void login(int i){\n\n    }\n\n/**\n     *退出系统的方法\n*/\npublic void logout(){\n        System.out.println(\"系统已经安全退出！\");\n    }\n}\n\n```\n\n```java\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.lang.reflect.Parameter;\n\npublic class Test11 {\n    public static void main(String[] args) throws Exception {\n        StringBuilder s=new StringBuilder();\n/*类声明 */\nClass aClass=Class.forName(\"com.reflect.test.Person\");\n        String p1= Modifier.toString(aClass.getModifiers());//修饰符\nString c1=aClass.getSimpleName();//获取简单类名\ns.append(p1+\" class \"+c1+\"{\\n\");\n/*获取字段 */\nField[] fields=aClass.getDeclaredFields();\n        for (Field f:fields\n             ) {\n//获取字段修饰符\ns.append(\"\\t\");\n            s.append(Modifier.toString(f.getModifiers()));\n            s.append(\" \");\n//获取字段类型\ns.append(f.getType().getSimpleName());\n            s.append(\" \");\n//获取字段名称\ns.append(f.getName());\n            s.append(\";\\n\");\n        }\n\n/*获取方法 */\nMethod[] methods=aClass.getDeclaredMethods();\n        for (Method m:methods\n             ) {\n//获取方法修饰符\ns.append(\"\\t\");\n            s.append(Modifier.toString(m.getModifiers()));\n            s.append(\" \");\n//获取方法返回值类型\ns.append(m.getReturnType());\n            s.append(\" \");\n//获取方法名称\ns.append(m.getName());\n            s.append(\"(\");\n//获取形参列表\nClass[] parameters=m.getParameterTypes();\n            for (Class c:parameters\n                 ) {\n                s.append(c.getSimpleName());\n                s.append(\",\");\n            }\n            s.deleteCharAt(s.length()-1);//删除因为循环多写的那个逗号\ns.append(\"){}\\n\");//方法体结尾\n}\n\n/*类声明结尾 */\ns.append(\"}\");\n\n        System.out.println(s);\n    }\n}\n\n```\n\n![Untitled](../../../../asset/Untitled%208.png)\n\n## 反射机制调用方法\n\n### 书写注意点：\n\n1. 先获取类\n2. 创建对象，在对象或类中查找对应的方法`getDeclaredMethod`\n3. 调用方法对象的方法，`method.invoke(对象名，方法形参…)`\n4. 可以设置一个对象用于接受返回值 `Object o`\n\n源代码\n\n```java\nimport com.reflect.test.Person;\n\nimport java.lang.reflect.Method;\n\npublic class Test12 {\n    public static void main(String[] args) throws Exception{\n/*正常的调用方法 */\n    //创建对象\nPerson p1=new Person();\n//调用方法\nSystem.out.println(p1.login(\"admin\",\"123\")?\"登录成功\":\"登录失败\");\n        p1.logout();\n\n/*采用反射机制调用方法 */\n    //    1.获取类\nClass aClass=Class.forName(\"com.reflect.test.Person\");\n//    2.创建对象\nObject o=aClass.newInstance();//创建无参对象\n//    3.查找方法\nMethod method=aClass.getDeclaredMethod(\"login\", String.class, String.class);//方法名，形参列表所使用的类\n//    4.调用方法\nObject o2=method.invoke(o,\"admin\",\"123\");\n        System.out.println(o2);\n\n//调用另一个方法\nMethod method1=aClass.getDeclaredMethod(\"logout\");\n        method1.invoke(o);\n    }\n}\n\n```\n\n所调用的方法类：\n\n```java\npackage com.reflect.test;\n\npublic class Person {\n    private int age;\n    public  short longs;\n    protected String name;\n    String address;\n\n/**\n     *登录方法\n* @paramname用户名\n* @parampassword密码\n* @return true表示登录成功，false表示登录失败！\n*/\npublic boolean login(String name,String password){\n        if(\"admin\".equals(name) \u0026\u0026 \"123\".equals(password)){\n            return true;\n        }\n        return false;\n    }\n\n//可能还有一个同名login方法\n// java中怎么区分一个方法，依靠方法名和参数列表。\npublic void login(int i){\n\n    }\n\n/**\n     *退出系统的方法\n*/\npublic void logout(){\n        System.out.println(\"系统已经安全退出！\");\n    }\n}\n\n```\n\n## 反射机制调用构造方法\n\n```java\nimport com.reflect.test.Vip;\n\nimport java.lang.reflect.Constructor;\n\npublic class Test14 {\n    public static void main(String[] args) throws Exception {\n//一般调用构造方法\nVip v1=new Vip(12,\"张三\");\n        System.out.println(v1);\n\n//采用反射机制调用构造方法\n//获取类\nClass aClass=Class.forName(\"com.reflect.test.Vip\");\n//调用无参构造方法\nObject o1=aClass.newInstance();\n\n//调用有参构造方法\n//获取构造方法\nConstructor c1=aClass.getDeclaredConstructor(int.class,String.class);\n//采用有参构造方法创建对象\nObject o2=c1.newInstance(125,\"王麻子\");\n        System.out.println(o2);\n        Constructor c2=aClass.getDeclaredConstructor(int.class,String.class,String.class,boolean.class);\n        Object o3=c2.newInstance(45,\"蔡徐坤\",\"2001年8月8日\",true);\n        System.out.println(o3);\n    }\n}\n\n```\n\n![Untitled](../../../../asset/Untitled%209.png)\n\n```java\npackage com.reflect.test;\n\npublic class Vip {\n    int no;\n    String name;\n    String birth;\n    boolean sex;\n\n    public Vip() {\n    }\n\n    public Vip(int no) {\n        this.no = no;\n    }\n\n    public Vip(int no, String name) {\n        this.no = no;\n        this.name = name;\n    }\n\n    public Vip(int no, String name, String birth) {\n        this.no = no;\n        this.name = name;\n        this.birth = birth;\n    }\n\n    public Vip(int no, String name, String birth, boolean sex) {\n        this.no = no;\n        this.name = name;\n        this.birth = birth;\n        this.sex = sex;\n    }\n\n    @Override\n    public String toString() {\n        return \"Vip{\" +\n                \"no=\" + no +\n                \", name='\" + name + '\\'' +\n                \", birth='\" + birth + '\\'' +\n                \", sex=\" + sex +\n                '}';\n    }\n}\n\n```\n\n## 获取父类和接口\n\n```java\npublic class Test15 {\n    public static void main(String[] args)throws Exception {\n//获取类\nClass c=Class.forName(\"java.lang.String\");\n//获取父类\nClass superclass=c.getSuperclass();\n        System.out.println(superclass);\n//获取父接口\nClass[] interfaces=c.getInterfaces();\n        for (Class cname:interfaces\n             ) {\n            System.out.println(cname.getName());\n        }\n    }\n}\n\n```\n\n![Untitled](../../../../asset/Untitled%2010.png)","lastmodified":"2022-09-20T05:41:07.270338644Z","tags":null},"/%E5%A4%9A%E7%BA%BF%E7%A8%8B":{"title":"","content":"# 多线程\n\nCreated: August 4, 2022 8:42 AM\nDate: August 4, 2022\n类别: 多线程\n\n# 书写注意点\n\n## 方法一 [继承](多线程.md)\n\n1. 编写一个类，**继承**`Thread`（java.lang.Thread），**重写`run`方法**\n2. 启动线程：在main中new对象，然后使用线程的`start()`，开辟线程栈空间\n\n## 方法二 [实现](多线程.md)  建议\n\n采用这种方式，面向接口编程，更灵活，只能继承一个类，但是接口没有限制\n\n1. 编写一个类A，**实现**`java.lang.Runnable`接口，实现`run` 方法\n2. 启动线程：new一个`Thread`对象，再new一个A对象，把new的A对象作为参数传进去，使用`Thread`对象的`start()`启动线程\n\n## 方法三 [实现`Callable`接口 带有返回值](多线程.md)\n\n1. 优点：带有返回值\n2. 缺点：使用`get()`方法获取返回值时，会导致当前线程产生阻塞，因为需要等待另一个线程返回值\n\n# 进程与线程\n\n## 解释\n\n进程：相当于一个**应用程序**\n\n线程：**一个进程中的执行单元**\n\n一个**进程可以执行多个线程**\n\n在Java语言中，线程之间可以共享堆内存和方法区，但是**线程栈内存独立，一个线程一个栈**\n\n多线程的作用：**提高程序处理效率**（在Java看有没有采用多线程，最简单的方法就是看有没有开辟新的栈）\n\n## 线程生命周期图\n\n![Untitled](../../../../asset/Untitled%2011.png)\n\n## 生活举例理解\n\n接力比赛，一个人跑到400米，就换另一个跑，因为没有各自跑各自的效率没有得到提升，单线程\n\n做作业，为了能够写快点，让另一个朋友帮忙一起写，都在写，但是互不干扰对方写作业，多线程\n\n### 真正的多线程\n\n一个线程只执行自己的线程，每个线程之间不干扰，t1只执行t1，t2只执行2，就叫多线程\n\n而**单核CPU**不能真正的实现多线程，因为只有一个大脑，但是可以通过**频繁切换线程**来给人一个多线程的错觉（计算机的计算速度很快，人类感受不出来）\n\n## 举例\n\n多线程举例：IDM下载，采用多线程下载\n\n多进程：Chrome浏览器，每次打开一个网站，都会新建一个进程\n\n![在任务管理中列举的就是进程](../../../../asset/Untitled%201%203.png)\n\n在任务管理中列举的就是进程\n\n# 基本使用方法\n\n## eg1 采用extends的方式\n\n```java\npublic class Test01 {\n    public static void main(String[] args) {\n//创建线程对象\nA t=new A();\n//t.run()//依旧是在main栈中，还是单线程，因为是调用的run方法在主栈中运行\n//怎么看几个线程，看有没有开辟新栈就是最简单的方法\nSystem.out.println(\"启动多线程\");\n        t.start();//开辟线程分支，开辟一个栈分支线程，只有一瞬间，就会结束这个方法。\n//然后JVM会自动在分支线程中，调用t的run方法，运行另一个分支线程\n\n//以下的依旧是在main栈中运行\nfor (int i=0;i\u003c100;i++){\n            System.out.println(\"主线程main--\u003e\"+i);\n        }\n\n    }\n}\nclass A extends Thread {\n    @Override\n    public void run() {\n        for (int i=0;i\u003c100;i++){\n            System.out.println(\"分支线程t--\u003e\"+i+\"===========\");\n        }\n    }\n}\n```\n\n![可以看到主线程和分支线程分别运行自己的，所以输出顺序不定](../../../../asset/Untitled%202%202.png)\n\n可以看到主线程和分支线程分别运行自己的，所以输出顺序不定\n\n## eg2 采用`implements`的方式 推荐这种方式\n\n```java\n\npublic class Test02 {\n    public static void main(String[] args) {\n//线程对象\nThread t=new Thread(new B());//把实现了Runnable的类创建对象，作为参数传进去，封装成线程对象\n//启动分支线程\nt.start();\n//主分支\nfor (int i = 0; i \u003c 100; i++) {\n            System.out.println(\"主分支\"+i);\n        }\n    }\n}\nclass B implements Runnable{\n    @Override\n    public void run() {\n        for (int i = 0; i \u003c100 ; i++) {\n            System.out.println(\"分支线程===========\"+i);\n        }\n    }\n}\n```\n\n![Untitled](../../../../asset/Untitled%203%202.png)\n\n## eg3 implements结合匿名内部类的方式\n\n```java\npublic class Test03 {\n    public static void main(String[] args) {\n//采用匿名内部类的方式\nThread t=new Thread(new Runnable() {\n            @Override\n            public void run() {\n                for (int i = 0; i \u003c 100; i++) {\n                    System.out.println(\"分支线程======\"+i);\n                }\n            }\n        });\n//启动线程\nt.start();\n//主方法\nfor (int i = 0; i \u003c100 ; i++) {\n            System.out.println(\"主线程\"+i);\n        }\n    }\n}\n\n```\n\n![Untitled](../../../../asset/Untitled%204%202.png)\n\n## eg4 实现Callable接口的方式\n\n需要作为参数将继承了`Callable`接口的对象传入FutureTask的构造方法中\n\n```java\nimport sun.security.util.AuthResources_it;\n\nimport java.text.SimpleDateFormat;\nimport java.util.Set;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.FutureTask;\n\npublic class Test17 {\n    public static void main(String[] args) throws Exception {\n//创建未来任务\nFu f=new Fu();//Fu对象创建，继承了Callable接口，作为参数传入到未来任构造方法中\nFutureTask task=new FutureTask(f);\n//将未来任务作为一个线程\nThread t=new Thread(task);\n        t.setName(\"t线程----》\");\n//启动线程\nt.start();\n//获取t线程的运行时间\nString s=task.get().toString();\n        System.out.println(t.getName()+s);\n    }\n}\n\n//返回了方法的运行时间\nclass Fu implements Callable{\n//这个call方法，就相当于run方法\n@Override\n    public Object call() throws Exception {\n//获取开始时间戳\nlong begin=System.currentTimeMillis();\n\n        System.out.println( \"start call\");\n        Thread.sleep(1000*5);\n        System.out.println( \"start end\");\n//获取结束时间戳\nlong end=System.currentTimeMillis();\n//计算运行了多少秒\nlong speed=(end-begin)/1000;\n        return speed;//自动装箱\n}\n}\n```\n\n![Untitled](../../../../asset/Untitled%205%201.png)\n\n# 常用方法\n\n1. 获取当前线程:`Thread.currentThread()`\n2. 获取线程名称：`getName()`\n3. 设置线程名字:`setName()`\n4. 休眠线程：`Thread.sleep()`  在哪个进程使用，就哪个线程休眠\n5. 终止线程的睡眠（叫醒线程，不让它睡眠）:`.interrupt()`\n6. 设置守护线程 `setDaemon(True)`\n\n## eg1 静态方法 Thread.sleep()\n\n```java\npublic class Test05 {\n    public static void main(String[] args)  {\n        Thread t=new Thread(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    Thread.sleep(5000);//分支线程休眠五秒\n} catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(\"分支线程运行==========\");\n            }\n        });\n        t.setName(\"分支线程t\");\n//分支线程运行\n\n//主线程运行\nSystem.out.println(\"主线程运行\");\n        System.out.println(\"分支程序运行\");\n        t.start();\n        for (int i = 0; i \u003c10 ; i++) {\n            try {\n                Thread.sleep(1000);//休眠1秒\n} catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(i);\n        }\n\n    }\n}\n\n```\n\n## eg2 Thread面试题\n\n在main方法中的t.sleep是否会休眠t线程\n\n并不会，因为t.sleep()会转换成`thread.sleep()`\n\n无论怎么变，**休眠的始终是当前线程**\n\n```java\nimport java.util.Set;\n\npublic class Test06 {\n    public static void main(String[] args) {\n        Thread t=new Thread(new AAA());\n        t.start();\n        t.setName(\"t\");\n        try {\n            t.sleep(5000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(\"end\");\n    }\n}\nclass  AAA extends Thread{\n    @Override\n    public void run() {\n        System.out.println(\"线程分支运行=====\");\n    }\n}\n```\n\n![Untitled](../../../../asset/Untitled%206%201.png)\n\n## eg3 终止线程的睡眠（叫醒线程，不让它睡眠）:`.interrupt()`\n\n```java\npackage com.bjpowernode.java.thread;\n/*\nsleep睡眠太久了，如果希望半道上醒来，你应该怎么办？也就是说怎么叫醒一个正在睡眠的线程？？\n    注意：这个不是终断线程的执行，是终止线程的睡眠。\n */\npublic class ThreadTest08 {\n    public static void main(String[] args) {\n        Thread t = new Thread(new MyRunnable2());\n        t.setName(\"t\");\n        t.start();\n\n//希望5秒之后，t线程醒来（5秒之后主线程手里的活儿干完了。）\ntry {\n            Thread.sleep(1000 * 5);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n//终断t线程的睡眠（这种终断睡眠的方式依靠了java的异常处理机制。）\nt.interrupt();//干扰，一盆冷水过去！\n}\n}\n\nclass MyRunnable2 implements Runnable {\n\n//重点：run()当中的异常不能throws，只能try catch\n    //因为run()方法在父类中没有抛出任何异常，子类不能比父类抛出更多的异常。\n@Override\n    public void run() {\n        System.out.println(Thread.currentThread().getName() + \"---\u003e begin\");\n        try {\n//睡眠1年\nThread.sleep(1000 * 60 * 60 * 24 * 365);\n        } catch (InterruptedException e) {\n//打印异常信息\n//e.printStackTrace();\n}\n//1年之后才会执行这里\nSystem.out.println(Thread.currentThread().getName() + \"---\u003e end\");\n\n//调用doOther\n        //doOther();\n}\n\n//其它方法可以throws\n    /*public void doOther() throws Exception{\n\n    }*/\n}\n\n```\n\n![Untitled](../../../../asset/Untitled%207%201.png)\n\n## eg4 终止线程的执行1   stop()不建议 不会保存数据\n\n```java\npublic class Test08 {\n    public static void main(String[] args) {\n        A1 a1=new A1();\n        Thread t=new Thread(a1);\n        System.out.println(\"开始线程\");\n        t.start();//\n        //5s之后终止线程\ntry {\n            Thread.sleep(5000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n//终止线程\nt.stop();//过时的终止，不会保存数据\n\nSystem.out.println(\"end\");\n    }\n\n}\nclass A1 implements Runnable{\n    @Override\n    public void run() {\n        for (int i = 0; i \u003c10 ; i++) {\n            System.out.println(Thread.currentThread().getName()+ i);\n            try {\n                Thread.sleep(1000);//睡1s\n} catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n![Untitled](../../../../asset/Untitled%208%201.png)\n\n## eg5 良好的终止线程\n\n优点：需要执行阶段是执行完了的，不是像stop那样强制停止，可能造成数据的丢失等等问题\n\n```java\npublic class Test09 {\n    public static void main(String[] args) {\n        A2 a = new A2();\n        Thread t = new Thread(a);\n        t.setName(\"t\");\n        t.start();\n        try {\n            Thread.sleep(5000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n\n        }\n// t.stop(); //强制停止线程\na.runStatus=false;//更好地停止方式\nSystem.out.println(a.runStatus);\n\n    }\n}\n\nclass A2 extends Thread {\n    Boolean runStatus=true;\n    @Override\n    public void run() {\n        for (int i = 0; i \u003c10 ; i++) {\n            if (runStatus){\n                System.out.println(Thread.currentThread().getName()+\"===\"+i);\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n\n![Untitled](../../../../asset/Untitled%209%201.png)\n\n## eg6 守护线程\n\n\u003caside\u003e\n💡 守护线程一般是死循环，设置为守护线程之后，会伴随用户线程的死亡而死亡\n**用户线程结束，守护线程自动终止**\n\n\u003c/aside\u003e\n\n```java\nimport jdk.nashorn.internal.ir.WhileNode;\nimport sun.security.util.AuthResources_it;\n\nimport java.util.Set;\n\npublic class Test15 {\n    public static void main(String[] args) {\n        Thread backup=new Thread(new Backup());\n        backup.setName(\"【备份线程t】\");\n//设置成守护线程\nbackup.setDaemon(true);\n//开启线程\nbackup.start();\n        for (int i = 0; i \u003c10; i++) {\n            System.out.println(\"主程序运行\"+i);\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\nclass Backup extends Thread{\n//模拟备份\n@Override\n    public void run() {\n        int i=0;\n        while (true){\n            System.out.println(Thread.currentThread().getName()+\"正在备份--\u003e\"+(++i));\n            try {\nsleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n![Untitled](../../../../asset/Untitled%2010%201.png)\n\n# 常见的线程调度模型\n\n## 分类\n\n1. **抢占式**调度模型\n    - 根据**线程的优先级**来对其分配时间片抢占的概率\n    - 优先级\n        - 默认：5  MIN：1 MAX:10\n    \n    设置优先级\n    \n2. **均分式**调度模型\n    \n    **平均分配**\n    \n\n## 线程调度 有关的方法\n\n1. [设置优先级方法](多线程.md)：`setPriority();` 实例方法\n2. 获取优先级方法：`getPriority();`\n3. [让位方法](多线程.md)：`yield()`,暂停当前执行的线程对象，并执行别的线程 （运行状态—\u003e 就绪状态）不是阻塞\n    1. 类似于抓阄，你抓到了，但是因为yield，你需要把这个纸条放回到盒子里面，大家又一起抓阄。抓到的依旧有可能是你\n4. [合并线程](多线程.md)：`join()`\n\n---\n\n### 设置线程优先级\n\n```java\npublic class Test11 {\n    public static void main(String[] args) {\n        System.out.println(\"max:\"+Thread.MAX_PRIORITY);\n        System.out.println(\"min:\"+Thread.MIN_PRIORITY);\n        System.out.println(\"normal:\"+Thread.NORM_PRIORITY);\n//设置main线程优先级\nThread.currentThread().setPriority(1);\n//创建线程\nThread t=new Thread(new Runnable() {\n            @Override\n            public void run() {\n                for (int i = 0; i \u003c1000; i++) {\n                    System.out.println(Thread.currentThread().getName()+\"---\u003e\"+i);\n                }\n            }\n        });\n\n        t.setPriority(10);\n        t.start();\n        for (int i = 0; i \u003c1000; i++) {\n            System.out.println(Thread.currentThread().getName()+\"==\u003e\"+i);\n        }\n    }\n}\n\n```\n\n![可以看到优先级更高的执行的时间片频率更高](../../../../asset/Untitled%2011%201.png)\n\n可以看到优先级更高的执行的时间片频率更高\n\n### 让位\n\n```java\npublic class Test12 {\n    public static void main(String[] args) {\n        Thread t = new Thread(new MyRunnable6());\n        t.setName(\"t\");\n        t.start();\n\n        for(int i = 1; i \u003c= 10000; i++) {\n            System.out.println(Thread.currentThread().getName() + \"---\u003e\" + i);\n        }\n    }\n}\nclass MyRunnable6 implements Runnable {\n\n    @Override\n    public void run() {\n        for(int i = 1; i \u003c= 10000; i++) {\n//每100个让位一次。\nif(i % 100 == 0){\n                System.out.println(\"yield============\");\n                Thread.yield();//当前线程暂停一下，让给主线程。\n}\n            System.out.println(Thread.currentThread().getName() + \"---\u003e\" + i);\n        }\n    }\n}\n```\n\n![Untitled](../../../../asset/Untitled%2012.png)\n\n让位不一定就是另一个线程运行，只是暂停当前线程的运行，回归到就绪，然后重新抢占时间片，依旧可能是之前让位的线程抢占到时间片。\n\n### 线程合并 join\n\n```java\npublic class Test13 {\n    public static void main(String[] args) {\n        Thread t=new Thread(new Runnable() {\n            @Override\n            public void run() {\n                for (int i = 0; i \u003c10000; i++) {\n                    System.out.println(Thread.currentThread().getName()+\"--\"+i);\n                }\n            }\n        });\n        t.setName(\"t\");\n        t.start();\n        System.out.println(\"main begin\");\n        for (int i = 0; i \u003c10000 ; i++) {\n//main到5000的时候，就进入阻塞状态，让t运行完了之后我才运行\nif (i==5000){\n                try {\n                    t.join();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            System.out.println(Thread.currentThread().getName()+\"=======\"+i);\n        }\n        System.out.println(\"Main end\");\n    }\n}\n\n```\n\n![Untitled](../../../../asset/Untitled%2013.png)\n\n# 线程安全（线程同步机制synchronize）\n\n## 书写注意点：\n\n1. `synchronize()`括号中填写的**对象**是这些进程之间**所共享的进程实例对象**，比如[例子](多线程.md)。\n2. **同步代码块的范围越小，效率越高**\n3. 放在实例方法上，表示共享对象是`this` 但是**整个方法体**都参与了同步（比如`StringBuffer`的方法）\n    \n    ![Untitled](../../../../asset/Untitled%2014.png)\n    \n\n什么时候用：静态\n\n## 三种写法\n\n1. 同步代码块\n2. 实例方法同步\n3. 类锁（排它锁，统一类的所有对象只有一把锁）\n    1. synchronize出现在静态方法（有static修饰的方法）上\n\n## 原理\n\n1. 原理：\n    1. 每个对象都有一把锁，这把锁决定了程序执行的权利，当程序线程运行到synchronize的时候，就会查看自己是否有括号中的这把锁。\n    2. 如果有，就可以进入同步代码区 进行时间片的抢占；如果发现锁被别的线程拿到了（线程运行的过程中一直是持有这把锁的），自己就需要在同步代码区外面**等待**他用完释放。\n    3. 当发现释放的锁之后，参与共享的线程就会抢那个锁，然后拿到在同步代码区中抢占时间片的权利，抢到时间片，就可以继续执行了。\n2. 如果括号中的是“abc”，因为abc是一个常量量，在常量池中的对象，所以每个参与abc的同步锁的线程，都会相互等待，非常费时间\n3. **局部变量和常量不存在安全问题，因为局部变量不共享，常量不可修改**\n\n## 相关\n\n出现线程安全的三个条件\n\n1. 多线程并发\n2. 线程共享数据\n3. 有修改数据的行为\n\n如何解决：\n\n**线程排队**的方式解决线程安全问题，这种机制称为“**线程同步机制**”，会牺牲一部分效率\n\n### 相关：编程模型\n\n1. 同步编程模型：线程之间发生了等待关系，比如t1需要看t2发生什么或者满足什么，t1才会继续执行，需要照顾到别的线程的运行条件。线程同步机制，需要排队\n2. 异步编程模型：自己干自己的，不管别人。并发\n\n## 线程安全eg\n\n### eg1 线程安全问题：两个线程对同一个账户进行访问\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        Account a1=new Account(\"张三\",1500);\n        Thread t1=new Thread(new AccountThread(a1));\n        Thread t2=new Thread(new AccountThread(a1));\n        t1.setName(\"t1\");\n        t2.setName(\"t2\");\n        System.out.println(\"余额:\"+a1.getBalance());\n//启动线程取款\nt1.start();\n\n        t2.start();\n    }\n}\n\nclass AccountThread extends Thread{\n    private Account act;\n\n    public AccountThread(Account act) {\n        this.act = act;\n    }\n\n    @Override\n    public void run() {\n        //模拟网络延迟\n        try {\n            Thread.sleep(1001);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        //取款操作\n        double money=500;//取款金额\n        act.withdraw(money);//取款操作\n        System.out.println(\"线程：\"+Thread.currentThread().getName()+\"\\t\"+act.getName()+\" 取款成功！ 余额：\"+act.getBalance());//余额\n    }\n}\n\npublic class Account {\n    private String name;\n    private double balance;\n    //封装\n\n    public Account() {\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public double getBalance() {\n        return balance;\n    }\n\n    public void setBalance(double balance) {\n        this.balance = balance;\n    }\n\n    public Account(String name, double balance) {\n        this.name = name;\n        this.balance = balance;\n    }\n    //取钱\n    public void withdraw(double money){\n        double before=this.balance;\n        double after=this.balance-money;\n        this.balance=after;\n    }\n}\n\n```\n\n![Untitled](../../../../asset/Untitled%2015.png)\n\n![Untitled](../../../../asset/Untitled%2016.png)\n\n![Untitled](../../../../asset/Untitled%2017.png)\n\n![Untitled](../../../../asset/Untitled%2018.png)\n\n出现了四种情况，有两种错误的情况。\n\n修改取款方法\n\n```java\npublic void withdraw(double money){\n//括号里面代表的是账户对象，\nsynchronized (this){\n        try {\n            Thread.sleep(200);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        double before=this.balance;\n        double after=before-money;\n        this.setBalance(after);\n\n    }\n}\n\n```\n\n正确了\n\n![Untitled](../../../../asset/Untitled%2019.png)\n\n目前不懂得是，如果不添加sleep，还是会出现不同步的情况，余额会变成两个500\n\n# 线程死锁\n\n```java\nimport static java.lang.Thread.sleep;\n\npublic class Test01 {\n    public static void main(String[] args) {\n        Object o1=new Object();\n        Object o2=new Object();\n//创建线程 两个线程公用两个对象\nThread t1=new MyThread1(o1,o2);\n        Thread t2=new MyThread2(o1,o2);\n        t1.setName(\"t1\");\n        t2.setName(\"t2\");\n//启动线程\nt1.start();\n        t2.start();\n    }\n}\nclass MyThread1 extends Thread{\n    private Object o1;\n    private Object o2;\n\n    public MyThread1(Object o1, Object o2) {\n        this.o1 = o1;\n        this.o2 = o2;\n    }\n\n    @Override\n    public void run() {\n        synchronized (o1){\n//睡眠\n/*    try {\n                Thread.sleep(2000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            } */\nSystem.out.println(Thread.currentThread().getName());\n//嵌套\nsynchronized (o2){\n                System.out.println(Thread.currentThread().getName());\n            }\n        }\n\n    }\n}\nclass MyThread2 extends Thread{\n    private Object o1;\n    private Object o所以尽\n```\n\n![Untitled](../../../../asset/Untitled%2020.png)\n\n一直在执行，但是执行不了，因为synchronize的原因，一直在等对方的同步锁释放，但是因为两个都提前占用了对方所需要的同步锁，一直没办法释放，所以造成了死锁。就相当于两个人堵在门口一直僵持\n\n**死锁不报错，无异常，难以纠错。**线程无法继续向下继续执行。执行一百年😒so\n\n所以尽量不要选择同步锁嵌套，如果你处理不好，电脑这辈子就卡在死锁上了 \n\n# 定时器Timer\n\n## 书写注意点\n\n1. 对定时器任务的类需要继承`TimerTask` ，并且重写`run`方法\n2. new的时候可以设置Timer对象的参数，**Timer(true)表示，以守护进程的方式设置定时器**\n3. 可以采用匿名内部类的方式\n\n## eg1\n\n```java\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.Timer;\nimport java.util.TimerTask;\n\npublic class TimerTest {\n    public static void main(String[] args) throws Exception {\n        Timer timer=new Timer();\n// Timer timer=new Timer(true);//采用守护进程的方式运行\n//设置的时间\nSimpleDateFormat geshi=new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n        Date firstTime=geshi.parse(\"2022-08-06 10:18:40\");\n//创建定时器任务\ntimer.schedule(new LogTimer(),firstTime,1000*10);//10秒运行一次\n}\n}\n\n//模拟数据备份的定时器\nclass LogTimer extends TimerTask {\n    @Override\n    public void run() {\n//获取当前时间\nSimpleDateFormat s=new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss SSS\");\n        String now=s.format(new Date());\n//输出\nSystem.out.println(now+\":完成数据备份\");\n    }\n}\n```\n\n![Untitled](../../../../asset/Untitled%2021.png)\n\n# 生产者和消费者模式wait() notify()\n\n\u003caside\u003e\n💡 wait和notify是Java对象的方法，不是线程对象的方法，不要通过线程对象去调用\n\n\u003c/aside\u003e\n\n## 作用\n\n\u003caside\u003e\n💡 在多个线程共享一个对象\n\n\u003c/aside\u003e\n\n## 方法作用\n\n```java\nObject o=new Object();\no.wait();\no.notify();\n```\n\n`wait：`表示将o对象**正在运行的进程进入等待状态，无期限等待，直到调用`notify`方法唤醒**\n\n**释放掉线程占用o对象的锁**\n\n`notify`：可以让o对象正在等待的线程唤醒\n\n**不会释放线程占用o对象的锁**，只是通知\n\n`notifyAll`：唤醒o对象上正在等待的所有线程\n\n### 解释wait和notify\n\n正在打群架，有一个人是跟我对线的，我是一个Object，需要获取与我之间的对战资格才能跟我打\n\n他：我要揍你（获取了与我之间对线的对象锁，获取了与我的对战资格）\n\n我：等一下，（释放了对象锁，没有了与我的对战资格，wait中）\n\n他：开始等待\n\n我：好了，别打帅脸（notify，我对其进行了唤醒）\n\n他：抢夺对战资格，获取对象锁，揍了我一顿\n\n## eg1 生产者和消费者问题\n\n达到的结果：生产一个消费一个，都是同一个\n\n代码解说员：\n\n1. 因为是一一直生产，就使用while\n2. 两个线程公用一个对象，所以需要用到线程同步机制`synchronize`\n3. 需要对仓库的容量进行判断，生产时，大于0就说明有货，进入等待，释放对象锁，\n4. 此时会竞争对象锁获取运行时间片，当消费者获取到时间片，发现大于0，就开始消费，运行完之后，**不会释放锁，而是运行完了synchronize同步代码块之后才释放**\n\n```java\nimport javax.swing.*;\nimport javax.xml.crypto.Data;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.List;\n\npublic class Test18 {\n    public static void main(String[] args) {\n        List lists = new ArrayList();// 仓库对象\n        // 创建两个线程，一个生产一个消费\n        // 两个线程公用一个仓库对象\n        Thread t1 = new Thread(new Producer(lists));// 将生产者作为参数传进去\n        Thread t2 = new Thread(new Consumer(lists));\n        t1.setName(\"生产者线程---\");\n        t2.setName(\"消费者线程---\");\n        t1.start();\n        t2.start();\n    }\n}\n\n// 生产者\nclass Producer implements Runnable {\n\n    private List lists;// 仓库\n\n    public Producer(List lists) {\n        this.lists = lists;\n    }\n\n    @Override\n    public void run() {\n        // 一直生产\n        while (true) {\n            synchronized (lists) {\n                // 仓库中是否有货\n                if (lists.size() \u003e 0) {\n                    // 有货就等待，释放掉list的锁\n                    try {\n                        lists.wait();\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n                // 能运行到这里，说明仓库没货了，那就开始制造\n                Object o = new Object();\n                //制造的时候，都想当懒狗，就歇一会\n                try {\n                    lists.wait(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                lists.add(o);\n                //加个时间，不然不好看\n                SimpleDateFormat gs=new SimpleDateFormat(\"HH:mm:ss SSS\");\n                String now=gs.format(new Date());\n\n                System.out.println(now+\"-\"+Thread.currentThread().getName() + \"制造货物：\" + o);\n                lists.notify();\n            }\n\n        }\n    }\n}\n\n// 消费者\nclass Consumer implements Runnable {\n    private List lists;// 仓库\n\n    public Consumer(List lists) {\n        this.lists = lists;\n    }\n\n    @Override\n    public void run() {\n        // 一直消费\n\n        while (true) {\n            synchronized (lists) {\n                // 判断是否仓库是否有货\n                if (lists.size() == 0) {\n                    // 仓库没货，就不能消费了，等待生产者生产，释放掉锁\n                    try {\n                        lists.wait();\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n                // 能运行到这里，说明仓库有货\n                Object o = lists.remove(lists.size() - 1);// 获取删除的最后一个货物的对象\n\n                SimpleDateFormat gs=new SimpleDateFormat(\"HH:mm:ss SSS\");\n                String now=gs.format(new Date());\n\n                System.out.println(now+\"-\"+Thread.currentThread().getName() + \"消费货物：\" + o);\n                // 消费了，叫醒生产者生产\n                lists.notify();// 不会释放锁，但是如果循环，进入到wait就会释放了\n            }\n        }\n    }\n}\n```\n\n![Untitled](../../../../asset/Untitled%2022.png)","lastmodified":"2022-09-20T05:41:07.270338644Z","tags":null},"/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E8%BD%BD%E5%99%A8%E6%AD%A5%E9%AA%A4":{"title":"","content":"1. main方法中写对下载链接进行基本的变量准备，以及输入变量\n2. 在工具类`util`中创建HTTP工具类，其中写下两个静态方法\n\t1. `getHttpURLConnection(String url)`：用于获取`HttpURLConnection`的对象\n\t2. `getHttpFileName(String url)`\n3. `core`类\n![普通下载速度](../../asset/Pasted%20image%2020220903155805.png)","lastmodified":"2022-09-20T05:41:06.47432571Z","tags":null},"/%E5%A6%82%E4%BD%95%E5%86%99%E5%87%BA%E4%BB%A4%E4%BA%BA%E5%BF%83%E5%8A%A8%E7%9A%84%E4%B8%AA%E4%BA%BA%E9%99%88%E8%BF%B0":{"title":"如何写出令人心动的个人陈述","content":"\n\n# 如何写出令人心动的个人陈述\n![[../../../asset/Pasted image 20220827170501.png]]\n![[../../../asset/Pasted image 20220827170534.png]]\n![[../../../asset/Pasted image 20220827170545.png]]\n![[../../../asset/Pasted image 20220827170549.png]]\n![[../../../asset/Pasted image 20220827170553.png]]\n![[../../../asset/Pasted image 20220827170557.png]]\n![[../../../asset/Pasted image 20220827170600.png]]\n![[../../../asset/Pasted image 20220827170604.png]]\n内容：  \n个人陈述是干啥的  \n招生官/学校想看啥  \n如何开始写个人陈述 - 列清单  \n如何完成个人陈述初稿 - 清单转完整草稿  \n如何完善个人陈述 - 草稿到定稿  \n如何写出吸引人的开头\u0026结尾  \n正式提交前需要做的  \n个人陈述终极检查清单\n","lastmodified":"2022-09-20T05:41:07.270338644Z","tags":null},"/%E5%AE%9E%E4%BE%8B%E8%B4%A6%E6%88%B7%E5%8F%96%E9%92%B1":{"title":"","content":"```java\npackage day15作业;\n/*\n写一个名为Account的类模拟账户。\n该类的属性和方法如下所示。\n该类包括的属性：账户id，余额balance，年利率annualInterestRate；\n包含的方法：各属性的set和get方法。取款方法withdraw()，存款方法deposit()\n\n写一个测试程序\n（1）创建一个Customer，名字叫Jane Smith，他有一个账号为1000，余额为2000，年利率为1.23%的账户\n（2）对Jane Smith操作：\n存入100元，再取出960元，再取出2000。\n打印Jane Smith的基本信息\n信息如下显示：\n成功存入：100\n成功取出：960\n余额不足，取钱失败\nCustomer [Smith，Jane] has a account ：id is 1000 annualInterestRate is 1.23% balance is 1140.0\n\n*/\npublic class Homework2 {\n    public static void main(String[] args) {\n        // 账号为1000，余额为2000，年利率为1.23%的账户\n        Account janAcc = new Account(\"1000\",2000,0.0123);\n        // 创建一个Customer，名字叫Jane Smith\n        Customer jan = new Customer(\"Jane Smith\",janAcc);\n        System.out.println(\"姓名:\"+jan.getName()+\"；账户id：\"+jan.getAct().getId()+\"；余额：\"+jan.getAct().getBalance());\n\n        // 存钱100\n        jan.getAct().deposit(100);\n        // 取钱960\n        jan.getAct().withdraw(960);\n        //取钱2000\n        jan.getAct().withdraw(2000);\n        \n    }\n}\n\n// 客户类\nclass Customer{\n    private String name;//客户名字\n    private Account act;\n\n\n    // 构造方法\n    public Customer() {\n        this.name=\"未知\";\n        this.act=new Account(\"账户1\",0,0.01);\n    }\n    public Customer(String name, Account act) {\n        this.name = name;\n        this.act = act;\n    }\n    //get and set封装\n    public String getName() {\n        return name;\n    }\n    public void setName(String name) {\n        this.name = name;\n    }\n    public Account getAct() {\n        return act;\n    }\n    public void setAct(Account act) {\n        this.act = act;\n    }\n    \n}\n\n// 账户类\nclass Account{\n    private String id;\n    private double balance;\n    private double annualInterestRate;\n    //get and set\n    public String getId() {\n        return id;\n    }\n    public void setId(String id) {\n        this.id = id;\n    }\n    public double getBalance() {\n        return balance;\n    }\n    public void setBalance(double balance) {\n        this.balance = balance;\n    }\n    public double getAnnualInterestRate() {\n        return annualInterestRate;\n    }\n    public void setAnnualInterestRate(double annualInterestRate) {\n        this.annualInterestRate = annualInterestRate;\n    }\n    //构造方法\n    public Account(){\n        this(\"id号\",0,0.0123);\n    }\n    public Account(String id,double balance,double annualInterestRate){\n        this.id=id;\n        this.balance=balance;\n        this.annualInterestRate=annualInterestRate;\n    }\n    /*\n     * 存款取款\n     */\n    //存款\n    public void deposit(double balance){\n        this.balance+=balance;\n        System.out.println(\"存款： \"+balance+\" 元\\t\"+\"当前余额： \"+this.balance+\"元。\");\n    }\n    // 取款\n    public void withdraw(double balance){\n        if (this.balance\u003cbalance) {\n            System.out.println(\"余额不足，取钱失败！！！\\t\"+\"当前余额： \"+this.balance+\"元。\");\n            return;\n        }\n        this.balance-=balance;\n        System.out.println(\"取款成功!!!\\t\"+\"当前余额： \"+this.balance+\"元。\");\n    }\n\n}\n```\noutput：\n![](asset/Pasted%20image%2020220704192450.png)","lastmodified":"2022-09-20T05:41:06.454325385Z","tags":null},"/%E6%83%85%E9%95%8C%E4%B8%89%E5%88%86%E6%9C%A8%E7%9B%B8%E6%80%9D%E4%B8%87%E9%AA%A8%E4%B9%A6":{"title":"情镌三分木，相思万骨书","content":"情镌三分木，相思万骨书\n\n  \n\n醉、倾城\n\n  \n\n　　几渚梁梦杯中尽，独影朱阁泪成诗？万里婵娟银河坠，星辰似海踏歌来。故梦千里清铃响，静候梵音斩红尘。——题记。\n\n　　那一世，你在这场缠绵的夜雨江南中为他悄悄的撑起那把泛青的油伞；我亦在烽台烛台望你千年之余，我曾听闻你为寻他走遍了千迢万里，踏过了雨雪绯林；而今离他只有那短短的一步之遥。看见你为了他在雨中温柔静候，那眼角滑落下的液体伴随着倾赋予他的漫天思念；静静的洒满这座城市的每一个角落。而我就这样静静的站在你们身后，多余的像极了一幅煞乱风景的残墨；顷刻间充斥着幸福流淌过的每一条暖流。但你是否曾知晓？那雨水从天而降肆无忌惮的在我的脸颊划落；泪水也参杂在雨水里紧附着思念随波逐流的晕开视线里残留下的最后一幅画面。也许你永远都不会知道，今生的我为了等候你那不轻易的回首；似乎比你等他的时间还要长。\n\n　　听人说一个人的时候，温起壶中酒；独倚拜月楼，望着庭中盛放的满院流光；凄冷的冬风定会静静的摇落下一地的相思，只为承载起那些忧伤孤独的过往，在岁月的年轮中不停的刻圈成画；却始终画不到那个所谓的终点。有你的曾经一直潜藏在故事里蔓延着最为凄美的片段，梦中的枯藤已千年不绿；被风吹干后的答案；夺走了彼此记忆中最为动人的拥抱。那些禁锢在心底深处的怅然，冲淡了相聚时的喜悦与快乐；难以掩盖的忧伤中载满了无法清点不舍与难过。\n\n　　人生短短十数载，梁月何时绕梦中？当彼此的相遇早已为离别埋下了深深的伏笔，当插肩而过时也不会在为过客不留的画面挽留下最后一丝温存；回忆总是美的让人心碎，曾经的过往依旧使人这般沉吟至今。或许那般留恋本不应该赖在记忆中，转进我心里霸占着每一寸缝隙。\n\n　　冬日春雨几月寒，半阕红豆怎续情？望穿了奈何秋水，我们终究还是等不到那不期而遇的再见。少了梦里梦外的花开，你说着曾经的相遇是如此的云淡风轻，我想着坐拥过着有你的岁月铅华；那时的我梦中藤萝不香醒，梦醒时节花落西厢。敛一轮皓月星空，抒一卷痴情惘然。怎奈文字铺垫的岁月里依旧美轮美奂，不禁让人再次心涌执念；荡漾起那假睡着的海誓山盟。我曾想待你拂去我眉宇间的忧愁，我愿牵起你的手浪迹天涯。最为灿烂的爱情，过界后也不过是烟花转瞬繁落一季。真正的爱情必然是经得起流年锦瑟的厮守，相伴过帘卷云舒的夕霞；也会共赏着烟雨散尽后的那一池澄碧。而此时的冬风枯叶镌落下一","lastmodified":"2022-09-20T05:41:07.270338644Z","tags":null},"/%E6%89%8B%E5%86%99%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84":{"title":"","content":"编写程序实现单向链表数据结构：\n\tpublic class Node {\n\t\tObject data;\n\t\tNode next;\n\t}\n\tpublic class MyLinkedList{\n\t\tNode header;\n\t\t....\n\t\t// 添加数据的方法\n\t\t// 删除数据的方法\n\t\t// 修改数据的方法\n\t\t// 查找数据的方法\n\t\t// 打印集合中每个元素的方法\n\t}\n\n\t最后编写测试程序","lastmodified":"2022-09-20T05:41:06.454325385Z","tags":null},"/%E6%89%8B%E5%86%99%E5%AD%A6%E7%94%9F%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F":{"title":"","content":"1、请使用序列化和反序列化机制，完成学生信息管理系统。\n\n系统打开时显示以下信息：\n欢迎使用学生信息管理系统，请认真阅读以下使用说明：\n请输入不同的功能编号来选择不同的功能：\n[1]查看学生列表\t\n[2]保存学生\n[3]删除学生\n[4]查看某个学生详细信息\n\n--------------------------------------------------------------------\n学生信息列表展示\n学号\t\t\t姓名\t\t\t性别\n------------------------------------\n1\t\t\t\tzhangsan\t\t男\n2\t\t\t\tlisi\t\t\t女\n.....\n\n--------------------------------------------------------------------\n查看某个学生详细信息\n学号：1\n姓名：张三\n生日：1990-10-10\n性别：男\n邮箱：zhangsan@123.com\n\n---------------------------------------------------------------------\n删除学生时，需要让用户继续输入删除的学生编号，根据编号删除学生。\n\n\n注意：请使用序列化和反序列化，以保证关闭之后，学生数据不丢失。\n学生数据要存储到文件中。\n\n\n","lastmodified":"2022-09-20T05:41:06.454325385Z","tags":null},"/%E6%97%A5%E7%A8%8B%E8%AE%B0%E5%BD%95%E6%B5%8B%E8%AF%95":{"title":"","content":"```mermaid\njourney\n\tsection 2022-09-18\n\t干饭:5:me\n\t干饭:6:me\n\t干饭:7:me\n\t干饭:8:me\n```\n\n","lastmodified":"2022-09-20T05:41:06.606327855Z","tags":null},"/%E6%97%A5%E8%AE%B0%E6%A8%A1%E6%9D%BF":{"title":"","content":"","lastmodified":"2022-09-20T05:41:07.270338644Z","tags":null},"/%E6%9C%AA%E5%91%BD%E5%90%8D":{"title":"","content":"","lastmodified":"2022-09-20T05:41:06.438325125Z","tags":null},"/%E6%B3%A8%E8%A7%A3":{"title":"","content":"# 注解\n\nCreated: August 10, 2022 8:13 PM\n\n# 基本\n\n注解，或者叫做注释类型，英文单词是：Annotation\n\n注解Annotation是一种引用数据类型。编译之后也是生成xxx.class文\n\n## 定义\n\n```java\n[修饰符列表] @interface 注解类型名{\n\n\t\t }\n```\n\n# 总结\n\n1. 有且只有value属性，可以直接写属性值\n2. 设置了default默认值的属性，使用时可以不写属性值，其他属性全都需要写 属性=属性值\n3. 注解的属性可以是  byte short int long float double boolean char String Class 枚举类型 以及以上每一种的数组形式。\n\n### 使用：\n\n1. 注解的使用格式是\n    \n    ```java\n    @注解类型名\n    ```\n    \n2. 注解可以出现在类上、属性上、方法上、变量上等....注解还可以出现在注解类型上。\n\n### 内置的注解\n\n`java.lang`包下的注解\n\n`Deprecated` 注解的程序元素，**不建议使用**，**已过时。** 通常是因为它很危险或存在更好的选择。（使用的上班，**会在编辑器上有删除线**）\n\n`Override` 表示一个方法声明，**重写父类方法**\n\n```\n@Override这个注解是给编译器参考的，和运行阶段没有关系。\n//凡是java中的方法带有这个注解的，编译器都会进行编译检查，如果这个方法不是重写父类的方法，编译器报错。\n```\n\n`SuppressWarnings` 指示应该在注释元素（以及包含在该注释元素中的所有程序元素）中**取消显示指定的编译器警告**\n\n# 元注解\n\n用来标注“注解类型”的“注解”，称为元注解。\n\n常见的元注解：\n\n1. `Target`\n    1. 这个`Target`注解用来标注“**被标注的注解”可以出现在哪些位置**\n    2. `@Target(ElementType.METHOD)`：表示“被标注的注解”**只能出现在方法上**。\n    3. `@Target(value={CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, MODULE, PARAMETER, TYPE})`   表示该注解可以出现在：构造方法上 字段上 局部变量上 方法上....类上...\n2. `Retention` 用来标注“**被标注的注解”最终保存在哪里。**\n    1. `@Retention(RetentionPolicy.**SOURCE**)`：表示该注解只被保留在**java源文件**中。\n    2. `@Retention(RetentionPolicy.**CLASS**)`：表示该注解被保存在**class文件**中。\n    3. `@Retention(RetentionPolicy.**RUNTIME**)`：表示该注解**被保存在class文件中，并且可以被反射**机制所读取。\n\n### 注解在开发中的作用\n\n假设有这样一个注解，叫做：@Id\n\n这个注解只能出现在类上面，当这个类上有这个注解的时候，要求这个类中必须有一个int类型的id属性。如果没有这个属性就报异常。如果有这个属性则正常执行！\n\n### Deprecated\n\n![Untitled](../../../../asset/Untitled.png)\n\n## eg1 注解属性以及默认值\n\n指明了属性，除了默认值属性，在使用的时候，其他未设置默认值的属性必须赋值（属性名=属性值，中间使用逗号隔开）\n\n**注意使用的时候，最后面没有`；`结束符号** \n\n注解代码\n\n```java\npackage Annotation;\n\npublic @interface MyAnnotation {\n//给注解设置属性，在使用的时候，必须指明 属性=属性名，否则会报错，无非其都设置了默认值\nString name();\n\n/*\n颜色属性\n     */\nString color();\n\n/*\n年龄属性\n     */\nint age() default 25;\n}\n\n```\n\n使用\n\n```java\npackage Annotation;\n\npublic class Test01 {\n    @MyAnnotation(name=\"张三\",color=\"红色\")\n    public void doSome(){\n\n    }\n\n    public static void main(String[] args) {\n\n    }\n}\n\n```\n\n## eg2 有且只有一个value属性值，value= 可以省略，直接写属性值\n\n注解\n\n```java\npackage Annotation02;\n\npublic @interface MyAnnotation {\n    int value();\n}\n\n```\n\n使用\n\n```java\npackage Annotation02;\n\npublic class Test {\n    @MyAnnotation(value=12)\n    public void doSome(){    }\n\n//value属性前面的 value=可以省略，其他属性不可以\n@MyAnnotation(12)\n    public void doSoem01(){   }\n}\n\n```\n\n## eg3 数组属性值\n\n数组属性值只有一个，可以省略大括号\n\n```\npackage Annotation04;\n//注解\npublic @interface MyAnnotation {\n    String name() default \"张三\";\n    String[] color();\n    JIJIE jijie();\n}\n//季节枚举\nenum JIJIE{\nCHUN,XIA,QIU,Dong\n}\n//使用\nclass Test{\n    @MyAnnotation(color ={\"yellow\",\"red\",\"green\"},jijie = JIJIE.CHUN)\n    public void Test01(){    }\n\n    @MyAnnotation(jijie = JIJIE.Dong,color = \"white\")//数组属性值只有一个可以省略大括号\npublic void Test02(){}\n}\n```\n\n## eg4 元注解的使用\n\n```java\npackage Annotation05;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n//希望注解只能在类和方法上使用\n@Target({ElementType.TYPE,ElementType.METHOD})\n//希望注解可以被反射\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Annotation {\n    String value() default \"上海\";\n}\n\n```\n\n```java\npackage Annotation05;\n\npublic class Test01 {\n    @Annotation(\"南京\")\n    public void some1(){}\n\n//value设置了默认值，可以不赋值\n@Annotation\n    public void  some2(){}\n}\n\n```\n\n## eg5 反射机制的使用\n\n源代码\n\n```java\npackage Annotation05;\n\nimport java.lang.reflect.Field;\n\npublic class Test02 {\n    public static void main(String[] args) throws Exception {\n//创建类\nClass aClass=Class.forName(\"Annotation05.Test01\");\n//查看类上是否是否有Annotation这个注解\nSystem.out.println(aClass.isAnnotationPresent(Annotation.class));//true\n    //获取类对象\nif (aClass.isAnnotationPresent(Annotation.class)){\n//获取注解对象\nAnnotation annotation=(Annotation)aClass.getAnnotation(Annotation.class);\n            System.out.println(\"注解对象:\"+annotation);\n//获取注解对象的值\nString s=annotation.value();\n            System.out.println(s);\n        }\n\n    }\n}\n\n```\n\n测试类\n\n```java\npackage Annotation05;\n@Annotation(\"上海浦东区\")\npublic class Test01 {\n\n//@MyAnnotation\nint i;\n\n//@MyAnnotation\npublic Test01(){\n    }\n\n    @Annotation\n    public void doSome(){\n\n//@MyAnnotation\nint i;\n    }\n\n}\n\n```\n\n注解类\n\n```java\npackage Annotation05;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n//希望注解只能在类和方法上使用\n@Target({ElementType.TYPE,ElementType.METHOD})\n//希望注解可以被反射\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Annotation {\n    String value() default \"上海\";\n}\n\n```\n\n## eg6 注解在开发中的作用\n\n测试类\n\n```java\npackage Annotation07;\n\nimport java.lang.reflect.Field;\n\npublic class Test01 {\n    public static void main(String[] args) throws Exception {\n        // 获取类\n        Class c = Class.forName(\"Annotation07.User\");\n        //    获取字段\n        Field[] fields = c.getDeclaredFields();\n        boolean isOk=false;//是否合法的标记\n        for (Field f : fields\n        ) {\n            //   是否有int类型的id字段\n            if (\"int\".equals(f.getType().getSimpleName()) \u0026\u0026 \"id\".equals(f.getName())){\n                isOk=true;\n                break;//跳出循环\n            }\n        }\n        //如果不合法，就抛出异常\n        if (!isOk){\n            throw new BuhefaException(\"没有包含int id字段的不合法异常\");\n        }\n    }\n\n    public void doSome() {\n    }\n}\n```\n\n异常类\n\n```java\npackage Annotation07;\n\npublic class BuhefaException extends  RuntimeException {\n    public BuhefaException() {\n    }\n\n    public BuhefaException(String message) {\n        super(message);\n    }\n}\n\n```\n\n注解类\n\n```java\npackage Annotation07;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Target(ElementType.METHOD)//只能在方法中使用\n@Retention(RetentionPolicy.RUNTIME)//可以反射\npublic @interface IdAnnotation {\n\n}\n\n```\n\n用户类\n\n```java\npackage Annotation07;\n\npublic class User {\n    int age;\n    String name;\n    String pass;\n}\n\n```\n\n结果\n\n开头只有int 的age字段，不满足条件\n\n![Untitled](../../../../asset/Untitled%201.png)\n\n增加int id字段后，无异常\n\n![Untitled](../../../../asset/Untitled%202.png)","lastmodified":"2022-09-20T05:41:07.270338644Z","tags":null},"/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8":{"title":"","content":"# 类加载器\n\nCreated: August 9, 2022 1:53 PM\nTags: 类加载\n\n## 概述\n\n专门负责加载类的命令/工具。\n`ClassLoader`\n\n## 分类\n\nJDK中自带了3个类加载器\n\n1. 启动类加载器:`rt.jar`\n2. 扩展类加载器:`ext/*.jar`\n3. 应用类加载器:`classpath` （你设置的那个环境变量）\n\n## 解释\n\nString s = \"abc\";\n\n1. 代码在开始执行之前，会将所需要类全部加载到JVM当中。\n2. 通过类加载器加载，看到以上代码类加载器会找String.class\n\t文件，找到就加载，那么是怎么进行加载的呢？\n3. **首先通过“启动类加载器”加载**。\n4. 注意：启动类加载器专门加载：`C:\\\\Program Files\\\\Java\\\\jdk1.8.0_101\\\\jre\\\\lib\\\\rt.jar`（rt.jar中都是**JDK最核心的类库**。）\n5. **如果通过“启动类加载器”加载不到的时候，会通过\"扩展类加载器\"加载**。（注意：扩展类加载器专门加载：`C:\\\\Program Files\\\\Java\\\\jdk1.8.0_101\\\\jre\\\\lib\\\\ext\\\\*.ja`r）\n6. **如果“扩展类加载器”没有加载到，那么会通过“应用类加载器”加载**。（注意：应用类加载器专门加载：**`classpath`中的类**。）\n\n## 双亲委派机制\n\n1. java中为了**保证类加载的安全**，使用了**双亲委派机制**。**优先从启动类加载器中加载**，这个称为“父”\n2. “**父”无法加载到，再从扩展类加载器中加载**，这个称为“母”。双亲委派。\n3. **如果都加载不到，才会考虑从应用类加载器中加载**。直到加载到为止。","lastmodified":"2022-09-20T05:41:06.47432571Z","tags":null},"/%E8%8E%AB%E5%90%8D%E5%BE%88%E5%96%9C%E6%AC%A2%E8%BF%99%E4%B8%AA%E6%96%87%E6%A1%88":{"title":"莫名很喜欢这个文案","content":"[莫名很喜欢这个文案：\n\n  \n\n你知道，我有很多朋友。\n\n你介意过，我有很多朋友。\n\n  \n\n我天生长袖善舞，如果愿意，可以把结识的所有人结交成朋友。\n\n除了你。\n\n我永远不想，和你做朋友。\n\n  \n\n我永远不会再主动发消息给你，\n\n永远不会再和朋友提起你，\n\n永远会控制自己，不再想到你。\n\n  \n\n你永远在我联系人的最末一位。\n\n和第一位隔了五十三页。\n\n所以有时候我想起你，就一点一点向下翻。\n\n翻到了,就不再那么想你了。\n\n  \n\n你知道吗?\n\n我的,好朋友。","lastmodified":"2022-09-20T05:41:07.270338644Z","tags":null},"/%E8%A1%8C%E5%86%85%E4%BB%A3%E7%A0%81%E5%9D%97":{"title":"","content":"`","lastmodified":"2022-09-20T05:41:06.47432571Z","tags":null},"/%E8%AE%B0%E5%BD%95%E4%BB%AA":{"title":"","content":"1. 鼠标电池使用：7/9 21.40左右 --|\u003e 7 25    \u003ci class=\"fa fa-java\"\u003e\u003c/i\u003e\n\n","lastmodified":"2022-09-20T05:41:06.606327855Z","tags":null},"/%E8%AE%B0%E5%BF%86%E7%B3%BB%E7%BB%9F":{"title":"","content":"","lastmodified":"2022-09-20T05:41:06.606327855Z","tags":null},"/%E8%B7%AF%E5%BE%84%E7%9A%84%E7%A7%BB%E6%A4%8D%E6%80%A7%E9%97%AE%E9%A2%98-849ea690f8ba410db611a15aadec3914":{"title":"","content":"# 路径的移植性问题\n\nCreated: August 9, 2022 2:10 PM\n\n## 文件路径的移植性问题：根据src获取文件的绝对路径\n\n关键语句\n\n获取路径： `String path=Thread.currentThread().getContextClassLoader().getResource(\"com/reflect/t1/test.txt\").getPath();`\n\n流的方式返回（方便获取配置文件）：`InputStream reader=Thread.*currentThread*().getContextClassLoader().getResourceAsStream(\"peizhi.properties\");`\n\n比如是在**类根文件夹下的文件才可以（src目录会复制到out的project目录下）**\n\n```java\nimport java.io.InputStream;\nimport java.util.Properties;\n\npublic class Test04 {\n    public static void main(String[] args) throws  Exception {\n        /*\n        * Thread.currendThread() 获取当前线程\n        * getContextClassLoader() 线程对象的方法，获取当前线程的类加载器对象\n        * getResource()           【获取资源】这是类加载器对象的方法，当前线程的类加载器默认从类的根路径下加载资源。\n        * getPath()              获取当前文件的绝对路径\n        * getResourceAsStream 资源以流的方式返回\n        *  */\n        \n        //获取src下的某文件的绝对路径\n        String path=Thread.currentThread().getContextClassLoader().getResource(\"test02.txt\").getPath();\n        System.out.println(path);\n        //通过流的方式返回\n        InputStream reader=Thread.currentThread().getContextClassLoader().getResourceAsStream(\"peizhi.properties\");\n        Properties pro=new Properties();\n        pro.load(reader);\n        System.out.println(pro.getProperty(\"classname\"));\n    }\n}\n```\n\n![Untitled](../../../../asset/Untitled%203.png)\n\n## 文件路径移植性问题：IO+properties通过绑定器解决\n\n### 书写注意点\n\n1. `getBundle`不要在后面的参数中放文件后缀名，**只需要写文件名，不要写后缀名**\n2. 只**适用于`properties`文件类型**\n\n```java\nimport java.util.ResourceBundle;\n\npublic class Test05 {\n    public static void main(String[] args) {\n//设置绑定器\nResourceBundle configFile=ResourceBundle.getBundle(\"com/reflect/test/配置\");\n        String classname=configFile.getString(\"classname\");\n        System.out.println(classname);\n    }\n}\n\n```\n\n![Untitled](../../../../asset/Untitled%201%201.png)","lastmodified":"2022-09-20T05:41:07.270338644Z","tags":null},"/%E8%BF%BD%E5%89%A7%E6%A8%A1%E6%9D%BF":{"title":"","content":"# \n\n\u003e [!bookinfo]+ **《`=this.file.name`》** \n\u003e `=\"![fm|200](\"+this.file.link.封面+\")\"`\n\u003e \n| 字段     | 值                         |\n| :------: | : -------------------:     |\n| 影视名:  | \u003c% tp.file.title %\u003e         |\n|主演| `=this.file.link.主演`|\n|进度|`=(\"![](https://progress-bar.dev/\" +(round((this.file.link.已看集数/this.file.link.总集数)*100)) + \"/)\")`|\n| 已看  |`=this.file.link.已看集数`|\n|总集数    |`=this.file.link.总集数`| \n| 上映时间 | `=this.file.link.上映时间` |\n|tag| `=this.file.etags`   |\n| 状态     | `=this.file.link.状态`     |\n|我的评级| `=this.file.link.我的评级` |\n\n\u003e [!abstract]- **内容简介**\n\u003e\n`=this.file.link.简介`\n","lastmodified":"2022-09-20T05:41:07.270338644Z","tags":null},"/%E9%80%9A%E7%94%A8yaml%E6%A8%A1%E6%9D%BF":{"title":"\u003c% tp.file.title %\u003e","content":"# \u003c% tp.file.title %\u003e\n","lastmodified":"2022-09-20T05:41:07.270338644Z","tags":null},"/%E9%83%A8%E7%BD%B2Obsidian%E9%9D%99%E6%80%81%E7%9F%A5%E8%AF%86%E5%BA%93%E7%BD%91%E7%AB%99":{"title":"部署Obsidian静态知识库网站","content":"# 部署\n\n## 基本结构\n\n```mermaid\ngraph BT\n\tzck(子模块_笔记仓库)\n\tfckhugo(父仓库hugo分支)\n\tfckmaster(父仓库master分支)--\u003ewz(你vercel部署的网站)\n\tzck.-通过推送workflows+TOKEN推送到.-\u003efckhugo\n\tfckhugo.-通过转换为gitpage的workflows+TOKEN转换到 .-\u003efckmaster\n\t\n\t\n\t\n```\n\n\n\n## 仓库设置以及部署\n\n### 父仓库（用于发布仓库：fork）\n\n1. fork我的的ObPublish仓库，然后使用git工具克隆`clone`到本地。\n\n   ```\n   git clone 你的仓库链接\n   ```\n\n   ![image-20220915232031007](../asset/image-20220915232031007.png)\n\n2. 使用`vscode`打开这个仓库，然后在 `设置`--\u003e`查看`--\u003e`终端` 打开终端，可以在此处进行git的基本操作\n\n   1. ![image-20220915230907147](../asset/image-20220915230907147.png)\n   2. 选择bash终端，这个是专门用来执行git命令的，当然，你也可以用除了shell之外的其他终端![image-20220915231014606](../asset/image-20220915231014606.png)\n\n3. 查看基本的情况\n\n   ```bash\n   $ git remote -v #查看当前连接的远程仓库\n   origin  https://github.com/tianzhongs/ObPublish.git (fetch)\n   origin  https://github.com/tianzhongs/ObPublish.git (push)\n   \n   22305@□□Ӵ□□ȥ MINGW64 ~/Desktop/ObPublish (hugo)\n   $ git submodule status #查看子模块状态，我的因为已经删除了所有的子模块文件，不会显示\n   \n   ```\n\n   \n\n4. 如果你有子模块仓库（仓库上的content上有@地址，就说明有子模块仓库），你需要采用一下命令对子模块进行删除，删除之后才能连接上你自己的(以下命令需要在bash下使用)\n\n   ```bash\n   rm -rf content     #删除子模块目录及源码 bash下使用\n   vi .gitmodules       #删除项目目录下.gitmodules文件中子模块相关条目 bash下使用\n   vi .git/config       #删除配置项中子模块相关条目 bash下使用\n   rm .git/module/*     #删除模块下的子模块目录，每个子模块对应一个目录，注意只删除对应的子模块目录即可 \n   ```\n\n### 子仓库设置\n\n1. github上新建一个远程仓库，建议勾选 `私有`，添加一个readme文件（可以初始化仓库，减少麻烦）。**此仓库保存你obsidian知识库中的文件，并通过之后设置的工作流推送到父仓库（发布仓库）**![image-20220915232548960](../asset/image-20220915232548960.png)\n\n2. 将此仓库克隆到本地\n\n   ```bash\n   git clone 你的仓库链接\n   ```\n\n3. 将此知识库必备文件包**解压后**放到你克隆的仓库中\n\n   [文件包点击可达下载地址](https://www.notion.so/tianzhongs/obsidian-de6a07362b774712b51ec44e12cd344d#166e6c51325148a28330dc8be53b2996)\n\n   所勾选的三个文件或文件夹是必须的目录结构，其中的部分文档和模板可以删除![image-20220915234134787](../asset/image-20220915234134787.png)\n\n4. 用vscode打开此知识库仓库，通过vscode或git命令进行提交，git命令采用以下进行\n\n   ```bash\n   git add . #添加所有文件到暂存区\n   git commit -m \"提交必备文件\" #提交信息\n   git push #提交到远程仓库\n   ```\n\n### 子模块仓库配置\n\n\u003e 因为笔记仓库和发布仓库是分离的，所以需要将子仓库与父仓库进行关联。将子仓库作为子模块放到父仓库中，作为父仓库的content文件夹\n\n1. 打开父仓库（发布仓库Obpublish），使用git命令\n\n   ```bash\n   git submodule add https://github.com/tianzhongs/ObZhishiku.git content #将仓库作为模块放到父仓库的content文件夹中\n   git submodule update --init #初始化子模块\n   git submodule update --remote #子模块最新的内容版本同步到父仓库\n   ```\n\n   ![image-20220916002216473](../asset/image-20220916002216473.png)\n\n   可以在本地父仓库（发布仓库）中看到多了一个content文件夹，其中包含的就是笔记仓库的内容\n\n2. 将本地的操作同步到github上(**提交三部曲**)\n\n   ```bash\n   git add .\n   git commit -m \"添加子模块\"\n   git push #提交到远程仓库\n   ```\n\n   ![image-20220916002603531](../asset/image-20220916002603531.png)\n\n此时，就可以在github父仓库中看到子模块的状态，有个`@`符号，所@的就是子模块的版本号，点击可以进入到对应的子仓库版本号 的内容\n\n## 配置转换工作流文件\n\n在父仓库中，有一个`workflows`文件夹中有一个`deploy.yaml`文件，是github的专属工作流文件，可以在其中部署自己的脚本等等达到自动化。\n\n### 添加TOKEN\n\n1. 打开github，点击头像，在弹出的选项中选择 `settings` ，往下翻，找到`Developer settings`（开发者设置）中，添加一个TOKEN，全部权限都勾选，期限设置永久\n   1. ![image-20220916003405259](../asset/image-20220916003405259.png)\n   2. ![image-20220916003652746](../asset/image-20220916003652746.png)\n\n2. 复制你的TOKEN，在桌面新建一个txt保存起来，因为之后也需要用到\n\n3. 在github上打开父仓库，点击**仓库的settings**,在下面可以找到添加，将刚才复制的TOKEN添加进去作为一个环境变量，需要注意：名字必须是全大写的`TOKEN`![image-20220916004320660](../asset/image-20220916004320660.png)\n\n4. 返回到本地父仓库（发布仓库）的`.github\\workflows\\deploy.yaml`，对工作流进行基本的设置。设置之后，git推送三部曲（add，commit，push到远程仓库）\n\n   ```yaml\n   name: Deploy to GitHub Pages\n   \n   on:\n     push:\n       branches:\n         - hugo\n   \n     workflow_dispatch:\n   \n   jobs:\n     deploy:\n       runs-on: ubuntu-22.04\n       steps:\n         - uses: actions/checkout@v2\n           with: \n             token: ${{ secrets.TOKEN }}  #这里是添加的token，不用设置，需要在仓库中添加TOKEN，$代表的是调用刚才添加的环境变量，所以不需要设置\n             submodules: 'true'\n         - name: Checkout submodules\n           run: git submodule update --init --recursive\n   \n         - name: config1 \n           run: rm -rf content/.obsidian content/cedict_ts.u8 content/Extras/Templates  \u0026\u0026 mv content/*.md content/Atlas \u0026\u0026 find content/ -name \"*.md\" | xargs -I file  mv -f file content \u0026\u0026  mv content/AboutTheGarden.md content/_index.md \n         \n         - name: config2\n           run: \"ls content/ \u0026\u0026 grep -lr --null 'title' content/* | xargs -0 sed -i -E -r 's/title: \"(.*)/title: \\\"\\\\1\\\"/g'\"\"\n         \n         - name: config3 \n           run: rm -rf content/*.md-E\n   \n         \n         - name: Build Link Index\n           uses: jackyzha0/hugo-obsidian@v2.18\n           with:\n             index: true\n             input: content\n             output: assets/indices\n             root: .\n   \n   \n         - name: Setup Hugo\n           uses: peaceiris/actions-hugo@v2\n           with:\n             hugo-version: '0.96.0'\n             extended: true\n   \n         - name: Build\n           run: hugo --minify --debug\n   \n         - name: Deploy\n           uses: peaceiris/actions-gh-pages@v3\n           with:\n             github_token: ${{ secrets.GITHUB_TOKEN }}\n             publish_dir: ./public\n             publish_branch: master  # deploying branch\n             cname: www.baidu.com   #修改成你的域名\n   ```\n\n   \n\n5. 将子模块的再次同步到父仓库一下，在本地父仓库（发布仓库）中执行以下命令（如果没有推送的东西，就打开readme文件，随便加个空格就有改动，可以推送了）\n\n   ```bash\n   git submodule update --init #初始化子模块\n   git submodule update --remote #子模块最新的内容版本同步到父仓库\n   git add .\n   git commit -m \"最新的\"\n   git psuh\n   ```\n\n6. 推送之后，打开github发布的远程仓库ObPublish中的`action`，这里是查看工作流的地方，查看刚才推送的能否成功转换，之前错误的工作流不用管![image-20220916005313382](../asset/image-20220916005313382.png)\n7. 你可以点击github中的code面板，可以选择分支，你会发现多了一个`master`分支，那个就是通过我们的工作流将hugo分支中子模块-我们的笔记content中的内容转换成了html文件放到了master分支中\n\n## Vercel基本部署\n\n1. 打开 [verel](https://vercel.com/)次用github登录之后，选择新建Project（项目），选择import你的发布仓库obPublish\n2. 选择环境是other，即默认没有环境，因为部署的是master分支，里面全是html文件，浏览器能够执行，不需要环境![image-20220916005911016](../asset/image-20220916005911016.png)开始部署\n3. 然后成功之后，你会发现主界面是错误，原因是因为vercel默认部署你github仓库中的默认分支，所以需要 **调整部署分支，为master**：在你部署的这个项目中点击settings，选择git，然后设置分支，保存。\n4. ![image-20220916010146988](../asset/image-20220916010146988.png)\n5. 你还需要在本地仓库中修改一下父仓库的readme文件，随便加个空格就行。这样做的原因是：vercel每次进行部署，都建立在你的仓库有改动的情况下，因为没有改动，他就不会部署你的master分支，所以**你在本地父仓库中修改内容，push推送（git推送三部曲）到远程仓库就好**（推送之后你依旧可以到github远程父仓库中的`action`查看工作流的情况，工作流成功之后，verel才会开始拉取github中的master分支，开始部署网站。）![image-20220916010603652](../asset/image-20220916010603652.png)\n6. 可以看到已经部署成功，在vercel也成功的部署了master分支![image-20220916010653216](../asset/image-20220916010653216.png)\n7. 点击overview面板中的visit进行访问，可以看到部署成功的界面了（搜索功能不能使用，因为父仓库中的`config.toml`文件中没有配置成你的域名，你也可以配置成vercel的项目域名Domains）。![image-20220916010751475](../asset/image-20220916010751475.png)\n\n## 配置文件部分\n\n### 域名\n\n1. 打开vercel的`settings`面板，在选择`Domain`，添加你的域名（域名解析方面不赘述），添加之后如图，当然你也可以用vercel自带的项目域名![image-20220916105704328](../asset/image-20220916105704328.png)\n\n\n\n### 父仓库中的文件配置\n\n`config.toml`：配置baseURl，配置成你的域名，刚才在vercel中设置的或者vercel项目自带生成的（此处域名不改成自己的，无法使用搜索功能）\n\n`data\\config.yaml`：配置一些基本信息\n\n### 设置子模块工作流(用于推送到父模块的hugo分支)\n\n1. 添加TOKEN到action\t\n\n   和之前的步骤一样，在github子模块笔记仓库中的settings中添加刚才的TOKEN进去，名字必须是全部大写\n\n2. 点击仓库才action，在这里可以添加工作流，如果你，如果仓库中有工作流文件，你可以对其进行修改，工作流在.github/workflows文件夹下\n\n3. 开始新建工作流![image-20220916160314431](../asset/image-20220916160314431.png)\n\n4. 全部删除，将以下内容复制粘贴进去，然后进行修改配置\n\n   ```yaml\n   name: Send submodule updates to parent repo\n   \n   on:\n     push:\n       branches:\n         - main\n   \n   jobs:\n     update:\n       runs-on: ubuntu-latest\n   \n       steps:\n         - uses: actions/checkout@v2\n           with:\n             repository: zhangsan/dg3 # 设置你用户名/发布仓库的仓库名,作用是将子模块更新到父仓库dg3\n             token: ${{ secrets.TOKEN }}\n             # 把子模块打开\n             submodules: 'true'\n   \n         - name: Pull \u0026 update submodules recursively\n           run: |\n             git submodule update --init --recursive\n             git submodule update --recursive --remote\n         - name: Commit\n           run: |\n             git config user.email \"提交的邮箱，一般是你github的邮箱\" #修改\n             git config user.name \"你的名称\" #修改\n             git add --all\n             git commit -m \"Update submodules\" || echo \"No changes to commit\"\n             git push\n   ```\n\n   5. 提交之后，点击action进行查看![image-20220916161016944](../asset/image-20220916161016944.png)\n   6. 到这里，在本地笔记仓库中做了修改，就可以直接推送，就不需要到父仓库中进行子模块同步了，工作流会自动在云端同步。\n\n\n\n## 额外评论区设置\n\n预览图\n\n![image-20220916163756206](../asset/image-20220916163756206.png)\n\n\u003e 为了方便配置，我选择的是gitTalk的方式，开始我使用了`waline`的方式去配置，虽然能够评论，但是不清楚为什么一直加载评论区，所以我就弃用了，waline的界面配置性更高，同时可以无需登录评论。\n\n### gitTalk评论区进行配置\n\n\u003e 因为评论区是和仓库的issue相互连接的，评论区中的内容都会转到仓库issue中，因为笔记仓库私有化，所以相对于评论的可见性，我建议可以自己进行选择。比如我希望别人也能够看见评论，在父仓库发布仓库中进行以下步骤。\n\n注意：**仓库的issue必须打开**，默认是打开的\n\n1. 点击`头像`--\u003e`setting`--\u003e`开发者设置`--\u003e`OAuth Apps`，或者直接点击这个连接进入(开发者设置)[https://github.com/settings/developers]，添加一个应用\n\n2. 设置好你的域名，别的随便设置![image-20220916162639143](../asset/image-20220916162639143.png)\n\n3. 复制id和密码，![image-20220916162812917](../asset/image-20220916162812917.png)\n\n4. 打开本地仓库父仓库的`layouts\\partials\\contact.html`文件，末尾添加以下代码，然后配置id和密码\n\n   ```html\n   \n   \u003c!-- 以下为你需要配置的评论区，以下部分可以删除 --\u003e\n   \u003c!-- 引入 --\u003e\n   \u003clink rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css\"\u003e\n   \u003cscript src=\"https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js\"\u003e\n       \u003c/script\u003e\n   \n       \u003c!-- 添加一个容器--\u003e\n       \u003cdiv id=\"gitalk-container\"\u003e\u003c/div\u003e\n   \n       \u003c!-- 生成 gitalk 插件--\u003e\n       \u003cscript\u003e\n           var gitalk = new Gitalk({\n               clientID: 'b3de82d3148c36a4a587', //Client ID 自己配置\n   \n               clientSecret: '973b351e5a54ff9ea6d93e7db3f431beef48dc2d', //Client Secret 自己配置\n   \n               repo: 'blogtalk',//保存评论的仓库仓库名称  自己配置\n               owner: 'tianzhongs',//仓库拥有者  自己配置\n               admin: ['Tianzhongs'], //仓库管理员\n               id: location.href,      // Ensure uniqueness and length less than 50\n               distractionFreeMode: false  // Facebook-like distraction free mode\n           })\n   \n           gitalk.render('gitalk-container')\n       \u003c/script\u003e\n   ```\n\n   \n\n5. 等vercel拉取部署成功之后\n\n#### gittalk评论Lable问题\n\n\u003e 在我后来使用的过程中，点击除了主页笔记之外的页面，会出现评论区验证错误（Error: Validation Failed.）\n\n在此致谢：[我是东山啊](https://blog.misec.top/archives/2018810gitalk-error#:~:text=Error%3A%20Validation%20Failed%20%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98%E5%B0%B1%E6%AF%94%E8%BE%83%E5%A4%8D%E6%9D%82%E4%BA%86%EF%BC%8C%E9%83%A8%E5%88%86%E6%96%87%E7%AB%A0%E7%9A%84%E8%AF%84%E8%AE%BA%E5%8C%BA%E4%BC%9A%E6%8A%A5Error%3A%20Validation%20Failed%2C%E5%85%B7%E4%BD%93%E5%8E%9F%E5%9B%A0%E6%98%AF%E7%94%B1%E4%BA%8E,Github%20%E9%99%90%E5%88%B6%20labal%20%E9%95%BF%E5%BA%A6%E4%B8%8D%E8%83%BD%E8%B6%85%E8%BF%87%2050%E5%BC%95%E8%B5%B7%E7%9A%84%EF%BC%8C%E8%AF%A5%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%9D%A5%E8%87%AAGitalk%E9%A1%B9%E7%9B%AE%E4%BB%93%20Issues115%EF%BC%8C%E9%80%9A%E8%BF%87MD5%E5%8A%A0%E5%AF%86ID%E6%9D%A5%E7%BC%A9%E7%9F%ADlabal%E9%95%BF%E5%BA%A6%E3%80%82)的博客，已经将修改后的内容放置到了项目之中，可以直接fork进行使用\n\n# 注意事项\n\n1. 笔记仓库中的笔记都有`title`的yaml头，网站部署后的文章标题就是yaml中的title字段，所以title字段是笔记的必须\n2. 如果你已经部署好了相关的文档，那么就可以看一下这篇文章，其中包含了关于这个知识库在Obsidian中的一些格式问题，**尤其需要注意**，点击我[[Obsidian知识库笔记相关]]","lastmodified":"2022-09-20T05:41:07.270338644Z","tags":null},"/000.%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E4%B8%80%E8%88%AC%E6%B5%81%E7%A8%8B":{"title":"","content":"1. 配置好用户凭据以及 [[001.安装之后的配置#设置个人名称和邮箱 veaiyshu|用户邮箱]]\n2. 复制仓库链接![[../../asset/Pasted image 20220624141828.png]]\n\t ```bash\n\techo \"# hanguang\" \u003e\u003e README.md\n\tgit init\t\t\t\t#初始化仓库\n\tgit add README.md\t\t #新建标注文件，可以不要\n\tgit commit -m \"first commit\"\t#“提交信息”\n\tgit branch -M main\t\t\t\t#设置默认分支\n\tgit remote add origin https://github.com/tianzhongs/hanguang.git\t#添加远程分支到本地命名为origin\n\tgit push -u origin main\t#推送origin到默认分支main\n\t```\n\t\n3. 将文件`git clone url`进去，会自动将远端的仓库文件全部下载下来![[../../asset/Pasted image 20220624141947.png]]，`.gitigore`是配置文件，一般不用动\n4. 使用`git remote -v`查看连接远程仓库的信息,后面括号里面代表的权限 拉取推送![[../../asset/Pasted image 20220624142344.png]]\n5. 对文件进行修改中以后，使用`git status`可以查看当前仓库修改的内容状态![[../../asset/Pasted image 20220624145949.png]]\n6. 提交三部曲**add(暂存）,commit（注释）,push（推送）**[[../../asset/Pasted image 20220624150110.png]]\n7. 查看云端仓库是否有![[../../asset/Pasted image 20220624150237.png|相关注释]] “修改Blog配置文件”\n\n","lastmodified":"2022-09-20T05:41:06.438325125Z","tags":null},"/000.0GIit%E7%9B%AE%E5%BD%95":{"title":"","content":"# 目录\n```dataview\nlist\nFrom  \"Git\"\nsort file.name\n```","lastmodified":"2022-09-20T05:41:06.438325125Z","tags":null},"/000.A-little-List":{"title":"","content":"# 目录\n```dataview\nlist\nFrom \"999 A little\"\nsort this.file.name\n```","lastmodified":"2022-09-20T05:41:06.438325125Z","tags":null},"/0000-%E6%80%BB%E7%BB%93%E5%9F%BA%E6%9C%AC%E8%A6%81%E7%82%B9":{"title":"","content":"1. jdbc的作用，是啥\n2. jdbc开发的步骤：导包jar，[开发6部分](0002%20JDBC开发基本使用.md)\n3. [为了避免sql注入，statement以及PreparedStatement使用的区别](0004%20Statement和PreparedStatement的区别.md)\n4. 使用资源绑定器，采用类反射机制等等，降低程序耦合度，可以通过配置文件来修改相应的设置等等 [0007 通过资源绑定器获取属性文件](0007%20通过资源绑定器获取属性文件.md)\n5. 事物机制","lastmodified":"2022-09-20T05:41:06.438325125Z","tags":null},"/0000-%E6%95%B4%E4%B8%AA%E6%B5%81%E7%A8%8B":{"title":"","content":"# 1. 导包\n1. 导入图书管理的包到idea\n2. 选择src目录，设置为source root\n3. 设置编码为gbk，设置jdk为8或者以上\n---\n\n# 2. 初始化用户数据\n## 具体步骤\n1. 将User实现Serializable，添加序列化号\n2. 添加util工具包，添加initdatautil，添加初始化数据的方法\n3. 写出initdata通用方法，以及在主函数main方法中，写入具体的持久化user对象的方法，将对象写入到本地硬盘中，具体代码如下\n4. 注意：**存入本地的对象都需要添加序列号**，常**用的路径可以加入到常量类中**，pathConstant中的user对象存放路径\n\n## 主要代码\n```java\npackage com.bjpowernode.util;  \n  \nimport com.bjpowernode.bean.PathConstant;  \nimport com.bjpowernode.bean.User;  \n  \nimport java.io.File;  \nimport java.io.FileOutputStream;  \nimport java.io.IOException;  \nimport java.io.ObjectOutputStream;  \nimport java.math.BigDecimal;  \nimport java.util.ArrayList;  \nimport java.util.List;  \n  \n/**  \n * 初始化数据  \n *  \n * @author 22305  \n * @date 2022/08/29  \n */public class InitDataUtil {  \n    public static void main(String[] args) {  \n    /* 初始化用户数据 */        List\u003cUser\u003e userList=new ArrayList\u003c\u003e();  \n    //    添加用户数据  \n        userList.add(new User(1, \"张三\", \"正常\", new BigDecimal((\"100\"))));  \n        userList.add(new User(2, \"李四\", \"正常\", new BigDecimal((\"100\"))));  \n        userList.add(new User(3, \"王6\", \"正常\", new BigDecimal((\"100\"))));  \n    //    使用方法持久化到本地  \n        initData(PathConstant.User_Path,userList);  \n    }  \n  \n    /**  \n     * 初始化数据  \n     *  \n     * @param path 路径  \n     * @param list 列表  \n     */  \n    public static void initData(String path, List\u003c?\u003e list) {  \n        // 路径提取  \n        File directory = new File(path.split(\"/\")[0]);  \n        File file = new File(path);// 初始化文件存放路径  \n        ObjectOutputStream oos=null;//对象输出流  \n        //   判断文件夹是否存在  \n        if (!directory.exists()) {  \n            directory.mkdir();  \n        }  \n        //    判断文件是否存在  \n        if (!file.exists()){  \n            try {  \n                file.createNewFile();  \n                oos=new ObjectOutputStream(new FileOutputStream(file));  \n                oos.writeObject(list);//写入对象数据  \n            } catch (IOException e) {  \n                e.printStackTrace();  \n            }finally {  \n                try {  \n                    oos.close();  \n                } catch (IOException e) {  \n                    e.printStackTrace();  \n                }  \n            }  \n        }  \n  \n    }  \n}\n```\n5. 执行一次，将user对象持久化到本地上\n# 3. 用户查询\n## 具体步骤\n\n# 4. 用户添加\n## 步骤\n1. UserDao添加方法void add(User user);\n2. 对其进行实现,添加操作\n\t1. 读取文件中的list对象\n\t2. 如果有list通过最后一个用户，新生成一个用户编号+1\n\t3. 如果没有list，就创建一个空list，放到空list中\n\t4. 放入到list中，然后重新写入到本地硬盘\n3. 在UserService中添加同样的方法，\n4. 在UserServiceImpl中调用此方法\n5. 修改`UserHandleViewCtrl.java`中相关的持久化\n### 代码\n\n相关修改的代码\n\u003e 注意代码顺序，持续化到本地的代码在前，因为这个项目的数据来源在本地，所以以本地数据为主\n```java\nuserService.add(user);  \nusers.add(user);\n```\n\ndao层实现代码\n```java\npackage com.bjpowernode.dao.Impl;  \n  \nimport com.bjpowernode.bean.PathConstant;  \nimport com.bjpowernode.bean.User;  \nimport com.bjpowernode.dao.UserDao;  \n  \nimport java.io.*;  \nimport java.util.ArrayList;  \nimport java.util.List;  \n  \npublic class UserDaoImpl implements UserDao {  \n    /**  \n     * 选择  \n     *  \n     * @return {@link List}\u003c{@link User}\u003e  \n     */    @Override  \n    public List\u003cUser\u003e select() {  \n        try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(PathConstant.User_Path))) {  \n            //    读取  \n            List\u003cUser\u003e list = (List\u003cUser\u003e) ois.readObject();  \n            return list;  \n        } catch (Exception e) {  \n            // throw new RuntimeException(e);  \n            e.printStackTrace();  \n        }  \n        // 如果异常，就返回一个无用户对象的空列表  \n        return new ArrayList\u003c\u003e();  \n    }  \n  \n    /**  \n     * 添加  \n     *  \n     * @param user 用户  \n     */  \n    @Override  \n    public void add(User user) {  \n        ObjectInputStream ois = null;  \n        ObjectOutputStream oos = null;  \n        List\u003cUser\u003e list = null;  \n        try {  \n            //    读取硬盘中的用户信息  \n            ois = new ObjectInputStream(new FileInputStream(PathConstant.User_Path));  \n  \n            list = (List\u003cUser\u003e) ois.readObject();// 读取用户信息  \n            // 判断list是否有  \n            if (list != null) {  \n                // 设置新添加的用户id  \n                User lastUser = list.get(list.size() - 1);  \n                user.setId(lastUser.getId() + 1);  \n                //    添加到list中  \n                list.add(user);  \n            } else {  \n                //    当list为空的时候，就需要一个空的去装  \n                list = new ArrayList\u003c\u003e();  \n                user.setId(0001);  \n                list.add(user);  \n  \n            }  \n            //    持久化到本地硬盘  \n            oos = new ObjectOutputStream(new FileOutputStream(PathConstant.User_Path));  \n  \n            oos.writeObject(list);  \n            oos.flush();  \n  \n        } catch (Exception e) {  \n            throw new RuntimeException(\"添加用户失败\");  \n        } finally {  \n            // 释放资源  \n            try {  \n                if (ois != null) {  \n                    ois.close();  \n                }  \n                if (oos != null) {  \n                    oos.close();  \n                }  \n            } catch (IOException e) {  \n                e.printStackTrace();  \n            }  \n        }  \n    }  \n}\n```\n## 问题\n#问题 因为private UserService的时候没有new一个对象出来，导致了使用UserServiceImpl中的方法出错\n![](../../asset/Pasted%20image%2020220824112043.png)\n#问题 那个`ObjectOutputStream`放在`ObjectInputStream`下面就不行，不太理解为啥一定要放在最后面，是文件读取太快，那时候还在读，但是又打开了问完文件写入流的原因吗？\n\n### 结构\n因为需要层次话，所以需要在service和dao包中分别书写结果，**dao包用于持久化处理数据**，service用于**业务处理**\n```mermaid\ngraph TD\nid1(userService)\nid2(UserDao)\n\n需要使用的类--new--\u003eid1\nUserDaoImpl -.implement.-\u003eid2\nuserServiceImpl-.implement.-\u003eid1\nid1--调用--\u003eid2\n\n```\n1. 新建一个dao包，在dao包下新建接口UserDao，`List\u003cUser\u003e select()`\n2. dao包下创建子包ipml,在ipml下创玩UserDaoIpml类\n3. 在类下重写`List\u003cUser\u003e select()`方法，读取本地的硬盘对象文件，如果没有，就返回空的列表\n4. 在service下新建UserService接口，List\u003cUser\u003e select() 方法\n5. 在impl下新建实现类，UserServiceImpl，调用手写的\n\n\u003e总结一下：\n\u003e1. dao包括了一个接口，以及其下面的实现类，类中主要写了具体的实现方法\n\u003e2. Service主要包括了一个客户端调用的接口，其下面包括的实现类，主要通过new dao类的对象，返回dao下面的实现类\n\u003e3. 主要程序中方法，通过new service实现类，去实现service中的方法\n\u003e主要程序---调用---\u003esevice接口 --实现--\u003eserviceimpl类----调用---\u003edao接口---实现的---\u003edao实现\n\n### 主要代码\ndao层实现的方法\n\n```java\npackage com.bjpowernode.dao.Impl;  \nimport com.bjpowernode.bean.PathConstant;  \nimport com.bjpowernode.bean.User;  \nimport com.bjpowernode.dao.UserDao;  \nimport java.io.FileInputStream;  \nimport java.io.FileNotFoundException;  \nimport java.io.IOException;  \nimport java.io.ObjectInputStream;  \nimport java.util.ArrayList;  \nimport java.util.List;  \npublic class UserDaoImpl implements UserDao {  \n    /**  \n     * 选择  \n     *  \n     * @return {@link List}\u003c{@link User}\u003e  \n     */    @Override  \n    public List\u003cUser\u003e select() {  \n        try (ObjectInputStream ois=new ObjectInputStream(new FileInputStream(PathConstant.User_Path))){  \n        //    读取  \n            List\u003cUser\u003e list=(List\u003cUser\u003e) ois.readObject();  \n            return list;  \n        }catch (Exception e){  \n            // throw new RuntimeException(e);  \n            e.printStackTrace();  \n        }  \n        //如果异常，就返回一个无用户对象的空列表  \n        return new ArrayList\u003c\u003e();  \n    }  \n}\n```\n\n\n调用的地方（需要注意，实现对象和创建对应实现方法的对象）\n```java\n@Override  \npublic void initialize(URL location, ResourceBundle resources) {  \n  \n    /* users.add(new User(1, \"张三\", \"正常\", new BigDecimal((\"100\"))));  \n    users.add(new User(2, \"李四\", \"正常\", new BigDecimal((\"100\"))));  \n    users.add(new User(3, \"王五\", \"正常\", new BigDecimal((\"100\")))); */  \n    //改为本地读取数据加载用户信息  \n    users.addAll(userService.select());  \n  \n    c1.setCellValueFactory(new PropertyValueFactory\u003c\u003e(\"id\"));  \n    c2.setCellValueFactory(new PropertyValueFactory\u003c\u003e(\"name\"));  \n    c3.setCellValueFactory(new PropertyValueFactory\u003c\u003e(\"money\"));  \n    c4.setCellValueFactory(new PropertyValueFactory\u003c\u003e(\"status\"));  \n    userTableView.setItems(users);  \n  \n}\n```\n\n\n### 图片output\n![](../../asset/Pasted%20image%2020220829175404.png)\n\n\n---\n\n# 5. 用户修改\n## 步骤\n1. 在UserDao中添加接口`void update(User user)`更新接口方法，然后进行实现\n```java\n@Override  \npublic void update(User user) {  \n    ObjectInputStream ois = null;  \n    ObjectOutputStream oos = null;  \n    List\u003cUser\u003e list = null;  \n    try {  \n        //    读取本地用户信息  \n        ois = new ObjectInputStream(new FileInputStream(PathConstant.User_Path));  \n        list = (List\u003cUser\u003e) ois.readObject();  \n        if (list != null) {  \n            //    获取要修改的用户  \n            User originUser = list.stream().filter(u -\u003e u.getId() == user.getId()).findFirst().get();  \n            // 修改数值  \n            BeanUtil.populate(originUser, user);  \n            //    对数据进行持久化  \n            oos=new ObjectOutputStream(new FileOutputStream(PathConstant.User_Path));  \n            oos.writeObject(list);  \n            oos.flush();  \n        }  \n  \n        /* 当list有用户信息的时候， */  \n    } catch (Exception e) {  \n        throw new RuntimeException(\"更新用户信息错误\");  \n    }finally {  \n        try {  \n            if (ois!=null){  \n                ois.close();  \n            }  \n            if (oos!=null){  \n                oos.close();  \n            }  \n        } catch (IOException e) {  \n            e.printStackTrace();  \n        }  \n    }  \n}\n```\n2. 注意需要一个进行复制对象属性（将a的所有属性值复制给b的相同属性上）的方法`populate(Object origin,Object dest)`，可以创建在util工具包中的`BeanUtil`类中\n```java\n/**  \n * 复制对象属性  \n *  \n * @param origin 源对象  \n * @param dest   需要复制的对象属性  \n */  \npublic static void populate(Object origin, Object dest) {  \n    try {  \n        /* 通过反射机制复制对象的属性 */        if (origin.getClass()!=dest.getClass()){  \n            throw  new RuntimeException(\"必须是一样的类型才可以进行对象属性复制！！！\");  \n        }  \n  \n        Class\u003c?\u003e clazz=origin.getClass();//获取需要修改值的类文件  \n        Field[] fields=clazz.getDeclaredFields();//获取属性字段  \n        for (Field f:fields  \n        ) {  \n            //不对序列号id进行复制  \n            if (\"serialVersionUID\".equals(f.getName())){  \n                continue;  \n            }  \n            //打破封装  \n            f.setAccessible(true);  \n            //将dest的值复制给f  \n            f.set(origin,f.get(dest));  \n        }  \n    }catch (IllegalAccessException e) {  \n        throw new RuntimeException(e);  \n    }  \n}\n```\n4. 在UserService中编写同样的接口方法，然后进行实现，调用UserDao中的方法\n5. 修改主方法中的代码，将更新持久化到硬盘中`UserHandleViewCtrl.java`\n```java\nelse {  \n    //修改操作  \n    populate(this.user);  \n  \n    //持久化到本地（更新部分）  \n    userService.update(user);  \n    //刷新  \n    userTableView.refresh();  \n}\n```\n## picOutput\n![](../../asset/Pasted%20image%2020220830161337.png)\n\n---\n# 6.用户删除\n## 步骤\n\n1. UserDao中写删除方法，进行实现\n```java\n/**  \n * 删除  \n *  \n * @param user 用户  \n */  \n@Override  \npublic void delete(User user) {  \n    ObjectInputStream ois = null;  \n    ObjectOutputStream oos = null;  \n    List\u003cUser\u003e list = null;  \n    try {  \n        //    读取硬盘中的用户list  \n        ois = new ObjectInputStream(new FileInputStream(PathConstant.User_Path));  \n        list = (List\u003cUser\u003e) ois.readObject();  \n        if (list != null) {  \n            //    找到要删除的用户  \n            User originUser = list.stream().filter(u -\u003e u.getId() == user.getId()).findFirst().get();  \n            list.remove(originUser);  \n            //    持久化到文件中  \n            oos = new ObjectOutputStream(new FileOutputStream(PathConstant.User_Path));  \n            oos.writeObject(list);  \n            oos.flush();  \n        }  \n  \n    } catch (Exception e) {  \n        throw new RuntimeException(\"删除用户异常！！！\");  \n    } finally {  \n        try {  \n            if (oos != null) {  \n                oos.close();  \n            }  \n            if (ois!=null){  \n                ois.close();  \n            }  \n        } catch (IOException e) {  \n            throw new RuntimeException(e);  \n        }  \n  \n    }  \n}\n```\n2. 在UserServer中书写同样的接口方法，进行实现调用UserDao中的相同方法\n3. 在主方法中，进行修改,代码片段\n```java\n      return;  \n    }  \n    userService.delete(user);  \n    this.users.remove(user);  \n    Alerts.success(\"成功\", \"操作成功\");  \n} catch (Exception e) {\n```\n## 图片output\n![](../../asset/Pasted%20image%2020220830170452.png)\n---\n# 7. 用户冻结\n## 步骤\n1. 同上，dao层实现冻结代码功能\n```java\n/**  \n * 冻结  \n *  \n * @param user 用户  \n */  \n@Override  \npublic void frozen(User user) {  \n    //    变量  \n    ObjectInputStream ois = null;  \n    ObjectOutputStream oos = null;  \n    List\u003cUser\u003e list = null;  \n    try {  \n        //     获取硬盘中的User对象list  \n        ois = new ObjectInputStream(new FileInputStream(PathConstant.User_Path));  \n        list = (List\u003cUser\u003e) ois.readObject();  \n        if (list != null) {  \n            //    获取要冻结的用户对象  \n            User originUser = list.stream().filter(u -\u003e u.getId() == user.getId()).findFirst().get();  \n            //    修改属性进行冻结  \n            originUser.setStatus(Constant.USER_FROZEN);  \n            //    持久化到文件中  \n            oos = new ObjectOutputStream(new FileOutputStream(PathConstant.User_Path));  \n            oos.writeObject(list);  \n            oos.flush();  \n        }  \n    } catch (Exception e) {  \n        throw new RuntimeException(\"冻结用户异常\");  \n    }  \n}\n```\n2. service层实现，调用dao的代码\n3. 主方法中对service的方法进行调用\n```java\n//持久化到本地  \nuserService.frozen(user);  \nuser.setStatus(Constant.USER_FROZEN);  \nuserTableView.refresh();\n```\n ## 图片output\n  ![](../../asset/Pasted%20image%2020220830190926.png)\n---\n\n# 8. 初始化图书数据\n## 步骤\n1. 添加常量path，用于设置保存的位置\n2. 将book继承Serializable，添加序列号\n3. 在初始化方法`initDataUtil`中添加book list的代码\n```java\n /* 初始化图书数据 */    List\u003cBook\u003e bookList = new ArrayList\u003c\u003e();  \n    //    添加图书数据  \n   bookList.add(new Book(1, \"java实战入门\", \"张三\", Constant.TYPE_COMPUTER, \"12-987\", \"XX出版社\", Constant.STATUS_STORAGE));  \n   bookList.add(new Book(2, \"编程之道\", \"李四\", Constant.TYPE_COMPUTER, \"1245-987\", \"XX出版社\", Constant.STATUS_STORAGE));  \n   bookList.add(new Book(3, \"颈椎病康复指南\", \"王五\", Constant.TYPE_COMPUTER, \"08712-987\", \"XX出版社\", Constant.STATUS_STORAGE));  \n//   使用方法持久到本地  \n    initData(PathConstant.Book_Path,bookList);\n```\n## 图片output\n\n![](../../asset/Pasted%20image%2020220830192341.png)\n---\n# 9.图书查询操作\n\u003e #发现 我发现很多东西其实没有必要挨着写，相同的代码，其实只是代码的变量名不一样，把userdao的相同方法拿过来用记事本替换一下变量，对具体细节进行修改一下就好了\n## 步骤\n1. 依旧是实现dao层\n```java\n/**  \n * 查询  \n *  \n * @param book 书  \n * @return {@link List}\u003c{@link Book}\u003e  \n */@Override  \npublic List\u003cBook\u003e select(Book book) {  \n    ObjectInputStream ois = null;  \n    List\u003cBook\u003e list = new ArrayList\u003c\u003e();  \n    try {  \n        //    读取书籍信息  \n        ois = new ObjectInputStream(new FileInputStream(PathConstant.Book_Path));  \n        list = (List\u003cBook\u003e) ois.readObject();  \n        if (book == null || \"\".equals(book.getBookName()) \u0026\u0026 \"\".equals(book.getIsbn())) {  \n            return list;  \n        } else {  \n            /* 当list不为空的时候 */            //    需要返回的数据  \n            List\u003cBook\u003e conditionList = new ArrayList\u003c\u003e();  \n            /* //根据编号查询  \n            if (!(0==book.getId())){                conditionList=list.stream().filter(b-\u003eb.getId()==book.getId()).collect(Collectors.toList());                return conditionList;            } */            // 当查询书籍名称不为空的时候  \n            if (!\"\".equals(book.getBookName())) {  \n                // conditionList = list.stream().filter(b -\u003e b.getBookName().equals(book.getBookName())).collect(Collectors.toList());  \n                //模糊查询  \n                conditionList = list.stream().filter(b -\u003e b.getBookName().contains(book.getBookName())).collect(Collectors.toList());  \n            }  \n            // 当书籍isbn不为空的时候  \n            if (!\"\".equals(book.getIsbn())) {  \n                conditionList = list.stream().filter(b -\u003e b.getIsbn().equals(book.getIsbn())).collect(Collectors.toList());  \n            }  \n            // 当书籍名称以及isbn都不为空的时候,这个是根据上一个进行进步筛选的  \n            if (!\"\".equals(book.getBookName()) \u0026\u0026 !\"\".equals(book.getIsbn())) {  \n                conditionList = conditionList.stream().filter(b -\u003e b.getBookName().equals(book.getBookName())).collect(Collectors.toList());  \n  \n            }  \n            return conditionList;  \n        }  \n    } catch (Exception e) {  \n        e.printStackTrace();  \n    } finally {  \n        try {  \n            if (ois != null) {  \n                ois.close();  \n            }  \n  \n        } catch (IOException e) {  \n            e.printStackTrace();  \n        }  \n    }  \n    // 出现了异常，就返回一个空的  \n    return list;  \n}\n```\n2. 实现service层，调用dao层的方法\n3. 修改主方法（`BookViewCtrl`）中的代码，改为从本地硬盘中加载对象文件\n```java\npublic void initialize(URL location, ResourceBundle resources) {   \n    /* books.add(new Book(1, \"java实战入门\", \"张三\", Constant.TYPE_COMPUTER, \"12-987\", \"XX出版社\", Constant.STATUS_STORAGE));  \n    books.add(new Book(2, \"编程之道\", \"李四\", Constant.TYPE_COMPUTER, \"1245-987\", \"XX出版社\", Constant.STATUS_STORAGE));  \n    books.add(new Book(3, \"颈椎病康复指南\", \"王五\", Constant.TYPE_COMPUTER, \"08712-987\", \"XX出版社\", Constant.STATUS_STORAGE)); */  \n    /* 改为本地加载书籍信息 */    List\u003cBook\u003e bookList=bookService.select(null);  \n    books.addAll(bookList);\n```\n## 图片output\n![](../../asset/Pasted%20image%2020220831091310.png)\n# 10.图书添加操作\n## 步骤\n1. dao层实现\n```java\n/**  \n * 添加  \n *  \n * @param Book 书  \n */  \n@Override  \npublic void add(Book Book) {  \n    ObjectInputStream ois = null;  \n    ObjectOutputStream oos = null;  \n    List\u003cBook\u003e list = null;  \n    try {  \n        //    读取硬盘中的书籍信息  \n        ois = new ObjectInputStream(new FileInputStream(PathConstant.Book_Path));  \n  \n        list = (List\u003cBook\u003e) ois.readObject();// 读取书籍信息  \n        // 判断list是否有  \n        if (list != null) {  \n            // 设置新添加的书籍id  \n            Book lastBook = list.get(list.size() - 1);  \n            Book.setId(lastBook.getId() + 1);  \n            //    添加到list中  \n            list.add(Book);  \n        } else {  \n            //    当list为空的时候，就需要一个空的去装  \n            list = new ArrayList\u003c\u003e();  \n            Book.setId(0001);  \n            list.add(Book);  \n  \n        }  \n        //    持久化到本地硬盘  \n        oos = new ObjectOutputStream(new FileOutputStream(PathConstant.Book_Path));  \n  \n        oos.writeObject(list);  \n        oos.flush();  \n  \n    } catch (Exception e) {  \n        throw new RuntimeException(\"添加书籍失败\");  \n    } finally {  \n        // 释放资源  \n        try {  \n            if (ois != null) {  \n                ois.close();  \n            }  \n            if (oos != null) {  \n                oos.close();  \n            }  \n        } catch (IOException e) {  \n            e.printStackTrace();  \n        }  \n    }  \n}\n```\n2. service实现：调用dao层\n3. 主方法中进行修改，持久化到本地硬盘中\n```java\nprivate void addOrEditBook() {  \n    try {  \n        String id = bookIdField.getText();  \n        if (\"\".equals(id) || null == id) {  \n            //添加操作  \n            Book book = new Book();  \n            populate(book);  \n  \n            book.setStatus(Constant.STATUS_STORAGE);  \n            //修改本地的  \n            bookService.add(book);  \n            books.add(book);\n```\n## 图片output\n![](../../asset/Pasted%20image%2020220831092944.png)\n---\n\n# 11.图书删除操作\n## 步骤\n1. dao层\n2. service\n3. 主方法中进行修改\n## 图片output\n![添加的书籍不见了](../../asset/Pasted%20image%2020220831101013.png)\n---\n\n# 12.图书修改操作 \n## 步骤\n同上\n## 图片output\n![修改前](../../asset/Pasted%20image%2020220831112109.png)\n![修改后](../../asset/Pasted%20image%2020220831112136.png)\n# 13.分类饼状图数据修改\n## 步骤\n1. 新建一个dao接口，写入统计方法，进行实现\n```java\n/**  \n * 图书类型数量统计  \n *  \n * @return {@link Map}\u003c{@link String}, {@link Integer}\u003e  \n */@Override  \npublic Map\u003cString, Integer\u003e bookTypeCount() {  \n    try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(PathConstant.Book_Path))) {  \n        //    获取所有的图书信息  \n        List\u003cBook\u003e list = (List\u003cBook\u003e) ois.readObject();  \n    //    对图书根据书籍类型进行分组  \n        Map\u003cString,List\u003cBook\u003e\u003e collect=list.stream().collect(Collectors.groupingBy(Book::getType));  \n    //    遍历分别进行统计  \n        HashMap\u003cString ,Integer\u003e map=new HashMap\u003c\u003e();  \n        Iterator\u003cMap.Entry\u003cString,List\u003cBook\u003e\u003e\u003e iterator=collect.entrySet().iterator();//迭代器  \n        while (iterator.hasNext()){  \n        //    将统计结果放入到map中  \n            Map.Entry\u003cString,List\u003cBook\u003e\u003e next=iterator.next();//具体的书籍分类信息  \n            map.put(next.getKey(),next.getValue()==null?0:next.getValue().size());//写入统计书籍类型的数量  \n        }  \n        //返回结果  \n        return map;  \n    } catch (Exception e) {  \n        e.printStackTrace();  \n        throw new RuntimeException(\"统计图书异常~\");  \n    }  \n}\n```\n2. service层进行调用\n3. 主方法中进行修改关键代码\n```java\n@Override  \npublic void initialize(URL location, ResourceBundle resources) {  \n    // 获取书籍分类信息  \n    Map\u003cString, Integer\u003e map = chartDao.bookTypeCount();  \n    Data[] dataArray = new Data[map.size()];  \n    // 通过迭代传入到Data数组中  \n    Iterator\u003cMap.Entry\u003cString, Integer\u003e\u003e iterator=map.entrySet().iterator();  \n    int i=0;  \n    while (iterator.hasNext()){  \n        Map.Entry\u003cString, Integer\u003e next=iterator.next();  \n        dataArray[i++]=new Data(next.getKey(),next.getValue());//进行赋值  \n    }  \n    //将数组传入  \n    ObservableList\u003cjavafx.scene.chart.PieChart.Data\u003e pieChartData = FXCollections.observableArrayList(dataArray);  \n   /*  ObservableList\u003cjavafx.scene.chart.PieChart.Data\u003e pieChartData = FXCollections.observableArrayList(  \n            new Data(\"计算机\", 20),  \n            new Data(\"文学\", 12),  \n            new Data(\"经济\", 25),  \n            new Data(\"管理\", 22)  \n    ); */    pieChart.setData(pieChartData);  \n    pieChart.setClockwise(false);  \n}\n```\n## 图片output\n![](../../asset/Pasted%20image%2020220831120238.png)\n---\n# 14.借阅数据初始化\n## 步骤\n```java\n /* 初始化借阅数据 */    List\u003cLend\u003e lendList=new ArrayList\u003c\u003e();  \n//    添加借阅数据  \n    Book book = new Book(1, \"java实战入门\", \"张三\", Constant.TYPE_COMPUTER, \"12-987\", \"XX出版社\", Constant.STATUS_STORAGE);  \n    User user = new User(1, \"张三\", \"正常\", new BigDecimal((\"100\")));  \n    user.setLend(true);  \n    LocalDate now = LocalDate.now();  \n    //通过UUID生成的编号  \n    Lend lend=new Lend(UUID.randomUUID().toString(),book,user, Constant.LEND_LEND, now,now.plusDays(30));  \n    lend.setStatus(Constant.STATUS_LEND);//设置借阅状态  \n    lendList.add(lend);  \n  \n//    持久化到本地  \n    initData(PathConstant.Lend_Path,lendList);\n---\n\n# 15.借阅数据查询\n## 步骤\n\t1. dao层\n```java\n/**  \n * 查询  \n *  \n * @param lend 书  \n * @return {@link List}\u003c{@link Lend}\u003e  \n */@Override  \npublic List\u003cLend\u003e select(Lend lend) {  \n    ObjectInputStream ois = null;  \n    List\u003cLend\u003e list = new ArrayList\u003c\u003e();  \n    try {  \n        //    读取借阅信息  \n        ois = new ObjectInputStream(new FileInputStream(PathConstant.Lend_Path));  \n        list = (List\u003cLend\u003e) ois.readObject();  \n        //当lend为空的时候，就返回所有的借阅信息  \n        if (lend==null||\"\".equals(lend.getBook().getBookName()) \u0026\u0026 \"\".equals(lend.getBook().getIsbn())){  \n            return list;  \n        }else{  \n            //处理结果  \n            List\u003cLend\u003e conditionList=new ArrayList\u003c\u003e();  \n            //通过书籍名称获取借阅信息  \n            if(!\"\".equals(lend.getBook().getBookName())){  \n                conditionList=list.stream().filter(l-\u003el.getBook().getBookName().equals(lend.getBook().getBookName())).collect(Collectors.toList());  \n            }  \n            // 通过书籍ISBN号获取借阅信息  \n            if(!\"\".equals(lend.getBook().getIsbn())){  \n                conditionList=list.stream().filter(l-\u003el.getBook().getIsbn().equals(lend.getBook().getIsbn())).collect(Collectors.toList());  \n            }  \n            //联合查询  \n            if (!\"\".equals(lend.getBook().getIsbn())\u0026\u0026!\"\".equals(lend.getBook().getBookName())){  \n                conditionList=conditionList.stream().filter(l-\u003el.getBook().getBookName().equals(lend.getBook().getBookName())).collect(Collectors.toList());  \n            }  \n            //返回借阅结果集  \n            return  conditionList;  \n        }  \n  \n  \n    } catch (Exception e) {  \n        e.printStackTrace();  \n    } finally {  \n        try {  \n            if (ois != null) {  \n                ois.close();  \n            }  \n  \n        } catch (IOException e) {  \n            e.printStackTrace();  \n        }  \n    }  \n    // 出现了异常，就返回一个空的  \n    return list;  \n}\n```\n2.  service\n3. 主方法中修改关键代码\n```java\npublic void initialize(URL location, ResourceBundle resources) {  \n    //从硬盘中获取借阅信息List  \n    List\u003cLend\u003e list=lendDao.select(null);  \n    lends.addAll(list);\n```\n## 图片output\n![加载成功](../../asset/Pasted%20image%2020220831135819.png)\n# 16.借阅功能的实现\n## 步骤\n1. 给user添加一个boolean的字段，标识是否借过书\n2. dao层，可以借书的用户\n```java\n/**  \n * 可以借书给用户  \n *  \n * @return {@link List}\u003c{@link User}\u003e  \n */@Override  \npublic List\u003cUser\u003e canLendUser() {  \n    try (ObjectInputStream ois=new ObjectInputStream(new FileInputStream(PathConstant.User_Path))){  \n        //获取硬盘中的user数据  \n        List\u003cUser\u003e list=(List\u003cUser\u003e) ois.readObject();  \n        if (list!=null){  \n            //返回可以借书的用户  状态正常，没借过书  \n            return list.stream().filter(u-\u003efalse==u.isLend() \u0026\u0026Constant.USER_OK.equals(u.getStatus()) ).collect(Collectors.toList());  \n        }  \n    }catch(Exception e){  \n        e.printStackTrace();  \n    }  \n    return new ArrayList\u003c\u003e();  \n}\n```\n3. 主方法代码修改\n# 17.还书功能的实现\n# 18.逾期扣款，自动冻结\n# 19.用户充值\n# 20 #总结 要点\n1. 文件的读取\n2. list与map等集合对象的运用\n3. 对象的存储 与读取\n4. 序列号的使用\n5. list中查询的使用\n6. 层次结结构之间的不同\n\n# 收获\n\u003e fxml的那个界面逻辑怎么创建搞不来，那一个部分的代码搞不来，就是本地的数据都会操作，但是界面的东西弄不来，那个没学过，但是讲师又说不用学，就不搞刷新界面的那个部分了，![](../../asset/100A1653.png)\n\n","lastmodified":"2022-09-20T05:41:06.47432571Z","tags":null},"/0001-%E6%A6%82%E8%BF%B0":{"title":"","content":"# 概述\n\n## 忘记root密码怎么解决？\n\n关闭正在运行的ySQL服务。\n打开Dos窗口，转到nysql\\bin目录。\n输入mysqld-skip-grant-tables回车。--skip-grant-tables的意思是启动ysQL服务的时候跳过权限表认证。\n再开一个Dos窗口(因为刚才那个Dos窗口己经不能动了)，转到mysg1\\bin目录。\n输入mysg1回车，如果成功，将出现MySQL提示符\n\u003e。\n连接权限数据库：use mysq1;.\n改密码：update user set password-=password(\"123\")where user:=\"root\";（别忘了最后加分号）。\n刷新权限（必须步骤）：f1 ush privileges;\n退出guit.\n注销系统，再进入，使用用户名x00t和刚才设置的新密码123登录。\n\n## 常用的数据库系统\n\n\n\u003e[!faq]+ sql、DB、DBMS的区别\n\u003e1. DB：数据库，实际以文件的形式存放在硬盘上\n\u003e2. DBMS：数据库管理系统，常见的数据库系统Oracie、SQL Server、MySql、Sybase、informix、DB2、interbase\n\u003e3. sql:\n\u003e\t1. **结构化查询语言**，标准通用的语言，适用于所有的数据库产品\n\u003e\t2. 属于高级语言,内部也需要编译和执行\n\u003e4. DBMS通过执行sql语句，来操作数据DB中的数据\n\n","lastmodified":"2022-09-20T05:41:06.44232519Z","tags":null},"/0001-JDBC%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5":{"title":"","content":"1. Java DataBase Connectivity（Java语言连接数据库）\n\n3. JDBC的本质是什么？\n\t1. **JDBC是SUN公司制定的一套接口**（interface）`java.sql.\\*`; (这个软件包下有很多接口。)\n\t2. 面向接口编程可以**降低程序耦合度，提高程序扩展力**，**多态机制**就是典型的抽象编程。（`Animal a=new CAt();`）\n4. sun制定JDBC接口的原因：\n\t- 每一个数据库的底层实现原理不一样，每一个产品有自己独特的实现原理，所以就需要数据库产品自己去写jdbc中接口的实现方式，供用户调用。\n\n\n","lastmodified":"2022-09-20T05:41:06.438325125Z","tags":null},"/0001.%E4%B8%93%E6%B3%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E8%80%83%E9%87%8F%E5%9B%A0%E7%B4%A0":{"title":"0001.专注系统设计考量因素","content":"\n如何去选择一个合适的记录方式，是我所需要考虑的。\n目前需要设计一个专注系统，目前能够考虑到的如下：\n1. [ ] 专注的侧重点\n2. [ ] 如何完成一个专注\n3. [ ] 专注效果的判断，怎么定义值，怎么定义专注结果\n4. [ ] 专注过程是如何去进行的\n\t1. [ ] 效果\n\t2. [ ] 方式\n\t3. [ ] 对象\n5. [ ] 只有专注明显是不行的，所以还需要配合[[记忆系统]]","lastmodified":"2022-09-20T05:41:07.266338579Z","tags":null},"/00012-%E4%BA%8B%E5%8A%A1":{"title":"","content":"什么是事务？\n\u003e\n\u003e\t\t一个事务是一个完整的业务逻辑单元，不可再分。\n\u003e\t\t要想保证以上的两条DML语句同时成功或者同时失败，那么就需要使用数据库的“事务机制”。\n\n和事务相关的语句只有：**DML语句。**（insert delete update）\n\u003e\t\t为什么？因为它们这三个语句都是和数据库表当中的“数据”相关的。\n\u003e\t\t事务的存在是为了保证数据的**完整性**，**安全性**。\n\n\n\n\u003e[!faq]+ 事务的特性？\n\u003e\t事务包括四大特性：ACID\n\u003e\tA: 原子性：事务是最小的工作单元，不可再分。\n\u003e\tC: 一致性：事务必须保证多条DML语句同时成功或者同时失败。\n\u003e\tI：隔离性：事务A与事务B之间具有隔离。\n\u003e\tD：持久性：持久性说的是最终数据必须持久化到硬盘文件中，事务才算成功的结束。\n\n\n\u003e[!faq]+ 关于事务之间的隔离性\n\u003e事务隔离性存在隔离级别，理论上隔离级别包括4个：\n\u003e1. 第一级别：读未提交（read uncommitted）\n\u003e\t对方事务还没有提交，我们当前事务可以读取到对方未提交的数据。\n\u003e\t读未提交存在脏读（Dirty Read）现象：表示读到了脏的数据。\n\u003e2. 第二级别：读已提交（read committed）\n\u003e\t对方事务提交之后的数据我方可以读取到。\n\u003e\t这种隔离级别解决了: 脏读现象没有了。\n\u003e\t读已提交存在的问题是：不可重复读。\n\u003e3. 第三级别：可重复读（repeatable read）\n\u003e\t这种隔离级别解决了：不可重复读问题。\n\u003e\t这种隔离级别存在的问题是：读取到的数据是幻象。\n\u003e4. 第四级别：序列化读/串行化读（serializable） \n\u003e\t解决了所有问题。\n\u003e\t效率低。需要事务排队。\n\n\n**oracle数据库默认的隔离级别是：读已提交。\nmysql数据库默认的隔离级别是：可重复读。**\n\n\n\n### 自动提交eg\n```bash\nmysql\u003e create table t_user(id int primary key auto_increment,username varchar(255));\nQuery OK, 0 rows affected (0.01 sec)\n\nmysql\u003e insert into t_user(username) values('zs');\nQuery OK, 1 row affected (0.01 sec)\n\nmysql\u003e select * from t_user;\n+----+----------+\n| id | username |\n+----+----------+\n|  1 | zs       |\n+----+----------+\n1 row in set (0.00 sec)\n\nmysql\u003e rollback;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql\u003e select * from t_user;\n+----+----------+\n| id | username |\n+----+----------+\n|  1 | zs       |\n+----+----------+\n1 row in set (0.00 sec)\n```\n\n### 关闭自动提交机制 start transaction;\n```sql\nmysql\u003e start transaction;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql\u003e insert into t_user(username) values('lisi');\nQuery OK, 1 row affected (0.00 sec)\n\nmysql\u003e select * from t_user;\n+----+----------+\n| id | username |\n+----+----------+\n|  1 | zs       |\n|  2 | lisi     |\n+----+----------+\n2 rows in set (0.00 sec)\n\nmysql\u003e insert into t_user(username) values('wangwu');\nQuery OK, 1 row affected (0.00 sec)\n\nmysql\u003e select * from t_user;\n+----+----------+\n| id | username |\n+----+----------+\n|  1 | zs       |\n|  2 | lisi     |\n|  3 | wangwu   |\n+----+----------+\n3 rows in set (0.00 sec)\n\nmysql\u003e rollback;\nQuery OK, 0 rows affected (0.01 sec)\n\nmysql\u003e select * from t_user;\n+----+----------+\n| id | username |\n+----+----------+\n|  1 | zs       |\n+----+----------+\n1 row in set (0.00 sec)\n```\n\n### 设置事务机制\n读未提交\n```sql\nset global transaction isolation level read uncommitted;\n```\n读已提交\n```sql\nset global transaction isolation level read committed;\n```\n可重复读\n```sql\nset global transaction isolation level repeatable read;\n```\n序列化读/串行化读\n```sql\nset global transaction isolation level serializable;\n```","lastmodified":"2022-09-20T05:41:06.44232519Z","tags":null},"/00014-%E6%82%B2%E8%A7%82%E9%94%81%E8%A1%8C%E7%BA%A7%E9%94%81%E4%BB%A5%E5%8F%8A%E4%B9%90%E8%A7%82%E9%94%81%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86":{"title":"","content":"悲观锁：\nselect语句后面加上`for update`\n比如\n```sql\nselect cname from dept where no=12 for update`\n那么查询出来的数据，就会被加锁，直到释放之前，都不能都被别的线程使用修改\n简单的理解就是：线程同步锁，嘎嘎好理解\n```\n查询出出来的语句会被锁上，别的线程无法修改其中的数据\n**事务需要排队执行，类似于同步线程，要修改的数据需要事务一个一个的排队**\n\n\n乐观锁\n\t**支持并发**，需要修改的数据，每次读取都有一个版本号\n\t事务不需要排队，每次读取都有一个版本号（比如1.1），提交的时候核对版本号是否和读取的一样（1.1）\n\t一样就提交，并修改成新的版本号（1.2）\n\t不一样就回滚，不提交，重新读取\n\t","lastmodified":"2022-09-20T05:41:06.438325125Z","tags":null},"/0002-JDBC%E5%BC%80%E5%8F%91%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8":{"title":"","content":"## 开发前的准备\n1. 在对应的数据库官网下载jar包（这个jar中包括了的jdbc接口的具体实现方式）\n\t1. **如果是cmd窗口运行的话**，就需要将其配置到[环境变量](../爪哇基础/00理论/003.环境变量.md)`classpath`中，一般需要设置两个东西，一个是`.`，表示当前路径，一个是jar包的具体位置，比如`C:\\Users\\22305\\Documents\\MySql Connector Java 5.1.23\\mysql-connector-java-5.1.23-bin.jar` ()\n\t2. 如果是idea的话，就需要导包，具体方法为两种\n\t\t1. `File`--\u003e`Project Structure`---`Moudles`--\u003e选择你对应的模块，然后在右侧的编辑窗口中点击`+`号，选择对应的jar包--\u003e导入之后，勾选上----\u003e点击应用即可![](https://pcsdata.baidu.com/thumbnail/b4e0b1999q262f6bab2e926db0bfe0ae?fid=893181348-16051585-340834226556884\u0026rt=pr\u0026sign=FDTAER-yUdy3dSFZ0SVxtzShv1zcMqd-ccKxNIrkq3MxTOPkipfgSyrjA8o%3D\u0026expires=48h\u0026chkv=0\u0026chkbd=0\u0026chkpc=\u0026dp-logid=8851640456417683329\u0026dp-callid=0\u0026time=1661054400\u0026bus_no=26\u0026size=c1600_u1600\u0026quality=100\u0026vuk=-\u0026ft=video)\n","lastmodified":"2022-09-20T05:41:06.438325125Z","tags":null},"/0002-SQL%E8%AF%AD%E5%8F%A5%E7%9A%84%E5%88%86%E7%B1%BB":{"title":"","content":"\n## SQL语句的分类\n1. DQL（数据查询语言）：查询语句，凡是selecti语句都是DQL.\n2. [DML（数据操作语言)](0009%20DML（数据操作语言）.md)：insert delete update,对表当中的数据进行增删改。\n3. DDL（数据定义语言）：create drop alter,对表结构的增删改。\n4. TCL（事务控制语言）：commit提交事务，rollback回滚事务。\n5. DCL（数据控制语言）：grant授权、revoke撤销权限等。  ","lastmodified":"2022-09-20T05:41:06.44232519Z","tags":null},"/0003-JDBC%E5%BC%80%E5%8F%916%E6%AD%A5":{"title":"","content":"1. 注册驱动，两种方式\n2. 获取连接 \n3. 建立SQL数据库操作对象 \n4. 执行SQL语句 \n5. 处理结果集\n6. 释放资源（java与数据库之间属于进程之间的通信）（一般在finally语句中，编辑的时候建议需要关闭的对象放在try外面设置为null，之后，释放资源代码写了之后再开始选择编辑）","lastmodified":"2022-09-20T05:41:06.438325125Z","tags":null},"/0003-mysql%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8":{"title":"","content":"\n\n| 作用                                                                   | 命令                                | 相关                                                                                       |     |\n| ---------------------------------------------------------------------- | ----------------------------------- | ------------------------------------------------------------------------------------------ | --- |\n| [登录mysql数据库管理系统](asset/Pasted%20image%2020220816170651.png)  | `mysql -u root -p password`         |                                                                                            |     |\n| [查看有哪些数据库](asset/Pasted%20image%2020220816165702.png)         | `show databases;`                   |                                                                                            |     |\n| [创建数据库](asset/Pasted%20image%2020220816170413.png)               | `bash create database 数据库名称;`  |                                                                                            |     |\n| [选择要使用的数据库](asset/Pasted%20image%2020220816171311.png)       | `use 数据库名称`                    |                                                                                            |     |\n| [查看当前数据库中的表](asset/Pasted%20image%2020220816171435.png)     | `show tables;`                      |                                                                                            |     |\n| [初始化数据](asset/Pasted%20image%2020220816172212.png)               | ` source sql文件路径`               | [初始化之后的三张表](asset/Pasted%20image%2020220816172321.png)（sql类型的文件叫sql脚本） |     |\n| [删除数据库](asset/Pasted%20image%2020220816173230.png)               | `drop database  数据库名称;`        |                                                                                            |     |\n| [查看某个表结构](asset/Pasted%20image%2020220816173521.png)           | `desc 表名;`                        |                                                                                            |     |\n| [查看某个数据表的所有记录](asset/Pasted%20image%2020220816194313.png) | `select * from 表名*`               |                                                                                            |     |\n| [查看当前使用的数据库](asset/Pasted%20image%2020220816194637.png)     | `select database(); `               |                                                                                            |     |\n| [查看当前的mysql版本](asset/Pasted%20image%2020220816194754.png)      | `select version();`                 |                                                                                            |     |\n| 结束一条语句                                                           | `\\c`                                |                                                                                            |     |\n| 退出mysql                                                              | `exit`  `quit`    `\\q`              |                                                                                            |     |\n| 终止一条正在编写的语句                                                 | `键入\\c`                            |                                                                                            |     |\n| [查看其他库中的表](asset/Pasted%20image%2020220816195545.png)         | `show tables from \u003cdatabase name\u003e;` |                                                                                            |     |\n| [查看表的创建语句](asset/Pasted%20image%2020220816195815.png)         | `show create table \u003ctable name\u003e;`   |                                                                                            |     |\n\n\n","lastmodified":"2022-09-20T05:41:06.44232519Z","tags":null},"/0004-%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E7%9B%B8%E5%85%B3":{"title":"","content":"# like\n`like`：模糊查询，支持%和下划线匹配\n\t% 代表多个任意字符（包括0个）\n\t_ 代表一个任意字符 \n\tlike 后面的字符串必须放在单引号 '' 中\n\t![](asset/Pasted%20image%2020220816213350.png) \n\t\n---\n# order by\n升降序：\norder by\nasc表示升序，desc表示降序\n[多个排序条件，在多个条件中间逗号隔开即可](asset/Pasted%20image%2020220817092232.png)\n当有where时，必须放在where后面\n\n\n[ifnull()单行处理函数](asset/Pasted%20image%2020220817110624.png)\n\n---\n## 分组函数\n| count | 取得记录数 |\n| ----- | ---------- |\n| sum   | 求和       |\n| avg   | 取平均     |\n| max   | 取最大的数 |\n| min   | 取最小的数 |\n\n\n**注意：分组函数自动忽略空值，不需要手动的加where** **条件排除空值。**\n\t分组函数**不能直接使用在where关键字后面。**\n---\n## 分组查询\n分组查询主要涉及到两个子句，分别是：group by和having\n[示例](asset/Pasted%20image%2020220817160233.png)\n\n如果使用了order by，**order by必须放到group by后面**\n在SQL语句中若有group by 语句，那么在select语句后面只能跟**分组函数** **+参与分组的字段**\n\n\n## 执行顺序\n1.\t首先执行where语句过滤原始数据\n2.\t执行group by进行分组\n3. 执行having对分组数据进行操作\n4.\t执行select选出数据\n5.\t执行order by排序\n\n#书写原则\n能在where中过滤的数据，尽量在where中过滤，效率较高。having的过滤是专门对分组之后的数据进行过滤的。","lastmodified":"2022-09-20T05:41:06.44232519Z","tags":null},"/0004-Statement%E5%92%8CPreparedStatement%E7%9A%84%E5%8C%BA%E5%88%AB":{"title":"","content":"1. `Statement`存在SQL注入问题，而`PreparedStatement`解决了SQL注入问题\n2. `Statement`存在安全编译时的类型检查问题，而`PreparedStetement`因为是采用setxxx的方式，可以在编译的时候做安全检查\n3. **`Statement`每次执行都需要编译一次**，**`PreparedStatement`编译一次，执行多次。**\n\t-  `PreparedStatement`因为是先发送给DBMS一个sql语句架子，DMBS进行了编译，然后再通过setxxx进行传值，最后再执行。以后每一次执行，`PreparedStatement`就不会再编译了，传值就可以直接传值执行，所以`PreParedStatement`执行效率更高。 \n\n\n综合：`PreparedStatement`使用较多\n\n\n使用`PreparedStatement`之后传值，值中的特殊符号都会转义，所以避免了sql注入\n```sql\ncom.mysql.jdbc.JDBC4PreparedStatement@5ce81285: select * from t_user where loginName = 'z' and loginPassword = 'z\\' or \\'1\\'=\\'1'\n```\n\n什么时候采用`Statement`，需要用户注入sql语句的时候就需要用到，或者不包括安全问题的时候也可以用，参数不用单引号引起来的也需要用到","lastmodified":"2022-09-20T05:41:06.438325125Z","tags":null},"/0005-%E8%BF%9E%E6%8E%A5":{"title":"","content":"# 根据连接方式来分类\n1. 内连接：`inner join xxx on   条件`\n   1. 等值连接\n   2. [非等值连接](asset/Pasted%20image%2020220817164507.png)\n   3. [自连接](asset/Pasted%20image%2020220817165250.png)：通过自己来建立连接\n2. 外连接： ` left/right outer join xxx on 条件`  ：主表的所有不满足条件的也会显示出来\n   1. 左外连接（左连接）[示例](asset/Pasted%20image%2020220817182942.png) ： ` left outer join xxx on 条件`  outer可以省略\n   3. 右外连接（右连接）  [示例](asset/Pasted%20image%2020220817183309.png)\n\t示例：[多张表连接查询](asset/Pasted%20image%2020220817193513.png)\n   1. 全连接（这个不讲，很少用！）\n","lastmodified":"2022-09-20T05:41:06.44232519Z","tags":null},"/0005-JDBC%E6%A1%88%E4%BE%8B%E7%BB%99SQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE":{"title":"","content":"```java\nimport java.sql.*;  \n  \n  \npublic class JDBCTest01 {  \n    public static void main(String[] args) {  \n        Connection conn=null;//用来建立连接的mysql对象  \n        Statement stmt=null;//用来执行sql语句的对象  \n        try {  \n            // 1.注册驱动  \n            Driver driver = new com.mysql.jdbc.Driver();  \n            DriverManager.registerDriver(driver);  \n            // 2.获取连接  \n            String url = \"jdbc:mysql://127.0.0.1:3306/bjpowernode\";  \n            String user = \"root\";  \n            String password = \"root\";  \n            conn = DriverManager.getConnection(url, user, password);  \n            System.out.println(\"Database connection object------\u003e\" + conn);  \n            //3.获取数据库操作对象（statement专门执行sql语句）  \n            stmt=conn.createStatement();  \n            //4.执行sql  \n            String sql=\"insert into dept(deptno,dname,loc) values(90,'renshibu','Beijing')\";  \n\t\t\t//返回值是影响数据库的记录条数  \n            int count=stmt.executeUpdate(sql);  \n            System.out.println(count==0?\"failure\":\"succeed\");  \n            //处理结果集，因为没有需要处理的，不需要写\n        } catch (SQLException e) {  \n            throw new RuntimeException(e);  \n  \n        }finally {  \n  \n            //6、释放资源  \n            // 为了保证资源一定释放，在finally语句块中关闭资源  \n            // 并且要遵循从小到大依次关闭  \n            // 分别对其try..catch  \n            try {  \n                if (stmt!=null){  \n                    stmt.close();  \n                }  \n            } catch (SQLException e) {  \n                e.printStackTrace();  \n            }  \n  \n            try {  \n                if (conn!=null){  \n                    conn.close();  \n                }  \n            } catch (SQLException e) {  \n                e.printStackTrace();  \n            }  \n        }  \n  \n  \n    }  \n}\n```\noutput\n```shell\nDatabase connection object------\u003ecom.mysql.jdbc.JDBC4Connection@446cdf90\nsucceed\n\nProcess finished with exit code 0\n```","lastmodified":"2022-09-20T05:41:06.438325125Z","tags":null},"/0006-%E5%B5%8C%E5%A5%97%E5%AD%90%E6%9F%A5%E8%AF%A2":{"title":"","content":"# 嵌套子查询\n## where后面嵌套\n![](asset/Pasted%20image%2020220818092829.png)\n## from后面\n![](asset/Pasted%20image%2020220818094542.png)\n![](asset/Pasted%20image%2020220818094917.png)\n\n## select中使用子查询作为字段\n![](asset/Pasted%20image%2020220818100754.png)","lastmodified":"2022-09-20T05:41:06.44232519Z","tags":null},"/0006-%E9%87%87%E7%94%A8Class.forName%E6%96%B9%E5%BC%8F%E6%B3%A8%E5%86%8C%E9%A9%B1%E5%8A%A8":{"title":"","content":"```java\nimport java.sql.*;  \n  \npublic class JDBCTest03 {  \n    public static void main(String[] args) {  \n        Connection conn=null;  \n        Statement statement=null;  \n        // Driver driver=null;  \n        try {  \n        //    1.注册驱动  \n       /*  //    第一种注册方式  \n            driver=new com.mysql.jdbc.Driver();            DriverManager.registerDriver(driver); */        //    第二种注册方式，不需要返回值，只需要类加载动作,作用是告诉程序我们使用的是哪一个驱动  \n            Class.forName(\"com.mysql.jdbc.Driver\");  \n        //    2.建立连接  \n            String url=\"jdbc:mysql://localhost:3306/bjpowernode\";  \n            String user=\"root\";  \n            String pass=\"root\";  \n            conn=DriverManager.getConnection(url,user,pass);  \n            System.out.println(\"Connection---\u003e\"+conn);  \n        //     发送SQL语句的对象  \n            statement=conn.createStatement();  \n        //    发送sql语句  \n            String sql=\"insert into dept values(133,'人事部','beijing')\";  \n            int count=statement.executeUpdate(sql);  \n            System.out.println(count!=0?\"succeed\":\"failure\");  \n        } catch (SQLException e) {  \n            e.printStackTrace();  \n        } catch (ClassNotFoundException e) {  \n            e.printStackTrace();  \n        } finally {  \n            if (statement!=null){  \n                try {  \n                    statement.close();  \n                } catch (SQLException e) {  \n                    e.printStackTrace();  \n                }  \n            }  \n            if (conn!=null){  \n                try {  \n                    conn.close();  \n                } catch (SQLException e) {  \n                    e.printStackTrace();  \n                }  \n            }  \n        }  \n    }  \n}\n```\n\noutput\n```shell\nDatabase connection object------\u003ecom.mysql.jdbc.JDBC4Connection@446cdf90\nsucceed\n```","lastmodified":"2022-09-20T05:41:06.438325125Z","tags":null},"/0007-%E9%80%9A%E8%BF%87%E8%B5%84%E6%BA%90%E7%BB%91%E5%AE%9A%E5%99%A8%E8%8E%B7%E5%8F%96%E5%B1%9E%E6%80%A7%E6%96%87%E4%BB%B6":{"title":"","content":"```java\nimport java.sql.*;  \nimport java.util.ResourceBundle;  \n  \npublic class JDBCTest04 {  \n    public static void main(String[] args) {  \n    //    通过资源绑定器获取属性文件  \n        ResourceBundle bundle=ResourceBundle.getBundle(\"jdbc\");  \n        String driver=bundle.getString(\"driver\");  \n        String url=bundle.getString(\"url\");  \n        String user=bundle.getString(\"user\");  \n        String password=bundle.getString(\"pass\");  \n        String sql=bundle.getString(\"sql\");  \n  \n        //需要的变量  \n        Connection connection;  \n        Statement statement;  \n        try {  \n        //    1.注册驱动  \n            Class.forName(driver);  \n        //    2.获取连接  \n            connection= DriverManager.getConnection(url,user,password);  \n            System.out.println(\"Connection Object---\u003e\"+connection);  \n        //    发送sql语句的对象  \n            statement=connection.createStatement();  \n        //    发送sql语句  \n            int count=statement.executeUpdate(sql);  \n            System.out.println(count!=0?\"succeed\":\"failure\");  \n        } catch (ClassNotFoundException e) {  \n            e.printStackTrace();  \n        } catch (SQLException e) {  \n            e.printStackTrace();  \n        }  \n    }  \n}\n```\n\n属性文件\n```properties\ndriver=com.mysql.jdbc.Driver  \nurl=jdbc:mysql://localhost:3306/bjpowernode  \nuser=root  \npass=root  \nsql=insert into dept values(165,'???','beijing')\n```\n\noutput\n```shell\nConnection Object---\u003ecom.mysql.jdbc.JDBC4Connection@446cdf90\nsucceed\n```","lastmodified":"2022-09-20T05:41:06.438325125Z","tags":null},"/0007-union":{"title":"","content":"![](asset/Pasted%20image%2020220818101325.png)\n合并集合（相加）","lastmodified":"2022-09-20T05:41:06.44232519Z","tags":null},"/0008-%E5%AE%8C%E6%88%90%E7%AC%AC%E4%BA%94%E6%AD%A5%E5%A4%84%E7%90%86%E7%BB%93%E6%9E%9C%E9%9B%86":{"title":"","content":"#书写注意点\n在集合中的`resultSet.getInt()`等方法中的参数，select语句中有as的话，填写的是as之后的字段，而不是sql语句中的原有字段名称\n\n```java\nimport java.sql.*;  \n  \npublic class JDBCTest05 {  \n    public static void main(String[] args) {  \n    //    变量预设  \n        Connection connection=null;//连接的对象  \n        Statement statement=null;//发送sql语句的对象  \n        ResultSet resultSet=null;//结果集  \n  \n        try {  \n        //    注册驱动  \n            Class.forName(\"com.mysql.jdbc.Driver\");  \n        //    建立连接  \n            connection= DriverManager.getConnection(\"jdbc:mysql://localhost:3306/bjpowernode\",\"root\",\"root\");  \n        //    获取发送sql语句的对象  \n            statement=connection.createStatement();  \n        //    发送sql语句  \n            resultSet=statement.executeQuery(\"select * from dept\");//专门执行DQL的方法,返回值是ResultSet  \n        //    处理查询集合  \n            while (resultSet.next()){  \n                //getString 可以将数据库中的内容以String的方式获取  \n                //可以使用列数，从1开始，不是从0就开始  \n                int deptno=resultSet.getInt(\"deptno\");  \n                String dname=resultSet.getString(\"dname\");  \n                String loc=resultSet.getString(\"loc\");  \n                System.out.println(deptno+\" \"+dname+\" \"+loc);  \n            }  \n  \n        } catch (ClassNotFoundException e) {  \n            e.printStackTrace();  \n        } catch (SQLException e) {  \n            e.printStackTrace();  \n        }finally {  \n        //    6.释放资源  \n            if (resultSet!=null){  \n                try {  \n                    resultSet.close();  \n                } catch (SQLException e) {  \n                    e.printStackTrace();  \n                }  \n            }  \n            if (statement!=null){  \n                try {  \n                    statement.close();  \n                } catch (SQLException e) {  \n                    e.printStackTrace();  \n                }  \n            }  \n            if (connection!=null){  \n                try {  \n                    connection.close();  \n                } catch (SQLException e) {  \n                    e.printStackTrace();  \n                }  \n            }  \n        }  \n    }  \n}\n```\noutput\n```\n10 ACCOUNTING NEW YORK\n20 RESEARCH DALLAS\n30 SALES CHICAGO\n40 OPERATIONS BOSTON\n50 人事部 北京\n80 renshibu Beijing\n90 renshibu Beijing\n\n```","lastmodified":"2022-09-20T05:41:06.438325125Z","tags":null},"/0008-limit":{"title":"","content":"\n是sql语句最后执行的一个环节\nlimit m,n\n从第m个开始取，取n个记录\n![](asset/Pasted%20image%2020220818101732.png)\n\nlimit n 取n个记录![](asset/Pasted%20image%2020220818101627.png)","lastmodified":"2022-09-20T05:41:06.44232519Z","tags":null},"/0009-%E6%A1%88%E4%BE%8B%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E9%AA%8C%E8%AF%81%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E5%8F%AF%E8%A2%ABsql%E6%B3%A8%E5%85%A5":{"title":"","content":"```java\nimport java.sql.*;  \nimport java.util.HashMap;  \nimport java.util.Map;  \nimport java.util.Scanner;  \n  \npublic class JDBCTest06 {  \n    public static void main(String[] args) {  \n        // 1.初始化用户界面  \n        Map\u003cString, String\u003e userLoginInfo = initUI();// 返回用户名和密码  \n        //2.用户登录，验证用户名和密码  \n        boolean loginSucceed = login(userLoginInfo);  \n  \n        //3.输出结果  \n        System.out.println(loginSucceed?\"登录成功\":\"登录失败\");  \n    }  \n  \n    /**  \n     * @param userLoginInfo 传入的用户信息集合  \n     * @return 返回是否登录成功的结果  \n     */  \n    private static boolean login(Map\u003cString, String\u003e userLoginInfo) {  \n        // 初始化登录结果  \n        boolean loginSucceed = false;  \n        //    获取用户输入的信息  \n        String loginName = userLoginInfo.get(\"loginName\");  \n        String loginPassword = userLoginInfo.get(\"loginPassword\");  \n  \n        // JDBC部分  \n        // 定义基本的连接变量  \n        Connection connection = null;// 建立sql数据库的连接  \n        Statement statement = null;// sql执行语句的发送语句  \n        ResultSet resultSet = null;// 返回结果的集合  \n        try {  \n            // 1.注册驱动  \n            Class.forName(\"com.mysql.jdbc.Driver\");  \n            // 2.获取连接  \n            connection = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/bjpowernode\", \"root\", \"root\");  \n            // 3.创建数据库操作对象  \n            statement = connection.createStatement();  \n            // 4.sql执行语句  \n            String sql = \"select * from t_user where loginName='\" + loginName + \"' and loginPassword='\" + loginPassword + \"'\";  \n            // int count=statement.executeUpdate(sql);//影响的条数，此处无用  \n            resultSet = statement.executeQuery(sql);// 执行slq，并返回结果集  \n            // 5.处理结果集  \n            // 如果有返回的记录，说明数据中存在这样的用户信息，就设置true  \n            if (resultSet.next()) {  \n                loginSucceed = true;  \n            }  \n  \n        } catch (ClassNotFoundException e) {  \n            e.printStackTrace();  \n        } catch (SQLException e) {  \n            e.printStackTrace();  \n        } finally {  \n            // 6释放资源  \n            if (resultSet != null) {  \n                try {  \n                    resultSet.close();  \n                } catch (SQLException e) {  \n                    throw new RuntimeException(e);  \n                }  \n            }  \n  \n            if (statement != null) {  \n                try {  \n                    statement.close();  \n                } catch (SQLException e) {  \n                    e.printStackTrace();  \n                }  \n            }  \n            if (connection != null) {  \n                try {  \n                    connection.close();  \n                } catch (SQLException e) {  \n                    e.printStackTrace();  \n                }  \n            }  \n        }  \n        return loginSucceed;  \n    }  \n  \n    /**  \n     * 初始化用户界面  \n     *  \n     * @return 返回用户账户和密码的map集合  \n     */  \n    private static Map\u003cString, String\u003e initUI() {  \n        // 输入  \n        Scanner s = new Scanner(System.in);  \n        System.out.println(\"请输入用户名：\");  \n        String loginName = s.nextLine();  \n        System.out.println(\"请输入密码\");  \n        String loginPassword = s.nextLine();  \n        // 存放到map集合中  \n        Map\u003cString, String\u003e userLoginInfo = new HashMap\u003c\u003e();  \n        userLoginInfo.put(\"loginName\", loginName);  \n        userLoginInfo.put(\"loginPassword\", loginPassword);  \n        // 返回账户信息集合  \n        return userLoginInfo;  \n    }  \n  \n  \n}\n```\noutput\n```shell\n请输入用户名：\nzhangsan\n请输入密码\n123\n登录成功\n\nProcess finished with exit code 0\n```\n\nsql注入\n```shell\n请输入用户名：\nanyone\n请输入密码\nf' or '1'='1\n登录成功\n\n```\n[[0010 解决sql注入问题的PreparedStatement]]","lastmodified":"2022-09-20T05:41:06.438325125Z","tags":null},"/0009-DML%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E8%AF%AD%E8%A8%80":{"title":"","content":"```sql\ncreate table tableName(\n\n   columnName dataType(length),\n\n   ………………..\n\n   columnName dataType(length)\n\n);\n\nset character_set_results='gbk';\n\nshow variables like '%char%';\n\n创建表的时候，表中有字段，每一个字段有：\n\n     * 字段名\n\n     * 字段数据类型\n\n     * 字段长度限制\n\n     * 字段约束\n```\n\n# 表操作\n## 创建表\nchar和varchar怎么选择？\n在实际的开发中，当某个字段中的数据长度不发生改变的时候，是定长的，例如：性别、生日等都是采用chr。当一个字段的数据长度不确定，例如：简介、姓名等都是采用varchar。\n\n### 字段类型\n\n| 类型                         | 描述                                             |\n| ---------------------------- | ------------------------------------------------ |\n| Char(长度)                   | 定长字符串，存储空间大小固定，适合作为主键或外键 |\n| Varchar(长度)                | 变长字符串，存储空间等于实际数据空间             |\n| double(有效数字位数，小数位) | 数值型                                           |\n| Float(有效数字位数，小数位)  | 数值型                                           |\n| Int( 长度)                   | 整型                                             |\n| bigint(长度)                 | 长整型                                           |\n| Date                         | 日期型 年月日                                    |\n| DateTime                     | 日期型 年月日 时分秒 毫秒                        |\n| time                         | 日期型 时分秒                                    |\n| BLOB                         | Binary Large OBject（二进制大对象）              |\n| CLOB                         | Character Large OBject（字符大对象）             |\n| 其它…………………                  |                                                  |                                                  |\n\n\n### eg1\n![](asset/Pasted%20image%2020220818103823.png)\n[navicat图](asset/Pasted%20image%2020220818112743.png)\n\n## 插入数据\n![](asset/Pasted%20image%2020220818114508.png)\n![](asset/Pasted%20image%2020220818114655.png)\n\n[0002 SQL语句的分类](0002%20SQL语句的分类.md \"最好的markdown教程\")\n\ninsert into tablename（字段） values（）；\n\n[一次插入多条数据](asset/Pasted%20image%2020220818130016.png)\n\n## 复制表\n```mysql\ncreate table 新建的表名 as select语句\n```\n![](asset/Pasted%20image%2020220818130930.png)\n\n### 查询结果插入数据到表\n```msyql\ninsert into 表名 select语句\n```\n![](asset/Pasted%20image%2020220818131243.png)\n\n## 修改数据\n```mysql\nupdate 表名 set 字段名=值,字段名=值 where 条件;\n```\n![](asset/Pasted%20image%2020220818131651.png)\n\n## 删除数据\n![](asset/Pasted%20image%2020220818131822.png)\n**删除大表数据**： `truncate table 表名`   表被截断，不可回滚。永久丢失。\n\n## 删除表\n```sql\ndrop table if exists 表名\n```\n\n\n增删改查有一个术语：**CRUD操作**\nCreate（增） Retrieve（检索） Update（修改） Delete（删除）","lastmodified":"2022-09-20T05:41:06.44232519Z","tags":null},"/001.%E5%AE%89%E8%A3%85%E4%B9%8B%E5%90%8E%E7%9A%84%E9%85%8D%E7%BD%AE":{"title":"","content":"## 初始化\n```bash\ngit init\n```\n## 设置个人名称和邮箱 ^veaiyshu\n```\n$ git config --global user.name \"runoob\"\n$ git config --global user.email test@runoob.com\n```\n# 查看配置\n```\ngit config --global user.name\n\n```\n# 查看仓库状态\n`git status`\n## 额外配置\n```bash\ngit config --global core.editor emacs\n``` \n配置**git**文本编辑器\n","lastmodified":"2022-09-20T05:41:06.438325125Z","tags":null},"/001.%E6%90%AD%E5%BB%BA%E4%B9%A6%E6%9E%B6%E6%95%99%E7%A8%8B":{"title":"","content":"# 相关\n1. [豆瓣图书](https://book.douban.com/)\n# 准备工具\n[相关工具资料](https://andlight.notion.site/obsiddian-759c542c58d64881a380850b10d1b26b)\n![](https://pic.rmb.bdstatic.com/bjh/bf36273938bc6047dae512120876cc54.jpeg)\n1. Banners\n2. Dataview\n3. QuickAdd\n\t1. Style Settings\n4. Templater\n\n# 步骤\n## 页面\n1. 建立相应文件夹，将对应的文件移到相应文件夹里\n\t1. 模板文件夹![](https://pic.rmb.bdstatic.com/bjh/55ea1b9aa60cc67c57d648c96bfdec9d.jpeg)\n\t2. 书架文件夹![image.png](https://pic.rmb.bdstatic.com/bjh/2a253a2b63eb565fba9f4f623a2b93c4.jpeg)\n2. 修改个人css，头部信息隐藏\n\t1. user.css\n\t\t```css\n\t\t/*隐藏头部*/\n\t\t.frontmatter-container {\n\t\t\tdisplay: none;\n\t\t}\n\t\t\n\t\t/*dataview用于的 */\n\t\tspan.nav {\n\t\t\tborder-top: 1px solid var(--gray-dark-3);\n\t\t\tborder-bottom: 1px solid var(--gray-dark-3);\n\t\t\tclear: right;\n\t\t\tdisplay: flex;\n\t\t\tflex-direction: row;\n\t\t\tjustify-content: space-around;\n\t\t}\n\t\t\n\t\t```\n\t\t![image.png](https://pic.rmb.bdstatic.com/bjh/4c98449002120aefc29c55b2e291c593.jpeg)\n\t\t![image.png](https://pic.rmb.bdstatic.com/bjh/398e373d8f547a58f2c6c1b8f8a9ae63.jpeg)\n3. Templater插件，设置文件夹和文件模板\n   ![image.png](https://pic.rmb.bdstatic.com/bjh/82d0c975b85368211369189b55577015.jpeg)\n   ![image.png](https://pic.rmb.bdstatic.com/bjh/7cceb546464b27937269110f68561ec9.jpeg)\n   了解占位符\u003c % tp.file.title %\u003e\n4. 启用quickAdd插件\n\t1. ![image.png](https://pic.rmb.bdstatic.com/bjh/bef3c5b5616013079c4cb92bd9471f54.jpeg)  \n\t2. ![image.png](https://pic.rmb.bdstatic.com/bjh/81c7b75278904c718302f79e03dcabf7.jpeg)\n\t3. 添加宏![image.png](https://pic.rmb.bdstatic.com/bjh/909a57a46ee4321ecfc7612d2b141588.jpeg)\n\t4. 添加一个脚本进行，豆瓣的图书查询![image.png](https://pic.rmb.bdstatic.com/bjh/a4e35319e395239e53ea67936ece4cf7.jpeg)，这个js脚本需要先放在obsidian的目录里，哪都行\n\t5. 添加一个模板![image.png](https://pic.rmb.bdstatic.com/bjh/10172f5143485dbc53a2f7de835d8836.jpeg)\n\t6. 对模板进行配置![[../../asset/Pasted image 20220714155206.png]]\n\t\t{{VALUE:bookname}}，文件名\n\t7. 添加一个动作，![image.png](https://pic.rmb.bdstatic.com/bjh/c32be7218faaf61c0105cd822b8e5727.jpeg)\n\t8. 点击闪电标识 ，添加到ctrl p里面![image.png](https://pic.rmb.bdstatic.com/bjh/de7d69c049df6be412377ffb3fce2e07.jpeg)\n\t9. 绑定快捷键![image.png](https://pic.rmb.bdstatic.com/bjh/e935b7eabf6b2bffd575d161660c9272.jpeg)\n5. 重载 ctrl 搜重载\n\n效果output\n![image.png](https://pic.rmb.bdstatic.com/bjh/fb788b9293f6be54e9b89b2523f00c2c.jpeg)\n\n---\n## dataview \n","lastmodified":"2022-09-20T05:41:07.266338579Z","tags":null},"/001.JDKJREJVM%E7%9A%84%E5%85%B3%E7%B3%BB":{"title":"","content":"\nJDK：java开发工具包\nJRE：java运行环境\nJVM：java虚拟机\n软件需要JRE才能跑起来\njDK包括jRE，JVM\nJRE包括JVM\nJDK以及JRE不能跨平台，不同平台需要安装不同平台的对应包\nJava程序最终运行在**JVM**上\njava体系技术的分类\n1. JavaSE：标准版\n2. JavaEE：J企业版\n3. JavaME：微型版","lastmodified":"2022-09-20T05:41:06.454325385Z","tags":null},"/0010-%E7%BA%A6%E6%9D%9FConstraint":{"title":"","content":"# 概述\n1. 什么是约束？常见的约束有哪些呢？\n\t1. 在创建表的时候，可以给表的字段添加相应的约束，\n\t2. 添加约束的目的是为了保证表中数据的**合法性**、**有效性**、**完整性**。\n2. 常见的约束有哪些呢？\n\t1. 非空约束(not null)：约束的字段不能为NULL   \n\t2. 唯一约束(unique)：约束的字段不能重复 ** 但可以为NULL **。\n\t3. 主键约束(primary key)：约束的字段既不能为NULL，也不能重复（简称PK）\n\t4. 外键约束(foreign key)：...（简称FK）\n\t5. 检查约束(check)：注意Oracle数据库有check约束，但是mysql没有，目前mysql不支持该约束。\n\n---\n##  实操例子\n### 非空约束eg\n[建表](asset/Pasted%20image%2020220818210147.png) \n[测试](asset/Pasted%20image%2020220818210112.png)\n\n### 唯一约束(unique)eg\n列级约束\n![](asset/Pasted%20image%2020220818210753.png)\n![](asset/Pasted%20image%2020220818210759.png)\n\n表级约束，多个字段\n\n### 主键约束\n字段后面添加`primary key`即可\n![](asset/Pasted%20image%2020220819084456.png)\n\n主键的特点：**不能为NULL，也不能重复**\n\n主键有什么作用？\n- 表的设计三范式中有要求，第一范式就要求任何一张表都应该有主键。\n- 主键的作用：主键值是这行记录在这张表当中的唯一标识。\n\n主键的分类？\n\t根据主键字段的字段数量来划分：\n\t\t单一主键（推荐的，常用的。）\n\t\t复合主键(多个字段联合起来添加一个主键约束)（复合主键不建议使用，因为复合主键违背三范式。）\n\t根据主键性质来划分：\n\t\t自然主键：主键值最好就是一个和业务没有任何关系的自然数。（这种方式是推荐的）\n\t\t业务主键：主键值和系统的业务挂钩，例如：拿着银行卡的卡号做主键，拿着身份证号码作为主键。（不推荐用）\n\t\t\t\t\t  最好不要拿着和业务挂钩的字段作为主键。因为以后的业务一旦发生改变的时候，主键值可能也需要\n\t\t\t\t\t  随着发生变化，但有的时候没有办法变化，因为变化可能会导致主键值重复。\n\t** 一张表的主键约束只能有1个。**\n\n表级约束定义主键\n![](asset/Pasted%20image%2020220819085218.png)\n\n复合主键，**由两个字段组成主键约束**\n![](asset/Pasted%20image%2020220819085350.png)\n\n### 提供的主键自增\n![](asset/Pasted%20image%2020220819085511.png)\n```sql\nprimary key auto_increment\n```\nOracle当中也提供了一个自增机制，叫做：序列（sequence）对象。\n\n### 外键约束\n外键约束` foreign key(classno) references t_class(cno)`\n\n被引用的字段不一定是主键，但至少具有unique约束。\n* 关于外键约束的相关术语：\n\t外键约束: foreign key\n\t外键字段：添加有外键约束的字段\n\t外键值：外键字段中的每一个值。\n顺序要求：\n\t\t\t删除数据的时候，先删除子表，再删除父表。\n\t\t\t添加数据的时候，先添加父表，在添加子表。\n\t\t\t创建表的时候，先创建父表，再创建子表。\n\t\t\t删除表的时候，先删除子表，在删除父表。\n\t\t\t\n![](asset/Pasted%20image%2020220819091853.png)\n创建外键关联\n![](asset/Pasted%20image%2020220819091901.png)  ","lastmodified":"2022-09-20T05:41:06.44232519Z","tags":null},"/0010-%E8%A7%A3%E5%86%B3sql%E6%B3%A8%E5%85%A5%E9%97%AE%E9%A2%98%E7%9A%84PreparedStatement":{"title":"","content":"```java\nimport java.sql.*;  \nimport java.util.HashMap;  \nimport java.util.Map;  \nimport java.util.Scanner;  \n  \npublic class JDBCTest07 {  \n    public static void main(String[] args) {  \n    //1.  初始化界面  \n        Map\u003cString,String\u003e userLoginInfo=initUI();  \n    //2.  验证用户信息  \n        boolean loginSucceed=login(userLoginInfo);  \n    //3.  输出结果信息  \n        System.out.println(loginSucceed?\"登录成功\":\"登录失败\");  \n    }  \n  \n    /**  \n     * 验证用户登录信息  \n     * @param userLoginInfo 用户输入的用户信息  \n     * @return 返回登录的结果  \n     */  \n    private static boolean login(Map\u003cString, String\u003e userLoginInfo) {  \n        //获取用户的登录信息  \n        String loginName=userLoginInfo.get(\"loginName\");  \n        String loginPassword=userLoginInfo.get(\"loginPassword\");  \n        //与sql服务器进行验证  \n        boolean loginSucceed=false;// 登录结果是否成功的标签  \n        Connection connection=null;//连接的对象  \n        PreparedStatement preparedStatement=null;//操作sql数据库的对象，避免sql注入的方式  \n        ResultSet resultSet=null;  \n        try {  \n            // 1.注册驱动  \n            Class.forName(\"com.mysql.jdbc.Driver\");  \n            // 2.获取连接  \n            connection = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/bjpowernode\", \"root\", \"root\");  \n            // 3.创建sql操作对象  \n            String sql=\"select * from t_user where loginName = ? and loginPassword = ?\";  \n            //发送的sql框子给DBMS，DBMS进行sql语句的预编译，  \n            // 之后给？传值即可就不会讲传的值作为编译的一部分，造成sql注入  \n            preparedStatement=connection.prepareStatement(sql);  \n            //设置sql语句中？的值  \n            preparedStatement.setString(1,loginName);  \n            preparedStatement.setString(2,loginPassword);  \n            //执行sql  \n            resultSet=preparedStatement.executeQuery();  \n            if (resultSet.next()){  \n                loginSucceed=true;  \n            }  \n        } catch (ClassNotFoundException e) {  \n            e.printStackTrace();  \n        } catch (SQLException e) {  \n            e.printStackTrace();  \n        }finally {  \n            if (resultSet!=null){  \n                try {  \n                    resultSet.close();  \n                } catch (SQLException e) {  \n                    e.printStackTrace();  \n                }  \n            }  \n            if (preparedStatement!=null){  \n                try {  \n                    preparedStatement.close();  \n                } catch (SQLException e) {  \n                    e.printStackTrace();  \n                }  \n            }  \n            if (connection!=null){  \n                try {  \n                    connection.close();  \n                } catch (SQLException e) {  \n                    e.printStackTrace();  \n                }  \n            }  \n        }  \n        return loginSucceed;  \n    }  \n  \n    /**  \n     * 用户登录的界面  \n     * @return 返回用户填写的登录信息集合  \n     */  \n    private static Map\u003cString, String\u003e initUI() {  \n        Scanner s=new Scanner(System.in);  \n        String loginName,loginPassword;  \n        System.out.println(\"请输入用户名：\");  \n        loginName=s.nextLine();  \n        System.out.println(\"请输入  密码：\");  \n        loginPassword=s.nextLine();  \n  \n        //        放入到集合中  \n        Map\u003cString,String\u003e userLoginInfoSet=new HashMap\u003c\u003e();  \n        userLoginInfoSet.put(\"loginName\",loginName);  \n        userLoginInfoSet.put(\"loginPassword\",loginPassword);  \n        return userLoginInfoSet;  \n    }  \n}\n```\n\n\n为什么这个能够解决注入问题\n[0004 Statement和PreparedStatement的区别](0004%20Statement和PreparedStatement的区别.md)","lastmodified":"2022-09-20T05:41:06.438325125Z","tags":null},"/0011-%E4%BA%8B%E5%8A%A1%E6%9C%BA%E5%88%B6":{"title":"","content":"## 事务机制的作用\nJDBC中默认事务机制是：执行一条，提交一条。\n但是在实际应用开发中，有时候需要多条DML语句共同联合完成或者失败来决定是否提交到数据库，所以就需要事物机制。\n比如：转账，需要两个语句中的转出和转入都要成功，或者总共的钱就会有缺失或者多余\n\n关闭事物提交：`获取连接的对象.setAutoCommit(true);`\n进行提交：`xx.commit();`\n回滚：`xx.rollback();`一般写在异常中，用于DML语句中出现了异常就回滚事务\n\n```java\nimport jdbc.DBUtil;  \n  \nimport java.sql.Connection;  \nimport java.sql.PreparedStatement;  \nimport java.sql.SQLException;  \n  \n/* 关于事务机制 */public class JDBCTest11 {  \n    public static void main(String[] args) {  \n        Connection con = null;  \n        PreparedStatement ps = null;  \n  \n        try {  \n            //1. 注册驱动,以及连接连接,因为在调用的时候，会自动调用dbutil类中的静态代码块，静态代码块中包括了注册驱动的方法  \n            con=DBUtil.getConnection();  \n            //2.获取sql操作对象  \n            //修改自动提交机制  \n  \n            //关闭自动提交，开启事务  \n            con.setAutoCommit(false);  \n        //从一个账户取出1000  \n            String sql=\"update t_act set balance = ? where actno = ?\";  \n            ps=con.prepareStatement(sql);//发送sql语句进行预编译  \n            //传值  \n            ps.setDouble(1,1000);  \n            ps.setInt(2,111);  \n            int count=ps.executeUpdate();//执行sql，并获取影响的条数  \n  \n  \n            // sql=\"update t_act set balance = ? where actno = ?\";  \n            // ps=con.prepareStatement(sql);//发送sql语句进行预编译  \n        //把取出的1000放入到另一个账户  \n            //传值进行查询  \n            ps.setInt(1,1000);  \n            ps.setInt(2,222);  \n            count+=ps.executeUpdate();//执行并返回影响条数  \n            System.out.println(count==2?\"转账成功\":\"转账失败\");  \n            // System.out.println(count);  \n        //    提交事务  \n            con.commit();  \n        } catch (Exception e) {  \n            //如果执行过程中出现了异常，就回滚事务  \n            if (con!=null){  \n                try {  \n                    con.rollback();  \n                } catch (SQLException ex) {  \n                    e.printStackTrace();  \n                }  \n            }  \n            e.printStackTrace();  \n        }finally {  \n        //    释放资源  \n  \n            if (ps!=null){  \n                try {  \n                    ps.close();  \n                } catch (SQLException e) {  \n                    e.printStackTrace();  \n                }  \n            }  \n            DBUtil.close(con,null,null);  \n        }  \n    }  \n}\n```","lastmodified":"2022-09-20T05:41:06.438325125Z","tags":null},"/0011-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E":{"title":"","content":"完整的建表语句\n```sql\nCREATE TABLE `t_x` (\n  `id` int(11) DEFAULT NULL\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n```\n\nmysql默认使用的存储引擎是InnoDB方式。\n\t\t默认采用的字符集是UTF8\n\n\n什么是存储引擎呢？\n1. 存储引擎这个名字只有在mysql中存在。（Oracle中有对应的机制，但是不叫做存储引擎。Oracle中没有特殊的名字，就是“表的存储方式”）\n2. mysql支持很多存储引擎，每一个存储引擎都对应了一种不同的存储方式。\n\t每一个存储引擎都有自己的优缺点，需要在合适的时机选择合适的存储引擎。\n\n\n查看当前mysql支持的存储引擎？\n\t\t[show engines \\G](asset/Pasted%20image%2020220819092322.png)\n\n\n### 常见的存储引擎\n常见的存储引擎？\n\n\u003e[!faq]- MyISAM\n\u003e Engine: MyISAM\n\u003e\t  Support: YES\n\u003e\t  Comment: MyISAM storage engine\n\u003eTransactions: NO\n\u003e\t\t\t XA: NO\n  \u003eSavepoints: NO\n\u003e\n\u003eMyISAM这种存储引擎不支持事务。\n\u003eMyISAM是mysql最常用的存储引擎，但是这种引擎不是默认的。\n\u003eMyISAM采用三个文件组织一张表：\n\t\u003exxx.frm（存储格式的文件）\n\t\u003exxx.MYD（存储表中数据的文件）\n\t\u003exxx.MYI（存储表中索引的文件）\n\u003e优点：可被压缩，节省存储空间。并且可以转换为只读表，提高检索效率。\n\u003e缺点：不支持事务。\n\n\n\u003e[!faq]- InnoDB\n\u003e\t\t  Engine: InnoDB\n\u003e\t\t  Support: DEFAULT\n\u003e\t\t  Comment: Supports transactions, row-level locking, and foreign keys\n\u003e\tTransactions: YES\n\u003e\t\t\t\t XA: YES\n\u003e\t  Savepoints: YES\n\u003e\t\t\n\u003e\t优点：支持事务、行级锁、外键等。这种存储引擎数据的安全得到保障。\n\u003e\t\n\u003e\t表的结构存储在xxx.frm文件中\n\u003e\t数据存储在tablespace这样的表空间中（逻辑概念），无法被压缩，无法转换成只读。\n\u003e\t这种InnoDB存储引擎在MySQL数据库崩溃之后提供自动恢复机制。\n\u003e\tInnoDB支持级联删除和级联更新。\n\n\n\u003e[!faq]- MEMORY\n\u003e\t\t\tEngine: MEMORY\n\u003e\t\t  Support: YES\n\u003e\t\t  Comment: Hash based, stored in memory, useful for temporary tables\n\u003e\tTransactions: NO\n\u003e\t\t\t\t XA: NO\n\u003e\t  Savepoints: NO\n\u003e\t\n\u003e\t缺点：不支持事务。数据容易丢失。因为所有数据和索引都是存储在内存当中的。\n\u003e\t优点：查询速度最快。\n\u003e\t以前叫做HEPA引擎。","lastmodified":"2022-09-20T05:41:06.44232519Z","tags":null},"/0012-JBMC%E5%B0%81%E8%A3%85%E7%B1%BB":{"title":"","content":"```java\npackage jdbc;  \n  \nimport java.sql.*;  \n  \npublic class DBUtil {  \n    //不需要new对象，直接调用工具类中的公开静态方法即可  \n    private DBUtil() {  \n  \n    }  \n  \n    /**  \n     * 静态代码块，加载类的时候执行一次，后面就需要执行了  \n     * 用于注册驱动  \n     */  \n    static {  \n        try {  \n            Class.forName(\"com.mysql.jdbc.Driver\");  \n        } catch (ClassNotFoundException e) {  \n            e.printStackTrace();  \n        }  \n    }  \n  \n    /**  \n     *     * @return 将sql连接对象返回去  \n     * @throws SQLException  sql异常跑出去，让父类异常处理  \n     */  \n    public static Connection  getConnection() throws SQLException {  \n        return DriverManager.getConnection(\"jdbc:mysql://localhost:3306/bjpowernode\",\"root\",\"root\");  \n    }  \n  \n    /**  \n     * 释放资源  \n     * @param con   sql连接对象  \n     * @param st    sql操作对象  \n     * @param rs    资源集合对象  \n     */  \n    public static void close(Connection con, Statement st, ResultSet rs){  \n        if (rs!=null){  \n            try {  \n                rs.close();  \n            } catch (SQLException e) {  \n                e.printStackTrace();  \n            }  \n        }  \n        if (st!=null){  \n            try {  \n                st.close();  \n            } catch (SQLException e) {  \n                e.printStackTrace();  \n            }  \n        }  \n        if (con!=null){  \n            try {  \n                con.close();  \n            }catch(SQLException e){  \n                e.printStackTrace();  \n            }  \n        }  \n    }  \n}\n```","lastmodified":"2022-09-20T05:41:06.438325125Z","tags":null},"/0013-%E7%B4%A2%E5%BC%95":{"title":"","content":"\n# 什么是索引？有什么用？\n\u003e索引就相当于一本书的目录，通过目录可以快速的找到对应的资源。\n\u003e在数据库方面，查询一张表的时候有两种检索方式：\n\u003e1. 第一种方式：全表扫描\n\u003e2. 第二种方式：根据索引检索（效率很高）\n\n\n## 索引为什么可以提高检索效率呢？\n\u003e\t其实最根本的原理是缩小了扫描的范围。\n\u003e索引虽然可以提高检索效率，但是不能随意的添加索引，因为索引也是数据库当中\n\u003e的对象，也需要数据库不断的维护。是有维护成本的。比如，表中的数据经常被修改\n\u003e这样就不适合添加索引，因为数据一旦修改，索引需要重新排序，进行维护。\n\u003e\n\u003e添加索引是给某一个字段，或者说某些字段添加索引。\n\n### 举例\n\u003e\t\tselect ename,sal from emp where ename = 'SMITH';\n\u003e\t\t当ename字段上没有添加索引的时候，以上sql语句会进行全表扫描，扫描ename字段中所有的值。\n\u003e\t\t当ename字段上添加索引的时候，以上sql语句会根据索引扫描，快速定位。\n\n## 怎么创建索引对象？怎么删除索引对象？\n创建索引对象：\n```sql\ncreate index 索引名称 on 表名(字段名);\n```\n删除索引对象：\n```sql\ndrop index 索引名称 on 表名;\n```\n\n\n## 什么时候考虑给字段添加索引？（满足什么条件）\n\u003e\t\t* 数据量庞大。（根据客户的需求，根据线上的环境）\n\u003e\t\t* 该字段很少的DML操作。（因为字段进行修改操作，索引也需要维护）\n\u003e\t\t* 该字段经常出现在where子句中。（经常根据哪个字段查询）\n\u003e\t\n## 注意：主键和具有unique约束的字段自动会添加索引。\n\u003e\t\t根据主键查询效率较高。尽量根据主键检索。\n\u003e\t\n## 查看sql语句的执行计划：\n```sql\n\t\tmysql\u003e explain select ename,sal from emp where sal = 5000;\n\t\t+----+-------------+-------+------+---------------+------+---------+------+------+-------------+\n\t\t| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra       |\n\t\t+----+-------------+-------+------+---------------+------+---------+------+------+-------------+\n\t\t|  1 | SIMPLE      | emp   | ALL  | NULL          | NULL | NULL    | NULL |   14 | Using where |\n\t\t+----+-------------+-------+------+---------------+------+---------+------+------+-------------+\n\n\t\t给薪资sal字段添加索引：\n\t\t\tcreate index emp_sal_index on emp(sal);\n\t\t\n\t\tmysql\u003e explain select ename,sal from emp where sal = 5000;\n\t\t+----+-------------+-------+------+---------------+---------------+---------+-------+------+-------------+\n\t\t| id | select_type | table | type | possible_keys | key           | key_len | ref   | rows | Extra       |\n\t\t+----+-------------+-------+------+---------------+---------------+---------+-------+------+-------------+\n\t\t|  1 | SIMPLE      | emp   | ref  | emp_sal_index | emp_sal_index | 9       | const |    1 | Using where |\n\t\t+----+-------------+-------+------+---------------+---------------+---------+-------+------+-------------+\n```\n\t\n## 索引底层采用的数据结构是：B + Tree\n## 索引的实现原理？\n\u003e通过B Tree缩小扫描范围，底层索引进行了排序，分区，索引会携带数据在表中的“物理地址”，\n\u003e最终通过索引检索到数据之后，获取到关联的物理地址，通过物理地址定位表中的数据，效率\n\u003e是最高的。\n\u003e\tselect ename from emp where ename = 'SMITH';\n\u003e\t通过索引转换为：\n\u003e\tselect ename from emp where 物理地址 = 0x3;\n\u003e\n## 索引的分类？\n\u003e\t\t单一索引：给单个字段添加索引\n\u003e\t\t复合索引: 给多个字段联合起来添加1个索引\n\u003e\t\t主键索引：主键上会自动添加索引\n\u003e\t\t唯一索引：有unique约束的字段上会自动添加索引\n\u003e\t\t....\n\u003e\t\n## 索引什么时候失效？\n\u003e\t\tselect ename from emp where ename like '%A%';\n\u003e\t\t模糊查询的时候，第一个通配符使用的是%，这个时候索引是失效的。\n\u003e\n","lastmodified":"2022-09-20T05:41:06.44232519Z","tags":null},"/0013-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8":{"title":"","content":"## 准备MySQL\n安装MySQL，老是出现安不上的问题，nt软件，重新多安几次\n## Navicat的基本使用\n没啥说的\n## 设计数据库表\n1. 下载**PowerDesigner**工具\n2. 打开之后，选择`create model`--\u003e`model types`--\u003e`physical data model`\n3. 在下面的DBMS中选择mysql的对应版本，比如mysql5.0![](asset/Pasted%20image%2020220821133926.png)，点击ok\n4. 设计表![](asset/Pasted%20image%2020220821134220.png)\n5. 保存sql脚本,你可以将保存的sql脚本继续进行优化修改 ![](asset/Pasted%20image%2020220821134404.png)\n6. cmd登录mysql后，可以采用`source xxx.sql`执行sql脚本，将表创建，或者右击sql文件，用navicat软件打开，也可以在里面进行run导入","lastmodified":"2022-09-20T05:41:06.438325125Z","tags":null},"/0014%E8%A7%86%E5%9B%BEview":{"title":"","content":"# 什么是视图？\n\u003e站在不同的角度去看到数据。（同一张表的数据，通过不同的角度去看待）。\n\u003e\n## 怎么创建视图？怎么删除视图？\n\u003ecreate view myview as select empno,ename from emp;\n\u003edrop view myview;\n\u003e\n\u003e注意：只有DQL语句才能以视图对象的方式创建出来。\n\u003e\n## 对视图进行增删改查，会影响到原表数据。（通过视图影响原表数据的，不是直接操作的原表）\n\u003e可以对视图进行CRUD操作。\n\u003e\n## 面向视图操作？\n\u003emysql\u003e select * from myview;\n\u003e+-------+--------+\n\u003e| empno | ename  |\n\u003e+-------+--------+\n\u003e|  7369 | SMITH  |\n\u003e|  7499 | ALLEN  |\n\u003e|  7521 | WARD   |\n\u003e|  7566 | JONES  |\n\u003e|  7654 | MARTIN |\n\u003e|  7698 | BLAKE  |\n\u003e|  7782 | CLARK  |\n\u003e|  7788 | SCOTT  |\n\u003e|  7839 | KING   |\n\u003e|  7844 | TURNER |\n\u003e|  7876 | ADAMS  |\n\u003e|  7900 | JAMES  |\n\u003e|  7902 | FORD   |\n\u003e|  7934 | MILLER |\n\u003e+-------+--------+\n\u003e\n\u003ecreate table emp_bak as select * from emp;\n\u003ecreate view myview1 as select empno,ename,sal from emp_bak;\n\u003eupdate myview1 set ename='hehe',sal=1 where empno = 7369; // 通过视图修改原表数据。\n\u003edelete from myview1 where empno = 7369; // 通过视图删除原表数据。\n## 视图的作用？\n\u003e视图可以**隐藏表的实现细节**。保密级别较高的系统，数据库只对外提供相关的视图，java程序员\n\u003e只对视图对象进行CRUD。\n\u003e","lastmodified":"2022-09-20T05:41:06.44232519Z","tags":null},"/0015-DBA%E5%91%BD%E4%BB%A4":{"title":"","content":"## 将数据库当中的数据导出\n\u003e在windows的dos命令窗口中执行：（导出整个库）\n\u003emysqldump bjpowernode\u003eD:\\bjpowernode.sql -uroot -p333\n\u003e\n\u003e在windows的dos命令窗口中执行：（导出指定数据库当中的指定表）\n\u003emysqldump bjpowernode emp\u003eD:\\bjpowernode.sql -uroot –p123\n\u003e\n## 导入数据\n\u003ecreate database bjpowernode;\n\u003euse bjpowernode;\n\u003esource D:\\bjpowernode.sql","lastmodified":"2022-09-20T05:41:06.44232519Z","tags":null},"/0016-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E4%B8%89%E8%8C%83%E5%BC%8F":{"title":"","content":"什么是设计范式？\n\u003e设计表的依据。按照这个三范式设计的表不会出现数据冗余。\n\u003e\n## 三范式都是哪些？\n\n\u003e第一范式：任何一张表都应该有主键，并且每一个字段原子性不可再分。\n\u003e第二范式：建立在第一范式的基础之上，所有非主键字段完全依赖主键，不能产生部分依赖。\n\u003e第三范式：建立在第二范式的基础之上，所有非主键字段直接依赖主键，不能产生传递依赖。\n\n\n两张表，多的表加外键","lastmodified":"2022-09-20T05:41:06.44232519Z","tags":null},"/0017-%E4%B8%80%E5%AF%B9%E4%B8%80%E6%80%8E%E4%B9%88%E8%AE%BE%E8%AE%A1":{"title":"","content":"## 一对一设计有两种方案：主键共享\n```\n\u003et_user_login  用户登录表\n\u003eid(pk)\t\tusername\t\t\tpassword\n\u003e--------------------------------------\n\u003e1\t\t\t\tzs\t\t\t\t\t123\n\u003e2\t\t\t\tls\t\t\t\t\t456\n\u003e\n\u003et_user_detail 用户详细信息表\n\u003eid(pk+fk)\trealname\t\t\ttel\t\t\t....\n\u003e------------------------------------------------\n\u003e1\t\t\t\t张三\t\t\t\t1111111111\n\u003e2\t\t\t\t李四\t\t\t\t1111415621\n```\n\n## 一对一设计有两种方案：外键唯一。\n```\n\u003et_user_login  用户登录表\n\u003eid(pk)\t\tusername\t\t\tpassword\n\u003e--------------------------------------\n\u003e1\t\t\t\tzs\t\t\t\t\t123\n\u003e2\t\t\t\tls\t\t\t\t\t456\n\u003e\n\u003et_user_detail 用户详细信息表\n\u003eid(pk)\t   realname\t\t\ttel\t\t\t\tuserid(fk+unique)....\n\u003e-----------------------------------------------------------\n\u003e1\t\t\t\t张三\t\t\t\t1111111111\t\t2\n\u003e2\t\t\t\t李四\t\t\t\t1111415621\t\t1\n```\n","lastmodified":"2022-09-20T05:41:06.44232519Z","tags":null},"/0018-%E4%BF%AE%E6%94%B9root%E5%AF%86%E7%A0%81":{"title":"","content":"方法1： 用SET PASSWORD命令 \n首先登录MySQL。 \n格式：mysql\u003e set password for 用户名@localhost = password('新密码'); \n例子：mysql\u003e set password for root@localhost = password('123'); \n\n方法2：用mysqladmin \n格式：mysqladmin -u用户名 -p旧密码 password 新密码 \n例子：mysqladmin -uroot -p123456 password 123 \n\n方法3：用UPDATE直接编辑user表 \n首先登录MySQL。 \nmysql\u003e use mysql; \nmysql\u003e update user set password=password('123') where user='root' and host='localhost'; \nmysql\u003e flush privileges; \n\n方法4：在忘记root密码的时候，可以这样 \n以windows为例： \n1. 关闭正在运行的MySQL服务。 \n2. 打开DOS窗口，转到mysql\\bin目录。 \n3. 输入mysqld --skip-grant-tables 回车。--skip-grant-tables 的意思是启动MySQL服务的时候跳过权限表认证。 \n4. 再开一个DOS窗口（因为刚才那个DOS窗口已经不能动了），转到mysql\\bin目录。 \n5. 输入mysql回车，如果成功，将出现MySQL提示符 \u003e。 \n6. 连接权限数据库： use mysql; 。 \n6. 改密码：update user set password=password(\"123\") where user=\"root\";（别忘了最后加分号） 。 \n7. 刷新权限（必须步骤）：flush privileges;　。 \n8. 退出 quit。 \n9. 注销系统，再进入，使用用户名root和刚才设置的新密码123登录。","lastmodified":"2022-09-20T05:41:06.44232519Z","tags":null},"/002.%E4%B8%93%E6%B3%A8%E6%97%B6%E9%97%B4%E6%8C%91%E6%88%98%E8%AE%B0%E5%BD%95":{"title":"002.专注时间挑战记录","content":"","lastmodified":"2022-09-20T05:41:07.266338579Z","tags":null},"/002.%E5%9F%BA%E6%9C%AC%E7%9B%AE%E5%BD%95%E6%A8%A1%E6%9D%BF":{"title":"","content":"\n\u003ch1 style=\"font-family: STZhongsong;color: #004A80; letter-spacing: 0; text-shadow: 0px 1px 0px #999, 0px 2px 0px #888, 0px 3px 0px #777, 0px 4px 0px #666, 0px 5px 0px #555, 0px 6px 0px #444, 0px 7px 0px #333, 0px 8px 7px #001135;font-size:50px;text-align:center\"\u003e\u003c% tp.file.folder() %\u003e 目录\u003c/h1\u003e\n\n---\n```dataview\ntable\nfile.etags as 标签\nFrom  \"\u003c% tp.file.folder() %\u003e\"\nsort file.name\n```","lastmodified":"2022-09-20T05:41:06.47432571Z","tags":null},"/002.%E6%9F%A5%E7%9C%8B%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF":{"title":"","content":"```bash\ngit config --list\n```\n文件放置在`~/.gitconfig `或 `/etc/gitconfig`\n使用命令`vim ~/.gitconfig`可以查看和进行编辑\n查看单个环境变量可以采用\n`git config user.name`就可以只查看name变量\n![[../../asset/Pasted image 20220624132723.png]]\n","lastmodified":"2022-09-20T05:41:06.438325125Z","tags":null},"/002.Java%E8%BF%90%E8%A1%8C%E4%B8%8E%E5%8A%A0%E8%BD%BD":{"title":"","content":"[TOC]\n# 两个阶段：\n1. 编译 `javac *.java`\n\t\n\t1. java将源代码执行，生成JVM可以识别的字节码\n\t2. 源代码不能直接执行\n\t3. 一次编译到处运行\n2. 运行 `java 类名(不要加文件后缀名)`\n\n源代码文件：.java\n字节码文件：.class(**不是二进制，因为如果是二进制，就可以直接被操作系统识别，就不需要JVM了**)\n\n# 大致过程：\n使用Javac编译源代码.java文件，生成.class字节码文件，通过JVM将字节码进行解释为二进制文件，然后JVM将生成的二进制文件交给操作系统，操作系统与硬件进行交互。\n\n当java HelloWorld之后发生了生么\n1. 启动类加载器classloader，类加载器在硬盘上查找HelloWorld.class文件。找不到就会报错“找不到或无法加载主类”\n2. 类加载器找到对应的类文件，将类的字节码文件装载到JVM中\n3. JVM对字节码进行解释，然后将解释之后的二进制编码传给操作系统，操作系统可以直接识别执行\n# 注意事项\n\u003e注意：.class也是一种特殊的二进制文件，只是不能直接被机器识别和执行，需要通过JVM进行解释后传给操作系统才能执行。\n\n\u003ejava命令使用时，一般是在当前路径下去查找对应的类文件，但是也可以改变查找的路径，通过别的路径去进行查找类文件。\n\u003e查找类文件到别的文件查找，可以修改[[003.环境变量]]classpath，修改之后只会到那个目录进行查找，可以，但没必要。\n\u003e在有些版本的JDK中，不需要javac，可以直接使用`java 源代码文件名.java`就可以直接运行代码，并且不会生成字节码class文件，这是新的java jdk的新特性，为了简化开发流程。","lastmodified":"2022-09-20T05:41:06.454325385Z","tags":null},"/002.obsidian%E7%9B%B8%E5%85%B3":{"title":"","content":"\n|内容|URL|\n|---|---|\n| callout | https://zhuanlan.zhihu.com/p/494647464    https://help.obsidian.md/How+to/Use+callouts|\n|[templater文档 ]|(https://silentvoid13.github.io/Templater/internal-functions/internal-modules/date-module.html)|\n| [dataview 文档]|(https://blacksmithgu.github.io/obsidian-dataview/)|","lastmodified":"2022-09-20T05:41:06.438325125Z","tags":null},"/003.%E5%85%B3%E4%BA%8E%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%E7%9A%84%E6%A0%87%E8%AF%86%E7%AC%A6":{"title":"","content":"一个知识库的文件如何对各个文件进行命名","lastmodified":"2022-09-20T05:41:06.438325125Z","tags":null},"/003.%E6%9B%B4%E6%96%B0%E5%86%85%E5%AE%B9%E4%B8%80%E8%88%AC%E6%B5%81%E7%A8%8B":{"title":"","content":"```bash\ngit add . #添加所有文件到暂存区\ngit commit -m \"注释\" #更新的注释\ngit push \u003c远程主机名\u003e \u003c本地分支名\u003e:\u003c远程分支名\u003e\n```","lastmodified":"2022-09-20T05:41:06.438325125Z","tags":null},"/003.%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F":{"title":"","content":"# 三种方法\n1. win+R，运行窗口中输入`sysdm.cpl`\n2. 打开资源管理，右击`此电脑`-属性-高级系统设置-高级\n3. 搜索环境变量","lastmodified":"2022-09-20T05:41:06.454325385Z","tags":null},"/004.%E6%9F%A5%E7%9C%8B%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC":{"title":"","content":"git log --oneline \n查看过去提交的\n\n---\n\n回退\n git reset --hard 版本号\n git reset --soft 版本号 （软回退）\n \n \ngit reflog\n查看操作历史，用来查看自己是否成功回退\t","lastmodified":"2022-09-20T05:41:06.438325125Z","tags":null},"/004.%E6%B3%A8%E9%87%8A%E6%96%B9%E6%B3%95":{"title":"","content":"1. 多行注释\n\t```java\n\t/*\n\t  注释内容\n\t*/\n\t```\n1. 单行注释\n\t```java\n \t//\n    ```\n3. 文档注释，用于javadoc生成文档\n\t```java\n\t/**\n\t* content\n\t* content\n\t*/\n\t```","lastmodified":"2022-09-20T05:41:06.454325385Z","tags":null},"/004.yaml%E4%BF%A1%E6%81%AF%E5%AD%97%E6%AE%B5%E7%AE%A1%E7%90%86":{"title":"004.yaml信息字段管理","content":"\n# 如何管理yaml字段\n```yaml\n#博客相关\ncomments: 评论开启\ndate created: 2022-09-18 #创建时间\ndate modified: 2022-09-18 #修改时间\nid:   #id\nlayout: page #布局类型\ntags: 999-A _little \ntitle: \"004.yaml信息字段管理\"\n\n```","lastmodified":"2022-09-20T05:41:07.266338579Z","tags":null},"/005.%E4%BB%A3%E7%A0%81%E5%90%88%E5%B9%B6%E7%9A%84%E4%B8%8D%E5%90%8C%E6%96%B9%E5%BC%8F":{"title":"","content":"# 强制推送\n`git push --force origin master`\n## 删除主机分支\n`git push origin --delete master`\n## 下载远程仓库与本地合并\n**git pull** 命令用于从远程获取代码并合并本地的版本。\n```bash\ngit pull \u003c远程主机名\u003e \u003c远程分支名\u003e:\u003c本地分支名\u003e\n```\neg:`git pull origin master`\n","lastmodified":"2022-09-20T05:41:06.438325125Z","tags":null},"/005.public-class%E5%92%8Cclass%E7%9A%84%E5%8C%BA%E5%88%AB":{"title":"","content":"1. 一个源文件中可以定一个*多个*class类\n2. 定义public类名的时候，需要与源文件名一样\n3. public类最多只能有一个，但不是必须的\n4. 只要有一个class文件的定义，就必然会生成一个class文件\n\n![[../../../../asset/test9.png]]\n以上通过`javac`会生成三个class文件（T1 T2 T3)，需要进入哪个，就java哪个类","lastmodified":"2022-09-20T05:41:06.454325385Z","tags":null},"/006.%E5%85%8B%E9%9A%86%E4%BB%93%E5%BA%93":{"title":"","content":"## 强制推送\n`git push --force origin master`\n## 删除主机分支\n`git push origin --delete master`\n## 下载远程仓库与本地合并\n**git pull** 命令用于从远程获取代码并合并本地的版本。\n```bash\ngit pull \u003c远程主机名\u003e \u003c远程分支名\u003e:\u003c本地分支名\u003e\n```\neg:`git pull origin master`\n","lastmodified":"2022-09-20T05:41:06.438325125Z","tags":null},"/010.%E7%AC%A6%E5%8F%B7%E5%AE%9A%E4%B9%89":{"title":"","content":"# 标识符\n\u003e1. 程序员有权利自己命名的单词\n\u003e1. 通常用于设置方法名、接口名、常量名、等等\n\n一般采用*驼峰*命名\nStudentName\n\n# 关键字\n\u003e具有特殊含义的单词，比如`Public`,\t`static`\n![[Pasted image 20220623184204.png]]","lastmodified":"2022-09-20T05:41:06.454325385Z","tags":null},"/011.javadoc%E7%9A%84%E4%BD%BF%E7%94%A8":{"title":"","content":"1. 先在源文件中进行javadoc注释\n2. ![](asset/Pasted image 20220623190413.png)\n\n1. 使用命令javadoc执行生成文档\n\t命令格式为\n```shell\n\t\tjavadoc -d 生成文档放入的目录 -附件参数（比如作者author等等） java源文件\n```\n![](asset/Pasted image 20220623185936.png)\n\n\u003e如果不添加参数，默认几乎所有参数都会参与生成\n1. 在文件夹下打开index.html文件即可查看![](asset/Pasted image 20220623190646.png)","lastmodified":"2022-09-20T05:41:06.454325385Z","tags":null},"/012.%E4%B8%8D%E5%90%8C%E6%95%B0%E6%8D%AE%E6%95%B0%E7%B1%BB%E5%9E%8B%E5%8D%A0%E7%94%A8%E5%A4%A7%E5%B0%8F":{"title":"","content":"|类型|占用字节数量|\n|--|--|\n|byte|1|\n|short|2|\n|int|4|\n|long|8|\n|--|--|\n|float|4|\n|doubl|8|\n|boolean|1|\n|char|2|","lastmodified":"2022-09-20T05:41:06.454325385Z","tags":null},"/013-.%E6%8E%A5%E6%94%B6%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5":{"title":"","content":"# 接收方法\n1. 导包方式\n\t```java\n\t\timport java.util.Scanner;\n\t```\n\t定义键盘扫描对象\n```java\n\tScanner s=new Scanner(System.in);\n\tint a=s.nextInt() //接收用户输入的整型变量\n---\n2. 直接在对应内容中定义*输入扫描器*对象\n```java\n\tjava.util.Scanner s=new java.util.Scanner(System.in);\n\tint a=s.nextInt()\n```\t\t\n# 接收不同的数据格式\n```java \n\tint a=s.nextInt(); //整型\n\tlong l=s.nextLong(); //长整型\n\tfloat f=s.nextFloat();//浮点型\n\tdouble d=s.nextDouble();//双精度浮点数\n\tboolean b=s.nextBoolean();//布尔\n\t\n//字符串类型\n\tString str=s.next();//空格或者换行结束输入\n\tString str=s.nextLine();//以换行结束输入，更香一点，但我不习惯用\n```","lastmodified":"2022-09-20T05:41:06.454325385Z","tags":null},"/014.%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8":{"title":"","content":"```java\n\tpublic class Tmp {\n\n    public static void main(String[] args) {\n\n        Dayin.dayin();//跨类调用，在前面加上类名.\n\n    }\n\n}\n\n\n\nclass Dayin {\n\n    public static void dayin(){\n\n        System.out.println(\"打印1\");\n\n    }\n\n}\n```\n1. 在定义class的时候，**每一个文件最多只能有一个公开的public 类（class）**\n2. 在一个类中，需要调用其他方法，可以直接采用 `方法名(参数列表)`的方式去进行调用\n3. **如果不在一个类中**，则需要在前面加入**类名.**才能进行调用，如Dayin.dayin()\n4. 方法可以不返回值，也可以返回值不进行接收。当不需要进行返回的时候，可以使用void对返回值类型进行定义。\n5. **调用方法不一定用main方法去进行调用，也可以通过别的方法去简洁进行调用，采用多个方法可以将过程层次化，调用和组装心方法更加简单。**\n","lastmodified":"2022-09-20T05:41:06.454325385Z","tags":null},"/015.break%E5%92%8Creturn%E7%9A%84%E5%8C%BA%E5%88%AB":{"title":"","content":"break用于停止循环和switch\nreturn用于返回一个方法的返回值，用即停止这个方法，**不会执行后面的语句**\n\n**return 不负责运行程序，只负责讲道理。对于不能百分之百能够返回值的方法，都会编译错误**","lastmodified":"2022-09-20T05:41:06.454325385Z","tags":null},"/016.%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E5%8F%98%E5%8C%96":{"title":"","content":"# 基本\n局部变量 只在方法体重有效，方法借宿之后，局部变量就释放了。局部变量一般在循环中或者方法函数中。\nJVM中有三块主要的内存：**栈内存**、**堆内存**、**方法区内存**\n堆\n## 栈\n\u003e栈：方法函数调用的时候，方法所需要的内存在栈中进行分配。!\n\n![[Pasted image 20220628094821.png]]\n如图，由于栈是先进后出，所以在依次嵌套的方法函数调用的时候，**最先调用的函数，最后结束**，符合栈的先进后出\n\n\u003e调用的时候在栈中**分配空间**，叫压栈push\n\u003e结束的时候，**内存释放**，叫弹栈pop","lastmodified":"2022-09-20T05:41:06.454325385Z","tags":null},"/017.%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BDoverload":{"title":"","content":"## 用途\n\u003e 主要用在多个具有相似功能的方法函数中\n\u003e 通过将方法函数名称设置为相同，由java自己通过参数列表去判断执行具体的哪一个方法\n\u003e 让代码更加美观\n\n## 执行重载的条件\n1. 方法名称相同\n2. 参数列表**不同** （也就是形参列表）\n\t\u003e    参数的**个数**不同\n\t\u003e   参数的**顺序**不同\n\t\u003e   参数的****不同\n\n**只要能够让java编译器能够区分具体执行哪个方法的参数列表就行**\n## 注意\n\u003e **在同一个类中的方法，才叫重载**\n\u003e 重载和返回值类型无关，主要是根据形参列表去判断是否是重载的方法函数","lastmodified":"2022-09-20T05:41:06.454325385Z","tags":null},"/021.%E9%80%92%E5%BD%92":{"title":"","content":"1. 递归方法必须有结束条件，否则就会`栈溢出错误`，因为**没有结束的条件**，递归会一直不断地执行新的自己的方法，导致栈溢出。\n2. 递归有结束条件，但也会发生栈溢出，因为递归太深了，自身的栈内存不够用了，一直不断地压栈。\n3. 递归不断的循环，可能会导致JVM死掉，**非常耗费内存**\n4. **能用for或者while替换，尽量不用递归**\n\n## 书写思路\n1. 如何进入循环的，比如阶乘，是根据此一个值去乘以-1之后的方法，然后再加上自己自己本身，`sum(n-1)+1`\n2. 更重要的是停止方法的条件，如何将自己停止，一般是需要返回值，特殊的条件是什么样的，返回什么值。\n\t```java\n\tif(a!=0) {\n\n\t\t\t   sum(a);\n\n\t\t\t}\n\t```\n\n---\n如果栈溢出怎么解决\n\u003e 检查递归结束条件\n\u003e 手动调整JVM的栈内存，调大点\n\u003e 继续扩大栈内存大小\n\n\n求1+到n\n```java\n    public static int dgSum(int a) {\n\n        if(a!=0) {\n\n           sum(a);\n\n        }\n\n        return sum(a);\n\n    }\n```\n\n或者\n```java\n    public static int sum(int n) {\n\n        if (n==0) {\n\n            return 0;\n\n        }\n\n        return sum(n-1)+n;\n\n    }\n```","lastmodified":"2022-09-20T05:41:06.454325385Z","tags":null},"/022.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B":{"title":"","content":"## 常见语言\nC是面向过程\nC++是一般面向过程，一般面向对象\njava是完全面向对象\n\n## 面向过程\n1. 面向过程注重步骤，注重实现这个功能的因果关系，每一步之间的因果关系，联系形成子模块，**耦合度高**，**扩展能力就差**\n2. 对于小型项目，面向过程方便直接开发，效率高，快速开发\n\n## 面向对象\n1. 面向对象符合人类的思维方式，将世界分割成不同的单元形成驱动，然后驱动各个对象，形成一个系统\n2. **耦合度低**，**扩展能力强**\n3. **三大特征**：封装 继承 多态 ^sandatezheng\n\t有了封装才能说继承，有了继承，才能说多态 ^c344fe\n\n\n\u003e 当我们采用面向对象的方式贯穿系统，需要\n\u003e OOA 面向对象分析\n\u003e OOD 面向对象设计\n\u003e OOP 面向对象编程\n","lastmodified":"2022-09-20T05:41:06.454325385Z","tags":null},"/023.%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB":{"title":"","content":"## 简要\n类是抽象的概念，好像一个**模板**\n对象是一个实际存在的个体，对象的另一个名称就是**“实例”**\n通过类创建对象的过程，称为**“实例化”**\n根据多个对象的**共同属性**抽取形成的概念，叫做**“抽象”**\n```mermaid\ngraph LR\n\tl1(对象)\n\tl2(类)\n\tl1--抽象--\u003el2\n\tl2--实例化--\u003el1\n```\n \n\n## 举例\neg\n\u003e 明星是一个类\n\u003e 宋小宝，姚明就是一个实际的对象\n## 注意\n在java中，必须先定义“类”，才能够创建“对象”\n类就是一个模板，描述类中所有对象的共同特征或者属性\n\n## 定义类\n类一般包括了对象的属性特征，以及对象的方法\n比如\n```java\npublic class Student(){\n\t姓名\n\t性别\n\t身高\n\t\t\n\t打篮球(){\n\t}\n\t唱歌(){\n\t}\n\t跳舞(){\n\t}\n\trap(){\n\t}\n}\n```\n\n```java\npublic class Test(){\n\tpublic static void main(String[] args){\n\t\tStudent s=new Student();\n\t\t\n\t}\n}\n```\n\n\u003e **方法体中**的生命变量叫做**局部变量**，s.身高，s.性别就是局部变量\n\u003e **方法体外,类体内定义**的变量，叫做**成员变量**，也就是类体中（class中）的属性变量，实例变量不能用类名去访问，必须创建对象之后，通过对象去进行访问","lastmodified":"2022-09-20T05:41:06.454325385Z","tags":null},"/024.%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA":{"title":"","content":"## 创建对象\n通过`new`来创建一个对象\n对象存储在**“堆”**当中\n\u003e 堆内存中存储对象，以及对象的实例变量\n\u003e **实例变量就是对象变量，也就是对象的属性，例如student.name**\n\n局部变量存储在**栈内存**中\n```java\n\t类名 变量名=new 类名();\n```\n\n\u003eJava中所有的类，都是一个数据类型，且都是引用数据类型\n\u003e一般在进行调用的时候，是调用的对象的地址，而不是对象本身。\n\u003e比如 在`Student s=new Student();`中，进行调用s的时候，是对其s的对象地址进行调用，而不是对象本身，所以类都是引用数据类型的。\n1. 抽象一个学生类，定义其中的属性\n\t```java\n\tpackage a001对象的创建;\n\tpublic class Student {\n\t\tint xueHao;\n\t\tString xingMing;\n\t\tint nianLing;\n\t\tboolean xingBie;\n\t\tString zhuZhi;\n\n\t}\n\t```\n2. 通过定义的类，来创建一个对象\n\t```java\n\tpackage a001对象的创建;\n\n\tpublic class StudentTest {\n\n\t\tpublic static void main(String[] args) {\n\n\t\t\tStudent s=new Student(); //实例化之后的对象，通过s引用s所在的对象，s是对象的地址，并不是对象本身\n\n\t\t}\n\n\t}\n\t```\n\n## 编译过程\n1. 在编译`StudentTest.java`的过程时，按理来说，是先编译类文件`Student.java`，然后才编译`StudentTest.java`文件\n2. 但是现在的编译器已经做到能够自己去寻找其中所定义的类，所以可以直接编译`Student.java`文件，编译器会**自动**去查找Student类所属的文件对其进行编译\n---\n## 对实例化变量进行赋值\n```java\n\t        //对实例变量进行赋值\n\n        iKun.xingMing=\"蔡徐坤\";\n\n        iKun.xingBie=true;\n\n        iKun.nianLing=24;\n\n        iKun.xueHao=20191045;\n\n        iKun.zhuZhi=\"基尼太美星球\";\n\n        //对实例对象的变量进行打印\n\n        System.out.println(\"姓名：\\t\"+iKun.xingMing);\n\n        System.out.println(\"性别：\\t\"+iKun.xingBie);\n\n        System.out.println(\"年龄：\\t\"+iKun.nianLing);\n\n        System.out.println(\"学号：\\t\"+iKun.xueHao);\n\n        System.out.println(\"地址：\\t\"+iKun.zhuZhi);\n```\n![[../../../../asset/Pasted image 20220629202044.png]]\n\n## 对实例化对象进行赋值\n```java\n    public static void main(String[] args) {\n\n        User 蔡徐坤=new User();\n\n        System.out.println(\"蔡徐坤进行赋值前：\");\n\n        System.out.println(\"id:\\t\\t\"+蔡徐坤.id);\n\n        System.out.println(\"name:\\t\\t\"+蔡徐坤.username);\n\n        System.out.println(\"address:\\t\"+蔡徐坤.addr);\n\n  \n\n        //对蔡徐坤实例变量进行赋值\n\n        //赋值User类中的属性\n\n        蔡徐坤.id=123;\n\n        蔡徐坤.username=\"蔡徐坤太美\";\n\n        //首先实例化一个Address对象\n\n        Address cxkAdd=new Address();\n\n        cxkAdd.city=\"上海市\";\n\n        cxkAdd.street=\"松江区北松公路\";\n\n        cxkAdd.zipcode=\"201600\";\n\n  \n\n        //将实例化cxkAdd的Address赋值给 蔡徐坤 对象的add属性\n\n        蔡徐坤.addr=cxkAdd;\n\n        //也可以采用 蔡徐坤.addr.city对实例化对象的属性进行赋值\n\n  \n\n        // 对其进行输出\n\n        System.out.println(\"蔡徐坤进行赋值前：\");\n\n        System.out.println(\"id:\\t\\t\"+蔡徐坤.id);\n\n        System.out.println(\"name:\\t\\t\"+蔡徐坤.username);\n\n        System.out.println(\"address:\\t\"+蔡徐坤.addr.city+蔡徐坤.addr.street+蔡徐坤.addr.zipcode);\n\n  \n\n    }\n```\n\t\n![[../../../../asset/Pasted image 20220629223003.png]]\n对象必须通过`引用.`去引用\n\n## 内存图绘画\n![[../../../../asset/无标题-2022-06-28-0956.excalidraw.png]]\n\u003e 在对象进行赋值的时候，只是将对象的内存地址引用例如`“0x1234”`赋值给了新的实例变量，而不是将对象复制了给它\n```java\n        Address cxkAdd=new Address();\n\n        cxkAdd.city=\"上海市\";\n\n        cxkAdd.street=\"松江区北松公路\";\n\n        cxkAdd.zipcode=\"201600\";\n\n  \n\n        //将实例化cxkAdd的Address赋值给 蔡徐坤 对象的add属性\n\n        蔡徐坤.addr=cxkAdd;\n        System.out.println(蔡徐坤.addr);\n\n        System.out.println(cxkAdd);\n```\n\n![[../../../../asset/Pasted image 20220630100420.png]]\n打印对象地址函数`System.identityHashCode(类名.对象)`\n```java\n        System.out.println(System.identityHashCode(蔡徐坤.addr));\n\n        System.out.println(System.identityHashCode(cxkAdd));\n\n```\n输出结果\n```cmd\n292938459\n292938459\n```\n\n由上可知打印的是同一个引用地址","lastmodified":"2022-09-20T05:41:06.454325385Z","tags":null},"/025.%E7%A9%BA%E6%8C%87%E9%92%88%E5%BC%82%E5%B8%B8":{"title":"","content":"\n## 基本\n\u003e “空引用”访问实例（对象相关）的数据，都会出现空指针异常。\n\u003e 当一个java对象没有任何的引用指向该对象时，垃圾回收期GC就会将该垃圾数据释放回收掉。\n\u003e 垃圾回收主要针对与**堆内存**的数据进行回收\n\n## 举例\n定义一个垃圾类，创建垃圾对象l1，对l1进行引用置空，出现空指针异常\n1. 创建类`Laji`\n\t```java\n\tpackage a001对象的创建;\n\tpublic class Laji {\n\t\tint id;\n\t\tString name;\n\t}\n\t```\n1. 创建垃圾对象`l1`\n\t```java\n\tpackage a001对象的创建;\n\tpublic class LajiTest {\n\t\tpublic static void main(String[] args) {\n\t\t\tLaji l1=new Laji();\n\t\t\tl1.id=001;\n\t\t\tl1.name=\"垃圾1\";\n\t\t\t//对垃圾l1所指向对象的属性进行输出\n\t\t\tSystem.out.println(l1.id+\"\\t\"+l1.name);\n\t\t\t//将l1的指向置空\n\t\t\tl1=null;\n\t\t\t//再进行输出属性\n\t\t\tSystem.out.println(l1.id+\"\\t\"+l1.name);\n\t\t}\n\t}\n\t```\n3. 输出结果为\n\t```CMD\n\t\t1       垃圾1\n\t\tException in thread \"main\" java.lang.NullPointerException\n        at a001对象的创建.LajiTest.main(LajiTest.java:13)\n\t```\n\t\n\u003e 由此可见出现了空指针异常的情况`java.lang.NullPointerException`，原因就是因为对l1所引用的对象内存地址置空了，对象l1所引用的对象没有了引用，就变成了类似于幽灵的状态，而l1页没有了具体的引用，所以就出现了空指针异常。需要进行**垃圾回收**，将之前l1所指向的对象进行回收.\n\u003e **当new的实例化对象引用被置空，那么访问这个被置空引用内的对象属性就会出现空指针异常**\n![[../../../../asset/空指针异常.png]]","lastmodified":"2022-09-20T05:41:06.454325385Z","tags":null},"/026.%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E6%97%B6%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92":{"title":"","content":"## 形式参数\n```java\n\tpublic class Cscd {\n    public static void main(String[] args) {\n        int i=10;\n        add(i);\n        System.out.println(\"i--\u003e\"+i);\n    }\n    public static void add(int i){\n        i++;\n        System.out.println(\"i--\u003e\"+i);\n    }\n}\n```\n输出结果\n```cmd\n\ti--\u003e11\n\ti--\u003e10\n```\n\n\u003e 将i传入到add方法中的形参i，通过i++之后输入11，但是在main方法中，再次进行输出i却还是10\n\u003e 原因是因为main方法中的i是实际参数，而add方法的i是形式参数，两个是重名的不同的两个引用，所以并没有改变main方法中的i值\n\u003e 如果需要改变i方法中的i，可以在main方法中进行赋值操作`i=add(i);`,同时将方法add()改为int返回值类型，最后在add方法中进行return返回增加之后的值\n```java\n\tpublic class Cscd {\n\n    public static void main(String[] args) {\n\n        int i=10;\n\n        i=add(i);\n\n        System.out.println(\"i--\u003e\"+i);\n\n    }\n\n    public static int add(int i){\n\n        i++;\n\n        System.out.println(\"i--\u003e\"+i);\n\n        return i;\n\n    }\n\n}\n```\n修改之后输出结果\n```cmd\n\ti--\u003e11\n\ti--\u003e11\n```","lastmodified":"2022-09-20T05:41:06.454325385Z","tags":null},"/031.%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95":{"title":"","content":"## 概念\n构造方法的作用：\n\u003e 构造方法就是用来**构造对**象，并对**对象属性进行初始化赋值**的特殊方法\n1. 比较特殊的方法\n1. 构造方法是一个比较特殊的方法，通过**构造方法可以完成对象的创建，以及实例变量的初始化**\n1. 作用**相当于使用函数去创建对象，同时对实例化对象进行赋值**\n1. 方法就类似于函数，不要在其中添加class\n1. 构造方法可以有**多个**，当参数列表不同，**支持方法重载**\n\n\n## 格式\n构造方法语法格式：\n```java\n 修饰符列表 方法名(形式参数){\n \t方法体;\n }\n```\n**使用`new 方法名`进行调用**\n\n普通语法语法格式：\n```java\n修饰符列表 返回值类型 方法名(形式参数){\n\t方法体;\n}\n```\n直接使用方法名进行调用\n\n\n## eg\n构造方法\n```java\npackage a003构造方法;\n\n  \n\npublic class Student {\n\n    int id;\n\n    String name;\n\n    public Student(){ //必须使用和类名相同的方法名Student\n\n        System.out.println(\"我是一个无参数的构造方法\");\n\n    }\n\n}\n```\n\n普通方法，以及对两种方法的调用\n```java\npackage a003构造方法;\npublic class ConstructorTest {\n    public static void main(String[] args) {\n        System.out.println(\"普通方法\");\n        //普通方法，直接进行方法名调用\n        noneGz();\n        //构造方法，使用new进行调用\n        new Student();\n    }\n    public static void noneGz() {\n        System.out.println(\"我是一个无参数普通方法\");\n    }\n}\n```\n输出结果\n```cmd\n普通方法\n我是一个无参数普通方法\n我是一个无参数的构造方法\n```\n\n","lastmodified":"2022-09-20T05:41:06.454325385Z","tags":null},"/032.%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9":{"title":"","content":"## 注意\n1. 修饰符列表目前统一使用public,**不要使用public static**\n2. **构造方法名与类名保持一致**\n3. 构造方法不需要指定返回值类型\n4. 当一个类中**手动的提供了有参数的构造方法**，那么**系统就不再提供无参数的构造方法**\n5.当一个类中没有提供任何构造方法，系统会提供一个默认的构造方法\t\n\t```java\n\t\t\tSystem.out.println(new Student());\n\t```\n\t输出显示\n\t```cmd\n\ta003构造方法.Student@7de26db8\n\t```\n\t没有定义student()构造方法，但是依旧会有默认的缺省构造器可以使用 ^2dca02\n6. 在编译的时候，如果构造方法的名称和类名不一致，那么编译器会认为其是普通方法，但是没有写返回值，会报错。\n\n\u003e [!todo]- 注意点\n\u003e[[#^2dca02|手动的提供构造方法]]之后，原来的无参数构造方法就**不存在**了，所以建议在建立类的时候，建议将[[033.构造方法举例#^wcgz001|无参数构造方法]]进行书写，避免编译和调用错误\n","lastmodified":"2022-09-20T05:41:06.454325385Z","tags":null},"/033.%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E4%B8%BE%E4%BE%8B":{"title":"","content":"构造方法的作用\n\u003e 创建对象，同时将对象的属性进行赋值\n## 对无参数构造方法进行赋值\nuser类\n```java\n\tpublic class User {\n    int id;\n    String name;\n    int age;\n}\n```\nid,age的默认值是0，name的默认值是null，\n\u003e 这个默认值是在实例化对象创建之后才有的默认值，而不是本身就有默认值\n\u003e 也就是说需要`User u1=new User()`之后才有的默认值，必须要先new一个实例化对象，才有默认值。\n\n在进行书写构造方法的时候，**建议书写无参数构造方法**，避免出错\n无参数构造方法，同时可以对其进行默认值赋值，如下 ^wcgz001\n```java\n    public User(){\n\t\t//当你在无参数构造方法中进行赋值，那么就按照设置的默认值创建实例化对象\n\tid=1;\n\tname=\"test\";\n\tage=25;\n    }\n```\n在主方法中使用构造方法创建无参数的对象：\n```java\n        User u1=new User();\n\n        System.out.println(u1.id);\n\n        System.out.println(u1.name);\n\n        System.out.println(u1.age);\n```\n输出\n```cmd\n1\ntest\n25\n```\n\n## 构造方法调用实例\n建立四个不同参数的构造方法\n```java\npackage a003构造方法;\npublic class Vip {\n    long no;\n    String name;\n    String birth;\n    Boolean sex;\n    //无参数构造方法\n    public  Vip() {\n    }\n    //有参数构造方法\n\n    public Vip(long huiYuanHao,String xingMing){\n\n        no=huiYuanHao;\n\n        name=xingMing;\n\n    }\n\n  \n\n    //三个参数的构造方法\n\n    public Vip(long huiYuanHao,String xingMing,String shengRi){\n\n        no=huiYuanHao;\n\n        name=xingMing;\n\n        birth=shengRi;\n\n    }\n\n  \n\n    // 四个参数的构造方法\n\n    public Vip(long huiYuanHao,String xingMing,String shengRi,boolean xingBie){\n\n        no=huiYuanHao;\n\n        name=xingMing;\n\n        birth=shengRi;\n\n        sex=xingBie;\n\n    }\n\n}\n```\n在main方法中，调用不同的构造方法，并输出结果\n```java\npublic class VipTest {\n\n    public static void main(String[] args) {\n\n        //调用无参数的构造方法\n\n        Vip v1 = new Vip();\n\n        System.out.println(v1.no+\"\\t\"+v1.name+\"\\t\"+v1.birth+\"\\t\"+v1.sex);\n\n        //两个参数\n\n        Vip v2 = new Vip(1l,\"蔡徐坤\");\n\n        System.out.println(v2.no+\"\\t\"+v2.name+\"\\t\"+v2.birth+\"\\t\"+v2.sex);\n\n        //三个参数\n\n        Vip v3 = new Vip(002l,\"张家阿三\",\"不知道\");\n\n        System.out.println(v3.no+\"\\t\"+v3.name+\"\\t\"+v3.birth+\"\\t\"+v3.sex);\n\n        //四个参数\n\n        Vip v4 = new Vip(4l,\"阿四\",\"周四\",true);\n\n        System.out.println(v4.no+\"\\t\"+v4.name+\"\\t\"+v4.birth+\"\\t\"+v4.sex);\n\n    }\n\n}\n```\n输出结果\n![[../../../../asset/Pasted image 20220701162905.png]]","lastmodified":"2022-09-20T05:41:06.454325385Z","tags":null},"/034.%E5%A4%AB%E5%A6%BB%E7%BB%93%E5%A9%9A":{"title":"","content":"```java\npackage day14作业;\n\npublic class Handw {\n    public static void main(String[] args) {\n        // 创建丈夫对象蔡徐坤\n        Husband cxk = new Husband(\"1234\",\"蔡徐坤\",\"1998年8月2日\",null);\n\n        // 创建妻子对象篮球\n        Wife basketball=new Wife(\"1235\",\"篮球\",\"1928年5月2日\",null);\n\n\n        //开始结婚\n        cxk.wife=basketball;\n        basketball.husband=cxk;\n        // 输出\n        System.out.println(basketball.name+\"的丈夫是\\t\"+basketball.husband.name);\n        System.out.println(cxk.name+\"的妻子是\\t\"+cxk.wife.name);\n    }\n}\nclass Husband{\n    String idCard;\n    String name;\n    String birth;\n    Wife wife;\n    //构造方法\n    public Husband(){\n\n    }\n    public Husband(String idCard,String name,String birth,Wife wife){\n        this.idCard=idCard;\n        this.name=name;\n        this.birth=birth;\n        this.wife=wife;\n    }\n}\nclass Wife{\n    String idCard;\n    String name;\n    String birth;\n    Husband husband;\n\n    //构造方法\n    public Wife(){\n\n    }\n    public Wife(String idCard, String name, String birth, Husband husband) {\n        this.idCard = idCard;\n        this.name = name;\n        this.birth = birth;\n        this.husband = husband;\n    }\n}\n\n```\n输出结果\n![[../../../../asset/Pasted image 20220703170404.png]]","lastmodified":"2022-09-20T05:41:06.454325385Z","tags":null},"/041.%E5%B0%81%E8%A3%85":{"title":"","content":"## [[../02基本/022.面向对象和面向过程#^c344fe|封装]]的作用\n\u003e[!作用]\n\u003e保证内部结构的安全性\n\u003e屏蔽复杂，暴露简单\n\n## 怎么进行封装 ^zmfg\n1. **属性**私有化`private`\n2. 创建简单的访问入口:对外提供公开的set和get方法作为**实例方法**,一个属性对外提供两个实例方法（get和set），同时可以对其的set实例方法设立关卡，满足什么条件才set。  ^cjjddfwrk\n\tget方法：\n\t\t```java\n\t\tpublic 返回值类型 get+属性名首字母大写(无参数){\n\t\t\treturn xxx;\n\t\t}\n\t\t```\n\tset方法：\n\t\t```java\n\t\tpublic void set+属性名首字母大写(类型 xxx){\n\t\t\tthis.xxx=xxx;\n\t\t}\n\t\t``` ^e24f40","lastmodified":"2022-09-20T05:41:06.454325385Z","tags":null},"/042.%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95":{"title":"","content":"\u003e[!概要]\n\u003e与实例相关的有：实例变量，实例方法\n\u003e实例变量就是**对象变量**，实例方法就是**对象方法**\n\u003e实例相关的都需要先`new`对象，通过**引用**的方式进行访问\n\u003e**实例变量**相当于一个对象，需要我们自己创建一个对象实例来对其进行引用，才能够使用。每次创建一个实例变量，JVM就会为实例变量分配内存\n\u003e也就是实例方法必须通过`实例对象.`去进行调用\n\n语法格式\n相当于普通方法去掉`static`修饰符\n```java\npublic void 方法名(){\n\t方法体\n}\n```\n\n## 举例\n```java\npublic class Shilifangfa {\n\n    public static void main(String[] args) {\n\t\t\n        // 在进行普通方法调用时，通过.方法名进行调用\n        Shilifangfa.daYin1();\n        System.out.println(\"-----------------\");\n\n        // 进行实例方法进行调用的时候，需要先new一个对象给实例方法，再通过 对象. 的方式对其进行调用\n        Shilifangfa dy=new Shilifangfa();\n        dy.daYin2();\n    }  \n\t\n    // 普通方法\n    public static void daYin1() {\n        System.out.println(\"普通方法\");\n    }\n\n    // 实例方法\n    public void daYin2() {\n        System.out.println(\"实例方法\");\n\n    }\n}\n```\n\n输出\n```cmd\n普通方法\n-----------------\n实例方法\n```\n\n\u003e[!关键]\n\u003e实例方法必须要有对象作为支撑，如果没有对象，那么它就相应的不存在\n\u003e实例方法不加static，即动态方法\n\u003e动态方法（实例方法）必须有对象支撑，且通过对象才能使用，而静态方法可以全局使用（前提是public）\n\n## 相关\n![[../05this和static关键字/1static相关/054.实例方法的调用]]","lastmodified":"2022-09-20T05:41:06.454325385Z","tags":null},"/043.%E4%B9%A6%E5%86%99%E6%A0%BC%E5%BC%8F":{"title":"","content":"## Java的封装[[041.封装#^zmfg|格式]]举例\n## 对java对象的属性进行私有化\n```java\npulic class Person{\n\tprivate int age;//private私有化修饰符\n\tprivate String name;\n}\n```\n## [[041.封装#^e24f40|对外提供get和set公开入口]]\n```java\npulic class Person{\n\tprivate int age;//private私有化修饰符\n\n\t\n\tpublic int getAge(){//获取，需要返回值\n\treturn age;\n\t}\n\tpublic void setAge(int nianLing){//修改，不需要返回值\n\t\tage=nianLing;\n\t}\n}\n```\n以上的get和set方法都没有加`static`修饰符，因为其为**实例方法**，需要依赖于生成的对象，没有对象，就不知道设置谁的属性了，这样才符合规律。没有person对象，设置年龄没用。\n## 进行调用\n```java\n        Person per1 = new Person();    \n\n        per1.setName(\"蔡徐坤\");\n\n        System.out.println(per1.getName());\n```\n输出结果\n```cmd\n蔡徐坤\n```","lastmodified":"2022-09-20T05:41:06.454325385Z","tags":null},"/051.%E5%AE%9E%E4%BE%8B%E4%BB%A3%E7%A0%81%E5%9D%97":{"title":"","content":"## 语法格式\n```java\n\t{\n\tjava 语句;\n\t}\n```\n## 作用\n\u003e[!作用]\n\u003esun公司为程序员准备的特殊时机：**对象创建时机**；\n\u003e实例代码块，会在构造方法前执行，只要**构造方法创建对象**，就会在**对象创建之前执行实例代码块**；\n\u003e如果每个构造方法中都有相同的部分，可以将相同的部分放在实例代码块中，这样每次执行new对象的时候，都可以通过实例代码块执行内容。\n\n## eg\n```java\npackage a005StaticAndthis;\n\npublic class a05ShiliDaimakuai {\n    public static void main(String[] args) {\n        System.out.println(\"main开始执行：\");\n        a05ShiliDaimakuai c1 = new a05ShiliDaimakuai();//创建对象\n        a05ShiliDaimakuai c2 = new a05ShiliDaimakuai(\"sds\");//创建对象\n\n        \n\n        \n    }\n    //无参数构造方法\n    public a05ShiliDaimakuai() {\n        System.out.println(\"开始使用无参数构造方法\");\n    }\n    //有参数构造方法\n    public a05ShiliDaimakuai(String name){\n        System.out.println(\"开始使用有参数的构造方法\\t\"+name);\n\n    }\n\n}\n\n```\n输出结果\n![[../../../../../asset/Pasted image 20220703105401.png]]\n\u003e[! ]\n\u003e由此可见，每次new对象的时候，就会率先执行实例代码块中的内容，通过实例代码块可以直观的看到创建对象时机\n\n\n","lastmodified":"2022-09-20T05:41:06.454325385Z","tags":null},"/051.%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97":{"title":"","content":"## 执行\n1. **类加载时**执行，在**main方法前执行**\n2. 只执行一次\n3. 常常用于记录程序类加载到JVM中的日志\n4. 自上而下执行\n5. 允许多个静态代码块\n6. 是一个特殊时机：**类加载时机**\n\n\n## 语法格式\n```java\nstatic{\n\tjava 语句;\n\tjava 语句;\n}\n```\n\n## eg\n![[../../../../../asset/Pasted image 20220702221730.png]]\n由上图可以**即使将静态代码块写在main方法后面，依旧只是在类加载时，main方法执行前加载**\n\n一般只写一个静态代码块，用来记录类加载时机的日志，因为其每次只在类加载时加载一次，所以不会反复加载。（废物文学）\n静态代码块与静态变量是有顺序的。eg忘了","lastmodified":"2022-09-20T05:41:06.454325385Z","tags":null},"/051.static":{"title":"","content":"1. static翻译“静态”\n2. static修饰的都是类相关的，class级别的\n3. static修饰的，都可以直接采用`类名.`进行访问\n4. static修饰的变量：静态变量\n5. static修饰的方法：[[052.静态方法和实例方法|静态方法]]\n\n\u003e[!变量的分类]\n\u003e根据声明的位置分为\n\t\u003e1. 方法体中的变量：局部变量\n\t\u003e2. 方法体外的变量：成员变量\n\t\t\u003e成员变量又分为：\n\t\t\t\u003e实例变量：需要通过[[../../02基本/024.对象的创建|创建对象]]来进行调用\n\t\t\t\u003e静态变量：可以直接使用，**没有空指针异常的情况发生**\n\n","lastmodified":"2022-09-20T05:41:06.454325385Z","tags":null},"/051.static%E5%8F%98%E9%87%8F":{"title":"","content":"## 不声明static时\n```java\npublic class a02Chinese {\n    public static void main(String[] args) {\n        Chinese c1=new Chinese(\"521\",\"张三\",\"Chinese\");\n        Chinese c2=new Chinese(\"522\",\"李四\",\"Chinese\");\n        //输出\n        System.out.println(c1.idCard);\n        System.out.println(c1.name);\n        System.out.println(c1.country);\n        System.out.println();\n        System.out.println(c2.idCard);\n        System.out.println(c2.name);\n        System.out.println(c2.country);\n    }\n}\nclass Chinese{\n    String idCard;//身份证号\n    String name;\n    String country;//国家\n    //无参数构造方法\n    public Chinese(){\n\n    }\n    //有参数构造方法\n    public Chinese(String idCard, String name, String country) {\n        this.idCard = idCard;\n        this.name = name;\n        this.country = country;\n    }\n\n\n}\n```\n对于Chinese中国人类的国籍属性中，因为中国人类的国籍都是中国，所以在new对象之后，会重复的创建国籍中国属性\n内存图如图\n![[../../../../../asset/不声明静态变量的时候.png]]\n每次new一个对象，都会在堆内存中新开辟一块地址用于存储country属性，耗内存\n\n输出结果\n```cmd\n521张三\nChinese\n\n522\n李四\nChinese\n```\n\n## 声明static之后\n```java\npublic class a02Chinese {\n    public static void main(String[] args) {\n        Chinese c1=new Chinese(\"521\",\"张三\");\n        Chinese c2=new Chinese(\"522\",\"李四\");\n        //输出\n        System.out.println(c1.idCard);\n        System.out.println(c1.name);\n        //国籍就不能采用实例对象.的方式去进行调用了，而是采用类.方式去调用\n        System.out.println(Chinese.country);\n        System.out.println();\n        System.out.println(c2.idCard);\n        System.out.println(c2.name);\n        System.out.println(Chinese.country);\n    }\n}\nclass Chinese{\n    String idCard;//身份证号\n    String name;\n    static String country=\"Chinese\";//声明静态变量的同时对其进行默认值赋值\n    //无参数构造方法\n    public Chinese(){\n\n    }\n    //有参数构造方法\n    public Chinese(String idCard, String name) {\n        this.idCard = idCard;\n        this.name = name;\n\n    }\n}\n```\nstatic静态变量的同时，对其进行赋值\n内存图\n![[../../../../../asset/静态变量.png]]\n输出结果\n```cmd\n521\n张三\nChinese\n\n522\n李四\nChinese\n```\n\n\u003e[!tips]\n\u003e注意声明静态变量的时候，在之后的构造方法中，就不需要将其加入形参\n\u003e进行调用的方式，采用`类.`方式去进行调用，使用 实例对象.的方式去调用也可以 \n\t![[Pasted image 20220702164519.png]]虽然有报错，但是依旧可以这样调用，只是更加建议采用 `类.` 的方式去调用","lastmodified":"2022-09-20T05:41:06.454325385Z","tags":null},"/052.%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95":{"title":"","content":"```java\npublic class a01Statictest {\n\n    public static void main(String[] args) {\n\n    daYin1();//直接调用\n\n  \n\n    // 实例方法\n\n    a01Statictest dd = new a01Statictest();//创建该类的实例化对象\n\n    dd.daYin2();    //调用\n\n    }\n\n    // 静态方法\n\n    public static void daYin1(){\n\n        System.out.println(\"静态方法可以直接调用\");\n\n    }\n\n  \n\n    // 实例方法\n\n    public void daYin2(){\n\n        System.out.println(\"实例方法需要先创建对象，对 对象.进行调用\");\n\n    }\n\n}\n```\n静态方法和实例方法的 调用方法不同\n静态方法可以直接进行调用，而实例方法需要通过创建对象，对对象.的方法进行调用实例中的方法","lastmodified":"2022-09-20T05:41:06.454325385Z","tags":null},"/053.%E7%A9%BA%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E9%9D%99%E6%80%81%E4%B8%8D%E4%BC%9A%E7%A9%BA%E6%8C%87%E9%92%88":{"title":"","content":"![[../../../../../asset/Pasted image 20220702164751.png]]\n即使将对象置空，引用静态变量，依旧不会出现空指针异常，\n因为静态变量不依赖于对象的建立，而是类级别的，类相关的","lastmodified":"2022-09-20T05:41:06.454325385Z","tags":null},"/054.%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8":{"title":"","content":"调用实例方法的原则\n类=属性+方法\n\n实例变量，需要对象\n所以**当方法需要由对象触发，就需要定义为实例方法**\n## 相关\n![[../../04封装/042.实例方法]]","lastmodified":"2022-09-20T05:41:06.454325385Z","tags":null},"/055.%E4%B8%8D%E5%90%8C%E4%BB%A3%E7%A0%81%E5%9D%97%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F":{"title":"","content":"\n代码\n```java\npackage a005StaticAndthis;\n\npublic class A06DaimaShunxu {\n    // 静态代码块\n    static{\n        System.out.println(\"静态代码块A\");\n    }\n    public static void main(String[] args) {\n        System.out.println(\"main主方法\");\n        A06DaimaShunxu d = new A06DaimaShunxu();\n    }\n\n    //构造方法\n    public A06DaimaShunxu(){\n        System.out.println(\"无参构造方法A\");\n    }\n    {\n        System.out.println(\"实例代码块A\");\n    }\n    static{\n        System.out.println(\"静态代码块B\");\n    }\n}\n\n```\n---\n输出结果\n![[../../../../../asset/Pasted image 20220703110707.png]]\n---\n由此可见\n1. 当类加载的时候，会最先执行静态代码块，自上而下\n2. 然后执行main主方法中的代码\n3. 如果遇到构造方法的时候，那么就会在构造方法的之前执行实例代码块的内容，然后再构造对象","lastmodified":"2022-09-20T05:41:06.454325385Z","tags":null},"/056.this%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84":{"title":"","content":"```java\npackage a005StaticAndthis.This;\n\npublic class B01nc {\n    public static void main(String[] args) {\n        Customer c=new Customer(\"张三\");\n        Customer c2=new Customer(\"李四\");\n\n        c.shopping();\n        c2.shopping();\n    }\n}\nclass Customer{\n    String name;//属性\n\n    //构造方法\n    public Customer(){}\n    // 有参构造方法\n    public Customer(String s){\n        name=s;\n    }\n\n    //顾客购物的方法\n    //实例方法\n    public void shopping(){\n        System.out.println(name+\" 正在购物！\");\n    }\n}\n\n\n```\n内存图如图所示\n![[../../../../../asset/this关键字内存.png]]\n\n\n\u003ethis保存在堆内存中对象自身内部，并且执行自身的内存地址\n\u003e相当于每个对象都有自己的this属性，这个属性保存的是对象在堆内存中的地址\n\u003e**this代表的是当前对象在内存中的地址，调用那个实例对象，this就是那个实例对象的内存地址**\n\n## 什么时候this不能省略\n当采用实例方法的时候，局部变量与对象的属性名字一样的时候，不能省略this\n如下\n```java\nclass Book{\n    private String title;\n    private int page;\n\n    //提供实例方法进行封装\n      public String getTitle() {\n        return title;\n    }\n\n    public void setTitle(String title) {\n        this.title = title;\n    }\n}\n```\n当局部变量的title与所创建对象的属性名称一样的时候，在进行赋值的时候，必须在前面的实例对象属性前加上`this.`，否则赋值无效\n\u003e[!作用]\n\u003e \"this.\" 相当于 “这个实例对象的”\n\u003e 其作用主要是为了在实例方法或者构造方法中区分实例变量与局部变量","lastmodified":"2022-09-20T05:41:07.266338579Z","tags":null},"/057.this%E6%80%BB%E7%BB%93":{"title":"","content":"## 基本\n1. this用于在实例对象中，表示当前对象\n\n1. **this不能用在静态方法中**，因为静态方法是类级别的，不是对象级别的\n1. 静态方法中不存在当前对象，采用`类.`的方式使用静态方法\n\n## 主要作用\n1. 在实例方法或者构造方法中[区分实例变量与局部变量](056.this的内存结构.md#什么时候this不能省略)\n2.  在构造方法中，可以[通过this在无参数构造方法去调用本类的有参数构造方法](060.this无参调有参构造方法.md)","lastmodified":"2022-09-20T05:41:06.454325385Z","tags":null},"/058.this%E4%BE%8B%E5%AD%90":{"title":"","content":"```java\npackage day15作业;\n\npublic class Homework01 {\n    public static void main(String[] args) {\n        Book book1 = new Book(\"高三数学\",126);\n        System.out.println(book1.getTitle());;\n        System.out.println(book1.getPage());\n\n        Book book2 = new Book();\n        book2.setPage(456);\n        book2.setTitle(\"盗墓笔记\");\n        System.out.println(book2.getTitle());\n        System.out.println(book2.getPage());\n\n        System.out.println(\"打印细节\");\n        book1.detail();\n\n    }  \n}\nclass Book{\n    private String title;\n    private int page;\n\n    //提供实例方法进行封装\n      public String getTitle() {\n        return title;\n    }\n\n    public void setTitle(String title) {\n        this.title = title;\n    }\n\n    public int getPage() {\n        return page;\n    }\n\n    public void setPage(int page) {\n        if(page\u003c200){\n            System.out.println(\"本书小于200页,已经设置为200页\");\n            this.page=200;\n            return;\n        }\n        this.page = page;\n    }\n\n    //创建构造方法\n    public Book(){\n        this.page=200;\n\n    }\n    public Book(String title, int page) {\n        this.title = title;\n        if(page\u003c200){\n            System.out.println(\"本书小于200页,已经设置为200页\");\n            this.page=200;\n        }else{\n            this.page = page;\n        }\n\n    }\n    public void detail(){\n        System.out.println(\"教材名称:\"+title+\"\\t教材页数：\"+page);\n    }\n\n    \n\n  \n}\n```\n输出\n![[../../../../../asset/Pasted image 20220704153923.png]]","lastmodified":"2022-09-20T05:41:07.266338579Z","tags":null},"/059.%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%86%E5%B8%83":{"title":"","content":"局部变量、实例变量、静态变量在内存中的分配\n![](../../../../../asset/java变量的分布.png)","lastmodified":"2022-09-20T05:41:06.454325385Z","tags":null},"/060.this%E6%97%A0%E5%8F%82%E8%B0%83%E6%9C%89%E5%8F%82%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95":{"title":"","content":"```java\n    public Date(){\n        // year=1982;\n        // month=12;\n        // day=3;\n        //等同于通过this去调用这个对象的有参数构造方法\n        this(1982,12,3);\n    }\n    public Date(int year,int month,int day){\n        this.year=year;\n        this.month=month;\n        this.day=day;\n    }\n```\n通过this()可以直接在无参数构造方法去调用有参数的构造方法，节省代码编写量\n\n\u003e[!注意]\n\u003ethis()只能出现在构造方法的第一行","lastmodified":"2022-09-20T05:41:06.454325385Z","tags":null},"/061.%E7%BB%A7%E6%89%BF%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5":{"title":"","content":"## 重要\n**除了构造方法，其余的子类都继承，包括实例方法和get set方法都可以继承**\n在进行重新构造构造器的时候，可以通过super关键字快速完成，this.xx=xxx;的语句，比如\n```java\nclass A extends B{\npublic A(String name,int age){\n\tsuper(name,age);\n}\n}\n```\n需要注意的是，**super语句只能放在构造器内部的第一行**\n\n\u003e[!举例]\n\u003e爹很有钱，儿子以后也会有钱，爹的钱没用完\n\n## 作用\n1. 子类继承父类，**代码复用**\n2. 主要作用：有了继承关系，才有后续的方法覆盖和多态\n\n## 语法格式\n```java\n//A为父类，B为子类，B类继承A类\n//除了构造方法之外，无论是实例方法（get，set）还是变量都继承\nclass A{\n}\nclass B extends A{\n}\n```\n\n## 相关特性\n1. B类继承A类，则A类为超类，父类，B为子类，派生类\n2. **java中只支持单继承**，不支持多继承，C++支持多继承\n3. **缺点是耦合度高**，父类修改，那么子类也会受到牵连\n4. java中**除了构造方法之外都能继承，私有的属性（private）无法在子类中直接访问**（父类private修饰的不能在子类中直接访问）\n5. 没有指定父类的class，都默认继承的`Object`,`Object`是所有类的根类。\n\n## eg\n```java\npackage a006继承;\n\npublic class Jicheng {\n    public static void main(String[] args) {\n        Account a1 = new Account(\"zhangsan123\",100);//创建普通账户\n        System.out.println(a1.getAct()+\" 的余额是 \"+a1.getBalance());\n        CreditAccount c1 = new CreditAccount(\"lisi321\",120,100);\n        System.out.println(c1.getAct()+\" 的余额是 \"+c1.getBalance()+\"信誉度： \"+c1.getCredit());\n    }\n}\n\n// 银行卡\nclass Account{\n    private String act;\n    private double balance;\n    // get and set \n    public String getAct() {\n        return act;\n    }\n    public void setAct(String act) {\n        this.act = act;\n    }\n    public double getBalance() {\n        return balance;\n    }\n    public void setBalance(double balance) {\n        this.balance = balance;\n    }\n    // 构造方法\n    public Account(){\n        this(\"\",0);\n    }\n    public Account(String act, double balance) {\n        this.act = act;\n        this.balance = balance;\n    }\n    \n\n}\n\nclass CreditAccount extends Account{\n        private double credit;\n        //get and set\n        public double getCredit() {\n            return credit;\n        }\n\n        public void setCredit(double credit) {\n            this.credit = credit;\n        }\n        //构造方法\n        public CreditAccount(double credit) {\n            this.credit = credit;\n        }\n            //构造方法\n        public CreditAccount(String act, double balance, double credit) {\n            super(act, balance);\n            this.credit = credit;\n        }\n}\n```\n![](asset/Pasted%20image%2020220705215622.png)\n`super`是用来做引用父类的构造方法的。","lastmodified":"2022-09-20T05:41:06.454325385Z","tags":null},"/062.super%E5%85%B3%E9%94%AE%E5%AD%97":{"title":"","content":"在继承关系中，由于在子类的构造方法中，第一条语句默认为调用父类的无参构造方法（即默认为 super();，一般这行代码省略了）。\n\n简单的来说，要想使用父类的那个构造方法，就super它的形参按顺序放进来\t\n\n```java\npublic class Person {\n    public Person(String name, int age) {\n\n    }\n\n    public Person(String name, int age, String sex) {\n\n    }\n}\n```\nz\n```java\n\npublic class Student extends Person {\n    public Student(String name, int age, String birth) {\n        super(name, age); // 调用父类中含有2个参数的构造方法\n    }\n\n    public Student(String name, int age, String sex, String birth) {\n        super(name, age, sex); // 调用父类中含有3个参数的构造方法\n    }\n}\n```\n","lastmodified":"2022-09-20T05:41:06.454325385Z","tags":null},"/063.%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E7%BB%A7%E6%89%BF":{"title":"","content":"凡是可以用“is a”来描述的，都可以考虑采用继承\n## eg\n1. 猪是一个动物\n2. 信用卡是一个银行账户\n\n\u003e[!注意]\n\u003e即使两个类中有相同的代码，也不一定要采用继承\n\u003e比如客户和产品中都有名字，不适合继承的，一是因为不符合常理，难以理解两者的关系，二是因为如果后续在父类中添加字段等等，那么子类也会受到奇怪的牵连","lastmodified":"2022-09-20T05:41:06.454325385Z","tags":null},"/071.%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96override":{"title":"","content":"## 什么时候使用\n子类继承父类之后，当继承的方法无法满足当前子类的业务需求，子类有权利对这个方法进行重新编写，进行方法覆盖。`override`\n## 语法格式\n\n## 编写的结论\n1. 两个类**必须要有继承关系**\n2. 重写之后的方法必须满足的条件**（除了**修饰符列表可以不同**，其他必须完全一样）**\n\t1. **相同的返回值类型**\n\t2. **相同的方法名称**\n\t3. **相同的形式参数列表**\n3. 子类的**访问权限不能更低，可以更高**，比如父类是`public`,那么子类就不能是`protected`**受保护的**，但是相反则可以\n4. **覆盖之后的方法不能比之前的方法抛出更多的异常，可以更少或者没有。**\n\n## 注意事项\n1. 方法覆盖只针对**方法**，和属性（实例对象的属性，就是你定义的那几个字段）无关\n2. **私有方法（private）无法覆盖**\n3. 构造方法不能继承，所以构造方法不能被覆盖\n4. **方法覆盖只能针对实例方法**，静态方法无法覆盖\n\n---\n相关：[017.方法重载overload](../../01铺垫/017.方法重载overload.md)","lastmodified":"2022-09-20T05:41:06.454325385Z","tags":null},"/072.%E8%A6%86%E7%9B%96eg":{"title":"","content":"## 举例\n```java\npackage a007方法覆盖和多态;\n\npublic class Dongwu1 {\n    public static void main(String[] args) {\n        System.out.println(\"动物：\");\n        Animal a1 = new Animal();\n        a1.move();\n\n        System.out.println(\"猴子：\");\n        Monkey m1=new Monkey();\n        m1.move();\n\n        System.out.println(\"鸟儿：\");\n        Bird b1=new Bird();\n        b1.move();\n    }\n}\n\nclass Animal{\n    public void move(){\n        System.out.println(\"动物在移动！\");\n    }\n}\n\n// 猴子类继承animal\nclass Monkey extends Animal{\n    //动物和猴子的移动方式可能不一样，所以需要方法覆盖重写移动方式为爬树\n    public void move(){\n        System.out.println(\"猴子在爬树\");\n    }\n}\n\n// 鸟类继承Monkey\nclass Bird extends Monkey{\n    // 鸟不爬树，飞重写移动方式\n    public void move(){\n        System.out.println(\"鸟儿在飞\");\n    }\n}\n```\noutput\n![](asset/Pasted%20image%2020220706160404.png)","lastmodified":"2022-09-20T05:41:06.454325385Z","tags":null},"/073.%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96%E7%BB%8F%E5%85%B8%E4%BE%8B%E5%AD%90":{"title":"","content":"```java\npackage a007方法覆盖和多态;\n\npublic class Speak {\n    public static void main(String[] args) {\n        People p1=new People(\"人\");\n        p1.speak();\n\n        ChinesePeople c1=new ChinesePeople(\"蔡徐坤\");\n        c1.speak();\n\n        American a1=new American(\"Davoe\");\n        a1.speak();\n    }\n}\n// 人类\nclass People{\n    private String name;\n\n    //get and set\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n    \n    // 构造方法\n    public People(){}\n    public People(String name) {\n        this.name = name;\n    }\n\n    // 说话\n    public void speak(){\n        System.out.println(name+\"在说话\");\n    }\n\n}\n// 中国人\nclass ChinesePeople extends People{\n    // 构造方法\n    public ChinesePeople(){\n\n    }\n    public ChinesePeople(String name){\n        this.setName(name);\n    }\n\n\n    public void speak(){\n        System.out.println(this.getName()+\"在说汉语.\");\n    }\n}\n// 美国人\nclass American extends People{\n    public American(){\n\n    }\n    public American(String name){\n        super(name);\n    }\n    public void speak(){\n        System.out.println(this.getName()+\"are speaking English.\");\n    }\n}\n```\noutput\n![](asset/Pasted%20image%2020220706164253.png)\n\n## 说明\n在这个例子中，通过中国人和美国人去继承父类人类，然后由于说的语种不同，通过方法覆盖实现了不同人种说不同的语言\n值得一说的是，可以将super()实现的构造方法，通过\n`    public ChinesePeople(String name){\n        this.setName(name);\n    }`也可以完成对象的有参构造","lastmodified":"2022-09-20T05:41:06.454325385Z","tags":null},"/074.%E4%BE%8B%E5%AD%90toString%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96":{"title":"","content":"## 要求\n定义一个日期类\n输出日期对象的时候，直接输出日期对象的值\n\n```package a007方法覆盖和多态;\n\n  \n\npublic class ToString1 {\n\n    public static void main(String[] args) {\n\n        Date d1=new Date(2019, 12, 2);\n\n        System.out.println(d1);\n\n    }\n\n}\n\nclass Date{\n\n    private int year;\n\n    private int month;\n\n    private int day;\n\n    // 对tostring进行方法覆盖\n\n    public int getYear() {\n\n        return year;\n\n    }\n\n    public void setYear(int year) {\n\n        this.year = year;\n\n    }\n\n    public int getMonth() {\n\n        return month;\n\n    }\n\n    public void setMonth(int month) {\n\n        this.month = month;\n\n    }\n\n    public int getDay() {\n\n        return day;\n\n    }\n\n    public void setDay(int day) {\n\n        this.day = day;\n\n    }\n\n    public Date(int year, int month, int day) {\n\n        this.year = year;\n\n        this.month = month;\n\n        this.day = day;\n\n    }\n\n  \n\n}\n```\n## 提示\n`println`默认是将对象`toString`之后进行输出，但是`toString`是将对象位置@在内存中的地址hash之后的值进行输出，如下\n```java\n        Date d1=new Date(2019, 12, 2);\n        System.out.println(d1);\n```\n![](asset/Pasted%20image%2020220706171545.png)\n\n那么可以根据date的实际需求，方法覆盖toString方法，直接返回其日期，这样打印的日期对象，就直接是日期了\n\n添加方法覆盖\n```java\n    public String toString(){\n\n        return year+\"年\"+month+\"月\"+day+\"日\";\n\n    }\n```\n添加后 ^tostringfffg\n```java\npackage a007方法覆盖和多态;\n\npublic class ToString1 {\n    public static void main(String[] args) {\n        Date d1=new Date(2019, 12, 2);\n        System.out.println(d1);\n    }\n}\nclass Date{\n    private int year;\n    private int month;\n    private int day;\n    // 对tostring进行方法覆盖\n    public int getYear() {\n        return year;\n    }\n    public void setYear(int year) {\n        this.year = year;\n    }\n    public int getMonth() {\n        return month;\n    }\n    public void setMonth(int month) {\n        this.month = month;\n    }\n    public int getDay() {\n        return day;\n    }\n    public void setDay(int day) {\n        this.day = day;\n    }\n    public Date(int year, int month, int day) {\n        this.year = year;\n        this.month = month;\n        this.day = day;\n    }\n    public String toString(){\n        return year+\"年\"+month+\"月\"+day+\"日\";\n    }\n\n}\n```\noutput \n![](asset/Pasted%20image%2020220706172335.png) ^4a2490","lastmodified":"2022-09-20T05:41:06.454325385Z","tags":null},"/075.%E5%A4%9A%E6%80%81":{"title":"","content":"\n## 基本概念\n多动态，就是多种形态，多种状态。\n\u003e简单的来说，就是java程序在 **[编译阶段 和执行阶段 所真正参与的是不同的对象](076.多态举例.md#java程序执行过程)**，所以叫多态。\n\u003e父类型引用执行子类型对象，包括编译阶段和执行阶段\n\u003e编译阶段 ：静态绑定父类的方法（方法区） ^jtbd\n\u003e执行阶段：动态绑定子类的方法（堆内存）\n\n","lastmodified":"2022-09-20T05:41:06.454325385Z","tags":null},"/076.%E5%A4%9A%E6%80%81%E4%B8%BE%E4%BE%8B":{"title":"","content":"\n## eg\n定义Animal、Cat、Dog类用来定义对象\n动物\n```java\npackage a007方法覆盖和多态;\n\npublic class Animal {\n    public void move(){\n        System.out.println(\"动物在移动。\");\n    }\n}\n```\n猫\n```java\npackage a007方法覆盖和多态;\n\npublic class Cat extends Animal{\n    public void move(){\n        System.out.println(\"猫在爬树。\");\n    }\n}\n```\n狗\n```java\npackage a007方法覆盖和多态;\n\npublic class Dog extends Animal {\n    public void move(){\n        System.out.println(\"你在狗叫什么？\");\n    }\n}\n\n```\n\n\n主方法通过不同的对象创建方式，输出不同对象 所产生的行为方式\n```java\npackage a007方法覆盖和多态;\n\npublic class Duotai01 {\n    public static void main(String[] args) {\n        // new object\n        Animal a1 = new Animal();\n        a1.move();\n        Cat c1 = new Cat();\n        c1.move();\n        Dog d1 = new Dog();\n        d1.move();\n        \n        System.out.println(\"=====分割线=====\");\n        // 多态\n        Animal a2 = new Animal();//动物园，向上转型\n        a2.move();\n        Animal c2=new Cat();//猫是一种动物\n        c2.move();\n        Animal d2=new Dog();//狗屎一种动物\n        d2.move();\n    }\n}\n\n```\noutput\n![](asset/Pasted%20image%2020220707154739.png)\n\n---\n由上图可知，通过多态，可以将动物中不同的具体动物所产生的行为进行输出，\n在创建实例对象的时候，可以通过向上转型将对象中的子类与父类产生关系\n比如 动物和猫都是一个类，但是猫也是动物的一部分，所以猫是一种动物，可以\n`动物 汤姆=new 动物;`来将猫new在动物中\n\n## java程序执行过程\neg\n```java\nAnimal c2=new Cat();//猫是一种动物\n        c2.move();\n```\n编译阶段：\n\t编译器知道c2的类型是Animal，编译器检查语法，Animal.class字节码文件中寻找move()方法，找到之后，绑定move()方法，编译通过，静态绑定就成功，此时在方法区中。（编译阶段称为静态绑定）\n运行阶段\n\t运行的时候，在堆内存的c2对象实际是Cat对象，在move()的时候实际是Cat在参与，所以运行阶段就会动态的去执行Cat中的move()方法\n\t![](asset/Pasted%20image%2020220707161219.png)","lastmodified":"2022-09-20T05:41:06.454325385Z","tags":null},"/077.%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B":{"title":"","content":"## 向上转型和向下转型\n![](上下转型.png)\n1. java中允许[向上转型](076.多态举例.md)，也允许向下转型（不要说自动类型转换和强制类型转换，那是基本变量类型转换，上图只是为了能够更好地理解）\n2. 不论是向上转型还是向下转型，都**必须有继承关系**（没有继承关系，那么不能转型）\n\n向上转型： `Anlimal a=new Cat()`\n向下转型：`Cat b=(Cat)a`\n\n## 什么时候使用向下转型\n\u003e 不要随便做强制转换\n\u003e 1. 当你访问的是一个**父类中没有，子类对象中所“特有”的方法**，此时必须**向下转型**\n\u003e 2. 当然，你也可以在父类中补充这个方法，那样就是方法覆盖了，就不用向下转型了\n\u003e 3. 原因是 **虽然aa3运行是猫对象，但是由于底层是狗对象，而且Cat和Dog两个之间没有相互继承关系，所以无法向下转型，抛出异常**，可以通过if判断和`instanceof`判断来避免这种错误\neg\n在`Cat`类中增加**猫抓老鼠**的方法\n```java\n    public void catchMouse(){\n        System.out.println(\"猫抓老鼠\");\n    }\n```\n主方法中new猫，让猫抓老鼠\n```java\n        Animal c3=new Cat();\n\n        c3.catchMouse();\n```\noutput\n![](asset/Pasted%20image%2020220707163142.png)\n可以发现失败了，因为虽然子类cat有猫抓老鼠的方法，但是，在代码编译阶段，父类中没有书写抓老鼠的catchMouse方法，那么就会[[075.多态#^0e7d11|静态绑定]]失败。\n这个时候就需要**强制转换**\n**子类特有的方法才需要强制转换**，也可以通过在父类添加对应的同名方法避免报错\n```java\n        Animal c3=new Cat();\n\n  \n\n        Cat cc3=(Cat)c3;//强制转换\n\n        cc3.catchMouse();\n```\n动物和猫之间存在继承关系，可以进行强制转换\n将动物`c3`强制转换成**猫**，然后赋给`cc3`，这样就可以了\n\n## 向下转型的风险\n\u003e 可能出现`java.lang.ClassCastException` 类型转换异常\n\neg\n```java\nAnimal a3=new Dog();//动物对象 a3，底层为对象狗\n        Cat aa3=(Cat)a3;    // 将a3强制转换成Cat对象，赋值给aa3\n        aa3.catchMouse();   //虽然aa3运行是猫对象，但是由于底层是狗对象，而且Cat和Dog两个之间没有相互继承关系，所以无法向下转型，抛出异常\n```\noutput\n![[asset/Pasted image 20220707170451.png]]\n原因是因为底层对象Dog a3和被定义的Cat aa3之间的类不存在继承关系，所以编译不会报错，但是运行之后发现两者的继承存在问题，无法强制向下转型\n\n## 怎么避免java.lang.ClassCastException\n可以通过使用if语句判断[[078.instanceof运算符|instanceof运算符]]是否是指定的对象，来决定是否执行方法\n```java\n        if(a3 instanceof Cat){\n            Cat aa3=(Cat)a3;    // 将a3强制转换成Cat对象，赋值给aa3\n            aa3.catchMouse();   //虽然aa3运行是猫对象，但是由于底层是狗对象，而且Cat和Dog两个之间没有相互继承关系，所以无法向下转型，抛出异常\n\n        }\n```\noutput 没有提示 类型转换错误\n![[asset/Pasted image 20220707185422.png]]","lastmodified":"2022-09-20T05:41:06.454325385Z","tags":null},"/078.instanceof%E8%BF%90%E7%AE%97%E7%AC%A6":{"title":"","content":"\u003e[!作用]\n\u003e用于判断 某**对象实例 是否动态指向 一个类 ，或者由一个类直接或间接创建**的\n\n## 重要结论\n\n1. 左边是实例对象，右边是类\n2. 只要左边的实际对象 是右边类的 继承树 以下的类或刚好一样的类，就是true\n\n## 判断\n\u003e判断方法：\n\u003e可以通过判断是否与实例对象的底层对象在 **同一底层类** 上进行判断\n实例对象 “**蔡徐坤**” 是否是某个类 直接或者间接创建的，比如 `person cxk=new chinse`，“人类”下有“中国人”和“美国人”两个子类，，那么 `蔡徐坤 instanceof 中国人`或者`蔡徐坤 instanceof 人`就为`true`，而`蔡徐坤 instanceof 美国人`就为`false`\n![[asset/instanceof.png]]\n如上，蔡徐坤实例，底层是中国人，同时中国人继承自人类，所以无论是instanceof中国还是人类，都是**true**，而美国人与这两个虽然与人类具备了继承关系，但是与底层中国人不具备直接继承关系，所以为false\n\n## eg\n类文件\n动物\n```java\npackage a007方法覆盖和多态;\n\npublic class Animal {\n\n}\n\n```\n\n猫和猪\n```java\npackage a007方法覆盖和多态;\n\npublic class Cat extends Animal{\n}\n\nclass Pig extends Cat{\n    \n}\n```\n\n狗\n```java\npackage a007方法覆盖和多态;\n\npublic class Dog extends Animal {\n\n}\n\n```\n\n主方法\n```java\npackage a007方法覆盖和多态;\n\npublic class Duotai01 {\n    public static void main(String[] args) {\n        // new object\n\n        Animal a3=new Dog();//动物对象 a3，底层为对象狗\n        System.out.println(a3 instanceof Animal);\n        Animal a4=new Pig();\n        System.out.println(a4 instanceof Animal);\n\n        \n    }\n}\n\n```\n那么类和实例的关系就是\n![[asset/狗和猪.png]]\n可以看到a3底层是狗，a4底层是猪，但是在父类或者父类的父类继承树上都是 animal，所以输出为ture\n![[asset/Pasted image 20220707185248.png]]\n\n","lastmodified":"2022-09-20T05:41:06.454325385Z","tags":null},"/079.%E5%A4%9A%E6%80%81%E4%BE%8B%E5%AD%90a%E4%B8%BB%E4%BA%BA%E5%96%82%E5%AE%A0%E7%89%A9":{"title":"","content":"代码\n```java\npackage a007方法覆盖和多态.多态例子动物喂养;\n\n\npublic class Test {\n    public static void main(String[] args) {\n        System.out.println(\"主人喂养宠物实例：\");\n    \n        Master cxk=new Master();//创建主人\n\n        Pet p1=new Pet();//创建宠物\n        System.out.println(\"\\n开始喂宠物：\");\n        cxk.feed(p1);\n\n        Dog d1=new Dog();//创建狗对象\n        System.out.println(\"\\n开始喂狗：\");\n        cxk.feed(d1);\n\n        Cat c1 = new Cat();//创建猫对象\n        System.out.println(\"\\n开始喂猫：\");\n        cxk.feed(c1);\n        \n\n    }\n}\n\n\n// Master class\nclass Master{\n    // 喂养宠物\n    public void feed(Pet pet){\n        pet.eat();\n    }\n}\n\n// class Pet\nclass Pet{\n    // 宠物吃东西\n    public void eat(){\n        System.out.println(\"宠物吃东西\");\n    }\n}\n\n// Dog class\nclass Dog extends Pet{\n    // 狗儿啃骨头\n    public void eat(){\n        System.out.println(\"狗儿啃骨头\");\n    }\n}\n\n// Cat class\nclass Cat extends Pet{\n    public void eat(){\n        System.out.println(\"猫儿吃鱼\");\n    }\n}\n```\noutput \n![[asset/Pasted image 20220708163700.png]]\n解释\n![[asset/主人喂猫.png]]\n1. 主人cxk需要喂养宠物，宠物有猫和狗，所以宠物可以作为子类继承父类宠物\n2. 主人有`feed`喂养方法，但是由于喂养的宠物对象不同，宠物吃的也不同，所以可以采用 feed Pet类去，然后通过Pet与各个具体宠物的继承关系，去考虑宠物的具体吃的方法\n3. 由于吃是一个方法，在继承中，由于继承会继承吃，所以在父类`Pet`中的`eat`方法，在子类`Cat`和`Dog`中可能不太适用，所以可以通过方法覆盖 **override**的方式将eat在各个具体的宠物类中书写eat方法\n执行\n1. 在执行的时候，d1是一个继承于 Pet的 狗\n2. 在cxk 喂养的时候，执行feed方法，feed方法中有eat方法表示动物吃饭\n3. 就会在Pet中寻找类型为Dog的类，在类中发现了**方法覆盖的eat方法**，就执行这个覆盖的eat()方法——狗啃骨头\n\n相关优化\n[[080.宠物养猫优化]]","lastmodified":"2022-09-20T05:41:06.454325385Z","tags":null},"/080.%E5%AE%A0%E7%89%A9%E5%85%BB%E7%8C%AB%E4%BC%98%E5%8C%96":{"title":"","content":"## 相关\n1. 类继承：猫狗与宠物之间的继承关系\n2. 向下继承：向下继承，如果需要调用子类独有的方法（pig的睡觉方法，在pet中没有），需要强制转换类型，前提是两个类继承关系，且[[077.向下转型|向下转型]]才必须强制转型\n3. 独有实例方法的调用\n4. 向上继承的创建对象：Pet p2=new Pig();\n5. 多态：宠物的多个具体事物，有不同的吃的方法，主人通过调用喂养方法，去访问宠物的吃\n6. 方法覆盖override：由于子类有不同的eat方法，在实际调用的时候，会访问其具体对象的eat方法\n## 代码\n\n```java\npackage a007方法覆盖和多态.多态例子动物喂养;\n\n\npublic class Test {\n    public static void main(String[] args) {\n        System.out.println(\"主人喂养宠物实例：\");\n    \n        Master cxk=new Master(\"蔡徐坤\");//创建主人\n        System.out.println(cxk.getName());\n        Pet p1=new Pet();//创建宠物\n        System.out.println(\"\\n\"+cxk.getName()+\"开始喂宠物：\");\n        cxk.feed(p1);\n\n        Dog d1=new Dog(\"旺财\");//创建狗对象\n        System.out.println(\"\\n\"+cxk.getName()+\"开始喂狗：\"+d1.getName());\n        cxk.feed(d1);\n\n        Cat c1 = new Cat(\"汤姆\");//创建猫对象\n        System.out.println(\"\\n\"+cxk.getName()+\"开始喂猫：\"+c1.getName());\n        cxk.feed(c1);\n\n        System.out.println(\"Pig对象\");\n        Pet p2 = new Pig(\"佩奇\");\n        System.out.print(p2.getName());\n        Pig p3=(Pig)p2;\n        p3.sleep();\n\n        Pig p4=new Pig(\"乔治\");\n        System.out.print(p4.getName());\n        p4.sleep();\n                \n\n    }\n}\n\n\n// Master class\nclass Master{\n    private String name;\n    //get and set\n    public String getName() {\n        return name;\n    }\n    public void setName(String name) {\n        this.name = name;\n    }\n    //constructor\n    public Master(){}\n    public Master(String name) {\n        this.name = name;\n    }\n\n\n    // 喂养宠物\n    public void feed(Pet pet){\n        pet.eat();\n    }\n}\n\n// class Pet\nclass Pet{\n    private String name;\n    \n    // constructor\n    public Pet(){}\n    public Pet(String name) {\n        this.name = name;\n    }\n\n\n    public String getName() {\n        return name;\n    }\n\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n\n    // 宠物吃东西\n    public void eat(){\n        System.out.println(\"宠物吃东西\");\n    }\n}\n\n// Dog class\nclass Dog extends Pet{\n    //re constructor\n\n    public Dog(String name) {\n        super(name);\n    }\n\n    public Dog() {\n    }\n\n    // 狗儿啃骨头\n    public void eat(){\n        System.out.println(\"狗儿啃骨头\");\n    }\n}\n\n// Cat class\nclass Cat extends Pet{\n    \n    public Cat() {\n    }\n\n    public Cat(String name) {\n        super(name);\n    }\n\n    public void eat(){\n        System.out.println(\"猫儿吃鱼\");\n    }\n}\n\nclass Pig extends Pet{\n    public Pig(){\n    }\n    public Pig(String name){\n        super(name);\n    }\n    // 猪的独有方法\n    public void sleep(){\n        System.out.println(\"猪在睡觉\");\n    }\n}\n```\noutput\n```cmd\n主人喂养宠物实例：\n蔡徐坤\n\n蔡徐坤开始喂宠物：\n宠物吃东西\n\n蔡徐坤开始喂狗：旺财\n狗儿啃骨头\n\n蔡徐坤开始喂猫：汤姆\n猫儿吃鱼\nPig对象\n佩奇猪在睡觉\n乔治猪在睡觉\n```","lastmodified":"2022-09-20T05:41:06.454325385Z","tags":null},"/081.%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%8D%E5%AD%98%E5%9C%A8%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96":{"title":"","content":"对象之间，有了继承之后，才有方法的覆盖和多态。\n方法覆盖只是针对于“实例方法”，“静态方法”没有方法意义，因为其与对象无关，只和类有关。\n\ncode\n```java\npackage a008遗留问题;\n\nimport a007方法覆盖和多态.Cat;\n\npublic class 静态方法and方法覆盖 {\n    public static void main(String[] args) {\n\n        // 直接调用dosome方法\n        Animal.doSome();\n        Cat.doSome();\n        // 建立对象之后调用dosome方法\n        System.out.println(\"========\");\n        Animal a1=new Animal();\n        a1.doSome();\n\n        Cat c1=new Cat();\n        c1.doSome();\n    }\n}\n\nclass Animal{\n    public static void doSome(){\n        System.out.println(\"animal 的dosome方法\");\n    }\n}\nclass Cat extends Animal{\n    // 尝试在子类中对父类的静态方法重写\n    public static void doSome(){\n        System.out.println(\"Cat 的dosome方法\");\n    }\n}\n````\noutput![](../../../../asset/Pasted%20image%2020220708221554.png)\n\n不论是通过实例调用，还是通过类调用，都与对象无关，实际都是通过类去进行调用的。\n\n**方法覆盖不能和多态分开**","lastmodified":"2022-09-20T05:41:06.45832545Z","tags":null},"/082.%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95%E6%97%A0%E6%B3%95%E8%A6%86%E7%9B%96":{"title":"","content":"```java\npackage a008遗留问题;\n\n  \n\npublic class A {\n\n  \n\n    private void do(){\n\n        System.out.println(\"public类的do方法\");\n\n    }\n\n    public static void main(String[] args) {\n\n        A a1 = new T();\n\n        a1.do();\n\n    }\n\n}\n\nclass T extends A{\n\n    public void do(){\n\n        System.out.println(\"T的do方法\");\n\n    }\n\n}\n```\n抱歉，运行不出来，打扰了\n![](../../../../asset/Pasted%20image%2020220708223626.png)\n在写就不礼貌了","lastmodified":"2022-09-20T05:41:06.45832545Z","tags":null},"/083.%E5%85%B3%E4%BA%8E%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96%E6%97%B6%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B":{"title":"","content":"```java\n\npublic class OverrideTest07{\n\tpublic static void main(String[] args){\n\t\t// 一般重写的时候都是复制粘贴。不要动。不要改。\t\n\t}\n}\n\nclass Animal{\n\t/*\n\tpublic double sum(int a, int b){\n\t\treturn a + b;\n\t}\n\t*/\n\t\n\t/*\n\tpublic long sum(int a, int b){\n\t\treturn a + b;\n\t}\n\t*/\n\n\t/*\n\tpublic int sum(int a, int b){\n\t\treturn a + b;\n\t}\n\t*/\n}\n\nclass Cat extends Animal{\n\t// 重写\n\t// 错误: Cat中的sum(int,int)无法覆盖Animal中的sum(int,int)\n\t/*\n\tpublic int sum(int a, int b){\n\t\treturn a + b;\n\t}\n\t*/\n\t\n\t/*\n\tpublic double sum(int a, int b){\n\t\treturn a + b;\n\t}\n\t*/\n\n\t//错误: Cat中的sum(int,int)无法覆盖Animal中的sum(int,int)\n\t/*\n\tpublic long sum(int a, int b){\n\t\treturn a + b;\n\t}\n\t*/\n}\n\n// 父类\nclass MyClass1{\n\t\n\tpublic Animal getAnimal(){\n\t\treturn null;\n\t}\n}\n\n// 子类\nclass MyClass2 extends MyClass1{\n\n\t// 重写父类的方法\n\t/*\n\tpublic Animal getAnimal(){\n\t\treturn null;\n\t}\n\t*/\n\n\t// 重写的时候返回值类型由Animal变成了Cat，变小了。（可以，java中允许）\n\t/*\n\tpublic Cat getAnimal(){\n\t\treturn null;\n\t}\n\t*/\n\n\t// 重写的时候返回值类型由Animal变成了Object。变大了。（不行，java中不允许）\n\t/*\n\tpublic Object getAnimal(){\n\t\treturn null;\n\t}\n\t*/\n}\n```\n\n结论：学习了多态之后你会发现\n方法覆盖的返回值类型在基本数据类型必须一样，而在引用类型中（就是你class的那些类的对象），可以是你class的子类树上的类","lastmodified":"2022-09-20T05:41:06.45832545Z","tags":null},"/091.suepr%E5%85%B3%E9%94%AE%E5%AD%97":{"title":"","content":"\n## 重要的结论：\n当一个构造方法第一行：既没有this()又没有super()的话，**默认会有一个super()**;表示通过当前子类的构造方法调用父类的无参数构造方法。所以**必须保证父类的无参数构造方法是存在的**。\n## super和this\n1. this() 通过当前的构造方法去调用“本类”中其它的构造方法\n2. super() **通过当前的构造方法去调用“父类”中的构造方法**（*相当于把父类的构造方法代码部分复制过来*），目的是：创建子类对象的时候，先初始化父类型特征，**父类的构造方法是一定会执行的**,所以**object的构造方法一定会执行**\n3. **由于this和super都只能出现在构造方法第一行，所以不能同时出现在一个构造方法中**\n4. 都能出现在**实例方法**和**构造方法**中。\n2. **不能使用在静态方法中**。\n3. 目的都是：代码复用。\n4. `super`后面必须跟`.`，和this不同，super不保存内存地址，只是表示了父对象的一部分特征，this可以直接打印输出内存地址，而super不行，必须`super.xxxx`的方式使用，或者`super()`的方式使用。\n\n\u003e[!super()]\n\u003e表示通过子类的构造方法调用父类的构造方法。\n\u003e模拟现实世界中的这种场景：要想有儿子，需要先有父亲。\n\u003e父类的构造方法一定是会执行的\t\t\n\t\n## 注意：\n```java\npackage a009Super;\n\npublic class Super01 {\n    public static void main(String[] args) {\n        new B();\n    }\n}\nclass A {    //当没有extends时，默认继承超父类Object类,你也可以写上\n    public  A(){//A的无参数构造\n        super(); //默认有这行，因为有默认的继承对象extends，当你不写构造方法，那么就默认使用父类的无参数构造\n        System.out.println(\"A的无参数构造\"+this.hashCode());\n    }\n    public A(int i){\n        super();//默认也是有这行的\n        System.out.println(\"A的int有参构造\");\n    }\n}\nclass B extends A{\n    /*\n    public B(){\n\t\tsuper();\n\t\tSystem.out.println(\"B类的无参数构造方法！\");\n\t}\n\t*/\n\n\tpublic B(){\n\t\tthis(\"zhangsan\");\n\t\t// 调用父类中有参数的构造方法\n\t\t//super(123);\n\t\tSystem.out.println(\"B类的无参数构造方法！\");\n\t}\n\n\tpublic B(String name){\n\t\tsuper();\n\t\tSystem.out.println(\"B类的有参数构造方法(String)\"+this.hashCode());\n\t}\n\n}\n```\n\noutput\n![[asset/Pasted image 20220709095747.png]]\n\n\u003e[!分析]\n\u003e1. 当一个类不指定继承关系时，默认继承超父类Object类，\n\u003e2. 在子类构造方法中，如果不书写构造方法，都默认有super()，表示通过子类构造方法调用父类的构造方法\n\u003e3. 当调用子类的构造方法时，默认先使用父类的构造方法，所谓“有子先有父”","lastmodified":"2022-09-20T05:41:06.45832545Z","tags":null},"/092.%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F":{"title":"","content":"```java\n/*\n\t判断程序的输出结果\n\t1\n\t3\n\t6\n\t5\n\t4\n\n\t在java语言中不管是是new什么对象，最后老祖宗的Object类的无参数构造方法\n\t一定会执行。（Object类的无参数构造方法是处于“栈顶部”）\n\n\t栈顶的特点：\n\t\t最后调用，但是最先执行结束。\n\t\t后进先出原则。\n\t\n\t大家要注意：\n\t\t以后写代码的时候，一个类的无参数构造方法还是建议大家手动的写出来。\n\t\t如果无参数构造方法丢失的话，可能会影响到“子类对象的构建”。\n\n*/\npublic class SuperTest02{\n\tpublic static void main(String[] args){\n\t\tnew C();\n\n\t}\n}\n\n/*\nclass Object{\n\tpublic Object(){\t\n\t}\n}\n*/\n\nclass A extends Object{\n\tstatic{\n\t\tSystem.out.println(\"A类加载\");\n\t}\n\n\t\n\t{\n\t\tSystem.out.println(\"A 的对象\");\n\t}\n\tpublic A(){\n\t\tSystem.out.println(\"1\"); //1\n\t}\n}\n\nclass B extends A{\n\n\tstatic{\n\t\tSystem.out.println(\"B类加载\");\n\t}\n\n\t{\n\t\tSystem.out.println(\"B 的对象\");\n\t}\n\tpublic B(){\n\t\tSystem.out.println(\"2\"); //2\n\t}\n\tpublic B(String name){\n\t\tsuper();\n\t\tSystem.out.println(\"3\"); // 3\n\t}\n}\n\nclass C extends B{\n\tstatic{\n\t\tSystem.out.println(\"C类加载\");\n\t}\n\t{\n\t\tSystem.out.println(\"c 的对象\");\n\t}\n\tpublic C(){ // 这个是最先调用的。但是最后结束。\n\t\tthis(\"zhangsan\");\n\t\tSystem.out.println(\"4\");//4\n\t}\n\tpublic C(String name){\n\t\tthis(name, 20);\n\t\tSystem.out.println(\"5\");//5\n\t}\n\tpublic C(String name, int age){\n\t\tsuper(name);\n\t\tSystem.out.println(\"6\");//6\n\t}\n}\n```\noutput\n\n![[asset/Pasted image 20220709104223.png]]","lastmodified":"2022-09-20T05:41:06.45832545Z","tags":null},"/093.%E4%BD%BF%E7%94%A8super%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E6%96%B9%E6%B3%95":{"title":"","content":"super不仅可以调用父类的属性，还可以调用父类的方法。\n\nsuper.属性名\t\t\t  访问父类的属性\nsuper.方法名(实参)\t访问父类的方法\nsuper(实参)\t\t\t    调用父类的构造方法\n\n## eg\n```java\n/*\n\t判断程序的输出结果\n\t1\n\t3\n\t6\n\t5\n\t4\n\n\t在java语言中不管是是new什么对象，最后老祖宗的Object类的无参数构造方法\n\t一定会执行。（Object类的无参数构造方法是处于“栈顶部”）\n\n\t栈顶的特点：\n\t\t最后调用，但是最先执行结束。\n\t\t后进先出原则。\n\t\n\t大家要注意：\n\t\t以后写代码的时候，一个类的无参数构造方法还是建议大家手动的写出来。\n\t\t如果无参数构造方法丢失的话，可能会影响到“子类对象的构建”。\n\n*/\npublic class SuperTest02{\n\tpublic static void main(String[] args){\n\t\tnew C();\n\n\t}\n}\n\n\tpublic static void main(String[] args){\n\t\t/*\n\t\t\tCat move!\n\t\t\tCat move!\n\t\t\tAnimal move!\n\t\t*/\n\t\tCat c = new Cat();\n\t\tc.yiDong();\n\t}\n}\n\nclass Animal{\n\tpublic void move(){\n\t\tSystem.out.println(\"Animal move!\");\n\t}\n}\n\nclass Cat extends Animal{\n\t// 对move进行重写。\n\tpublic void move(){\n\t\tSystem.out.println(\"Cat move!\");\n\t}\n\n\t// 单独编写一个子类特有的方法。\n\tpublic void yiDong(){\n\t\tthis.move();\n\t\tmove();\n\t\t// super. 不仅可以访问属性，也可以访问方法。\n\t\tsuper.move();\n\t}\n}\n```","lastmodified":"2022-09-20T05:41:06.45832545Z","tags":null},"/100.%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89static":{"title":"","content":"\t```java\n\t\tpublic static void jiecheng(int a) {\n\n        int aa=1;\n\n        for (int i = 1; i \u003c= a; i++) {\n\n            aa*=i;\n\n        }\n\n        System.out.println(a+\"的阶乘是\\t\"+aa);\n\n    }\n```\n\n^d527f7\n\n没有实例化的方法函数，需要在前面的修饰符中加入static，否则就会报错`Cannot make a static reference to the non-static method jiecheng(int) from the type Jiecheng`\n![[../01铺垫/asset/Pasted image 20220628103019.png]]","lastmodified":"2022-09-20T05:41:06.454325385Z","tags":null},"/101.%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93":{"title":"","content":"## 前序\n通过大致17天的学习，学习了javase的基础，让我对java的一些基本特点或者使用有了轮廓。\n接下来将要学习java进阶，所以就目前的学习做一下总结。\n## 一、理论\n在理论方面学习了\n1. java开发工具包JDK，包括了JREJava运行环境（包括了JVM虚拟机）\n2. 学习了java程序的执行过程：源代码执行，生成字节码，JVM解释为二进制文件，交给操作系统，操作系统与硬件进行交互\n3. 基本的环境变量设置：`sysdm.cpl`\n4. 三种注释方法\n5. `public class`和`class`的区别：一个文件最多一个public class，但可以有无数个class，public的class必须和文件名一致\n\n---\n## 二、铺垫\n1. 变量名定义：驼峰命名；基本的关键字50个\n2. javadoc的基本使用：需要配合文档注释\n3. 不同数据类型所占用的字节大小：1248 4812 （byte short int long；float double boolean char）\n4. Scanner的使用，基本的导包方式（和那个python好像一样）\n5. 方法的调用：在一个类中，可以直接写想要调用的方法，如果不在一个类中，则采用：`类名.方法`\n6. break和return的区别：return可以后面不跟返回值，用来停止一个方法\n7. JVM的三个主要内存：堆 栈 方法区的基本分配，一个程序运行时在内存JVM中的情况\n8. 方法重载overload：在一个类中，书写的某个方法可能有多重变化，可以定义多个**参数列表不同**，方法名称相同的方法，就叫方法重载。（参数列表指的形参列表），在使用的时候，java会根据你的形参列表去判断执行哪一个具体的方法\n---\n## 三、基本\n1. 递归：能转成循环就转成循环，耗内存。写递归嘴重要的是知道停止条件。通过调用自身去解决问题\n2. 面向对象和面向过程的特点和区别：java面向对象，耦合度低，扩展性强\n3. 对象和类的关系：通过类去实例化对象。如何去定义类，如何去实例化对象new\n4. 实例化对象，对对象进行赋值和修改\n5. 什么时候会出现空指针异常`java.lang.NullPointerException`，将实例化对象的那个引用置空，那么那个对象就引用任何东西了，对象所存储的东西就处于游离状态。访问引用对象的属性时就会出现空指针异常\n6. 方法调用时的参数传递，实参和形参以及局部变量的释放\n\n---\n## 四、构造方法\n1. 构造方法语法格式：`public 类名{}`\n2. 构造方法的注意事项：手动提供有参构造之后，无参构造就不再提供，所以必须要**记得把无参构造写上**，除非你不用无参构造\n3. 无参数和有参数的构造方法及其使用:蔡徐坤打篮球\n\n---\n## 五、封装\n1. 封装的作用：保证内部安全，屏蔽复杂，暴露简单。\n2. 基本语法：就是get和set对内部数据进行获取和修改\n3. get和set应该也是实例方法，因为需要依赖实例对象\n4. 通俗的解释：封装就是，把数据转换成一个工具。你可以通过这个工具进行修改，工具使用起来很简单，客户方便使用；而我可以通过这个工具，把里面有的不想给你看到的，不想让你有修改权利的东西给藏住不让你用，不让你看。\n\n---\n## 六、this 和 static关键字\n1. 静态代码块：类加载时机\n2. 实例代码块：对象创建时机\n3. static声明之后存在方法区，类加载时就加载static定义的东西\n4. 静态方法和实例方法：实例方法依赖于实例对象，用对象.的方式调用；而静态方法加载在方法区，用类.的方法调用\n5. 即使将对象置空，引用静态变量，依旧不会出现空指针异常，因为静态变量不依赖于对象的建立\n6. 不同代码块的执行顺序：最先加载类\n7. this的内存结构:放在堆内存中\n8. this();\n9. 各种变量在内存中的分布：局部变量（栈），静态变量（方法区），实例变量（堆）\n---\n## 七、继承\n1. **除了构造方法，其余的子类都继承，包括实例方法和get set方法都可以继承**\n2. 主要作用：有了继承关系，才有后续的方法覆盖和多态\n3. **java中只支持单继承**\n4. 在进行重新构造子类构造器的时候，可以通过super关键字快速完成\n5. 凡是可以用“is a”来描述的，都可以考虑采用继承\n---\n## 八、方法覆盖和多态\n1. 当继承的方法无法满足当前子类的业务需求，子类有权利对这个方法进行重新编写，进行方法覆盖override\n2. 私有方法、构造方法、静态方法无法覆盖，方法覆盖针对实例方法\n3. java程序在 编译阶段 和执行阶段 所真正参与的是不同的对象，所以叫多态。\n4. Java中允许向上向下转型\n5. 当你访问的是一个**子类对象中所“特有”的方法**，此时必须**向下转型**，使用强制转型方法 \n6. 强制类型转型的风险是`java.lang.ClassCastException` （类型转换错误），原因是强制类型转换的两个类没有父子类型继承关系，可以通过if和instanceof关键字解决\n7. 学习采用抽象编程，而不是具体编程：主人养宠物\n---\n\n## 九、super关键字\n1. this与super都是与对象有关，常常在构造方法或者实例方法中使用\n2. super后面必须跟`.`，因为他不是引用，不保存内存地址，而this可以直接使用\n3. 当一个构造方法没有this和super的时候，第一行默认是有`super();`的，表示通过子类的构造方法调用父类的无参构造方法\n4. 必须保证父类的无参构造方法是存在的\n5. 构造方法的执行顺序：超父类`Object`类是一定会执行的，因为任何一个类extends类，都默认继承`Object`类\n6. 使用super() 可以调用父类的构造方法，使用super.xxx可以调用父类的属性，使用super.方法名称（实参），可以访问父类的方法\n---\n## 十、遗留问题\n1. 静态方法不存在方法覆盖，没有意义，因为与对象无关\n2. 私有方法无法覆盖\n3. 方法覆盖的返回值类型在基本数据类型必须一样，而在引用类型中（就是你class的那些类的对象），可以是你class的子类树上的类","lastmodified":"2022-09-20T05:41:06.45832545Z","tags":null},"/111.Idea%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8":{"title":"","content":".1. module：模块的创建\n\n## dae的快捷键\n\n| 作用                 | 快捷键                                     |\n| -------------------- | ------------------------------------------ |\n| 新建class            | 选中文件夹 alt +insert（笔记本需要按住fn） |\n| 打开设置set          | ctrl+alt+s                                 |\n| 最大窗口 | ctrl+shift+F12                             |\n| 构造器，get、set方法 | alt+insert                                 |\n| 折叠打开代码块       | alt+←或者→                                 |\n| 切换窗口 | alt + 标号数字 |\n| 提示方法的参数 | ctrl + p |\n| 注释 | 单行注释：ctrl + /\u003cbr/\u003e\t\t多行注释：ctrl + shift + / |\n| 复制一行 | ctrl + d |\n| 删除行               | ctrl +y                                    |\n| 纠错                       | alt+Enter|\n|查看一个类的属性和方法|ctrl + F12|\n|光标停留在红色，**创建方法**| alt +enter，（方法默认是private，可以修改一下）|","lastmodified":"2022-09-20T05:41:06.45832545Z","tags":null},"/112.java%E7%9B%B8%E5%85%B3%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3":{"title":"","content":"\u003e[!bug]+ java帮助文档\n\u003e1. 好用的[http://www.matools.com/api/java8](http://www.matools.com/api/java8)\n\u003e2. 英文版本 https://tool.oschina.net/apidocs/api#A\n\u003e3. 看不懂的[https://www.w3cschool.cn/java/dict](https://www.w3cschool.cn/java/dict)\n\u003e4. 效果不错的 https://itmyhome.com/java-api/\n\u003e5. W3c的 https://www.w3cschool.cn/java/dict\n\n\nUML\n![[../22u异常处理/222.UML 统一建模语言]]","lastmodified":"2022-09-20T05:41:06.45832545Z","tags":null},"/121-final":{"title":"","content":"final是一个关键字，表示最终的、不可变的。\nfinal一般用来修饰**变量，方法，类**\n## 作用\n1. final修饰的**局部变量只能赋一次值**（局部变量必须[[asset/Pasted image 20220712105836.png|手动赋值]]）\n2. final修饰的方法，**无法被覆盖、被重写**\n3. final修饰的类，**无法被继承**\n4.  **final修饰的实例变量，系统不负责赋默认值，需要你自己赋值，要么在定义的时候赋值，要么在构造方法中进行赋值**\n5. final上修饰的实例变量一般和static联合使用是，成为常量，存储在方法区，所有的实例公用一份。\n\t```java\n\tpublic static final double PI=3.1415926;\n\t```","lastmodified":"2022-09-20T05:41:06.45832545Z","tags":null},"/122-final%E4%BF%AE%E9%A5%B0%E7%9A%84%E5%BC%95%E7%94%A8%E5%9E%8B%E5%8F%98%E9%87%8F":{"title":"","content":"实例化的对象的变量是一个**引用型变量，这个变量所指向的是这个对象在堆内存中的地址**\n通过final对其进行修饰，那么这个引用型变量将不能再指向新的对象地址，但是通过set方法区修改这个引用型变量所指向对象的内部属性\n\n```java\npublic class FinalTest01 {  \n    public static void main(String[] args) {  \n        final User u1=new User();  \n        u1.dayin();  \n        u1.setName(\" 蔡徐坤\");  \n        u1.dayin();  \n        u1.setName(\"阿三\");  \n        u1.dayin();  \n    }  \n}\n```\n\noutput\n![[asset/Pasted image 20220712110809.png]]\n可以看到，可以对其对象的属性内容进行修改（通过set方法），这是因为u1引用型变量本身的内容是指向对象的内存地址，比如`0x235f`，而不是对象本身\n\n但是如果再次对其进行新的对象赋值，就不行了\n![[Pasted image 20220712111109.png]]\n\n![[asset/final修饰的引用型变量.png]]","lastmodified":"2022-09-20T05:41:06.45832545Z","tags":null},"/123-final%E4%BF%AE%E9%A5%B0%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F":{"title":"","content":"```java\npublic class FinalTest03 {  \n    public static void main(String[] args) {  \n        User1 u3=new User1();  \n        System.out.println(u3.age);  \n        User1 u5=new User1(100);  \n        System.out.println(u5.age);  \n  \n    }  \n}  \nclass User1{  \n    final int age;  \n  \n    public User1() {  \n        this.age=45;  \n    }  \n  \n    public User1(int age) {  \n        this.age = age;  \n    }  \n}\n```\noutput\n![[asset/Pasted image 20220712163533.png]]\n## 结论\n1. **final修饰的实例变量，系统不负责赋默认值，需要你自己赋值，要么在定义的时候赋值，要么在构造方法中进行赋值**\n2. 只要在系统对齐赋值默认值之前，对齐进行赋值都是可以的\n3. 如果对其进行赋值了，那么就无法通过构造方法对其进行赋值（[[asset/Pasted image 20220712164409.png|没有final 属性 xxx=xxx]]）\n4. 如果没有对其进行赋值，那么就可以在构造方法的内部对其进行一次赋值\n5. final修饰的实例变量一般添加“static”进行修饰，变为静态变量，存储在方法区，节省内存空间。`static final`","lastmodified":"2022-09-20T05:41:06.45832545Z","tags":null},"/131-%E6%8A%BD%E8%B1%A1%E7%B1%BB":{"title":"","content":"![[asset/Pasted image 20220712170300.png]]\n1. 什么是抽象类？\n\t1. 类和类之前具有共同特征，把共同特征提取出来，形成的就是抽象类。抽象类本身不存在，所以抽象类无法创建对象，无法实例化。\n2. 抽象类的数据类型\n\t1. 引用数据类型\n3. 抽象类是用来继承的，所以final和abstract不能结合使用\n4. 抽象类的子类可以是抽象类\n5. 抽象类无法实例化，但是可以有构造方法，这个构造方法是供子类使用的\n\n## 定义的语法\n```java\n[修饰符列表] abstract class 类名{\n\t类体;\n}\n```\n\n","lastmodified":"2022-09-20T05:41:06.462325515Z","tags":null},"/132-%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95":{"title":"","content":"1. 抽象方法表示没有实现的方法，没有方法体的方法\n\t```java\n\tpublic abstract void doSome();\n\t```\n2. 抽象类不一定有抽象方法，但是**抽象方法只能出现在抽象类中。**\n3. **一个非抽象的类继承抽象类，必须将抽象类中的抽象方法覆盖，进行实现**。（因为抽象方法只能卸载抽象类中，所以才需要这样）","lastmodified":"2022-09-20T05:41:06.462325515Z","tags":null},"/133-%E4%BE%8B%E5%AD%90":{"title":"","content":"```java\npublic class AbstractTest01 {  \n    public static void main(String[] args) {  \n        Animal c1=new Cat();//向上转型  \n        c1.move();  \n    }  \n  \n}  \nabstract class Animal{  \n    public abstract  void move();  \n}  \n  \n  \nclass Cat extends Animal{  \n      \n    public void move(){  \n        System.out.println(\"小猫走猫步\");  \n    }  \n}\n```\n![](asset/Pasted%20image%2020220812215034.png)","lastmodified":"2022-09-20T05:41:06.462325515Z","tags":null},"/139-%E9%9D%A2%E8%AF%95%E9%A2%98":{"title":"","content":"\u003e[!java语言中凡是没有方法体的方法都是抽象方法吗？]\n\u003e错误。\n\u003eObject类中的很多方法都没有方法体，都是以“；”结尾。但是他们都不是抽象方法。\n\u003e比如`public native int hashCode();`\n\u003e这个方法底层调用了C++写的动态链接库程序，前面修饰符列表中没有abstract，有一个native，表示调用JVM本地程序","lastmodified":"2022-09-20T05:41:06.462325515Z","tags":null},"/141-%E6%8E%A5%E5%8F%A3":{"title":"","content":"## 语法格式\n```java\n[修饰符列表] interface 接口名{\n\n}\n```\n## 基础语法\n1. 接口等于**常量+抽象方法**\n4. 接口也是一种“引用数据类型”，编译之后，也是一个class字节码文件\n5. 接口是完全抽象的（抽象类是半抽象的），也可以说接口是特殊的抽象类\n6. 接口支持继承，且**支持多继承**\n7. 接口中只包含两部分内容：1. 常量；2.**抽象**方法\n8. 接口中的所有元素都是**public**修饰的 \n9. `public abstract`可以省略不写\n10. 接口中都是抽象方法，所以不能有方法体\n11. 接口中的常量 `public static final`也可以省略不写\n\n## 接口的使用\n1. 类和接口之间叫做**实现**，可以看做继承\n\t1. 继承用extens关键字完成\n\t2. 实现用`implement`关键字完成\n2. **接口中不能有方法体**\n3. **接口可以继承多个接口**\n4. 当一个非抽象的类实现接口的话，**必须对接口中的抽象方法进行 方法覆盖**，同时进行方法覆盖的要求和继承中方法覆盖的要求一样，访问权限只能更高 ，不能更低，一般是public\n5. 接口可以继承接口，类可以实现接口，抽象类不可以继承接口\n6. **一个类可以实现多个接口**（弥补了java中类和类只支持单继承的缺陷，类似于多继承）\n7. 接口与接口之间没有继承关系，也可以**强制类型转换**，编译没错，但是陨星的时候可能 会出现`ClassCastException`异常，建议**接口转型之前进行instanceof进行判断**\n8. extends和implements可以共存，extends在前，implements在后 [[044.extends和implements同时出现|例子]]\n9. 使用接口可以采用多态，父类型引用接口指向子类型对象`Flyable cat=new Cat();`\n\n## 接口中在开发的作用\n类似多态在开发中的作用\n面向抽象编程，不要具体编程。低耦合高扩展\n1. 接口是完全抽象的，面向接口编程\n2. ","lastmodified":"2022-09-20T05:41:06.462325515Z","tags":null},"/142-%E6%8E%A5%E5%8F%A3eg1":{"title":"","content":"```java\npublic class Test {  \n  \n  \n    public static void main(String[] args) {  \n        //调用接口中的常量,  \n        System.out.println(MyMath.PI);  \n    }  \n}  \n  \ninterface MyMath {  \n    //    常量,省略 public static final，接口中随便写一个变量就是常量  \n    double PI = 3.1415926;  \n  \n    //    抽象方法,可以省略public abstract  \n    int sum(int a, int b);  \n}\n```\noutput\n```\n3.1415926\n```","lastmodified":"2022-09-20T05:41:06.462325515Z","tags":null},"/143-%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%B8%AA%E6%8E%A5%E5%8F%A3":{"title":"","content":"```java\npublic class Test01 {  \n    public static void main(String[] args) {  \n        D d1=new D();  \n        d1.f1();  \n        d1.f2();  \n        d1.f3();  \n    }  \n}  \ninterface A{  \n    void f1();  \n}  \ninterface B{  \n    void f2();  \n}  \ninterface C{  \n    void f3();  \n}  \n  \nclass D implements A,B,C{  \n    public void f1(){  \n        System.out.println(\"我是F1\");  \n    }  \n    public void f2(){  \n        System.out.println(\"我是f2\");  \n    }  \n    public void f3(){  \n        System.out.println(\"我是f3\");  \n    }  \n}\n```\noutput\n![[asset/Pasted image 20220712215205.png]]","lastmodified":"2022-09-20T05:41:06.462325515Z","tags":null},"/144-extends%E5%92%8Cimplements%E5%90%8C%E6%97%B6%E5%87%BA%E7%8E%B0":{"title":"","content":"```java\npublic class Test02 {  \n    public static void main(String[] args) {  \n        Flyable c1=new Cat();//创建对象，父类型指向子对象。多态  \n        c1.fly();  \n//        同一个接口调用同一个方法  \n        Flyable s1=new Snake();//创建蛇  \n        s1.fly();  \n    }  \n}  \n//动物类：父类  \nclass Animal{  \n  \n  \n}  \n//飞的技能接口  \ninterface Flyable{  \n//    飞的方法  \n    void fly();  \n}  \n//猫类：动物子类  \nclass Cat extends Animal implements Flyable{  \n//        实现接口中的飞的方法  \n    public void fly(){  \n        System.out.println(\"我是一只猫，我想做太空猫，我要飞！\");  \n    }  \n}  \n  \nclass Snake extends Animal implements Flyable{  \n    public void fly(){  \n        System.out.println(\"我是一条蛇，我飞不起来\");  \n    }  \n}\n```\noutput\n![[asset/Pasted image 20220712221053.png]]","lastmodified":"2022-09-20T05:41:06.462325515Z","tags":null},"/145-%E6%8E%A5%E5%8F%A3%E5%9C%A8%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8":{"title":"","content":"## 作用\n将调用者和实现者解耦合。\n调用者面向接口调用，实现者面向接口编写实现。","lastmodified":"2022-09-20T05:41:06.462325515Z","tags":null},"/146-is_ahas_alike_a":{"title":"","content":"1. 凡是满足“**has a**”来描述的，表示“关联关系”，统一以**属性**的方式存在。\n\t```java\n\tclass A{\n\t\tB b\n\t}\n\t```\n```java\nclass Custer{\n\t//每个顾客手里都有一个菜单，菜单就是另一个接口类，包含了很多的做菜方法\n\tFootMenu footMenu;//顾客有一个菜单，所以设置为属性 \n}\n```\n2. 凡是满足“**is a**”来描述的，表示可以设置为**继承**。\n\t```java\n\tclass A extend B\n\t```\n\t```java  //猫是一只动物，我以采用继承\n\tclass Cat extends Animal{\n\t}\n\t```\n1. 翻译满足“l**ike a**”，表示**实现关系**，通常是**类实现接口**。\n\t```java\n\tclass A implements B{\n\t}\n\t```\n\n```java\n\tclass ChineseCooker implements FoodMenu{\n\t\t//厨师像一个菜单一样，实现了菜单中的具体方法，所以可以通过类实现接口中的方法\n\tpublic void cook(){}\n\t}\n```","lastmodified":"2022-09-20T05:41:06.462325515Z","tags":null},"/147-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB":{"title":"","content":"1. 抽象：抽象类是半抽象的；接口是完全抽象的\n2. 构造方法：抽象类中有构造方法；接口中没有构造方法\n3. 继承：类与类之间只能单继承；接口与接口之间支持多继承。\n4. 实现与继承：一个类可以同时实现（`implements`）多个接口；一个抽象类只能继承（`extends`）一个类（单继承）\n5. 定义：接口中只允许常量和抽象方法\n6. 使用频率：一般接口比抽象类多，抽象类使用的少。接口一般是对行为的抽象，接口就是为了扩展能力。\n\n","lastmodified":"2022-09-20T05:41:06.462325515Z","tags":null},"/148-%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0eg2%E5%8E%A8%E5%B8%88%E7%82%92%E8%8F%9C":{"title":"","content":"1. 书写接口方法，用来描写具体的做菜方法\n```java\n//菜单  \n//用来描述具体的菜单做的东西  \npublic interface FootMenu {  \n    void Yuxiangrousi();  \n    void Fanqiechaodan();  \n}\n```\n2. 用类去实现接口中的具体方法\n```java\n//定义厨师类去具体实现菜单接口中的方法  \npublic class ChineseCooker implements FootMenu{  \n    public void Yuxiangrousi(){  \n        System.out.println(\"中餐厨师 做的鱼香肉丝\");  \n    }  \n    public void Fanqiechaodan(){  \n        System.out.println(\"中餐厨师 做的番茄炒蛋\");  \n    }  \n}\n```\n\n```java\n//美国厨师  \npublic class AmericanCooker implements FootMenu{  \n    public void Yuxiangrousi(){  \n        System.out.println(\"西餐厨师 做的鱼香肉丝\");  \n    }  \n    public void Fanqiechaodan(){  \n        System.out.println(\"西餐厨师 做的番茄炒蛋\");  \n    }  \n}\n```\n3. 描写客户，客户有个一个菜单（has a），所以需要将其定义为属性，并进行封装\n```java\n//客户类  \npublic class Customer {  \n    FootMenu footmenu;//客户手里的菜单通过菜单点菜  \n  \n    //点餐方法  \n    public  void order(){  \n        footmenu.Fanqiechaodan();  \n        footmenu.Yuxiangrousi();  \n    }  \n//    进行封装  \n  \n    public Customer(){}  \n    public Customer(FootMenu footmenu) {  \n        this.footmenu = footmenu;  \n    }  \n  \n    public FootMenu getFootmenu() {  \n        return footmenu;  \n    }  \n  \n    public void setFootmenu(FootMenu footmenu) {  \n        this.footmenu = footmenu;  \n    }  \n}\n```\n4. 整个主方法，点餐的过程\n\t1. 首先创建对象**中餐厨师**，以及菜单\n\t2. 创建客户，客户中有一个菜单，所以通过构造方法进行赋值\n\t3. 调用点餐方法\n```java\npublic class ATest {  \n    public static void main(String[] args) {  \n//        创建中餐厨师厨师  \n        FootMenu f1=new ChineseCooker();// 因为厨师是菜单的实现，所以通过父类接口去实现子类对象  \n//        创建客户  \n        Customer c1=new Customer(f1);//客户有一个菜单属性，通过这个菜单进行点餐  \n//        点餐  \n        c1.order();//order是客户类的方法，order方法中具体书写了具体的点餐方法  \n  \n        FootMenu f2=new AmericanCooker();  \n        Customer c2=new Customer(f2);  \n        c2.order();  \n  \n    }  \n}\n```\noutput\n![[asset/Pasted image 20220713105429.png]]\n\n## 还需要优化的问题：\n整个程序实现了点餐的过程，但是没有客户自己选择的权利，意思就是order中的点餐需要进行优化\n客户要点番茄炒蛋就只番茄炒蛋，要哪几个就只要那几个，而这个中只能全部点餐\n\n\u003e[!改进办法]\n\u003e在order方法中添加一个用于判断点餐的if语句\n\neg\n```java\nif (caiming==\"鱼香肉丝\") {  \n    foodMenu.yxrs();  \n}        if (caiming==\"番茄炒蛋\") {  \n    foodMenu.fqcd();  \n}        if (caiming==\"蚂蚁上树\") {  \n    foodMenu.myss();  \n}\n```","lastmodified":"2022-09-20T05:41:06.462325515Z","tags":null},"/151-package":{"title":"","content":"1. 作用\n\t1. package是java中的包机制，包机制的作用是为了方便程序的管理。不同功能的类分别存放在不同的包下。\n2. package的使用\n\t1. package是一个IE关键字，后面加包名\n\t\t1. 只允许出现在java源代码第一行\n\t\t2. `package com.bkd.jase.chapter17`\n3. 包名的命名规范\n\t1. 公司域名倒序+项目名+模块名+功能名\t\n\n## 对于package的程序，Java程序的运行过程\n编译\n\t和以前一样 \t`javac -d 文件名 `\n运行\n\t在项目的根文件夹，采用 `包名.类名`来运行\n\t![[asset/Pasted image 20220713151848.png]] ","lastmodified":"2022-09-20T05:41:06.462325515Z","tags":null},"/152-import%E6%9C%BA%E5%88%B6%E7%9A%84%E4%BD%BF%E7%94%A8":{"title":"","content":"当两个类不在一个包内，当  需要调用另一个包的文件时，就需要使用import导入别的包\n特殊：`java.lang`这个包下的类不需要使用，因为他默认是`自动导入`的\n\neg\n![[asset/Pasted image 20220713153048.png]]\n\n运行output\n![[asset/Pasted image 20220713153625.png]]\n\n如果不导包，可以采用\n```java\n包名.类名 名称=new 包名.类名\n```\n来使用别的包的类\n\n按需导入，可以采用“``\\*``”去进行通配，不影响运行时的效率，只是影响编译时的效率，因为在编译时是去找需要导入的包，而不是把里面的所有包全面导进去。","lastmodified":"2022-09-20T05:41:06.462325515Z","tags":null},"/161-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E6%9D%83%E9%99%90":{"title":"","content":"## 四种权限\n1. `private` 私有的\n\t\n\t1. 只能在**本类**中使用，可以通过封装的方式让外部进行访问\n\t\n2. `public` 公开的\n\t\n\t1. **任何位置**都可以访问\n\t\n3. 默认，什么都不写\n\n   1. 只能在**本类或同包**下访问\n\n4. `protected` 受保护的\n\n  1. 只能在**本类或同包以及子类**下访问\n\n  \n\n| 访问控制权限修饰符 |         访问         |\n| :----------------: | :------------------: |\n|      private       |       **本类**       |\n|       public       |     **任何位置**     |\n|        默认        |    **本类、同包**    |\n|     protected      | **本类、同包、子类** |\n\n\n\n## 可以修饰什么\n\n1. 属性\n2. 方法","lastmodified":"2022-09-20T05:41:06.46632558Z","tags":null},"/171-Object%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95":{"title":"","content":"JDK库的根类：`Object`\n\n怎么去查找：\n1. 源代码中找\n2. 查阅java\t帮助文档，可以通过javadoc来生成\n\t1. ![[asset/Pasted image 20220713193605.png]]\n\n\n---\n额外知识：\n\u003e[!API]\n\u003e应用程序编程接口。（Application Program Interface)\n\u003e整个JDK的类库就是一个javase的API.\n\u003e每一个API都会配置一套API帮助文档。\n\n  ## 常用方法：\n  ### toString()\n默认实现是：\n`类名@对象的内存地址转换为十六进制的形式`\n将一个java对象转换成字符串表示形式，建议所有子类都去重写toString()方法\n**打印默认会调用此方法，比如println和print**\n [[../../爪哇基础/07方法覆盖和多态/01方法覆盖/074.例子toString方法覆盖#^tostringfffg|例子]]\n \n ### equals\n 默认实现：\n \n 目的：\n 通过equals来判断两个**对象是否相等**\n 用来判断两个基本数据 类型是否相等用“==”，而对象用“equals\"来判断\n \n 对象使用“==”判断的是在**对象保存的内存地址**  \n \n\u003e 重写equals之前，是比较的内存地址，所以常常也需要重写**equals**方法。\n\nString已经重写了equals方法，所以两个字符串的比较，可以不用再重写equals方法了，直接用equals方法来比较两个字符串的内容是否相同。\n\n## finalize()\n![[asset/Pasted image 20220713215900.png]]\n\n1. 不需要程序员手动调用，JVM的垃圾回收器去负责调用这个方法\n2. finalize()方法实际 是sun公司为java程序员准备的一个时机，**垃圾销毁时机**\n3.  **只需要重写，不需要调用，将来自动会有程序来调用**（GC负责来调用finalize()方法）\n4.  建议垃圾回收器启动（也可能 不启动，只是可能 性加大了）`System.gc();\t`\n\n# hashCode()\n```java\npublic native int hashCode();\n```\n不是抽象方法，带有native，底层调用c++程序\n实际上是**一个java对象的内存地址，经过哈希算法，得出的一个数值**\n可以看作一个java的内存地址 \n\t![[asset/Pasted image 20220715090249.png]]","lastmodified":"2022-09-20T05:41:06.46632558Z","tags":null},"/172-%E9%87%8D%E5%86%99equals%E6%96%B9%E6%B3%95eg":{"title":"","content":"```java\nimport com.sun.org.apache.regexp.internal.REUtil;  \n  \npublic class Test01 {  \n  \n    public static void main(String[] args) {  \n        Student s1=new Student(12,\"张三\");  \n        Student s2=new Student(12,\"张三\");  \n        Student s3=new Student(14,\"张三\");  \n        System.out.println(s1.equals(s2));  \n        System.out.println(s1.equals(s3));  \n    }  \n}  \n//Student  \nclass Student {  \n    private int no;  \n    private String name;  \n  \n    //重写equals方法来判断两个学生是否是一个学生  \n    //通过比较两个学生的姓名和学号来判断  \n    //重写toString 方法  \n    public String toString() {  \n        return no + name + \"\";  \n    }  \n  \n    //方法覆盖  \n    public boolean equals(Object obj) {  \n        if (obj == null || !(obj instanceof Student)) {  \n            return false;  \n        }  \n        if (this == obj) return true;  \n        Student s=(Student) obj;  \n        return (this.name.equals(s.name) \u0026\u0026 this.no==s.no);  //因为姓名是string类型的，所以还是需要用equals来对字符进行比较，这个equals是调用的string的equals，不是Student类型对象的equals\n    }  \n  \n  \n  \n    //constructor  \n    public Student() {  \n    }  \n  \n    public Student(int no, String name) {  \n        this.no = no;  \n        this.name = name;  \n    }  \n  \n}\n```\n\noutput\n![[asset/Pasted image 20220713211529.png]]  ","lastmodified":"2022-09-20T05:41:06.46632558Z","tags":null},"/181-%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB":{"title":"","content":"1. \n\u003e[!TIP]- 内部类：\n\u003e在一个类的内部又定义了一个新的类\n\n2. \n\u003e[!tip]- 内部类的分类   [[182.匿名内部类eg#^19f5ae|三种内部类的eg]]\n\u003e静态内部类：类似于静态变量\n\u003e实例内部类：类似于实例变量\n\u003e局部内部类：类似于局部变量，匿名内部类属于这一类\n\n# 注意\n![[182.匿名内部类eg#^8442de]]\n![[182.匿名内部类eg#^85d701]]\n\n","lastmodified":"2022-09-20T05:41:06.46632558Z","tags":null},"/182-%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BBeg":{"title":"","content":"```java\n/*\n\t匿名内部类：\n\n\t\t1、什么是内部类？\n\t\t\t内部类：在类的内部又定义了一个新的类。被称为内部类。\n\n\t\t2、内部类的分类：\n\t\t\t静态内部类：类似于静态变量\n\t\t\t实例内部类：类似于实例变量\n\t\t\t局部内部类：类似于局部变量\n\n\t\t3、使用内部类编写的代码，可读性很差。能不用尽量不用。\n\n\t\t4、匿名内部类是局部内部类的一种。\n\t\t\t因为这个类没有名字而得名，叫做匿名内部类。\n\t\t\n\t\t5、学习匿名内部类主要是让大家以后在阅读别人代码的时候，能够理解。\n\t\t并不代表以后都要这样写。因为匿名内部类有两个缺点：\n\t\t\t缺点1：太复杂，太乱，可读性差。\n\t\t\t缺点2：类没有名字，以后想重复使用，不能用。\n\t\t\n\t\t6、不理解算了，你只要记住这种写法就行。\n*/\n\nclass Test01{\n\n\t// 静态变量\n\tstatic String country;\n\t// 该类在类的内部，所以称为内部类\n\t// 由于前面有static，所以称为“静态内部类”\n\tstatic class Inner1{\n\t}\n\t\n\t// 实例变量\n\tint age;\n\t// 该类在类的内部，所以称为内部类\n\t// 没有static叫做实例内部类。\n\tclass Inner2{\n\t}\n\n\t// 方法\n\tpublic void doSome(){\n\t\t// 局部变量\n\t\tint i = 100;\n\t\t// 该类在类的内部，所以称为内部类\n\t\t// 局部内部类。\n\t\tclass Inner3{\n\t\t}\n \n\n\tpublic void doOther(){\n\t\t// doSome()方法中的局部内部类Inner3，在doOther()中不能用。\n\t}\n\n\t// main方法，入口\n\tpublic static void main(String[] args){\n\t\t// 调用MyMath中的mySum方法。\n\t\tMyMath mm = new MyMath();\n\t\t/*\n\t\tCompute c = new ComputeImpl();\n\t\tmm.mySum(c, 100, 200);\n\t\t*/\n\t\t\n\t\t//合并（这样写代码，表示这个类名是有的。类名是：ComputeImpl）\n\t\t//mm.mySum(new ComputeImpl(), 100, 200);\n\t\n\t\t// 使用匿名内部类，表示这个ComputeImpl这个类没名字了。\n\t\t// 这里表面看上去好像是接口可以直接new了，实际上并不是接口可以new了。\n\t\t// 后面的{} 代表了对接口的实现。\n\t\t// 不建议使用匿名内部类，为什么？\n\t\t// 因为一个类没有名字，没有办法重复使用。另外代码太乱，可读性太差。\n\t\tmm.mySum(new Compute(){\n\t\t\tpublic int sum(int a, int b){\n\t\t\t\treturn a + b;\n\t\t\t}\n\t\t}, 200, 300);\n\n\n\n\t}\n\n}\n\n// 负责计算的接口\ninterface Compute{ \n\t\n\t// 抽象方法\n\tint sum(int a, int b);\n}\n\n// 你自动会在这里编写一个Compute接口的实现类\n/*\nclass ComputeImpl implements Compute{\n\n\t// 对方法的实现\n\tpublic int sum(int a, int b){\n\t\treturn a + b;\n\t}\n}\n*/\n\n// 数学类\nclass MyMath{\n\t// 数学求和方法\n\tpublic void mySum(Compute c, int x, int y){\n\t\tint retValue = c.sum(x, y);\n\t\tSystem.out.println(x + \"+\" + y + \"=\" + retValue);\n\t}\t\n}\n\n```\n\n^19f5ae\n\n---\n\n自己写的\n```java\npublic class Test01 {  \n    public static void main(String[] args) {  \n        Math m1=new Math();  \n        Calc c1=new CalcIm();  \n        System.out.println(\"非匿名内部方式\");  \n        m1.mysum(c1,5,10);  \n        System.out.println(\"匿名内部的方式\");  \n        m1.mysum(new Calc() {  \n            @Override  \n            public int sum(int a, int b) {  \n                return a+b;  \n            }  \n        }, 15, 20);  \n    }  \n}  \n  \n//计算接口  \ninterface Calc{  \n    int sum(int a,int b);//加法  \n}  \n//对calc进行实现  \nclass CalcIm implements Calc{  \n  \n    @Override  \n    public int sum(int a, int b) {  \n       return a+b;  \n    }  \n}  \n  \n//math类  \nclass Math{  \n//    math的加法方法，调用了calc接口实现的CalcIm方法  \n    public void mysum(Calc c,int x,int y){ //接口calc需要类去实现，然后再产生实例  \n        c.sum(x,y);  \n        System.out.println(x+\"+\"+y+\"=\"+c.sum(x,y));  \n    }  \n}\n```\noutput\n![[asset/Pasted image 20220715162727.png]]\n\n\u003e[!FAQ]+ 常见问题 \n\u003e缺点\n\u003e\t缺点1：太复杂，太乱，可读性差。\n\u003e\t缺点2：类没有名字，不能重复使用\n\u003e使用的注意点\n\u003e\t1. 不需要class去实现那个接口，可以直接new 接口，然后在花括号里面实现方法覆盖\n\u003e\t2. 注意参数是，new的是接口，不是像别的那样采用`类型 名称`的方式作为实参\n\u003e\t3. 接口不能作为参数实现，但是new的接口可以通过匿名内部类的方式作为类的匿名类作为参数带入\n\n^8442de\n\n```java\nm1.mysum(new Calc() {  \n\t@Override  \n\tpublic int sum(int a, int b) {  \n\t\treturn a+b;  \n\t}  \n}, 15, 20);  \n```\n\n^85d701\n\n","lastmodified":"2022-09-20T05:41:06.46632558Z","tags":null},"/191-%E6%95%B0%E7%BB%84":{"title":"","content":"## 概述\n1. Java语言中的数组是一种**引用数据类型**。不属于基本数据类型。数组的父类是`Object`。\n2. 数组可以同时容纳多个元素。（数组是一个数据的集合。）\n3. 数组当中*可以存储“基本数据类型”的数据，也可以存储“引用数据类型”的数据。*\n4. 数组因为是引用类型，数组是**存储在堆中**的\n5. 数组当中如果存储的是“java对象”的话，实际上存储的是对象的**引用（内存地址）**，数组中不能直接存储java对象。\n6. 数组一旦创建，**数组长度不可变**\n7. 数组的分类：一维数组. 二维数组. 三维数组. 多维数组...（一维数组较多，二维数组偶尔使用！）\n8. 采用`length`用来获取数组中元素的个数。\n9. java中的数组要求**数组中元素的类型统一**。比如int类型数组只能存储int类型，Person类型数组只能存储Person类型。\n例如：超市购物，购物袋中只能装苹果，不能同时装苹果和橘子。（数组中存储的元素类型统一）\n10. 数组在内存方面存储的时候，**存储的每一个元素都是连续的**，内存地址连续。数组实际上是一种简单的数据结构。\n11.数组中**首元素的内存地址作为整个数组对象的内存地址**。\n12. 数组中每一个元素都是有下标的，下标从0开始，以1递增。**最后一个元素的下标是`length - 1`**\n13. 存取元素都是通过下标来进行的。\n\n\u003e[!TIP]+ 缺点\n\u003e1. 数组上随机删除或者增加元素的时候，效率较低，因为随机增删元素会涉及到后面元素统一向前或者向后位移的操作 \t\n\u003e2. 不能存储大数据量，因为很难在内存空间上找到一块特别大的连续的内存空间\n\n注意：对于数组中最后一个元素的增删，是没有效率影响的。\n\n---\n## 内存图\n![[asset/数组的内存结构.png]]\n---\n\n## 定义和声明\n\n### 语法格式\n```java\nint[] array1;//整型\ndouble[] array2;//doule\nboolean[] array3;//布尔\nString[] array4;//字符\nObject[] array5;//对象型，引用型\n```\n\n### 初始化\n\u003e[!info]+ 用处\n\u003e静态初始化主要用在**知道具体的元素**的情况，动态初始化在不知道具体元素，或者只用一次的时候\n1. 动态初始化\n```java\nint[] array1=new int[5];//初始化一个一个元素的数组，整型\nString[] name=new String[4];\n```\n2. 静态初始化\n```java\nint[] array={1,5,2,3};\n```\n\neg\n\t\n```java\n\t\tSystem.out.println(new int[]{1,5,4});\n```\n```\n```\n## 创建和遍历\n```java\npublic class ArrayTest01 {\n    public static void main(String[] args) {\n        // 声明一个int类型的数组，使用静态初始化的方式\n        int[] a = {1, 100, 10, 20, 55, 689};\n        // 这是C++风格，不建议java中使用。\n        //int a[] = {1, 100, 10, 20, 55, 689};\n\n        // 所有的数组对象都有length属性\n        System.out.println(\"数组中元素的个数\" + a.length);\n\n        // 数组中每一个元素都有下标\n        // 通过下标对数组中的元素进行存和取。\n        // 取（读）\n        System.out.println(\"第一个元素 = \" + a[0]);\n        System.out.println(\"最后一个元素 = \" + a[5]);\n        System.out.println(\"最后一个元素 = \" + a[a.length - 1]);\n\n        // 存（改）\n        // 把第一个元素修改为111\n        a[0] = 111;\n        // 把最后一个元素修改为0\n        a[a.length - 1] = 0;\n\n        System.out.println(\"第一个元素 = \" + a[0]);\n        System.out.println(\"最后一个元素 = \" + a[5]);\n\n        // 一维数组怎么遍历呢？\n        for(int i = 0; i \u003c a.length; i++){\n            System.out.println(a[i]); // i是从0到5，是下标\n        }\n\n        // 下标为6表示第7个元素，第7个元素没有，下标越界了。会出现什么异常呢？\n        //System.out.println(a[6]); //ArrayIndexOutOfBoundsException（比较著名的异常。）\n\n        // 从最后一个元素遍历到第1个元素\n        for (int i = a.length - 1; i \u003e= 0; i--) {\n            System.out.println(\"颠倒顺序输出--\u003e\" + a[i]);\n        }\n    }\n}\n\n```\noutput\n![[asset/Pasted image 20220715190322.png]]","lastmodified":"2022-09-20T05:41:06.46632558Z","tags":null},"/192-main%E6%96%B9%E6%B3%95%E4%B8%8A%E9%9D%A2%E7%9A%84String-args":{"title":"","content":"\u003e[!tip]+ 作用\n\u003e这个数组是留给用户的，用户可以在控制台上输入参数，这个参数自动会被转换为“String[] args”\n## 解释\n JVM调用main方法的时候，会自动传一个String数组过来。\n 这个方法程序员负责写出来，JVM负责调用。JVM调用的时候一定会传一个String数组过来。\n默认长度：0\n! [[asset/Pasted image 20220715192618.png|400]]\n\n## 输入参数\n输入会变成一个数组，**空格分开各个参数**，不是逗号\n第一种：\n\t1. 打开run的这个  ![[asset/Pasted image 20220715192913.png|400]]\n\t2. 设置参数 ![[asset/Pasted image 20220715193053.png|400]]\n\t3. output![[asset/Pasted image 20220715193123.png|400]]\n第二种：\n\t1. 在cmd窗口，javac编译\n\t2. `javac 文件名 你输入的参数`，也可以带入参数\n\t3. ![[asset/Pasted image 20220715193821.png|500]]\n\t\n","lastmodified":"2022-09-20T05:41:06.46632558Z","tags":null},"/193-%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%95%B0%E7%BB%84":{"title":"","content":"\u003e[!info]+ 总结\n\u003e数组中可以将**引用类型**的类型实例作为**元素**\n\u003e元素可以是这个元素的类本身的对象，也**可以是他的继承对象**，即子类型的对象\n\u003e还可以通过遍历的方式去使用其中的方法\n\n```java\npublic class Test03 {  \n    public static void main(String[] args) {  \n//        创建一个Animal类型的数组  \n        Animal[] an={new Animal(),new Cat(),new Dog(),new DogSon()};  \n        for (int i=0;i\u003can.length;i++){  \n            an[i].move();  \n        }  \n    }  \n}  \n  \nclass Animal{  \n    public void move(){  \n        System.out.println(\"动物在移动\");  \n    }  \n}  \nclass Cat extends Animal{  \n    @Override  \n    public void move() {  \n        System.out.println(\"小猫在走猫步\");  \n    }  \n}  \nclass Dog extends Animal{  \n    @Override  \n    public void move() {  \n        System.out.println(\"小狗在打滚\");  \n    }  \n}  \nclass  DogSon extends Dog{  \n    @Override  \n    public void move() {  \n        System.out.println(\"狗儿子在学打滚\");  \n    }  \n}\n```\n\noutput\n![[asset/Pasted image 20220715204628.png]]","lastmodified":"2022-09-20T05:41:06.46632558Z","tags":null},"/194-%E6%95%B0%E7%BB%84%E6%89%A9%E5%AE%B9":{"title":"","content":"先新建一个大容量的数组，然后将小容量数组中的数据一个一个拷贝到大数组当中。\n\u003e[!tip]+ 注意\n\u003e如果数组的元素是引用，那么数组中存储的其对象的内存地址\n\u003e所以，拷贝的时候实际是拷贝的内存地址\n\n  结论：数组扩容效率较低。因为涉及到拷贝的问题。所以在以后的开发中请注意：尽可能少的进行数组的拷贝。\n  可以在创建数组对象的时候预估计以下多长合适，最好预估准确，这样可以减少数组的扩容次数。提高效率。\n  \u003e[!bug]+ 数组拷贝方法：arrarycopy()\n  \u003earraycopy() 方法位于 java.lang.System 类中\n\n语法格式\n  ```java\nSystem.arraycopy(dataType[] srcArray,int srcIndex,int destArray,int destIndex,int length)\n```\n原数组,原数组中的起始下标,目标数组,目标数组中的起始下标,复制的数组长度。\n# eg\n```java\npublic class Test04 {  \n    public static void main(String[] args) {  \n        int[] a={1,5,6,4,4};  \n        int[] b=new int[10];  \n        System.arraycopy(a,0,b,2,a.length);  \n        for (int i=0;i\u003c b.length;i++){  \n            System.out.println(\"第\"+i+\"个元素：\"+b[i]);  \n        }  \n    }  \n}\n```\n\noutput\n![[asset/Pasted image 20220716102350.png]]\n\n# 其他拷贝方法\n[java拷贝](http://c.biancheng.net/view/924.html)","lastmodified":"2022-09-20T05:41:06.46632558Z","tags":null},"/195-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84":{"title":"","content":"## 概述\n1. 二维数组其实是一个特殊的一维数组，特殊在这个**数组当中的每一个元素是一个一维数组。**\n2. 三维数组同理，每一个元素都是一个二维数组\n## 初始化\n1. 静态初始化\n```java\nint[][] array = {{1,1,1},{2,3,4,5},{0,0,0,0},{2,3,4,5},{2,3,4,5},{2,3,4,5},{2,3,4,5}};\n```\n2. 动态初始化\n```java\nnt[][] array = new int[3][4];\n```\n\n\u003e[!info]+ 注意\n\u003e静态初始化可以建立一个不规则的二维数组，即每个元素数组中的元素个数可能不相同。\n\u003e比如，第一个元素数组中的个数是5，第二个元素数组中的个数是8；\n\u003e但动态初始化，每行每列的个数都是一样的，即每个元素数组 中的个数都是一样的。\n\u003e**数组一旦建立，其元素个数不变，只能通过[[194.数组扩容|数组扩容]]**的方式来增加容量\n\u003e![[asset/Pasted image 20220716111850.png]]\n\n### 赋值的方法\n1. 先建一个一维数组b，然后赋给二维数组a[0]\n2. 对二维数组的元素一个一个赋值\n","lastmodified":"2022-09-20T05:41:06.46632558Z","tags":null},"/196-eg1-%E6%A8%A1%E6%8B%9F%E5%8E%8B%E6%A0%88":{"title":"","content":"```java\n\n/*\n\n    编写程序，使用一维数组，模拟栈数据结构。\n\n    要求：\n\n        1、这个栈可以存储java中的任何引用类型的数据。\n\n        2、在栈中提供push方法模拟压栈。（栈满了，要有提示信息。）\n\n        3、在栈中提供pop方法模拟弹栈。（栈空了，也有有提示信息。）\n\n        4、编写测试程序，new栈对象，调用push pop方法来模拟压栈弹栈的动作。\n\n        5、假设栈的默认初始化容量是10.（请注意无参数构造方法的编写方式。）\n\n */\n\npublic class MyStackTest {\n\n    public static void main(String[] args) {\n\n  \n\n        // 创建一个栈对象，初始化容量是10个。\n\n        MyStack stack = new MyStack();\n\n  \n\n        // 调用方法压栈\n\n        stack.push(new Object());\n\n        stack.push(new Object());\n\n        stack.push(new Object());\n\n        stack.push(new Object());\n\n        stack.push(new Object());\n\n        stack.push(new Object());\n\n        stack.push(new Object());\n\n        stack.push(new Object());\n\n        stack.push(new Object());\n\n        stack.push(new Object()); // 最后压入的。最先弹出来。（这个才符合栈的数据结构。）\n\n  \n\n        // 压这个元素失败了。\n\n        stack.push(new Object());\n\n  \n\n        // 弹栈\n\n        stack.pop();\n\n        stack.pop();\n\n        stack.pop();\n\n        stack.pop();\n\n        stack.pop();\n\n        stack.pop();\n\n        stack.pop();\n\n        stack.pop();\n\n        stack.pop();\n\n        stack.pop();\n\n  \n\n        stack.pop();\n\n    }\n\n}\n```\n\n```\nclass MyStack {\n\n    // 向栈当中存储元素，我们这里使用一维数组模拟。存到栈中，就表示存储到数组中。\n\n    // 因为数组是我们学习java的第一个容器。\n\n    // 为什么选择Object类型数组？因为这个栈可以存储java中的任何引用类型的数据\n\n    // new Animal()对象可以放进去，new Person()对象也可以放进去。因为Animal和Person的超级父类就是Object。\n\n    // 包括String也可以存储进去。因为String父类也是Object。\n\n    private Object[] elements;\n\n  \n\n    // 栈帧，永远指向栈顶部元素\n\n    // 那么这个默认初始值应该是多少。注意：最初的栈是空的，一个元素都没有。\n\n    //private int index = 0; // 如果index采用0，表示栈帧指向了顶部元素的上方。\n\n    //private int index = -1; // 如果index采用-1，表示栈帧指向了顶部元素。\n\n    private int index;\n\n  \n\n    /**\n\n     * 无参数构造方法。默认初始化栈容量10.\n\n     */\n\n    public MyStack() {\n\n        // 一维数组动态初始化\n\n        // 默认初始化容量是10.\n\n        this.elements = new Object[10];\n\n        // 给index初始化\n\n        this.index = -1;\n\n    }\n\n  \n\n    /**\n\n     * 压栈的方法\n\n     * @param obj 被压入的元素\n\n     */\n\n    public void push(Object obj){\n\n        if(index \u003e= elements.length - 1){\n\n            System.out.println(\"压栈失败，栈已满！\");\n\n            return;\n\n        }\n\n        // 程序能够走到这里，说明栈没满\n\n        // 向栈中加1个元素，栈帧向上移动一个位置。\n\n        index++;\n\n        elements[index] = obj;\n\n        // 在声明一次：所有的System.out.println()方法执行时，如果输出引用的话，自动调用引用的toString()方法。\n\n        System.out.println(\"压栈\" + obj + \"元素成功，栈帧指向\" + index);\n\n    }\n\n  \n\n    /**\n\n     * 弹栈的方法，从数组中往外取元素。每取出一个元素，栈帧向下移动一位。\n\n     * @return\n\n     */\n\n    public void pop(){\n\n        if(index \u003c 0){\n\n            System.out.println(\"弹栈失败，栈已空！\");\n\n            return;\n\n        }\n\n        // 程序能够执行到此处说明栈没有空。\n\n        System.out.print(\"弹栈\" + elements[index] + \"元素成功，\");\n\n        // 栈帧向下移动一位。\n\n        index--;\n\n        System.out.println(\"栈帧指向\" + index);\n\n    }\n\n  \n\n    // set和get也许用不上，但是你必须写上，这是规矩。你使用IDEA生成就行了。\n\n    // 封装：第一步：属性私有化，第二步：对外提供set和get方法。\n\n    public Object[] getElements() {\n\n        return elements;\n\n    }\n\n  \n\n    public void setElements(Object[] elements) {\n\n        this.elements = elements;\n\n    }\n\n  \n\n    public int getIndex() {\n\n        return index;\n\n    }\n\n  \n\n    public void setIndex(int index) {\n\n        this.index = index;\n\n    }\n\n}\n```\n\noutput\n![[asset/Pasted image 20220716200322.png]]","lastmodified":"2022-09-20T05:41:06.46632558Z","tags":null},"/197-eg2-%E9%85%92%E5%BA%97":{"title":"","content":"# 思路\n\u003e[!tip]+ 怎么个思路\n\u003e1. 搭建一个酒店，需要考虑其基本的组成\n\u003e2. 一个酒店的基本单位是房间，所以需要一个room类，房间有三个状态。\n\u003e\t1. 房间号，由层数和房间号组成\n\u003e\t2. 空闲与否，boolean\n\u003e\t3. 房间类型：单人间、标准间、豪华间\n\u003e4. 房间需要考虑是否是一个房间，以及如何进行输出。所以需要考虑重写`equals`和`toString`方法\n\u003e5. hotel类由许多的房间组成，所以hotel的属性就是room类型的二维数组 \n\u003e6. 需要的方法\n\u003e\t1. 打印房间情况的方法\n\u003e\t2. 订房的方法\n\u003e\t3. 退房的方法\n\u003e7. 一个主类对方法进行测试\n\u003e\t1. 建酒店，new 一个hotel\n\u003e\t2. if判断用户需求\n\n# 代码\n```java\n\npublic class Room {  \n    //test  \n/*    public static void main(String[] args) {  \n        Room r=new Room(12,\"单人间\",true);  \n        System.out.println(r);    }*/    private int no;  \n    private String type;  \n    private boolean status;  \n  \n    //封装  \n    public Room() {  \n        this.status=true;//默认空闲  \n    }  \n  \n    public Room(int no, String type, boolean status) {  \n        this.no = no;  \n        this.type = type;  \n        this.status = status;  \n    }  \n  \n    public int getNo() {  \n        return no;  \n    }  \n  \n    public void setNo(int no) {  \n        this.no = no;  \n    }  \n  \n    public String getType() {  \n        return type;  \n    }  \n  \n    public void setType(String type) {  \n        this.type = type;  \n    }  \n  \n    public boolean isStatus() {  \n        return status;  \n    }  \n  \n    public void setStatus(boolean status) {  \n        this.status = status;  \n  \n    }  \n//    重写equals方法  \n  \n    @Override  \n    public boolean equals(Object obj) {  \n        if (obj==null||!(obj instanceof Room)) return false;  \n        if (obj==obj) return true;  \n        Room r=(Room)obj;  \n        return this.no==r.no;  \n    }  \n//    重写toString方法  \n  \n    @Override  \n    public String toString() {  \n        return \"[\"+no+\" \"+type+\" \"+(status==true?\"空闲\":\"占用\")+\"]\";  \n    }  \n}\n```\n\n```java  \npublic class Hotel {  \n    private Room[][] rooms;  \n  \n    //对一个酒店进行基本的构造  \n    public Hotel() {  \n        rooms = new Room[3][10];  \n        for (int i = 0; i \u003c rooms.length; i++) {  \n            for (int j = 0; j \u003c rooms[i].length; j++) {  \n                if (i == 0) {  \n                    rooms[i][j] = new Room((i + 1) * 100 + j + 1, \"单人间\", true);  \n                } else if (i == 1) {  \n                    rooms[i][j] = new Room((i + 1) * 100 + j + 1, \"标准间\", true);  \n                } else {  \n                    rooms[i][j] = new Room((i + 1) * 100 + j + 1, \"豪华间\", true);  \n                }  \n            }  \n        }  \n    }  \n  \n    public Hotel(Room[][] rooms) {  \n        this.rooms = rooms;  \n    }  \n//    //重写toString方法，将所有的房间返回  \n    @Override  \n    public String toString() {  \n        String s=\"\";  \n        for (int i = 0; i \u003c rooms.length; i++) {  \n            for (int j = 0; j \u003c rooms[i].length; j++) {  \n                s+=rooms[i][j]+\" \";  \n            }  \n                s+=\"\\n\";  \n        }  \n        return s;  \n    }  \n//    打印空闲的房间  \n    public void dayin(){  \n        for (int i = 0; i \u003c rooms.length; i++) {  \n            for (int j = 0; j \u003c rooms[i].length; j++) {  \n                if (rooms[i][j].isStatus()==true){  \n                    System.out.println(rooms[i][j]);  \n                }  \n            }  \n            System.out.println();  \n        }  \n    }  \n  \n//    订房  \n    public void order(int roomNo){  \n        Room room=rooms[roomNo/100-1][roomNo%100-1];//获取房间对象的数组下标  \n        if (room.isStatus()==true){  \n            room.setStatus(false);  \n            System.out.println(room.getNo()+\"订房成功\");  \n        }else  \n            System.out.println(room.getNo()+\"已被其他人订房\");  \n    }  \n    //退房  \n    public void exit(int roomNo){  \n        Room room=rooms[roomNo/100-1][roomNo%100-1];//获取房间对象的数组下标  \n        if (room.isStatus()==false){  \n            room.setStatus(true);  \n            System.out.println(room.getNo()+\"退房成功\");  \n        }else  \n            System.out.println(room.getNo()+\"未被订房，退房失败\");  \n    }  \n  \n  \n}\n```\n\n```java\npublic class HotelManagerSystem {  \n    public static void main(String[] args) {  \n        Hotel h=new Hotel();  \n        System.out.println(\"请输入数字选择功能选项：\");  \n  \n        java.util.Scanner s=new java.util.Scanner(System.in);  \n  \n        while (true){  \n            System.out.println(\"[0]退出系统 [1]查看房间情况 [2]订房 [3]退房 [4]空房查询\" );  \n            int i=s.nextInt();  \n            if (i==0){  \n                System.out.println(\"欢迎下次光临，正在退出系统 ~\");  \n                break;  \n            } else if (i==1) {  \n                System.out.println(\"正在为你获取房间情况：\");  \n                System.out.println(h);  \n            } else if (i==2) {  \n                System.out.println(\"输入您要订阅的房间号码：\");  \n                i=s.nextInt();  \n                h.order(i);  \n            }else if (i==3) {  \n                System.out.println(\"输入您要退订的房间号码：\");  \n                i=s.nextInt();  \n                h.exit(i);  \n            }else if (i==4) {  \n                //剩余空房  \n                System.out.println(\"====剩余空房：\");  \n                h.dayin();  \n            }  \n        }  \n        s.close();  \n    }  \n}\n```\noutput\n![[asset/Pasted image 20220718215324.png]]\n![[asset/Pasted image 20220718215331.png]]\n## 总结\n\u003e[!bug]+ 总结\n\u003e如果直接做题的话，我发现思路非常不好，尤其是对于程序的逻辑方面，不知道自己需要做什么，老是忘记自己要写什么方法，需要怎么去覆盖tostring以及equals等等\n\u003e但是如果事先将思路整理写下来，然后再进行工作的话，我发现这个速度一下就蹭蹭上去了","lastmodified":"2022-09-20T05:41:06.46632558Z","tags":null},"/201-%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%9F%A5%E6%89%BE":{"title":"","content":"\n## 排序的内置方法java.util.Arrays\neg\n```java\njava.util.Arrays(数组名);\n```\noutput\n\t![[asset/Pasted image 20220720101424.png]]\n\n## [[202.冒泡排序方法]]\n## [[203.选择排序]]\n## [[204.顺序查找]]\n## [[205.二分查找]]\n## [[207.数组工具类java.util.Arrays]]","lastmodified":"2022-09-20T05:41:06.470325645Z","tags":null},"/202-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95":{"title":"","content":"\u003e[!tip]+ 讲解\n\u003e1. 从第一个开始，依次向右比较，左边比右边的数大，就交换两个数字\n\u003e2. 第一轮可以把最大的数字放到最左边，第二轮依次\n\u003e![冒泡](https://www.runoob.com/wp-content/uploads/2019/03/bubbleSort.gif)\n\n```java\npublic class Test02 {  \n    public static void main(String[] args) {  \n        int[] b={1,54,6,7,6,464,78,12,46};  \n        int[] c=sorta(b);  \n        for (int i = 0; i \u003c c.length ; i++) {  \n            System.out.println(c[i]);  \n        }  \n  \n    }  \n    //冒泡排序 方法  \n    public static int[] sorta(int[] a){  \n        for (int i = a.length-1; i \u003e0 ; i--) {  \n            for (int j = 0; j \u003ci; j++) {  \n                if (a[j]\u003ea[j+1]){  \n                    //如果前一个大于后一个，就互换位置  \n                    int tmp=a[j];  \n                    a[j]=a[j+1];  \n                    a[j+1]=tmp;  \n                }  \n            }  \n        }  \n        return a;  \n    }  \n}\n```\noutput\n![[asset/Pasted image 20220720192154.png]]\n\n\n","lastmodified":"2022-09-20T05:41:06.470325645Z","tags":null},"/203-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F":{"title":"","content":"\u003e[!tip]+ 讲解\n\u003e假设第一个数字为最小的数min，然后依次在这个数字后面找更小的数\n\u003e如果找到了就记录最小数的下标，然后再把这个数与参与排序的第一个数相互交换\n\u003e再假设第二个数为最小的数，在其后找最小的数交换\n\u003e注意：与冒泡排序循环次数一样，都是(n-1)?   阶加次\n\u003e时间复杂度： O(n²)\n演示\n![](https://www.runoob.com/wp-content/uploads/2019/03/selectionSort.gif)\n```java\npublic class Test03 {  \n  \n    public static void main(String[] args) {  \n        int[] c=sorta(new int[]{2,3,38,5,47,15,36,26,27,44,46,38,47,50,48});  \n        for (int i = 0; i \u003c c.length ; i++) {  \n            System.out.print(c[i]+\" \");  \n        }  \n    }  \n    public static int[] sorta(int[] a){  \n        //每次找出最小的那个数  \n        for (int i = 0; i \u003ca.length-1; i++) {  \n            int min=i;//假设每次最小的那个数是参与排序最前面的那个数，i是那个数的下标  \n            for (int j =i+1; j \u003ca.length; j++) {  \n                if (a[min]\u003ea[j]){  \n                    min=j;//如果能在其中找到更小的就记录下他的下标  \n                }  \n            }  \n            //如果这个最小的数不在参与排序的最前面，就和那个最前面的数交换  \n            if (min!=i){  \n                int tmp=a[i];  \n                a[i]=a[min];  \n                a[min]=tmp;  \n            }  \n  \n        }  \n        return a;  \n    }  \n  \n  \n}\n```\noutput\n![[asset/Pasted image 20220720210200.png]]\n\n","lastmodified":"2022-09-20T05:41:06.470325645Z","tags":null},"/204-%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE":{"title":"","content":"```java\npublic class SearchTest01 {  \n    public static void main(String[] args) {  \n        int[] arr={1,5,45,5,64,8};  \n/*        for (int i = 0; i \u003carr.length ; i++) {  \n            if (arr[i]==64){                System.out.println(\"64的下标是\"+i);  \n                return;            }        }        //程序能够走到这儿，说明没有找到64  \n        System.out.println(\"没找到\");*/  \n  \n    //    对以上封装一个方法  \n        int arrIndex=arraySearch(arr,5);  \n        System.out.println(arrIndex==-1?\"该元素不存在\":\"该元素的下标是\"+arrIndex);  \n  \n    }  \n  \n    /**  \n     *从数组中检索某个元素的下标  \n     * @param arr 被检索的数组  \n     * @param ele  被检索的元素  \n     * @return   返回的数值表示元素在数组中的下标,如果为-1表示不存在  \n     */  \n    public static int arraySearch(int[] arr, int ele) {  \n        for (int i = 0; i \u003carr.length ; i++) {  \n            if(ele==arr[i]){  \n                return i;    //返回下标  \n            }  \n        }  \n        return -1;//如果没找到就返回-1  \n    }  \n}\n```\noutput\n![[asset/Pasted image 20220722165403.png]]","lastmodified":"2022-09-20T05:41:06.470325645Z","tags":null},"/205-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE":{"title":"","content":"必要条件:**必须要在排序的基础上  **\n![](https://www.runoob.com/wp-content/uploads/2019/05/Binary_search_into_array.png)\n\n\n```java\npublic class ArraySearch02 {  \n    public static void main(String[] args) {  \n        int[] arr={1,45,56,78,89,455,1254,4546};  \n        int index=arrBinSearch(arr,78);  \n        System.out.println(index==-1?\"该元素不存在\":\"该元素的下标是\"+index);  \n        index=arrBinSearch(arr,1);  \n        System.out.println(index==-1?\"该元素不存在\":\"该元素的下标是\"+index);  \n    }  \n  \n    public static int arrBinSearch(int[] arr, int ele) {  \n    //    定义大数,小数,中间数的下标  \n        int first=0;  \n        int last=arr.length-1;  \n        int mid=0;  \n  \n        //当小数等于小于后面的大数才运行  \n        while (first\u003c=last){  \n            mid=(last+first)/2;  \n  \n            if (ele\u003earr[mid]){               //如果查找的元素大于中间数,那么就first就调整为mid的下一个元素,在右半区域继续二半查找  \n                first=mid+1;  \n            } else if (ele\u003carr[mid]) {          //如果查找的元素小于中间数,那么就last就调整为mid的下上个元素,在左半区域继续二半查找  \n                last=mid-1;  \n            } else {                //如果刚好相等,就直接返回下标  \n                return mid;  \n            }  \n        }  \n  \n        return -1;  \n    }  \n}\n```\noutput\n![[asset/Pasted image 20220722174209.png]]","lastmodified":"2022-09-20T05:41:06.470325645Z","tags":null},"/207-%E6%95%B0%E7%BB%84%E5%B7%A5%E5%85%B7%E7%B1%BBjava.util.Arrays":{"title":"","content":"\n\neg\n```java\nimport java.util.Arrays;  \n  \npublic class ArrayTest04 {  \n    public static void main(String[] args) {  \n        int[] arr={1,45,6,45,44,56,68,165,45,4,14,61,64,98};  \n    //    使用arrays工具类对其进行排序  \n        Arrays.sort(arr);  \n    //    对排序后的数组进行输出  \n        for (int i = 0; i \u003carr.length ; i++) {  \n            System.out.print(arr[i]+\" \");  \n        }  \n  \n    //    使用arrays工具类进行二分查找  \n        int index=Arrays.binarySearch(arr,45);  \n        System.out.println(index==-1?\"该元素不存在\":\"该元素的下标为\"+index);  \n    }  \n}\n```\n\n\u003e[!tip]+ 其他\n\u003e可以看到,[[205.二分查找|二分查找]]的方法相比顺序查找除了查找效率和查找条件(必须是排序好的序列)不同之外,查找到的元素如果有多个一样的值,那么可能查找的不是第一个元素的下标","lastmodified":"2022-09-20T05:41:06.470325645Z","tags":null},"/212-String%E7%B1%BB":{"title":"","content":"# String基本\n\n\u003e[!tip]+ 关于Java JDK中内置的一个类：`java.lang.String`\n\u003e1. String表示**字符串**，属于**引用数据类型**，不属于基本数据类型。\n\u003e2. 在java中随便使用双引号括起来的都是String对象。例如：\"abc\"，\"def\"，\"hello world!\"，这是3个String对象。\n\u003e3. java中规定，双引号括起来的字符串，是不可变的，也就是说\"abc\"自出生到最终死亡，不可变，不能变成\"abcd\"，也不能变成\"ab\"\n\u003e4. **在JDK当中双引号括起来的字符串**，例如：\"abc\" \"def\"都是**直接存储在“方法区”的“字符串常量池”当中**的。因为这些字符串需要频繁的进行使用,**垃圾回收器是不会回收常量的**\n\u003e5. 不管是直接用双引号定义的字符串变量,还是new出来的字符串,双引号字符串都是存储在方法区中的常量池的,new出来的,会在堆中存放一个指向这个常量池的内存地址\n\n## eg1\n\n```java\npublic class StringTest01 {\n    public static void main(String[] args) {\n        // 这两行代码表示底层创建了3个字符串对象，都在字符串常量池当中。\n        String s1 = \"abcdef\";\n        String s2 = \"abcdef\" + \"xy\";\n\n        // 分析：这是使用new的方式创建的字符串对象。这个代码中的\"xy\"是从哪里来的？\n        // 凡是双引号括起来的都在字符串常量池中有一份。\n        // new对象的时候一定在堆内存当中开辟空间。\n        String s3 = new String(\"xy\");\n\n        // i变量中保存的是100这个值。\n        int i = 100;\n        // s变量中保存的是字符串对象的内存地址。\n        // s引用中保存的不是\"abc\"，是0x1111\n        // 而0x1111是\"abc\"字符串对象在“字符串常量池”当中的内存地址。\n        String s = \"abc\";\n    }\n}\n```\n\n ![[../../../../../asset/001-String的内存图.png]]\n 如上图,s3保存的不是字符串\"xy\",保存的是\"xy\"字符串的内存地址,\"xy保存在方法区中的常量池当中\"\n## String的比较\n因为new对象的所保存的内存地址可能不同,采用\\=\\=比较的并不是直接比较的其字面量的地址,所以可能出错\n**建议采用equals的方法去对String类型字符串或者对象进行比较**\n**因为字符串对象的equals是已经被重写过,不用再写**\n```java\npublic class StringTest02 {\n    public static void main(String[] args) {\n        String s1 = \"hello\";\n        // \"hello\"是存储在方法区的字符串常量池当中\n        // 所以这个\"hello\"不会新建。（因为这个对象已经存在了！）\n        String s2 = \"hello\";\n        // 分析结果是true还是false？\n        // == 双等号比较的是不是变量中保存的内存地址？是的。\n        System.out.println(s1 == s2); // true\n\n        String x = new String(\"xyz\");\n        String y = new String(\"xyz\");\n        // 分析结果是true还是false？\n        // == 双等号比较的是不是变量中保存的内存地址？是的。\n        System.out.println(x == y); //false\n\n        // 通过这个案例的学习，我们知道了，字符串对象之间的比较不能使用“==”\n        // \"==\"不保险。应该调用String类的equals方法。\n        // String类已经重写了equals方法，以下的equals方法调用的是String重写之后的equals方法。\n        System.out.println(x.equals(y)); // true\n\n        String k = new String(\"testString\");\n        //String k = null;\n        // \"testString\"这个字符串可以后面加\".\"呢？\n        // 因为\"testString\"是一个String字符串对象。只要是对象都能调用方法。\n        System.out.println(\"testString\".equals(k)); // 建议使用这种方式，因为这个可以避免空指针异常。\n        System.out.println(k.equals(\"testString\")); // 存在空指针异常的风险。不建议这样写。\n    }\n}\n\n```\n\noutput\n```cmd\ntrue\nfalse\ntrue\n```\n\n# String常用构造方法\nhttps://www.matools.com/file/manual/jdk_api_1.8_google/java/lang/String.html\n```java\npublic class Test02 {  \n    public static void main(String[] args) {  \n    //    最常用的构造方法  \n        String s=\"最常用的常用方法\";  \n        System.out.println(s);  \n    //    第二种  \n        String s2=new String(\"第二种方法\");  \n        System.out.println(s2);  \n    //    第三种  \n        char[] c1={'我','是','中','国','人'};  \n        String s3=new String(c1);  \n        System.out.println(s3);  \n        String s33=new String(c1,2,3);//在char数组中,第二个开始,抽取三个元素  \n    //    第四种  \n        byte[] b4= {97,98,99,100};  \n        String s4=new String(b4);  \n        System.out.println(s4);  \n        String s44=new String(b4,0,3);  \n        System.out.println(s44);  \n  \n  \n    }  \n}\n```\noutput\n![[../../../../../asset/Pasted image 20220722204855.png]]\n\n ","lastmodified":"2022-09-20T05:41:06.470325645Z","tags":null},"/213-String%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95":{"title":"","content":"```java\n  \npublic class Test03 {  \n    public static void main(String[] args) {  \n        //charAt 返回字符串指定下标的字符  \n        String a=\"我是一个中国人\";  \n        System.out.println(a.charAt(2));  \n        System.out.println(\"===============\");  \n  \n        //compareTo 按照字典进行比较,按位比较,0就相等,正数或者负数表示前面和后面第一个不相同的数字的大小差值,能比出来,后面的就不比较了  \n        System.out.println(\"abc\".compareTo(\"abd\"));  \n        System.out.println(\"abc\".compareTo(\"abb\"));  \n        System.out.println(\"abc\".compareTo(\"cba\"));  \n        System.out.println(\"abc\".compareTo(\"abc\"));  \n        System.out.println(\"abc\".compareTo(\"efz\"));  \n        System.out.println(\"abc\".compareTo(\"a\"));  \n        System.out.println(\"=================\");  \n  \n        //contains(CharSequence s),前面的字符串是否包含后面的字符串  \n        System.out.println(\"我是你爸爸的儿子的大帅比\".contains(\"儿子\"));  \n        System.out.println(\"==============\");  \n  \n        System.out.println(\"endsWith(String suffix) 此字符串是否以指定的后缀结尾。\");  \n        System.out.println(\"我是大帅比\".endsWith(\"大帅比\"));  \n        System.out.println(\"我是蔡徐坤\".endsWith(\"还好吧\"));  \n        System.out.println(\"startsWith(String prefix) 此字符串是否以指定的前缀开始\");  \n        System.out.println(\"javadasklfjkalsfjakok\".startsWith(\"java\"));  \n        System.out.println(\"==================\");  \n  \n        //equals() 和      equalsIgnoreCase(String str)        System.out.println(\"abc\".equals(\"abc\"));  \n        System.out.println(\"abc\".equals(\"abC\"));  \n        System.out.println(\"abc\".  equalsIgnoreCase(\"abC\"));//忽略大小写的比较  \n  \n    //    getBytes()  把字符串对象转换成byte数组  \n        byte[] byte1=\"abc\".getBytes();  \n        System.out.println(byte1[2]);  \n  \n        // indexOf(String str) 返回指定子字符串第一次出现的字符串内的索引。  \n        //lastIndexOf(String str)  最后一次出现的索引  \n        System.out.println(\"凉风不顾归尘仆仆的行者零落了世间所有的风华，我在天涯征程之外寻寻觅觅那一树的花开，冷香随着秋风袭卷了草木荣枯的来去归途。\".indexOf(\"世间所有的风华\"));  \n        System.out.println(\"你是谁,我是谁\".lastIndexOf(\"是谁\"));  \n        // isEmpty() length是否为0,不包括null  \n        System.out.println(\"isEmpty=======\");  \n        System.out.println(\"ab\".isEmpty());  \n        System.out.println(\"\".isEmpty());  \n        String string1=new String();  \n        //string1=null;  //下面会出现空值异常,底层调用的length方法  \n        System.out.println(string1.isEmpty());  \n  \n  \n        //判断字符串长度是length()方法,判断数组长度是length属性  \n        System.out.println(\"hello\".length());  \n  \n        // replace(char oldChar, char newChar) 替换字符串  \n        System.out.println(\"我是大帅比,你是不是?\".replace(\"是\",\"像\"));  \n  \n        //split(String regex)  用字符串分割为数组  \n        String[] sp1=\"帅哥,小姐,美女,野兽,帅比,儿子,孙子,玫瑰,显化\".split(\",\");  \n        for (int i = 0; i \u003csp1.length ; i++) {  \n            System.out.print(sp1[i]+\" \");  \n        }  \n  \n        System.out.println(\"substring(int beginIndex) 返回该字符串指定下标开始的子字符串\");  \n        System.out.println(\"https://www.baidu.com\".substring(5));//下标为5开始的后面字符串,包括5  \n        System.out.println(\"https://www.baidu.com\".substring(4,6));//下标为4开始,下标为6-1结束,左闭右开  \n  \n        System.out.println(\"toCharArray() 将此字符串转换为新的字符数组。\");  \n        char[] chars2=\"我是大帅哥\".toCharArray();  \n        for (int i = 0; i \u003c chars2.length; i++) {  \n            System.out.println(chars2[i]);  \n        }  \n  \n        System.out.println(\"toLowerCase() 转换成小写\");  \n        System.out.println(\"ABdfdsfDDSFS\".toLowerCase());  \n        System.out.println(\"\\ttoUpperCase() 转换成大写\");  \n        System.out.println(\"abcdefgHJ\".toUpperCase());  \n  \n  \n        System.out.println(\"\\ttrim()\\n\" +  \n                \"返回一个字符串，其值为此字符串，并删除任何前导和尾随空格。\");  \n        System.out.println(\"   sjkfjslf  fskjfs  fsjfks\".trim());  \n  \n        System.out.println(\"valueOf(boolean b) 把不是字符串的转换成字符串\");  \n        String s7=String.valueOf(true);  \n        System.out.println(s7);//是字符串，不是boolean类型了  \n        System.out.println(String.valueOf(new Customer()));//当是对象的时候，会调用toString方法  \n    }  \n  \n}  \nclass Customer{  \n    @Override  \n    public String toString() {  \n        return \"我是一个vip客户\";  \n    }  \n}\n```\noutput\n\n```cmd\n\"C:\\Program Files\\Java\\jdk1.8.0_152\\bin\\java.exe\" \"-javaagent:C:\\Program Files\\JetBrains\\IntelliJ IDEA Community Edition 2022.1.3\\lib\\idea_rt.jar=4130:C:\\Program Files\\JetBrains\\IntelliJ IDEA Community Edition 2022.1.3\\bin\" -Dfile.encoding=UTF-8 -classpath \"C:\\Program Files\\Java\\jdk1.8.0_152\\jre\\lib\\charsets.jar;C:\\Program Files\\Java\\jdk1.8.0_152\\jre\\lib\\deploy.jar;C:\\Program Files\\Java\\jdk1.8.0_152\\jre\\lib\\ext\\access-bridge-64.jar;C:\\Program Files\\Java\\jdk1.8.0_152\\jre\\lib\\ext\\cldrdata.jar;C:\\Program Files\\Java\\jdk1.8.0_152\\jre\\lib\\ext\\dnsns.jar;C:\\Program Files\\Java\\jdk1.8.0_152\\jre\\lib\\ext\\jaccess.jar;C:\\Program Files\\Java\\jdk1.8.0_152\\jre\\lib\\ext\\jfxrt.jar;C:\\Program Files\\Java\\jdk1.8.0_152\\jre\\lib\\ext\\localedata.jar;C:\\Program Files\\Java\\jdk1.8.0_152\\jre\\lib\\ext\\nashorn.jar;C:\\Program Files\\Java\\jdk1.8.0_152\\jre\\lib\\ext\\sunec.jar;C:\\Program Files\\Java\\jdk1.8.0_152\\jre\\lib\\ext\\sunjce_provider.jar;C:\\Program Files\\Java\\jdk1.8.0_152\\jre\\lib\\ext\\sunmscapi.jar;C:\\Program Files\\Java\\jdk1.8.0_152\\jre\\lib\\ext\\sunpkcs11.jar;C:\\Program Files\\Java\\jdk1.8.0_152\\jre\\lib\\ext\\zipfs.jar;C:\\Program Files\\Java\\jdk1.8.0_152\\jre\\lib\\javaws.jar;C:\\Program Files\\Java\\jdk1.8.0_152\\jre\\lib\\jce.jar;C:\\Program Files\\Java\\jdk1.8.0_152\\jre\\lib\\jfr.jar;C:\\Program Files\\Java\\jdk1.8.0_152\\jre\\lib\\jfxswt.jar;C:\\Program Files\\Java\\jdk1.8.0_152\\jre\\lib\\jsse.jar;C:\\Program Files\\Java\\jdk1.8.0_152\\jre\\lib\\management-agent.jar;C:\\Program Files\\Java\\jdk1.8.0_152\\jre\\lib\\plugin.jar;C:\\Program Files\\Java\\jdk1.8.0_152\\jre\\lib\\resources.jar;C:\\Program Files\\Java\\jdk1.8.0_152\\jre\\lib\\rt.jar;E:\\javaAdvanced\\out\\production\\stringTest\" Test03\n一\n===============\n-1\n1\n-2\n0\n-4\n2\n=================\ntrue\n==============\nendsWith(String suffix) 此字符串是否以指定的后缀结尾。\ntrue\nfalse\nstartsWith(String prefix) 此字符串是否以指定的前缀开始\ntrue\n==================\ntrue\nfalse\ntrue\n99\n14\n5\nisEmpty=======\nfalse\ntrue\ntrue\n5\n我像大帅比,你像不像?\n帅哥 小姐 美女 野兽 帅比 儿子 孙子 玫瑰 显化 substring(int beginIndex) 返回该字符串指定下标开始的子字符串\n://www.baidu.com\ns:\ntoCharArray() 将此字符串转换为新的字符数组。\n我\n是\n大\n帅\n哥\ntoLowerCase() 转换成小写\nabdfdsfddsfs\n\ttoUpperCase() 转换成大写\nABCDEFGHJ\n\ttrim()\n返回一个字符串，其值为此字符串，并删除任何前导和尾随空格。\nsjkfjslf  fskjfs  fsjfks\nvalueOf(boolean b) 把不是字符串的转换成字符串\ntrue\n我是一个vip客户\n\nProcess finished with exit code 0\n\n```\n\n\u003e[!bug]+ 注意\n\u003e可以发现在java中输出 在控制台上的都是经过了toString方法的","lastmodified":"2022-09-20T05:41:06.470325645Z","tags":null},"/214-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5StringBuffer":{"title":"","content":"在`java.lang`中\n帮助文档 : https://www.matools.com/file/manual/jdk_api_1.8_google/java/lang/StringBuffer.html\n# 概述\n\u003e[!tip]+ 使用原因\n\u003e1. 使用+号来对字符串拼接,会在方法区常量池中占用大量的内存,造成方法区的压力(每次拼接都会新建一个字符串在常量池中)\n\u003e2. 使用StringBuffer可以创建字符串缓冲区对象,缓解常量池压力\n\u003e3. 默认是创建16byte的数组作为字符串缓冲区对象![[../../../../../asset/Pasted image 20220723102153.png]] ![[../../../../../asset/Pasted image 20220723102210.png]]\n\n\n\u003e[!tip]+ String和StringBuffer的区别\n\u003e为什么Stirng更加占用常量池,因为在定义String类中,对String添加了`final`关键字,表示其不可变,每次创建都是新创建的一个新的char数组 ![[../../../../../asset/Pasted image 20220723102641.png]]\n\u003e1. 在String创建对象`str`时候,因为`final`关键字,所以`String`指向的char[]数组对象内存地址不可在变,而采用+号进行拷贝的时候,无法str指向新的char[]进行拷贝,因为内存地址指定了就不可再变(final),所以需要新开辟一个地址重新存储拼接的字符串\n\u003e2. 而StringBuffer没有`final`修饰,所以可以通过char[]的arrayscopy操作,对数组进行拷贝,然后重新指向这个新的大数组,作为字符串对象,之前的字符串对象就被回收了,所以不占用多个内存地址\n\n\n# 注意\n1. 在使用`StringBuffer`时,**尽量先初始化合适的容量,避免多次扩容**\n```java\npublic class StringBufferTest01 {  \n    public static void main(String[] args) {  \n        //创建一个默认16byte的数组 作为字符串缓冲区对象  \n        StringBuffer strbuff1=new StringBuffer();  \n        strbuff1.append(\"abc\");  //拷贝进去  \n        System.out.println(strbuff1);  \n        strbuff1.append(\"efg\");  \n        System.out.println(strbuff1);  \n  \n        //给定一个合适的初始化容量  \n        StringBuffer strBuff2=new StringBuffer(100);  \n        strBuff2.append(1245);  //拼接  \n        System.out.println(strBuff2);  \n        strBuff2.append(\"我是大帅比,你是大沙贝\");  \n        System.out.println(strBuff2);  \n  \n    }  \n}\n```\n\noutput\n![[../../../../../asset/Pasted image 20220723103958.png]]","lastmodified":"2022-09-20T05:41:06.470325645Z","tags":null},"/215-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5StringBuilder":{"title":"","content":"帮助文档:[`StringBuilder`](https://www.matools.com/file/manual/jdk_api_1.8_google/java/lang/StringBuilder.html \"java.lang中的类\")\n\n# StringBuilder和[[214.字符串拼接StringBuffer|StringBuffer]]的区别\n\n1. StringBuilder没有`synchronized`关键字修饰,所以在多线程环境下是不安全的,而**[[214.字符串拼接StringBuffer|StringBuffer]]在多线程下是安全的** (StringBuilder非线程安全,StringBuffer线程安全)\n\n```java\npublic class StringBuilderTest01 {  \n    public static void main(String[] args) {  \n        StringBuilder s1=new StringBuilder(100);//初始化容量  \n        s1.append(\"abc\");  \n        System.out.println(s1);  \n        s1.append(123132);  \n        System.out.println(s1);  \n    }  \n}\n```\n\noutput\n```cmd\nabc\nabc123132\n```\n\n\u003e[!tip]+ 面试问题:为什么String是不可变的?\n\u003e\t因为源代码String中有一个char[]数组,一旦指定长度之后,长度就是不可改变的,并且用`final`修饰,指向的内存地址也就不可以指向其他对象了\n\n\n## Integer常量池\n```java\npublic class IntegerTest06 {\n    public static void main(String[] args) {\n\n        Integer a = 128;\n        Integer b = 128;\n        System.out.println(a == b); //false\n\n        /*\n        java中为了提高程序的执行效率，将[-128到127]之间所有的包装对象提前创建好，\n        放到了一个方法区的“整数型常量池”当中了，目的是只要用这个区间的数据不需要\n        再new了，直接从整数型常量池当中取出来。\n\n        原理：x变量中保存的对象的内存地址和y变量中保存的对象的内存地址是一样的。\n         */\n        Integer x = 127;\n        Integer y = 127;\n        // == 永远判断的都是两个对象的内存地址是否相同。\n        System.out.println(x == y); //true\n    }\n}\n```\n\u003e[!tip]+ 面试问题:为什么`Integer`以上的两个变量中,比较的结果不一样\n\u003e1. 因为`Integer`类加载的时候,会初始化整型的256个常量放到常量池中\n\u003e2.   java中为了提高程序的执行效率，将[-128到127]之间所有的包装对象提前创建好，放到了方法区的“整数型常量池”当中了，目的是只要用这个区间的数据不需要再new了，直接从整数型常量池当中取出来。\n\u003e3. 所以再下面的`x`和`y`变量中比较的直接就是比较的127的内存地址,而不是xy变量的内存地址了\n    \n![[../../../../../asset/Pasted image 20220723155717.png]]\n\n","lastmodified":"2022-09-20T05:41:06.470325645Z","tags":null},"/216-%E5%85%AB%E7%A7%8D%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8BInteger%E7%AD%89%E7%AD%89":{"title":"","content":"包: `java.long`\n\n\u003e[!tip]+ 八种包装类型存在的意义\n\u003e1. 因为8种基本数据类型不够用。所以SUN又提供对应的8种包装类型。\n\u003e2. **在调用方法等等时候,传入的参数如果是对象,那么基本数据类型不满足条件的时候,就可以传入包装类型就好了**\n\u003e3. **基本数据类型向引用数据类型的转换**\n\n## 对照\n\n| 基本数据类型 | 包装类型  父类                |\n| ------------ | ----------------------------- |\n| byte         | `java.lang.Byte` 父类Number   |\n| short        | `java.lang.Short`      Number |\n| int          | `java.lang.Integer` Number    |\n| long         | `java.lang.Long ` Number      |\n| float        | `java.lang.Float` Number      |\n| double       | `java.lang.Double` Number     |\n| boolean      | `java.lang.Boolean` Object    |\n| char         | `java.lang.Character` Objcet  |\n\n## 定义与转换\n手动装箱和拆箱:\n```java\npublic class Test01 {  \n    public static void main(String[] args) {  \n        //定义包装类型的整数  \n        //基本数据类型--\u003e包装数据类型  \n        Integer i=new Integer(123);  \n        //包装类型--\u003e基本数据类型的转换  \n        int i1=i.intValue();  \n        float f1=i.floatValue();  \n  \n        System.out.println(f1);  \n        System.out.println(i);  \n    }  \n}\n```\nouput\n![[../../../../../asset/Pasted image 20220723151806.png]]\n\n**jdk1.5之后支持自动装箱和自动拆箱**\n说白了,**装箱**就是**不用再new**那一下,把参数放进括号里了;**拆箱**就不用xxxValue()再进行赋值了\n```java\npublic class Test02 {  \n    public static void main(String[] args) {  \n        //自动装箱  \n        Integer i1=123;  \n        //自动拆箱  \n        double i2=i1;  \n        //自动装箱  \n        Character c1='c';  \n        float f1=1.115f;  \n        System.out.println(f1);  \n        //自动装箱  \n        Float f2=f1;  \n        System.out.println(f2);  \n  \n  \n        System.out.println(i1);  \n        System.out.println(c1);  \n  \n    }  \n}\n```\noutput\n![[../../../../../asset/Pasted image 20220723152726.png]]","lastmodified":"2022-09-20T05:41:06.470325645Z","tags":null},"/217-String-int-Integer%E4%B9%8B%E9%97%B4%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2":{"title":"","content":"![[../../../../../asset/005-String Integer int三种类型的互相转换.png]]\n\n```java\npublic class Test04 {  \n    public static void main(String[] args) {  \n        //String --\u003e int  \n        String s1=\"123\";  \n        int i1=Integer.parseInt(s1);  \n        System.out.println(i1+1);//124  \n  \n        //int --\u003e String        int i2=12;  \n        String s2=String.valueOf(i2);  \n        System.out.println(s2+45);//'1245'  \n  \n        //int --\u003eInteger  自动装箱  \n        Integer i3=45;//45  \n        //Integer --\u003e int 自动拆箱  \n        int i33=i3;//45  \n  \n        //String --\u003eInteger        Integer s4=Integer.valueOf(i3); //45  \n        System.out.println(i3+96);//141  \n  \n        //Integer --\u003eString        String s5=s4.toString();//'45'  \n        System.out.println(s5+45);//'4545'  \n  \n    }  \n}\n```\n\noutput\n![[../../../../../asset/Pasted image 20220723163151.png]]","lastmodified":"2022-09-20T05:41:06.470325645Z","tags":null},"/218.java%E5%AF%B9%E6%97%A5%E6%9C%9F%E7%9A%84%E5%A4%84%E7%90%86":{"title":"","content":"# 获取时间以及时间相互转换\n包名:`-   java.util.Date`\n帮助文档:https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/Date.html\n\n日期格式化`SimpleDateFormat`帮助文档:https://www.matools.com/file/manual/jdk_api_1.8_google/java/text/SimpleDateFormat.html\n1. 获取当前时间\n2. 对时间进行格式化输出\n3. 文本转换成Date格式\n```java\nimport java.text.SimpleDateFormat;  \nimport java.util.Date;  \n  \npublic class Test01  {  \n    public static void main(String[] args) throws Exception{  \n        //获取当前时间,采用无参构造对象  \n        Date nowTime=new Date();  \n        System.out.println(nowTime);//Sat Jul 23 16:43:44 CST 2022  \n  \n        //日期格式化 然后输出  \n        //SimpleDateFormat  \n        SimpleDateFormat sdf1=new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss SS\");  \n        String nowTimestr=sdf1.format(nowTime);  \n        System.out.println(nowTimestr); //2022-07-23 16:53:53 663  \n  \n        //String --\u003eDate类型  \n        String time1=\"2022-01-23 16:53:45 663\";  \n        SimpleDateFormat sdf2=new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss SS\");//必须要与转换的格式相互对应,不然会报错,在main方法上面添加throws Exception  \n        Date d2=sdf2.parse(time1);  \n        System.out.println(d2);//Sun Jan 23 16:53:45 CST 2022  \n  \n    }  \n}\n```\n\noutput\n![[../../../../../asset/Pasted image 20220723170216.png]]\n\n# 获取毫秒级时间戳\n1. 获取时间戳\n2. 使用时间戳记录方法使用的时间\n```java\n  \n  \npublic class Test02 {  \n    public static void main(String[] args) {  \n        //获取1970-1-1到当前时间的 毫秒级 时间戳  \n         long nowTimeMillis=System.currentTimeMillis();  \n        System.out.println(nowTimeMillis); //1658567135832  \n  \n        //记录一个方法执行的时长  \n        long begin=System.currentTimeMillis();//开始时间  \n        shushu();//方法开始  \n        long end=System.currentTimeMillis();//记录结束时间  \n        System.out.println(\"数数花费的时间是\"+(end-begin)+\"毫秒\");  \n  \n    }  \n  \n    public static void shushu(){  \n        for (int i = 0; i \u003c1000 ; i++) {  \n            System.out.print(i+\" \");  \n        }  \n        System.out.println();  \n    }  \n}\n```\nouput\n\n![[../../../../../asset/Pasted image 20220723172440.png]]","lastmodified":"2022-09-20T05:41:06.470325645Z","tags":null},"/219.%E5%85%B3%E4%BA%8E%E6%95%B0%E5%AD%97%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96":{"title":"","content":"# java.text.DecimalFormat\n作用\n\t对数字进行格式化,添加千分位,补位等等\n包:https://www.matools.com/file/manual/jdk_api_1.8_google/java/text/DecimalFormat.html\neg:\n```java\nimport java.text.DecimalFormat;  \n  \npublic class DecimalFormatTest01 {  \n    public static void main(String[] args) {  \n        //java.text.DecimalFormat 是专门用于对数字进行格式化  \n        /*  \n        # 任意数字  \n        . 小数点  \n        0 不够时补位0  \n        * */        DecimalFormat d1=new DecimalFormat(\"###,###.##\");//千分位,两位小数  \n        String s1=d1.format(45456456.1212);  \n        System.out.println(s1);  \n  \n        d1=new DecimalFormat(\"####,####.000\");  \n        System.out.println(d1.format(121212.12));  \n    }  \n}\n```\noutput\n![[../../../../../asset/Pasted image 20220724200600.png]]\n\n# 处理大数Big\n包类: java.math.BigDecima\n帮助文档: https://www.matools.com/file/manual/jdk_api_1.8_google/java/math/BigDecimal.html\n\n\u003e[!tip]+ 面试题 财务方面的数据的用什么类型\n\u003e**BigDecima类型**,属于大数据,**精度极高**,属于java对象,引用数据类型\n\u003e**不能直接使用+-\\**\\/ **  去进行运算,需要调用方法\neg\n```java\nimport java.math.BigDecimal;  \n  \npublic class BigDecimalTest01 {  \n    public static void main(String[] args) {  \n        //都是精度极高的数字,不是普通的123 456  \n        BigDecimal b1=new BigDecimal(123);  \n        BigDecimal b2=new BigDecimal(456);  \n    //    进行计算，不能直接加减乘除  \n        BigDecimal sum=b1.add(b2);  \n        System.out.println(sum);  \n  \n        BigDecimal div1=b2.divide(b1,2,2);  \n        System.out.println(div1);  \n  \n        BigDecimal mul=b1.multiply(b2);  \n        System.out.println(mul);  \n    }  \n}\n```\noutput\n![[../../../../../asset/Pasted image 20220724205157.png|200]]\n\n\n# 随机数 Random\n包类: java.util.Random\n帮助文档: https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/Random.html\n作用:产生随机数\n\neg\n```java\nimport jdk.management.resource.internal.inst.SocketOutputStreamRMHooks;  \n  \nimport java.util.Random;  \n  \npublic class RandomTest01 {  \n    public static void main(String[] args) {  \n        //创建随机数对象  \n        Random r1=new Random();  \n        int i1=r1.nextInt();//创建一个随机数  \n        System.out.println(i1);  \n        i1=r1.nextInt(100);//产生一个小于括号里面数的随机数,不包括括号里面的这个数  \n        System.out.println(i1);  \n    }  \n}\n```\n\nouput\n![[../../../../../asset/Pasted image 20220724210115.png]]\n\neg2:输出五个不重复的随机数\n```java\nimport java.util.Arrays;  \nimport java.util.Random;  \n  \npublic class RandomTest02 {  \n    public static void main(String[] args) {  \n    //    创建一个随机数对象  \n        Random r=new Random();  \n    //    创建一个五个元素的数组  \n        int[] arr=new int[5];  \n        int index;//随机数变量,最新插入随机数的下标  \n        index=0;  \n    //    对五个元素进行初始化  \n        //因为随机数是从0开始的,之后比较是否有重复元素的时候有所影响,所以全部默认值设置为不在范围内的数  \n        Arrays.fill(arr, 101);  \n  \n        while (index\u003carr.length){  \n            int rom=r.nextInt(101);  \n            Arrays.sort(arr);//对数组进行排序  \n            if (Arrays.binarySearch(arr, rom)==-1) {  \n                arr[index++]=rom;  \n            }  \n        }  \n  \n        //输出随机数数组  \n        for (int i = 0; i \u003c arr.length; i++) {  \n            System.out.print(arr[i]+\" \");  \n        }  \n    }  \n  \n  \n}\n```\n\nouput\n![[../../../../../asset/Pasted image 20220724214951.png]]","lastmodified":"2022-09-20T05:41:06.470325645Z","tags":null},"/219a.%E6%9E%9A%E4%B8%BEenum":{"title":"","content":"# 概述\n1. 枚举是一种**引用数据类型**\n2. 定义语法:\n\t```java\n\tenum 枚举类型名{\n\t\t枚举值1,枚举值2;\n\t}\n\t```\n3. **当结果超过两种(可以列举出来的结果)的时候,建议使用枚举,当结果只有两种的时候,建议使用布尔类型**\n4. 也会生成一个`.class`文件\n5. `switch` 也支持`case` 枚举\n## eg除法\n```java\npublic class EnumTest01 {  \n    public static void main(String[] args) {  \n        Result r=divTest(10,0);  \n        System.out.println(r==Result.SUCCESS?\"计算成功\":\"计算失败\");  \n        Result r1=divTest(12,5);  \n        System.out.println(r1==Result.SUCCESS?\"计算成功\":\"计算失败\");  \n  \n    }  \n  \n    /**  \n     *     * @param a  被除数i  \n     * @param b  除数  \n     * @return  返回枚举类型的值  \n     */  \n    public static Result divTest(int a,int b){  \n        try {  \n            int c=a/b;  \n            //执行成功,就可以继续执行,返回成功的枚举值  \n            return Result.SUCCESS;  \n        }catch (Exception e){  \n            //执行失败,就执行这个语句,返回失败的枚举  \n            return Result.FAIL;  \n        }  \n    }  \n  \n  \n}  \n//枚举类型  \nenum Result{  \n    SUCCESS,FAIL;  \n}\n```\n**ouput**\n![[asset/Pasted image 20220725094754.png]]","lastmodified":"2022-09-20T05:41:06.470325645Z","tags":null},"/221.%E5%BC%82%E5%B8%B8":{"title":"","content":"帮助文档:https://www.matools.com/file/manual/jdk_api_1.8_google/java/lang/Exception.html\n\n# 概述\n1. 异常是一种类,[[#eg2 new异常对象|可以new对象]]\n2. 通过处理异常,增加程序的健壮性\n\n---\n\n## eg1\n```java\npublic class Test01 {  \n    public static void main(String[] args) {  \n        int c=10/0;  \n        /*  \n        代码执行到此处,会出现异常,然后 就会new一个异常对象:Exception in thread \"main\" java.lang.ArithmeticException: / by zero  \n   at Test01.main(Test01.java:3)   JVM会将异常信息输出,打印到控制台  \n        * */    }  \n}\n```\nouput\n![[../../../../asset/Pasted image 20220725103128.png]]\n\n## eg2 new异常对象\n```java\npublic class Test02 {  \n    public static void main(String[] args) {  \n        NumberFormatException nfx=new NumberFormatException(\"数字格式化异常\");  \n        System.out.println(nfx);  \n    }  \n\t}\n```\nouput\n![[../../../../asset/Pasted image 20220725103506.png]]","lastmodified":"2022-09-20T05:41:06.470325645Z","tags":null},"/222.UML-%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80":{"title":"","content":"# 语法来源\n使用Mermaid创建类图 帮助文档:http://soft.xiaoshujiang.com/docs/grammar/feature/mermaid/#e7b1bbe59bbe_36\n**建议**博客版本:https://www.cnblogs.com/mybdss/p/14958781.html\n\n[[使用Mermaid语法画UML类图]]\n\n","lastmodified":"2022-09-20T05:41:06.470325645Z","tags":null},"/223.%E5%BC%82%E5%B8%B8%E7%9A%84%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84":{"title":"","content":"# 总结\n1. **编译阶段异常是不会出现的,**编译时异常和运行时异常都是发生在**运行阶段**\n\t1. 因为异常需要new对象,只有程序运行才会new对象\n\t2. 编译时异常是因为必须在编写代码阶段预先处理,不然编译器就会报错而得名\n2. `Object`下有`Throwable`(可抛出)\n3. `Throwable`下有两个分支:\n\t1. `Error`:错误,**不可以处理,终止程序执行,直接退出JVM**\n\t2. `Exception`:异常,**可以处理**\n4. 尽量避免Error,在Exception时就对其进行处理\n5. 编译时异常发生概率相对较高\n\n# 继承结构图\n```mermaid\nclassDiagram\n\tObject\u003c|--Throwable\n\tThrowable:不管是错误还是异常,都是可以抛出的\n\tThrowable\u003c|--Error\n\tError:所有的错误只要发生,java程序都会终止执行,退出JVM\n\t\tError\u003c|--IOError\n\t\tError\u003c|--VirtualMachineError\n\tThrowable\u003c|--Exception\n\t\tException\u003c|--ExceptionSubClass:编译时异常\n\t\tExceptionSubClass:不是编译时发生的\n\t\tExceptionSubClass:编写程序的时候事先对其进行异常处理\n\t\tExceptionSubClass:如果不处理,编译器就会报错\n\t\tException\u003c|--RuntimeException:运行时异常\n\t\tRuntimeException:运行时异常,\n\t\tRuntimeException:你可以处理,也可以不处理\n\t\t\tRuntimeException\u003c|--NullPointerException\n\t\t\tRuntimeException\u003c|--ClassCastException\n\t\t\tRuntimeException\u003c|--IllegalArgumentException\n\t\t\t\tIllegalArgumentException\u003c|--NumberFormatException\n%% 写起来还是挺简单的\n```\n","lastmodified":"2022-09-20T05:41:06.470325645Z","tags":null},"/224.%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E5%8E%9F%E7%90%86":{"title":"","content":"\u003e[!tip]+ 强调\n\u003e 所有异常都是发生在**运行阶段**.\n\n# 异常处理方法\njava对异常的处理有两种方式: **上抛(上报)**和**捕获**\n\u003e[!tip]+ 异常的两种处理方式\n\u003e1. 在方法声明的位置上,使用`throws`关键字,**抛给上一级**,谁调用我,就抛给谁 \n   [[#eg1 第一种异常处理 添加throws关键字]]\n\u003e2. 使用`try{}  catch{}`语句进行**异常捕获**,异常发生了,谁都不知道,但是我抓住了.    相关:\n\u003e\t1. [[#第二种异常处理 使用try catch捕获异常]]  \n\u003e\t2. [[225.异常对象的常用方法#^2efa19]]\n\u003e\t语法格式 **catch后面可以写确定的异常类型,也可以写父类异常(异常的爹)**\n```java\n\ttry {  \n\t\tdoSome();  \n\t}catch (ClassNotFoundException e){  \n\t\te.printStackTrace();  \n\t}\n```\n## 关键字\n\u003e[!tip]+ throw throws\n\u003ethrows **声明方法的时候使用**，将异常情况上报给调用者\n\u003ethrow 手动抛出异常 `throw new 异常()；`\n\n## eg1:第一种异常处理:添加throws关键字\n```java\npublic class Test03 {  \n//使用 throws关键字 继续上抛异常,上抛给调用者 main方法 ,类似于推卸责任\n    public static void main(String[] args) throws ClassNotFoundException{  \n        doSome();  \n  \n    }  \n    public static void doSome() throws ClassNotFoundException{  \n        System.out.println(\"doSome~~\");  \n    }  \n}\n```\nouput\n\u003e在方法上继续使用throws,完成异常上抛,将异常抛给调用者`main`\n![[../../../../asset/Pasted image 20220726095200.png]]\n\n## 第二种异常处理:使用try catch捕获异常\n```java\npublic class Test03 {  \n\n    public static void main(String[] args) {  \n    //直接捕获异常,解决异常,调用者不知道\n        try {  \n            doSome();  \n        }catch (ClassNotFoundException e){  \n            e.printStackTrace();  \n        }  \n    }  \n    public static void doSome() throws ClassNotFoundException{  \n        System.out.println(\"doSome~~\");  \n    }  \n}\n```\nouput\n![[../../../../asset/Pasted image 20220726100156.png]]","lastmodified":"2022-09-20T05:41:06.470325645Z","tags":null},"/225.%E5%BC%82%E5%B8%B8%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95":{"title":"","content":"```java\n//获取异常的描述信息\nString msg=excepiton.getMessage();\n//打印异常的堆栈信息\nexception.printStackTrace();\n```\n\n**使用`printStackTrace`不会让程序停止,只是输出堆栈异常信息,程序很健壮**\n\n## eg1\n```java\npublic class Test05 {  \n    public static void main(String[] args) {  \n        NullPointerException e=new NullPointerException(\"空指针异常~\");  \n        String msg=e.getMessage();  \n        System.out.println(msg);  \n    }  \n}\n```\n这里的异常是一个对象,没有作为异常**抛出**,所以执行的时候不会报错\n即,异常需要抛出,才会报错\nouput\n![[../../../../asset/Pasted image 20220726112134.png]]\n\n```java\ne.printStackTrace();  \nSystem.out.println(\"helloWorld\");\n```\nouput\n![[../../../../asset/Pasted image 20220726112207.png]]\n`printStackTrace`采用了**异步线程**,所以打印的顺序不对\n\n## eg2\n```java\nimport java.io.FileInputStream;  \nimport java.io.FileNotFoundException;  \nimport java.io.IOException;  \n  \npublic class Test06 {  \n    public static void main(String[] args) throws IOException {  \n        FileInputStream fis=null;//声明输入流对象  \n        try {  \n        //    创建输入流对象  \n            fis=new FileInputStream(\"C:\\\\Users\\\\22305\\\\Desktop\\\\01读书笔记模板.md\");  \n            String s=null;  \n            s.toString();//空指针异常  \n            System.out.println(\"hellword\");  \n            //fis.close();//由于上面异常,所以可能会出现无法关闭输入流,需要finally  \n        } catch (FileNotFoundException e) {  \n            System.out.println(\"文件没找到\");  \n            e.printStackTrace();//捕获堆栈异常  \n        }catch (NullPointerException e){  \n            System.out.println(\"空指针异常\");  \n            e.printStackTrace();  \n        }finally {  \n            fis.close();  \n            System.out.println(\"关闭输入流\");  \n        }  \n  \n        System.out.println(\"执行完毕\");  \n  \n    }  \n}\n```\nouput\n![[../../../../asset/Pasted image 20220726121947.png]]\n\n可以通过这个了解对捕获异常的堆栈打印,在printStackTrace是非常有必要的,不然不知道哪里发生了异常,哪里需要处理(一本正经胡说八道)\n`finall`语句的正确使用,无论异常是否发生,最后的`finally`语句块都会执行,通常用于**释放资源** ^2efa19","lastmodified":"2022-09-20T05:41:06.47432571Z","tags":null},"/226.finally%E8%AF%AD%E5%8F%A5":{"title":"","content":"1. finally语句通常用于**释放资源**,这非常有必要.\n2. `finally`中的语句是一定会执行的,除非你退出JVM`System.exe(0);`\n3. finally可以不要catch,只要`try finally`\n4. **即使try里面有`return`,`finally`中的语句依然会执行**\n5. try不能单独使用\n![[225.异常对象的常用方法#eg2]]\n\n## eg第三点\n```java\npublic class Test07 {  \n    public static void main(String[] args) {  \n        try {  \n            System.out.println(\"这是try\");  \n            return;  \n        } finally {  \n            System.out.println(\"这是finally\");  \n        }  \n    }  \n}\n```\nouput\n![[../../../../asset/Pasted image 20220726122752.png]]","lastmodified":"2022-09-20T05:41:06.47432571Z","tags":null},"/227.finally%E9%9D%A2%E8%AF%95%E9%A2%98":{"title":"","content":"```java\npackage com.bjpowernode.javase.exception;\n/*\nfinally面试题\n */\npublic class ExceptionTest13 {\n    public static void main(String[] args) {\n        int result = m();\n        System.out.println(result); //100\n    }\n\n    /*\n    java语法规则（有一些规则是不能破坏的，一旦这么说了，就必须这么做！）：\n        java中有一条这样的规则：\n            方法体中的代码必须遵循自上而下顺序依次逐行执行（亘古不变的语法！）\n        java中海油一条语法规则：\n            return语句一旦执行，整个方法必须结束（亘古不变的语法！）\n     */\n    public static int m(){\n        int i = 100;\n        try {\n            // 这行代码出现在int i = 100;的下面，所以最终结果必须是返回100\n            // return语句还必须保证是最后执行的。一旦执行，整个方法结束。\n            return i;\n        } finally {\n            i++;\n        }\n    }\n}\n\n/*\n反编译之后的效果\npublic static int m(){\n    int i = 100;\n    int j = i;\n    i++;\n    return j;\n}\n */\n\n```\noutput\n```cmd\n100\n```\n\n**输出很奇葩**,看反编译的代码","lastmodified":"2022-09-20T05:41:06.47432571Z","tags":null},"/228.finalfinallyfinalize%E7%9A%84%E5%8C%BA%E5%88%AB":{"title":"","content":"\u003e[!faq]+ final,finally,finalize()的区别\n\u003e1. `final`,`finally`是一个**关键字**,\n\u003e2. `final`用于修饰变量,类等等,表示最终的不可变的\n\u003e3. `finally`是用于异常处理try catch,无论异常是否发生,`finally`中的语句都会发生\n\u003e4. `finalize`是`Object`中的一个**方法**,是一个**标识符**,不是关键字,由JVM的GC垃圾回收器负责调用","lastmodified":"2022-09-20T05:41:06.47432571Z","tags":null},"/229.%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E8%87%AA%E5%B7%B1%E7%BC%96%E5%86%99%E5%BC%82%E5%B8%B8":{"title":"","content":"# 步骤\n1. 定义一个异常,继承`Exception`或者`RuntimeException`\n2. 提供两个方法,一个有参数的,一个`String`参数的\n\n## eg\n定义异常\n```java\npublic class MyException extends RuntimeException{  \n    public MyException(){  \n  \n    }  \n  \n    public MyException(String s) {  \n        super(s);  \n    }  \n}\n```","lastmodified":"2022-09-20T05:41:06.47432571Z","tags":null},"/2291.%E5%BC%82%E5%B8%B8%E5%AE%9E%E9%99%85%E4%BE%8B%E5%AD%90":{"title":"","content":"# 总结\n\u003e[!tip]+ 书写方法注意点\n\u003e1. 首先异常类\n\u003e\t1. 继承RuntimeException或者Exception\n\u003e\t2. 两个方法，一个无参，一个String\n\u003e2. 其次写栈类：主要用来new对象，以及对异常的抛出\n\u003e\t1. 在**方法**中**throws**抛出异常\n\u003e\t2. 判断if什么情况需要抛出异常`throw new StatckOperationException(\"异常信息\");  `\n\u003e3. 最后测试类\n\u003e\t1. 注意try对象的判断，异常情况抛出的e的**堆栈信息**、**异常信息描述**是否需要打印\n\u003e\t2. [[225.异常对象的常用方法]]\n\n\n# eg1 栈操作\n栈操作异常类\n```java\n//栈操作异常  \npublic class StatckOperationException extends RuntimeException{  \n    public StatckOperationException() {  \n  \n    }  \n  \n    public StatckOperationException(String message) {  \n        super(message);  \n    }  \n}\n```\n栈类\n```java\npublic class MyStack {  \n    private Object[] eles;  \n    private int index;//栈顶帧  \n    //压栈方法  \n    //继承栈操作异常  \n    public void push(Object obj) throws StatckOperationException{  \n        //当栈溢出的时候，抛出栈溢出的异常  \n        if (index\u003e=eles.length-1){  \n            throw new StatckOperationException(\"栈溢出\");  \n        }  \n        index++;  \n        eles[index]=obj;  \n        System.out.println(\"push success\"+obj+\" frame：\"+index);  \n    }  \n  \n    //弹栈方法  \n    public void pop() throws StatckOperationException{  \n        if (index\u003c0){  \n            throw new StatckOperationException(\"弹栈失败\");  \n        }  \n        System.out.println(\"pop\"+eles[index]);  \n        index--;  \n        System.out.println(\"stack iframe to: \"+index);  \n    }  \n  \n    //封装  \n  \n    public MyStack() {  \n        this.eles=new Object[10];//初始化站容量  \n        this.index=-1;//栈帧在底部  \n    }  \n  \n    public MyStack(Object[] eles, int index) {  \n        this.eles = eles;  \n        this.index = index;  \n    }  \n  \n    public Object[] getEles() {  \n        return eles;  \n    }  \n  \n    public void setEles(Object[] eles) {  \n        this.eles = eles;  \n    }  \n  \n    public int getIndex() {  \n        return index;  \n    }  \n  \n    public void setIndex(int index) {  \n        this.index = index;  \n    }  \n}\n```\n测试类\n```java\npublic class StackTest01 {  \n    public static void main(String[] args) {  \n        MyStack m1=new MyStack();  \n  \n        try {  \n            m1.push(new Object());  \n            m1.push(new Object());  \n            m1.push(new Object());  \n            m1.push(new Object());  \n            m1.push(new Object());  \n            m1.push(new Object());  \n            m1.push(new Object());  \n            m1.push(new Object());  \n            m1.push(new Object());  \n            m1.push(new Object());  \n            m1.push(new Object());  \n            m1.push(new Object());  \n            m1.push(new Object());  \n            m1.push(new Object());  \n            m1.push(new Object());  \n        }catch (StatckOperationException e){  \n            System.out.println(e.getMessage());  \n              \n        }  \n        try {  \n            m1.pop();  \n            m1.pop();  \n            m1.pop();  \n            m1.pop();  \n            m1.pop();  \n            m1.pop();  \n            m1.pop();  \n            m1.pop();  \n            m1.pop();  \n            m1.pop();  \n            m1.pop();  \n            m1.pop();  \n            m1.pop();  \n        }catch (StatckOperationException e){  \n            System.out.println(e.getMessage());  \n        }  \n    }  \n}\n```\nouput\n![[../../../../asset/Pasted image 20220726161026.png]]\n\n# eg2 用户登录\n异常类\n```java\n//非法名称异常  \npublic class illagalNameException extends RuntimeException{  \n    public illagalNameException() {  \n        super();  \n    }  \n  \n    public illagalNameException(String message) {  \n        super(message);  \n    }  \n}\n```\n服务器类\n```java\npublic class UserServers {  \n    /**  \n     *     * @param name 登录用户名  \n     * @param password 登录密码  \n     * @throws illagalNameException 判断登录用户名是否正确  \n     */  \n  \n    public void register(String name,String password) throws illagalNameException{  \n        if (null==name||name.length()\u003c4||name.length()\u003e16){  \n            throw new illagalNameException(\"用户名不合法！\");  \n        }  \n    //    以上异常没有抛出，就会执行下来  \n        System.out.println(\"欢迎 \"+ name+\" 登录~\");  \n    }  \n  \n  \n}\n```\n登录测试类\n```java\npublic class UserRegisterTest01 {  \n    public static void main(String[] args) {  \n    //    创建对象  \n        UserServers u1=new UserServers();  \n        try {  \n            u1.register(\"\",\"pass1\");  \n        }catch (illagalNameException e){  \n            System.out.println(e.getMessage());  \n            e.printStackTrace();  \n        }  \n        try {  \n            u1.register(\"caixukun\",\"pass1\");  \n        }catch (illagalNameException e){  \n            System.out.println(e.getMessage());  \n  \n        }  \n    }  \n}\n```\nouput\n![[../../../../asset/Pasted image 20220726171600.png]]","lastmodified":"2022-09-20T05:41:06.47432571Z","tags":null},"/2292.%E7%BB%A7%E6%89%BF%E7%9A%84%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96%E5%92%8C%E5%BC%82%E5%B8%B8":{"title":"","content":"![[../../../../asset/Pasted image 20220726163010.png]]\n总结：\n子类继承父类的时候，方法覆盖的异常不能大于父类的异常，不能比父类异常多。\n简单的描述：子类的异常只能是父类异常的**子异常或者同等异常**，要么就不写\n相关：[[../../爪哇基础/07方法覆盖和多态/01方法覆盖/071.方法覆盖override]]\n\n没有异常\u003e父类异常\u003e子类异常\n不写就是默认的父类的异常","lastmodified":"2022-09-20T05:41:06.47432571Z","tags":null},"/23-01.%E9%9B%86%E5%90%88list%E6%A6%82%E8%BF%B0":{"title":"","content":"包类: `java.util`\n# 概述\n1. 数组就是以一个集合，但是集合可以容纳不同数据类型的数据\n2. 是一个容器，可以**一次容纳多个对象**\n3. 集合**存储的是java对象的内存地址**，是**引用**，引用对象本身的内存地址。并不是对象本身。不能存储基本数据类型，也不能存储对象。![[../../../../asset/Pasted image 20220727164431.png]]\n4. 不同的集合，**底层会对应不同的数据结构**，往不同的集合中存储数据，相当于放到了不同的数据结构中\n\n---\n\n# 集合分类\nJava中集合分为两类：\n1. 单个方式存储元素，超级父接口为：`java.util.Collection`\n2. **键值对**方式存储元素，超级父接口为：`java.util.Map`","lastmodified":"2022-09-20T05:41:06.47432571Z","tags":null},"/23.02%E9%9B%86%E5%90%88%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84%E5%9B%BE1-Collection":{"title":"","content":"\n```mermaid\nclassDiagram\nclass Iterable{\n\t\u003c\u003cinterface\u003e\u003e\n\t+iterator()\n所有集合元素都是可以迭代的，\n可以遍历的\n}\n\nclass Collection{\n\t\u003c\u003cinterface\u003e\u003e\n\tCollection\n}\n\t\n\t\n\tCollection--\u003eIterator:关联，has a\n\tCollection--|\u003eIterable:泛化，继承，is a\nclass Iterator{\n\u003c\u003cinterface\u003e\u003e\n\t集合的迭代器对象\n\t+hasNext()\n\t+next()\n\t+remove()\n}\n\nclass List{\n\t\u003c\u003cinterface\u003e\u003e\n\t有序可重复\n\t\n\t有下标\n}\n%%有序说的是，存进去什么顺序，取出来还是什么顺序，不是大小的排序%%\nList--|\u003eCollection:泛化\n\n\n\nclass ArrayList{\n非线程安全\n数据结构：数组\n}\nArrayList..|\u003eList:实现\n\nclass LinkedList{\n数据结构：双向链表\n}\nLinkedList..|\u003eList:实现，like a\n\nclass Vector{\n线程安全但效率低\n数据结构：集合\n}\nVector..|\u003eList\n\nclass Set{\n\t\u003c\u003cinterface\u003e\u003e\n\t无序不重复\n\t无下标\n}\nSet--|\u003eCollection:泛化\n\nclass HashSet{\n底层实际new的是一个HashMap集合\n存储在了HashMap集合中\n数据结构：哈希表\n}\nHashSet..|\u003eSet\n\nclass SortSet{\n\t\u003c\u003cinterface\u003e\u003e\n\t可排序集合\n\t放到其中的元素会自动排序\n}\nSortSet--|\u003eSet\n\nclass TreeSet{\n底层实际是new的TreeMap集合\n数据实际存储在了TreeMap中了\n数据结构：二叉树\n}\nTreeSet..|\u003eSortSet\n\n```\n\n![[../../../../asset/Pasted image 20220728190823.png]]","lastmodified":"2022-09-20T05:41:06.47432571Z","tags":null},"/23.03%E9%9B%86%E5%90%88%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84%E5%9B%BE2-Map":{"title":"","content":"```mermaid\nclassDiagram\nclass Map{\n\u003c\u003cinterface\u003e\u003e\n}\n\nclass HashMap{\n非线程安全\n数据结构：哈希表\n}\nHashMap..|\u003eMap:实现\n\nclass Hashtable{\n线程安全效率低\n数据结构：哈希表\n}\nHashtable..|\u003eMap:实现\nclass Properties{\n属性类\n也是线程安全，继承自Hashtable\n只支持String类型\n}\nPreperties--|\u003eHashtable\n\nclass SortedMap{\n\u003c\u003cinterface\u003e\u003e\n无序不可重复\n可排序集合\n在key部分的元素会自动排序\n}\nSortedMap--|\u003eMap:继承\n\n\n```\n\n1. Map的key是无序不可重复的\n2. key和value都是存储对象的内存地址\n3. Map集合以键值对方式存储对象\n![[../../../../asset/Pasted image 20220728190807.png]]\n\n特点：\n![[../../../../asset/Pasted image 20220728191011.png]]\n![[../../../../asset/Pasted image 20220728191014.png]]\n![[../../../../asset/Pasted image 20220728191143.png]]","lastmodified":"2022-09-20T05:41:06.47432571Z","tags":null},"/23.04Collection%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95":{"title":"","content":"\u003e[!faq]+ `java.util.collection`中能够存放的元素\n\u003e1. 没有使用**泛型**，collection中可以存放Object中的所有子类型\n\u003e2. 使用**泛型**之后，collection中只能存放某种**具体的类型**\n\u003e3. 集合中**不能直接存储基本数据类型，也不能存储java对象**，存储的只是**java对象的内存地址\n\n\n## eg\n```java\nimport java.util.ArrayList;  \nimport java.util.Collection;  \n  \npublic class Test01 {  \n    public static void main(String[] args) {  \n    //    Collection是接口，无法实例化对象，不能new出来  \n    //    多态方式new实现子类  \n        Collection c=new ArrayList();  \n  \n    //   boolean add(Object e) 测试add方法  \n        c.add(11);//不是11，而是装箱之后的11封装类型integer  \n        c.add(new int[10]);  \n        c.add(\"djsk\");  \n  \n    //    int size(),获取集合个数  \n        System.out.println(\"集合元素个数：\"+c.size());  \n  \n    //    void clear()清空集合  \n        c.clear();  \n        System.out.println(\"清空之后：\"+c.size());  \n        c.add(\"Hello\");  \n        c.add(\"ok\");  \n        c.add(13);  \n  \n        // contains(Object o) 如果此集合包含指定的元素，则返回 true 。  \n        System.out.println(c.contains(13));  \n        System.out.println(c.contains(46));  \n  \n        // remove(Object o) 删除某个元素  \n        System.out.println(c.size());  \n        c.remove(13);  \n        c.contains(13);  \n        System.out.println(c.size());  \n  \n        //isEmpty() 判断是否为空  \n        System.out.println(c.isEmpty());  \n        c.clear();  \n        System.out.println(c.isEmpty());  \n  \n    //     toArray()转换成数组  \n        c.add(\"Hello\");  \n        c.add(\"ok\");  \n        c.add(13);  \n        c.add(new Object());  \n        Object[] o1=c.toArray();  \n        //对生成的数组进行输出  \n        for (int i = 0; i \u003co1.length ; i++) {//遍历数组  \n            System.out.println(o1[i]);  \n        }  \n    }  \n}\n```\noutput\n![[../../../../asset/Pasted image 20220728200324.png]]","lastmodified":"2022-09-20T05:41:06.47432571Z","tags":null},"/23.05Collection%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8Iterator":{"title":"","content":"\u003e[!tip]+ 迭代器遍历步骤\n\u003e1. 获取集合的迭代器对象itorator  `Iterator it=xxx.iterator();  `\n\u003e2. 进行迭代器遍历  \n\u003e\n\u003e\t```java\n\u003e\t//判断是否有下一个元素，有的话就执行输出，没有就停止循环\n\u003e\twhile (it.hasNext()){  \n\u003e \t           System.out.println(it.next());  \n \u003e \t      } \n\u003e\t```\n## eg\n```java\nimport java.util.ArrayList;  \nimport java.util.Collection;  \nimport java.util.Iterator;  \n  \npublic class Test02 {  \n    public static void main(String[] args) {  \n        //创建集合对象  \n        Collection c=new ArrayList();  \n        //添加元素  \n        c.add(12);  \n        c.add(\"添加第一个元素\");  \n        c.add(new Object());  \n  \n        //获取集合的迭代器对象itorator  \n        Iterator it=c.iterator();  \n    //    进行迭代器遍历  \n        while (it.hasNext()){  \n            System.out.println(it.next());  \n        }  \n    }  \n}\n```\noutput\n![[../../../../asset/Pasted image 20220728201705.png]]","lastmodified":"2022-09-20T05:41:06.47432571Z","tags":null},"/23.06.-Collection%E7%9A%84contains":{"title":"","content":"# 总结\ncontains底层调用的是通过`equals`方法去对内容进行比对，查看查看集合中是否包含，如果是String方法的话，因为已经被重写，所以是比较的字符内容是否包含。\n放在集合中的内容，如果要使用`contains()`或者[[23.07.remove方法|remove()]]，那么必须要**重写`equals`方法**\n源代码 ![[../../../../asset/Pasted image 20220729090025.png]]\n## eg\n\n```java\nimport java.util.ArrayList;  \nimport java.util.Collection;  \n  \npublic class Test03 {  \n    public static void main(String[] args) {  \n        //    创建集合对象  \n        Collection c = new ArrayList();  \n        //    添加元素  \n        String a = new String(\"abc\");  \n        c.add(a);  \n        String b = new String(\"abc\");  \n        c.add(b);  \n        //    contains  \n        System.out.println(c.contains(\"abc\"));  \n        System.out.println(a == b);//对比的a和b这个的地址，a和b中存储的“abc\"的内存地址  \n  \n    }  \n}\n```\nouput\n![[../../../../asset/Pasted image 20220729090138.png]]\n\n## eg2\n```java\nimport java.util.ArrayList;  \nimport java.util.Collection;  \n  \npublic class Test04 {  \n    public static void main(String[] args) {  \n        Collection c=new ArrayList();  \n        User u1=new User(\"张三\");  \n        c.add(u1);  \n        User u2=new User(\"张三\");  \n        System.out.println(c.contains(u2));  \n    }  \n}  \nclass User{  \n    private String name;  \n  \n    public User() {  \n    }  \n  \n    public User(String name) {  \n        this.name = name;  \n    }  \n  \n    @Override  \n    public boolean equals(Object obj) {  \n        if (obj==null||!(obj instanceof User)) return false;  \n        if (this==obj) return true;  \n        User u=(User)obj;//强制向下转型  \n        return this.name==u.name;  \n    }  \n}\n```\n\nouput\n![[../../../../asset/Pasted image 20220729094245.png]]","lastmodified":"2022-09-20T05:41:06.47432571Z","tags":null},"/23.07.remove%E6%96%B9%E6%B3%95":{"title":"","content":"1. 和contains一样，底层也使用了equals方法去对比，然后删除集合中的对应元素，所以需要重写`equals`方法\n2. 在迭代器迭代的过程中，**要使用 迭代器.remove()的方法去删除元**，因为集合.remove()会改变集合结构，需要构造new迭代器，不然会出现异常","lastmodified":"2022-09-20T05:41:06.47432571Z","tags":null},"/23.08.List%E7%89%B9%E6%9C%89%E7%9A%84%E6%96%B9%E6%B3%95":{"title":"","content":"```java\nimport com.sun.org.apache.xpath.internal.WhitespaceStrippingElementMatcher;  \nimport sun.security.util.AuthResources_it;  \n  \nimport java.util.ArrayList;  \nimport java.util.Iterator;  \nimport java.util.List;  \n  \npublic class Test05 {  \n    public static void main(String[] args) {  \n        //创建list集合  \n        List l=new ArrayList();  \n    //    添加元素  \n        l.add(132);  \n        l.add(\"fds\");  \n        l.add(132);  \n        l.add(0,\"jfks\");  \n        Iterator it=l.iterator();  \n        System.out.println(\"遍历=======\");  \n        while (it.hasNext()){  \n            System.out.println(it.next());  \n         /*   Object o=it.next();  \n            System.out.println(o);*/  \n      /*  //    根据下标获取元素  \n            System.out.println(l.get(0));*/        }  \n        System.out.println(\"获取指定对象第一次出现的索引==========\");  \n        //System.out.println(l.size());  \n        System.out.println(l.indexOf(132));  \n        //System.out.println(l.get(1));  \n        System.out.println(\"获取对象最后一次出现的索引====\");  \n        System.out.println(l.lastIndexOf(132));  \n  \n        System.out.println(\"修改特定位置的元素=====\");  \n        l.set(0,\"修改后的0\");  \n  \n        it=l.iterator();  \n        while (it.hasNext()){  \n            System.out.println(it.next());  \n        }  \n    }  \n}\n```\nouput\n\t![[../../../../asset/Pasted image 20220729154306.png]]","lastmodified":"2022-09-20T05:41:06.47432571Z","tags":null},"/23.09.ArrayList%E5%92%8CVector":{"title":"","content":"|属性|ArrayList|Vector|\n|--|--|--|\n|默认容量|10|10\n|扩容容量|1.5倍|2倍|\n|底层|数组|数组|\n|底层|非线程安全|线程安全|\n|优点|检索快|增删快|\n\n\n怎么得到一个线程安全的List：\nCollections.synchronizedList(list);","lastmodified":"2022-09-20T05:41:06.47432571Z","tags":null},"/23.10.LinkedList%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8":{"title":"","content":"# 特点\n1. LinkedList没有初始化容量，最初的链表中first和last都是null\n2. **增删效率高**\n3. 不能通过数学表达式计算被查找元素的内存地址，每一次查找都是从头节点开始遍历\n\n```java\nimport javax.swing.event.TreeWillExpandListener;  \nimport java.util.Iterator;  \nimport java.util.LinkedList;  \nimport java.util.List;  \n  \npublic class Test08 {  \n    /*  \n    链表  \n     */    public static void main(String[] args) {  \n        List l1=new LinkedList();  \n        l1.add(1);  \n        l1.add(2);  \n        l1.add(\"c\");  \n        l1.add(\"D\");  \n  \n        for (int i = 0; i \u003cl1.size() ; i++) {  \n            System.out.println(l1.get(i));  \n        }  \n  \n        System.out.println(\"代进行访迭问\\n\");  \n        Iterator it=l1.iterator();  \n        while (it.hasNext()){  \n            System.out.println(it.next());  \n        }  \n    }  \n}\n```\noutput\n![[../../../../asset/Pasted image 20220729200248.png]]","lastmodified":"2022-09-20T05:41:06.47432571Z","tags":null},"/23.11.LinkedList":{"title":"","content":"\t需要做的：\n\t1. [ ] 手写linkedlist数据结构\n\t2. [ ] 其优点与缺点\n\t3. [ ] 转换成线程安全的方法colllections工具类里面的sync\n\t4. [ ] 泛型机制\n\t5. [ ] 类型自动推断：钻石表达式","lastmodified":"2022-09-20T05:41:06.47432571Z","tags":null},"/23.11.Vector":{"title":"","content":"1. 底层是数组\n2. 默认容量10，扩容2倍（ArrayList扩容是1.5倍）\n3. 线程安全，但是效率会低\n4. 可以采用`Collections.synchronizedList(ArrayList);`的方法将ArrayList转换为Vector的线程安全\n\n```java\nimport java.util.*;  \n  \npublic class Test09 {  \n    public static void main(String[] args) {  \n        List v=new Vector();  \n    //    添加元素  \n        v.add(123);  \n        v.add(23);  \n        v.add(\"dsa\");  \n        v.add(235);  \n        v.add(235);  \n        v.add(235);  \n        v.add(235);  \n        v.add(235);  \n        v.add(235);  \n        v.add(235);  \n        //默认容量10，满了之后，扩容是成倍，就是20  \n        v.add(235);  \n        v.add(235);  \n  \n        System.out.println(\"迭代器遍历\");  \n        Iterator it=v.iterator();  \n        while (it.hasNext()){  \n            System.out.println(it.next());  \n        }  \n        //非线程安全转线程安全  \n        List l=new ArrayList();  \n        //ArrayList是非线程安全的，但是Vector是线程安全的  \n        Collections.synchronizedList(l);  \n        //现在就是线程安全的了,  \n        l.add(\"fjds\");  \n    }  \n}\n```\noutput\n![[../../../../asset/Pasted image 20220729201550.png]]\n\n","lastmodified":"2022-09-20T05:41:06.47432571Z","tags":null},"/23.12.HashSet%E5%92%8CTreeSet":{"title":"","content":"1. 两个set存入的数据都不会重复\n2. TreeSet存入的数据会自动排序，可排序集合\n3. TreeSet无序可排序，无序值得是存进去和取出来的数据顺序不一样\n\n```java\nimport java.util.HashSet;  \nimport java.util.Set;  \nimport java.util.TreeSet;  \n  \npublic class Test {  \n    public static void main(String[] args) {  \n        Set\u003cString\u003e s=new HashSet\u003c\u003e();  \n        s.add(\"d\");  \n        s.add(\"b\");  \n        s.add(\"c\");  \n        s.add(\"c\");  \n        s.add(\"c\");  \n        s.add(\"b\");  \n        s.add(\"o\");  \n        for (String string:s  \n             ) {  \n            System.out.println(string);  \n        }  \n        System.out.println(\"TreeSet=========\");  \n        Set\u003cString\u003e s2=new TreeSet\u003c\u003e();  \n        s2.add(\"b\");  \n        s2.add(\"c\");  \n        s2.add(\"a\");  \n        for (String string:s2  \n             ) {  \n            System.out.println(string);  \n        }  \n    }  \n}\n```\n![[../../../../asset/Pasted image 20220730094458.png]]","lastmodified":"2022-09-20T05:41:06.47432571Z","tags":null},"/23.13-Map%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95":{"title":"","content":"```java\nimport java.util.*;\n\npublic class Test {\n    public static void main(String[] args) {\n        //创建hashmap集合\n        Map\u003cInteger,String\u003e m=new HashMap\u003c\u003e();\n    //    添加键值对\n        m.put(1,\"zhangsan\");\n        m.put(1,\"lisi\");//不能有重复的key，但是可以有重复的值,重新put会更新之前的值\n        m.put(2,\"lisi\");\n    //    get获取value\n        String s=m.get(1);\n        System.out.println(s);\n    //size（）集合的大小\n        System.out.println(m.size());\n/*    //    clear（） 清空集合\n        m.clear();\n        System.out.println(m.size());*/\n\n        //是否包含某个键，某个值\n        System.out.println(m.containsKey(2));\n        System.out.println(m.containsValue(\"lisi\"));\n        System.out.println(m.containsValue(\"lis\"));\n        //判断是否为空\n        System.out.println(\"是否为空\"+m.isEmpty());\n\n        //keySet获取key组成的集合\n        Set\u003cInteger\u003e set=new HashSet();\n        set=m.keySet();\n        for (Integer i:set\n             ) {\n            System.out.println(i);\n        }\n\n        //remove通过key删除键值对\n        System.out.println(\"key:1 value:  \"+m.get(1));\n        m.remove(1);\n        System.out.println(m.containsKey(1));\n        m.put(45,\"fsd\");\n\n        //values（）返回一个collection类型的value的集合\n        Collection\u003cString\u003e s1=new ArrayList\u003c\u003e();\n        s1=m.values();\n        for (String string:s1\n             ) {\n            System.out.print(string+\" \");\n        }\n\n        //entrySet() 方法返回映射中包含的映射的 Set 视图。\n        System.out.println(\"映射关系\"+m.entrySet());\n    }\n}\n```\n\n![](../../../../asset/Map接口的常用方法.png)\n","lastmodified":"2022-09-20T05:41:06.47432571Z","tags":null},"/23.14-Map%E7%9A%84%E4%B8%A4%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F":{"title":"","content":"# Map的两种遍历\n\nCreated: July 30, 2022 4:56 PM Tags: 遍历 类别: Map\n```java\nimport java.nio.channels.InterruptedByTimeoutException;  \nimport java.util.HashMap;  \nimport java.util.Iterator;  \nimport java.util.Map;  \nimport java.util.Set;  \n​  \npublic class Teset04 {  \n    public static void main(String[] args) {  \n        //创建map集合  \n        Map\u003cInteger,String\u003e m=new HashMap\u003c\u003e();  \n        //添加键值对  \n        m.put(2,\"lier\");  \n        m.put(3,\"wangsan\");  \n        m.put(4,\"zhangsi\");  \n        m.put(5,\"wangwu\");  \n        m.put(0,\"zero\");  \n        //    第一种遍历方式，通过获取key机场，获取key值对应的value  \n        Set\u003cInteger\u003e set1=m.keySet();  \n        //    迭代器  \n        Iterator\u003cInteger\u003e it1=set1.iterator();  \n        //    进行迭代  \n        while (it1.hasNext()){  \n            Integer key=it1.next();  \n            String value=m.get(key);//通过key获取value  \n            System.out.println(\"key: \"+key+\" value: \"+value);  \n​  \n        }  \n​  \n    //    第二种方式，通过Map.EntrySet,返回的set  \n        System.out.println(\"Map.EntrySet的方式，获取node节点对象，然后取出getkey和getvalue属性值\");  \n        Set\u003cMap.Entry\u003cInteger,String\u003e\u003e set2=m.entrySet();  \n    //    迭代器  \n        Iterator\u003cMap.Entry\u003cInteger,String\u003e\u003e it2=set2.iterator();//泛型要和上面的保持一致，可以不写的话，里面就是object类型  \n    //    迭代  \n        while (it2.hasNext()){  \n            Map.Entry\u003cInteger,String\u003e node=it2.next();  \n            Integer key=node.getKey();//getkey获取键  \n            String value=node.getValue();  \n            System.out.println(\"key: \"+key+\"value: \"+value);  \n        }  \n    //    此方式更适合大数据量，因为直接从node获取的key和value  \n        System.out.println(\"Map.EntrySet改用foreach遍历============\");  \n    //    以下改为foreach采用这种方式  \n        for (Map.Entry\u003cInteger,String\u003e node:set2  \n             ) {  \n            System.out.println(\"key:\"+node.getKey()+\" value: \"+node.getValue());  \n        }  \n​  \n    }  \n}\n```\n\n![](../../../../asset/Map遍历方式12.png)","lastmodified":"2022-09-20T05:41:06.47432571Z","tags":null},"/23.15-HashMap":{"title":"","content":"# HashMap\n\nCreated: July 30, 2022 5:18 PM\nTags: 实现原理\n类别: HashMap\n\n![](../../../../asset/hashmap.png)\n\n内存图\n\n# 简述\n\nHashMap：**加载因子0.75，默认容量16，初始化容量必须是2的倍数**\n\n\u003caside\u003e\n💡 HashMap类似于由**单向链表组成的数组\n数据结构：哈希表**\n\n\u003c/aside\u003e\n\n# 哈希表的特点：\n\n结合了数组和链表各自的优点，相当于由一个个单向链表组成的数组\n\n链表：增删快，查找效率低\n\n数组：查找快，增删效率低，末节点的增删不受影响\n\n但是各自的优点没有完全，增删比不上链表，查找比不上数组\n\n# HashMap的`map.put(k,v)`方法`实现原理`\n\n1. 将k和v进行封装到node对象中\n2. 调用`hashCode()`方法，转换成数组下标，然后在这个下标中查看是否有链表\n    1. 如果没有，就把这个node放到这个位置\n    2. 如果有，就使用`equals()`方法就在这个里面比对k值的node，看看有没有一样的。如果没有一样的k，就添加到末尾；如果有，就更新它的`value`\n\n# HashMap的`map.get(k)`方法`实现原理`\n\n1. 和put类似，将k值使用`hashCode()`计算哈希值，通过哈希算法转换数组下标\n2. 通过数组下标快速找到这个node位置\n    1. 如果没有，就返回`null`\n    2. 如果有，就使用`equals`方法去比对k值，找到之后，拿出value值\n\n# HashMapp注意事项\n\n1. `equals`是`get`和put时都会使用到的方法，所以需要注意重写`equals()`方法，同时需要重写`hashCode()`方法[HashSet重写equals和hashCode方法](HashSet%E9%87%8D%E5%86%99equals%E5%92%8ChashCode%E6%96%B9%E6%B3%95%20c296142fac8f49e4b3ba38b622c32307.md) \n2. 是通过`hashCode()`**方法去获取node下标的**\n3. 如果将`hashCode()`方法的返回值设置为固定值，那么HashMap的底层哈希表数据结构编程纯**单向链表（**当每个单向链表上的节点数量差异过大时，称为“**散列分布不均匀**”）\n4. 当某个单向链表的**节点超过8**，那么这个单向链表的数据结构就会变成**红黑树；**如果节点**再次少于6**，就会变回单向链表","lastmodified":"2022-09-20T05:41:06.47432571Z","tags":null},"/23.16-HashSet%E9%87%8D%E5%86%99equals%E5%92%8ChashCode%E6%96%B9%E6%B3%95":{"title":"","content":"# HashSet重写equals和hashCode方法\n\n```java\nimport java.util.*;\n\npublic class Test06 {\n    public static void main(String[] args) {\n        Student s1=new Student(\"zhangsan\");\n        Student s2=new Student(\"zhangsan\");\n        System.out.println(s2.equals(s1));\n        Set\u003cStudent\u003e set=new HashSet\u003c\u003e();\n        set.add(s1);\n        set.add(s2);\n        System.out.println(set.size());\n\n    }\n}\n\n/**\n * 学生\n */\nclass Student{\n    private String name;\n\n    public Student() {\n    }\n\n    public Student(String name) {\n        this.name = name;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n//重写equals和hasCode\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Student student = (Student) o;\n        return Objects.equals(name, student.name);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(name);\n    }\n}\n```\n\n![](../../../../asset/Pasted%20image%2020220811215715.png)","lastmodified":"2022-09-20T05:41:06.47432571Z","tags":null},"/23.17-HashMap%E5%92%8CHashTable%E7%9A%84%E5%8C%BA%E5%88%AB":{"title":"","content":"1.  HashMap允许`key`为`null`，**HashTable不允许`key`和`value`为`null`**\n2.  HashTable有**线程安全**，但是对**线程处理效率低**，使用较少\n3.  HashTable的**初始化容量是11**，**默认加载因子0.75**（加载因子：当使用的容量达到这个比率就会进行扩容）；HashMap的初始化容量是16，默认加载因子也是0.75，当链表节点数量大于8，变成红黑树，小于6，变回单向链表\n4.  Hashtable的扩容：**原容量*2+1**","lastmodified":"2022-09-20T05:41:06.47432571Z","tags":null},"/23.18-Hashtable%E7%9A%84Properties%E5%B1%9E%E6%80%A7%E7%B1%BB":{"title":"","content":"帮助文档：[Properties](https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/Properties.html)\n\n1.  Properties是一个Map集合，继承**Hashtable**，Properties的key和value都是`String`类型\n2.  被称为**属性类对象**\n\n# 两个基本的方法\n\n`setProperty()`相当于put，`getProperty()`相当于get\n\n```java\nimport java.util.Properties;\n\npublic class Test01 {\n    public static void main(String[] args) {\n/**\n         * properties基本的两个方法，存取\n*/\nProperties p1=new Properties();\n//存入数据，相当于是put\np1.setProperty(\"url\",\"www.baidu.com\");\n        p1.setProperty(\"name\",\"fskf\");\n        p1.setProperty(\"age\",\"16\");\n        p1.setProperty(\"acc\",\"acc16jksjf\");\n        p1.setProperty(\"pass\",\"rrewqtweqeet\");\n\n//通过key获取value\nSystem.out.println(p1.getProperty(\"acc\"));\n        System.out.println(p1.getProperty(\"name\"));\n        System.out.println(p1.getProperty(\"url\"));\n        System.out.println(p1.getProperty(\"namefs\"));//因为没有对应的key值，返回null\n}\n}\n\n```\n![](../../../../asset/Pasted%20image%2020220811215926.png)","lastmodified":"2022-09-20T05:41:06.47432571Z","tags":null},"/23.19-TreeSet%E5%85%B3%E4%BA%8E%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0comparable%E6%8E%A5%E5%8F%A3%E6%88%96%E4%BD%BF%E7%94%A8%E6%AF%94%E8%BE%83%E5%99%A8Compartor":{"title":"","content":"💡 Comparable和Comparator怎么选择呢？ 当**比较规则不会发生改变**的时候，或者说**当比较规则只有1个的时候，建议实现Comparable接口。**因为这个要去实现，没下面那个方便，下面那个方便，但是每次都要作为参数传进去 如果比较规则有多个，并且需要多个比较规则之间频繁切换，建议使用Comparator接口。\n\n\n# 第一种：实现comparable接口\n\n## 关于TreeSet自定义类的排序，书写代码时需要注意\n\n1.  继承`Comparable`接口\n2.  override compareTo``方法\n3.  有必要的话，把`toString`方法也override\n\n## `compareTo`的比较规则怎么写\n\n1.  通过对象的属性进行比较，比如是String，可以用它本身就实现了的compareTo去进行比较，返回的一个数值能够代表他的数值\n2.  通过数值大小比较\n3.  使用if结合起来比较\n4.  **无论怎么写，返回的都是一个数值**，通过这个数值进行比较，一般是**升序**\n\n## 原因\n\n1.  TreeSet中存入的数据会默认的排序，因为String和Integer都是默认实现了Comparable接口，对排序的规则已经进行了一定，所以不用再写了。\n2.  但是，别的自己定义的类，没有定义规则，所以需要实现`Comparable`接口，不然无法排序，添加节点元素就会报错`Customer cannot be cast to java.lang.Comparable`\n\n```java\nimport java.util.TreeSet;\n\npublic class Test02 {\n    public static void main(String[] args) {\n\n//创建TreeSet\nTreeSet\u003cCustomer\u003e set=new TreeSet\u003c\u003e();\n//添加节点元素\n\t\tset.add(new Customer(\"zhangsan\",17));\n        set.add(new Customer(\"zhangsan1\",17));\n        set.add(new Customer(\"wangmazi\",16));\n        set.add(new Customer(\"haiya\",15));\n\n//遍历\nfor (Customer c:set\n             ) {\n            System.out.println(c);\n        }\n    }\n}\nclass Customer implements Comparable\u003cCustomer\u003e{\n    private String name;\n    private int age;\n\n    public Customer() {\n    }\n\n    public Customer(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n/**\n     *\n     * @paramothe object to be compared.\n     * @return返回数字表示这个set的排序方式：先根据年龄，再根据姓名排序\n*/\n@Override\n    public int compareTo(Customer o) {\n        if (this.age==o.age){\n            return this.name.compareTo(o.name);\n\n        }else{\n            return this.age-o.age;//返回一个数值，可以表示顺序的排列，如果大于0，就排在右子树，小于0，就在左子树\n\n}\n    }\n\n//重写toString方法，方便输出对象的值，这样就不是hashCode值了\n@Override\n    public String toString() {\n        return \"name:\"+name+\"\\\\tage:\"+age;\n    }\n}\n```\n\n![](../../../../asset/Pasted%20image%2020220811220231.png)\n\n# 第二种：传一个比较器\n\n```java\nimport com.sun.media.sound.SoftTuning;\n\nimport java.util.Comparator;\nimport java.util.TreeSet;\n\npublic class Test {\n    public static void main(String[] args) {\n/*        TreeSet\u003cWugui\u003e set=new TreeSet\u003c\u003e(new WuguiComparator());*/\n\n        //采用匿名内部类传入一个比较器\nTreeSet\u003cWugui\u003e set=new TreeSet\u003c\u003e(new Comparator\u003cWugui\u003e() {\n            @Override\n            public int compare(Wugui o1, Wugui o2) {\n                return o1.age-o2.age;\n            }\n        });\n//添加节点\nset.add(new Wugui(12));\n        set.add(new Wugui(18));\n        set.add(new Wugui(14));\n        for (Wugui w:set\n             ) {\n            System.out.println(w);\n        }\n    }\n}\nclass Wugui{\n    int age;//默认，在本包或本类使用\n\npublic Wugui(int age) {\n        this.age = age;\n    }\n\n    @Override\n    public String toString() {\n        return \"小乌龟 \"+age+\"岁\";\n    }\n}\n/*\n\n*/\n/**\n *乌龟比较器，创建之后，在创建乌龟集合的时候，new一个把比较器作为参数放进去\n*//*\n\nclass WuguiComparator implements Comparator\u003cWugui\u003e{\n    @Override\n    public int compare(Wugui o1, Wugui o2) {\n        return o1.age-o2.age;\n    }\n}*/\n\n```\n\n![](../../../../asset/Pasted%20image%2020220811220330.png)","lastmodified":"2022-09-20T05:41:06.47432571Z","tags":null},"/23.20-%E8%87%AA%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84":{"title":"","content":"# 自平衡二叉树数据结构\n\n原则：遵循**左小右大**\n\n存放的过程就是排序的过程，取出来就是顺序\n\n### 三种遍历方式\n\n顺序说的是根的位置\n\n1.  前序遍历：根左右\n2.  中序遍历：左根右 `TreeSet` / `TreeMap` / `Iterator`迭代器\n3.  后序遍历：左右根\n\n`TreeSet`和`TreeMap`采用的是**中序遍历**\n\n中序表达式画图的例子\n\n![](../../../../asset/Pasted%20image%2020220811220510.png)\n\n![](../../../../asset/Pasted%20image%2020220811220522.png)\n取出\n\n![](../../../../asset/Pasted%20image%2020220811220531.png)\n这个很离谱，但就是按照顺序取出来。在进阶237集","lastmodified":"2022-09-20T05:41:06.47432571Z","tags":null},"/23.21-Collections%E5%B7%A5%E5%85%B7%E7%B1%BB":{"title":"","content":"# 基本的使用\n\n```java\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Test03 {\n    public static void main(String[] args) {\n        List\u003cWugui2\u003e list=new ArrayList\u003c\u003e();\n//arrayList是非线程安全的，使用了collection工具类中的synchronizedList方法之后，就能变成线程安全的\nCollections.synchronizedList(list);\n        list.add(new Wugui2(12));\n        list.add(new Wugui2(64));\n        list.add(new Wugui2(45));\n//排序，如果不是string等已经实现了comparable接口的类，需要重新写实现\nCollections.sort(list);\n        for (Wugui2 w:list\n             ) {\n            System.out.println(w);\n        }\n    }\n}\nclass Wugui2 implements Comparable\u003cWugui2\u003e{\n    int age;//默认，在本包或本类使用\n\npublic Wugui2(int age) {\n        this.age = age;\n    }\n\n    @Override\n    public String toString() {\n        return \"小乌龟 \"+age+\"岁\";\n    }\n\n    @Override\n    public int compareTo(Wugui2 o) {\n        return this.age-o.age;\n    }\n}\n```","lastmodified":"2022-09-20T05:41:06.47432571Z","tags":null},"/241.%E6%B3%9B%E5%9E%8B":{"title":"","content":"1. 泛型这种语法机制，只在程序编译阶段起作用，只是给编译器参考的。\n2. 编译器规范了集合的中存储数据的类型，比如\u003cAnimal\u003e就只能存储animal\n3.  子类特有方法依旧需要向下转型\n4. 泛型**必须是引用数据类型**，不能是基本数据类型\n\n```java\nimport com.sun.org.apache.xpath.internal.WhitespaceStrippingElementMatcher;  \n  \nimport java.util.ArrayList;  \nimport java.util.Iterator;  \nimport java.util.List;  \n  \npublic class Test01 {  \n    public static void main(String[] args) {  \n        //不使用泛型  \n        List l=new ArrayList();  \n        Cat c=new Cat();  \n        Bird b=new Bird();  \n    //    添加对象到集合  \n        l.add(c);  \n        l.add(b);  \n  \n\t    //    遍历集合，取出每个动物的move  \n        Iterator it=l.iterator();//迭代器  \n        while (it.hasNext()){  \n            Object obj=it.next();//没有使用泛型就只能使用Object，取出来就是Object  \n  \n        //因为是animal的方法，所以需要转型  \n            if (obj instanceof Animal){  \n                Animal a=(Animal) obj;  \n                ((Animal) obj).move();//调用父类的方法  \n            }  \n        }  \n  \n    //    使用泛型  \n        List\u003cAnimal\u003e l2=new ArrayList\u003c\u003e();//砖石操作符中的类型可以省略  \n    //    添加元素  \n        l2.add(c);  \n        l2.add(b);  \n    //    遍历  \n        Iterator\u003cAnimal\u003e it2=l2.iterator();  \n        while (it2.hasNext()){  \n            //使用了泛型之后，就是animal了  \n            Animal a=it2.next();  \n            a.move();  \n            System.out.println(\"使用子类中特有的方法,仍然需要向下转型\");  \n            if (a instanceof Bird){  \n                Bird bird=(Bird)a;  \n                bird.fly();  \n            }else if (a instanceof Cat){  \n                Cat cat=(Cat)a;  \n                cat.catchMouse();  \n            }  \n        }  \n    }  \n}  \n  \nclass Animal{  \n    public void move(){  \n        System.out.println(\"动物在移动\");  \n    }  \n}  \nclass Cat extends Animal{  \n    public void catchMouse(){  \n        System.out.println(\"猫抓老鼠\");  \n    }  \n}  \n  \nclass Bird extends Animal{  \n    public void fly(){  \n        System.out.println(\"鸟儿飞翔\");  \n    }  \n}\n```\noutput\n![[../../../../asset/Pasted image 20220729210814.png]]","lastmodified":"2022-09-20T05:41:06.47432571Z","tags":null},"/242-%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8":{"title":"242-泛型方法的使用","content":"# 242-泛型方法的使用\n\n定义\n1. 定义方法时同时定义了泛型的方法就是泛型方法\n2. 泛型方法的格式\n```java\npublic \u003cT\u003e void show(T name){\n方法体;\n}\n```\n\n## 实例\n```java\npackage test;  \n  \npublic class Test02 {  \n    public static void main(String[] args) {  \n        String[] strings={\"linsa\",\"kanda\",\"ondel\",\"enter\"};  \n        Integer[] integers={2,34,53,5353,53};  \n    //    使用函数进行打印  \n        printArrs(strings);  \n        printArrs(integers);  \n    }  \n  \n    /**  \n     * 打印任意类型数组的所有元素  \n     *  \n     * @param arrs 泛型的数组  \n     */  \n    public static \u003cT\u003e void printArrs(T[] arrs){  \n        if (arrs!=null){  \n            StringBuilder sb=new StringBuilder(\"[\");  \n            for (int i = 0; i \u003carrs.length; i++) {  \n                sb.append(arrs[i]).append(i==arrs.length-1?\"\":\",\");  \n            }  \n            sb.append(\"]\");  \n            System.out.println(sb);  \n        }else {  \n            System.out.println(arrs);  \n        }  \n        }  \n  \n}\n```\noutput\n```java\n[linsa,kanda,ondel,enter]\n[2,34,53,5353,53]\n```\n\n其他：泛型约束\n\n## 通配符？\n案例：极品飞车比赛\nCar的子类benzs是子类关系\n但是Array\u003ccar\u003e和Array\u003cbenzs\u003e没有关系\n所以如果是对于array类的方法`go()`进行比赛的时候，就需要通过`?`来作为方法体的泛型形参类型，否则就无法参加比赛\n```java\npublic static void go(ArrayList\u003c?\u003e cars){\n}\n```","lastmodified":"2022-09-20T05:41:07.266338579Z","tags":null},"/25.foreach":{"title":"","content":"缺点：没有下标，不能及时反馈下标\n语法结构\n```java\nFor(数据类型 元素：数组或者集合\n   ){\n   带元素的语句;\n   }\n```\n\n# eg基本使用\n```java\npublic class Test02 {  \n    public static void main(String[] args) {  \n        int[] arr1={3,45,45,6,4,31,1,31,3,13,13};  \n        for (int num:arr1  \n             ) {  \n            System.out.println(num);  \n        }  \n    }  \n}\n```\noutput\n![[../../../../asset/Pasted image 20220729211711.png]]\n\n# eg各种遍历\n```java\nimport java.util.ArrayList;  \nimport java.util.Iterator;  \nimport java.util.List;  \n  \npublic class ForeachTest01 {  \n    public static void main(String[] args) {  \n        List\u003cString\u003e l=new ArrayList\u003c\u003e();//泛型  \n        l.add(\"a\");  \n        l.add(\"b\");  \n        l.add(\"c\");  \n        l.add(\"d\");  \n        System.out.println(\"使用foreach遍历=======\");  \n        for (String s:l  \n             ) {  \n            System.out.println(s);  \n        }  \n        System.out.println(\"使用for循环遍历============\");  \n        for (int i = 0; i \u003cl.size() ; i++) {  \n            System.out.println(l.get(i));  \n        }  \n        System.out.println(\"使用迭代器进行遍历========\");  \n        Iterator\u003cString\u003e it=l.iterator();//泛型  \n        while (it.hasNext()){  \n            String s=it.next();  \n            System.out.println(s);  \n        }  \n    }  \n}\n```\noutput\n![[../../../../asset/Pasted image 20220730092946.png]]","lastmodified":"2022-09-20T05:41:06.47432571Z","tags":null},"/3201-%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A1%A5%E5%85%85":{"title":"3201-单例设计模式【补充】","content":"# 3201-单例设计模式【补充】\n单例必须将构造器私有化\n\n单例：只需要一个对象即可\n\n## 饿汉单例模式\n\n使用情况：\n\n在用类获取对象的时候，对象已经提前为你创建好了（**提前创建所需要的对象**）\n\n### 设计步骤\n\n1.  定义一个类，构造器私有化\n2.  定义一个静态变量存储这个new的类的对象\n\n```java\n/** a、定义一个单例类 */\npublic class SingleInstance {\n    /** c.定义一个静态变量存储一个对象即可 :属于类，与类一起加载一次 */\n    public static SingleInstance instance = new SingleInstance ();\n\n    /** b.单例必须私有构造器*/\n    private SingleInstance (){\n        System.out.println(\"创建了一个对象\");\n    }\n}\n\n```\n\n## 懒汉单例模式\n\n使用情况：\n\n在需要的时候对象的时候才去创建这个对象（**延迟加载对象**）\n\n### 设计步骤\n\n1.  定义一个类，构造器私有化\n2.  定义一个静态变量存储一个变量\n3.  定义一个返回单例的public方法\n\n```java\nclass Singleton02{\n    //  b.定义一个静态变量存储一个对象(这里不能创建对象，需要的时候才创建，这里只是一个变量用于存储对象！)\n    public static Singleton02  instance ;\n\n    //   a.定义一个类，把构造器私有。\n    private Singleton02(){\n\n    }\n    //  c.提供一个返回单例对象的方法。\n    public static Singleton02 getInstance(){\n        if(instance == null){\n            // 第一次来拿单例对象！需要创建一次对象，以后直接返回！！\n            instance = new Singleton02();\n        }\n        return instance;\n    }\n}\n```","lastmodified":"2022-09-20T05:41:07.266338579Z","tags":null},"/3202-Calendar%E6%97%A5%E5%8E%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E8%A1%A5%E5%85%85":{"title":"3202-Calendar日历类使用【补充】","content":"注意，calendar不能直接new对象，需要通过懒汉单例\n\n```java\npackage test;\n\nimport sun.security.util.AuthResources_it;\n\nimport javax.xml.crypto.Data;\nimport java.util.Calendar;\nimport java.util.Date;\n\npublic class CalendarTest01 {\n    public static void main(String[] args) {\n        //拿到系统此时的日历对象\n        Calendar c=Calendar.getInstance();\n        System.out.println(c);\n\n    //    获取年份\n        int year=c.get(Calendar.YEAR);\n    //    获取月份\n        int month=c.get(Calendar.MONTH)+1;//月份比较特殊，范围在0--11，所以需要自己手动加1\n    //    获取日\n        int day=c.get(Calendar.DAY_OF_MONTH);\n        System.out.println(year+\"年\"+month+\"月\"+day+\"日\");\n\n    //    修改某个字段的值\n        c.set(Calendar.DAY_OF_MONTH,11);\n        System.out.println(c.get(Calendar.DAY_OF_MONTH));\n\n    //    增加某个字段的值\n        c.add(Calendar.DAY_OF_MONTH,8);//加8天之后是\n        System.out.println(c.get(Calendar.YEAR)+\"年\"+(c.get(Calendar.MONTH)+1)+\"月\"+c.get(Calendar.DAY_OF_MONTH)+\"日\");\n\n    //    拿到此刻日期\n        Date date=c.getTime();\n        System.out.println(date);\n\n    //    拿到毫秒级时间戳\n        long biglong=c.getTimeInMillis();\n        System.out.println(biglong);\n    }\n}\n```\n\noutput\n\n```java\njava.util.GregorianCalendar[time=1662987959416,areFieldsSet=true,areAllFieldsSet=true,lenient=true,zone=sun.util.calendar.ZoneInfo[id=\"Asia/Shanghai\",offset=28800000,dstSavings=0,useDaylight=false,transitions=19,lastRule=null],firstDayOfWeek=1,minimalDaysInFirstWeek=1,ERA=1,YEAR=2022,MONTH=8,WEEK_OF_YEAR=38,WEEK_OF_MONTH=3,DAY_OF_MONTH=12,DAY_OF_YEAR=255,DAY_OF_WEEK=2,DAY_OF_WEEK_IN_MONTH=2,AM_PM=1,HOUR=9,HOUR_OF_DAY=21,MINUTE=5,SECOND=59,MILLISECOND=416,ZONE_OFFSET=28800000,DST_OFFSET=0]\n2022年9月12日\n11\n2022年9月19日\nMon Sep 19 21:05:59 CST 2022\n1663592759416\n```","lastmodified":"2022-09-20T05:41:07.266338579Z","tags":null},"/3203-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F":{"title":"3203-正则表达式","content":"# 3203-正则表达式\n用于匹配字符规则\n```java\npackage d6_regex;  \n  \npublic class RegexTest01 {  \n    public static void main(String[] args) {  \n        System.out.println(checkQQ(\"2231235\"));  \n        System.out.println(checkQQ(\"123aad212\"));  \n    }  \n  \n    private static boolean checkQQ(String qq) {  \n        return  qq!=null \u0026\u0026 qq.matches(\"\\\\d{6,10}\");  \n    }  \n}\n```\noutput\n```java\ntrue\nfalse\n\n```\n\n## 例子\n```java\npackage d6_regex;  \n  \nimport com.sun.org.apache.xpath.internal.WhitespaceStrippingElementMatcher;  \n  \nimport java.security.interfaces.RSAKey;  \nimport java.util.regex.Matcher;  \nimport java.util.regex.Pattern;  \n  \npublic class RegexTest02 {  \n    public static void main(String[] args) {  \n    //    校验电话号码  \n        System.out.println(\"19221254565\".matches(\"1[3-9]\\\\d{9}\"));  \n        System.out.println(\"1922125455\".matches(\"1[3-9]\\\\d{9}\"));  \n        //校验邮箱  \n        System.out.println(\"223055@qq.com\".matches(\"\\\\d{2,25}@[a-zA-Z0-9]{2,10}(.[a-zA-Z0-9]{2,10}){1,2}\"));  \n        System.out.println(\"223055@bj.edu.com\".matches(\"\\\\d{2,25}@[a-zA-Z0-9]{2,10}(.[a-zA-Z0-9]{2,10}){1,2}\"));  \n    //    电话号码  \n        System.out.println(\"0211-12512\".matches(\"0\\\\d{2,6}-?\\\\d{5,20}\"));  \n        System.out.println(\"021112512\".matches(\"0\\\\d{2,6}-?\\\\d{5,20}\"));  \n        System.out.println(\"211-12512\".matches(\"0\\\\d{2,6}-?\\\\d{5,20}\"));  \n  \n        /* 匹配字符串 */        String str=\"张三jhhj李四jfksjf王麻子jfksl\";  \n        String[] strArrs=str.split(\"\\\\w+\");  \n        for (String s:strArrs  \n             ) {  \n            System.out.print(s+\"\\t\");  \n        }  \n  \n        /* 爬取规则 */        String str2=\"fakfjlajdf15513543245李四fjksljf,1232@163.edu（）dfaf16525554621fjslk\";  \n    //    1. 定义匹配规则：邮箱或者电话号码  \n        String regex=\"(1[3-9]\\\\d{9})|\\\\d{2,25}@[a-zA-Z0-9]{2,10}(.[a-zA-Z0-9]{2,10}){1,2}\";  \n    //    2.把这个爬取规则编译成对象  \n        Pattern pattern=Pattern.compile(regex);  \n    //    3.得到一个内容匹配器对象  \n        Matcher matcher=pattern.matcher(str2);  \n    //    匹配器去查找  \n        while (matcher.find()){  \n            String s=matcher.group();  \n            System.out.println(s);  \n        }  \n  \n    }  \n}\n```\n\noutput\n```java\ntrue\nfalse\ntrue\ntrue\ntrue\ntrue\nfalse\n张三\t李四\t王麻子\t15513543245\n1232@163.edu\n16525554621\n\nProcess finished with exit code 0\n\n```","lastmodified":"2022-09-20T05:41:07.266338579Z","tags":null},"/3203-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F":{"title":"3203-Lambda表达式","content":"# 3203-Lambda表达式\n**只能简化函数式接口的匿名内部类的写法**\n1. 必须是接口，有且只有一个抽象方法\n2. 一般这个接口上会加函数式接口的注解`@FunctionalInterface`\n\n作用\n\n简化匿名内部类的代码写法（Java8的一个新特性)\n\n## 书写格式\n```java\n(匿名内部类的被重写的形参列表)-\u003e{\n\t被重写的方法体;\n};\n```\n### 书写格式进一步简化\n1. 括号的形参类型可以不写\n2. 如果只有一个参数，参数类型可以省略，同时`()`可以省略\n3. 如果Lambda的方法体只有一行代码，可以**省略大括号**不写，同时需要**省略分号**；\n4. 如果只有一行代码，且是return语句，可以省略`return`不写，分号也需要省略\n\n## 实例\n```java\npackage LambdaTest;  \n  \nimport java.security.PublicKey;  \nimport java.sql.SQLOutput;  \n  \npublic class Test01 {  \n    public static void main(String[] args) {  \n        String name = \"张三\";  \n        // 采用匿名内部类  \n        Swimming swim1 = new Swimming() {  \n            @Override  \n            public void swim() {  \n                System.out.println(\"swimming\");  \n            }  \n        };  \n        swim1.swim();  \n  \n        //    采用Lambda表达式简化格式  \n        Swimming swim2 = () -\u003e {  \n            System.out.println(name + \"在游泳\");  \n        };  \n        swim2.swim();  \n    //        采用lambda表格式2  \n        go(()-\u003e{  \n            System.out.println(\"在河边游泳\");  \n        });  \n  \n    }  \n    public  static  void go(Swimming s){  \n        System.out.println(\"start---\");  \n        s.swim();  \n        System.out.println(\"end-----\");  \n    }  \n}  \n  \ninterface Swimming {  \n    void swim();  \n}\n```\n\noutput\n```java\nswimming\n张三在游泳\nstart---\n在河边游泳\nend-----\n```","lastmodified":"2022-09-20T05:41:07.266338579Z","tags":null},"/3204-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%BA%A2%E9%BB%91%E6%A0%91":{"title":"3204-二叉树、平衡二叉树、红黑树","content":"# 3204-二叉树、平衡二叉树、红黑树\n二叉树，查找二叉树（可能会变成瘸子，导致一边高一边低）\n## 平衡二叉树\n左右子节点的度数不超过1,\n\u003e[!faq]+ 平衡二叉树添加元素的过程中出现了不平衡怎么解决\n\u003e1. 左左：右旋\n\u003e2. 右右：左旋\n\u003e3. 左右：找到问题子树，将其左旋，然后将根树进行右旋\n\u003e4. 右左：找到问题子树，将其右旋，然后将根树进行左旋\n\n\n## 红黑树\n优点：**增删改查性能都很好**\n### 规则\n1. **根节点必须是黑色**，每一个节点是红色或者黑色\n2. 每一个节点**没有子节点或者父节点**，就将其**设置为黑色的`Nil`**（大致就是null）\n3. **红色节点的子节点必须是黑色**，不能出现两个红色父子节点相连的情况\n4. 每一个节点，**从该节点到所有子节点的简单路径上的黑色节点数是相同的**","lastmodified":"2022-09-20T05:41:07.266338579Z","tags":null},"/ADB%E5%91%BD%E4%BB%A4":{"title":"ADB命令","content":"\n# 基本常用adb命令\n## 线刷相关\n```bash\nadb version #查看adb版本\nadb devices #查看连接的手机\nadb sideload file.zip #刷zip包到手机\n\nadb reboot #重启\nadb reboot fastboot #重启到fastboot\nadb reboot bootloader #重启到bootloader界面\n\n```\n\nfast模式下\n\n```bash\nfastboot oem reboot-recovery #打开recovery\nfastboot flash recovery twrp.img #安装rec文件\n```\n\n## 卸载软件相关\n### 普通卸载\n\n```shell\n//所有软件的包名\nadb shell pm list packages\n\n//卸载命令\nadb uninstall 包名  #或者\nadb shell pm uninstall --user 0 包名\n\n```\n\n### 删除的系统软件的另一种方式\n```shell\nadb root。   #在终端输入该命令获得root权限。\nadb remount。  #重新挂载，获得对读写权限。\nadb shell。   #进入adb命令环境。\ncd /ystem/app #system/app目录，一般系统apk都安装在这个目录。\nrm -rf Browser.apk   #卸载那个文件，没有尝试过  \n```\n\n### 另一种离谱的方式\n并不会删除软件，但是会导致安装上的软件所有数据全部删除，0b的无数据软件\n使其**无法正常工作，无法工作**\n```shell\nadb shell #进入shell命令\ncd /system/     #这里记不得目录了，好像是sdcard目录\ncd Android/data/\nrm -rf 包名\n```\n\n\nFailure [DELETE_FAILED_INTERNAL_ERROR]之后rm apk卸载\n\n```bash\nadb shell pm list packages -s 找到要删除的包名\n\n//获取包名地址\nC:\\\\Users\\\\ShenWeiXing\u003eadb shell pm path com.xxx.xxx\npackage:/data/app/包名/base.apk\n\n//挂载系统读写权限\nC:\\\\Users\\\\ShenWeiXing\u003eadb remount\nremount succeeded\n\n//删除包\nC:\\\\Users\\\\ShenWeiXing\u003eadb shell rm /data/app/com.xxx.xxx-1/base.apk\n\n//重启后ok\nC:\\\\Users\\\\ShenWeiXing\u003eadb reboot\n\n```","lastmodified":"2022-09-20T05:41:07.266338579Z","tags":null},"/Clash%E4%B8%8D%E4%BB%A3%E7%90%86%E5%88%97%E8%A1%A8":{"title":"Clash不代理列表","content":"```java\ncom.tencent.mobileqq com.tencent.token com.jingdong.app.mall com.ss.android.ugc.aweme com.sohu.inputmethod.sogou com.taobao.taobao com.netease.cloudmusic com.wuba com.AiQiangGuo com.mmjang.ankihelper com.hpbr.bosszhipin net.csdn.csdnplus ganwu.doing com.estrongs.android.pop com.sangfor.vpn.client.phone org.geometerplus.zlibrary.ui.android com.lerist.fakelocation idm.internet.download.manager.plus com.amazon.kindlefc com.lingkou.leetcode com.foobnix.pdf.reader bin.mt.plus net.gsantner.markor notion.id com.fordownloads.orangefox io.github.qauxv com.tencent.androidqqmail com.tencent.qqmusic com.zdtc.ue.school cn.wps.moffice_eng com.snda.wifilocating com.wifi.link.wfys com.clover.ihour com.yicu.yichujifa cn.dxy.android.aspirin cn.dxy.idxyer com.qingyu.wifikey com.baidu.student cn.com.langeasy.LangEasyLexis com.netease.edu.ucmooc com.chinamworld.main com.greenpoint.android.mc10086.activity com.smzdm.client.android com.ltzk.mbsf com.xiaomi.mimobile.noti com.maidu.gkld com.cnblogs.xamarinandroid com.hmz.koudaiwriting com.kekeclient_ com.listendown.Music tv.danmaku.bili com.sunrise.scmbhc com.miui.cleanmaster com.maimemo.android.momo com.zhongduomei.rrmj.society com.duokan.reader com.HanBinLi.AbcPaper cn.daan.answer com.quark.browser cn.xuexi.android com.chaoxing.mobile com.xuexiaoyi.xxy com.tgelec.aqsh com.cxincx.xxjz com.fenbi.android.solar com.miui.newmidrive com.miui.mediaeditor com.xiaomi.vipaccount com.xingin.xhs com.yueme.itv com.android.soundrecorder com.tencent.mm com.tencent.weread com.sina.weibo com.truedian.dragon com.smile.gifmaker com.cnki.client com.xiaomi.scanner com.xunmeng.pinduoduo com.miui.compass com.eg.android.AlipayGphone com.yzzy.elt.passenger com.yiban.app com.miui.smarttravel cn.xiaochuankeji.tieba izuiyou.zuiyouwallpaper com.youdao.translator cn.dictcn.android.digitize.wys_lwddgjyycd_8027 com.heytap.headset com.eusoft.eudic com.mobile.pitaya.appwriter com.iudesk.android.photo.editor com.qiyi.video com.nowcoder.app.florida com.tencent.tmgp.sgame cn.dxy.medicinehelper com.ct.client com.yaerxing.fkst com.baidu.wenku com.baidu.netdisk com.baicizhan.ireading com.zhihu.android com.able.wisdomtree com.daimajia.gold com.miui.notes com.fenbi.android.yingyu com.fenbi.android.servant com.xiaomi.mibrain.speech com.youdao.dict cn.bevol.p com.tencent.wemeet.app com.tencent.map com.tencent.qqlive com.tencent.edu cn.dreamn.qianji_auto com.suning.mobile.ebuy com.cainiao.wireless com.chaoui.mintreading com.dd.antss fun.tooling.excel com.miui.calculator com.tencent.mp com.ghosun.dict com.ganji.android com.xtuone.android.syllabus com.yitong.mbank.psbc com.coolapk.market com.xt.retouch com.mutangtech.qianji com.tieyou.train.ark com.taobao.idlefish com.alicloud.databox com.flyersoft.moonreaderp com.autonavi.minimap\n```","lastmodified":"2022-09-20T05:41:07.266338579Z","tags":null},"/Git%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8":{"title":"Git的基本使用","content":"\n### 设置代理\n\n```bash\ngit config --global http.proxy http://127.0.0.1:7890\n```\n\n## 提交三部曲\n```bash\ngit add .\ngit commit -m \"提交内容\"\ngit push #提交到远程仓库中\n```\n## git配置方面\n\n```bash\ngit config --global http.proxy \u003chttp://127.0.0.1:7890\u003e  #设置代理\n\n#设置邮箱和用户名\ngit config --global user.email \"fa@fds.com\"   \ngit config --global user.name \"fa\"\n\ngit config --list  #查看配置列表\n```\n\n```bash\necho \"# hanguang\" \u003e\u003e README.md\ngit init\t\t\t\t#初始化仓库\ngit add README.md\t\t #新建标注文件，可以不要\ngit commit -m \"first commit\"\t#“提交信息”\ngit branch -M main\t\t\t\t#设置默认分支\ngit remote add origin \u003chttps://github.com/tianzhongs/hanguang.git\u003e\t#添加远程分支到本地命名为origin\ngit push -u origin main\t#推送origin到默认分支main\n```\n\n\n## 分支方面\n\n```bash\ngit branch -m main hugo \ngit fetch origin\ngit branch -u origin/hugo hugo\ngit remote set-head origin -a\n```\n\n## 子模块方面\n### 删除子模块\n第一种：\n```bash\ngit rm 子模块名称\n```\n第二种：\n```bash\nrm -rf 子模块目录 #删除子模块目录及源码 bash下使用 \nvi .gitmodules #删除项目目录下.gitmodules文件中子模块相关条目 \nvi .git/config #删除配置项中子模块相关条目 \nrm .git/module/* #删除模块下的子模块目录，每个子模块对应一个目录，注意只删除对应的子模块目录即可\n```\n\n### 添加子模块\n```bash\ngit submodule add url链接 作为父类文件夹的名称 #其中文件夹为可选，默认是子类仓库名称\n```\n\n### 子模块更新\n```\ngit submodule update --init #初始化\ngit submodule update --remote #同步子模块最新版本仓库到父仓库中\n```","lastmodified":"2022-09-20T05:41:07.266338579Z","tags":null},"/IO%E6%B5%81":{"title":"","content":"# IO流\n\nCreated: August 1, 2022 8:50 AM\n类别: IO\n\n包：`java.io`\n\n# 书写注意点\n\n1. 创建流对象的时候异常：\n    1. 写入对象会有`IOException`需要捕获，因为你输出输出数据了\n    2. 读取对象会有`FileNotFoundException` 需要捕获，因为你读取文件路径要找文件\n    3. 流关闭的时候会有`IOException`，同理，你要找文件把它关闭了\n2. 先创建的流对象要赋值`null`，放在`try`外面，`try`里面在对文件路径进行赋值，避免在`finally`关闭的时候找不到变量\n3. `output`**操作一定要记得`flush`**\n4. Stream结尾的是**字节流**，什么文件都可以操作；但是writer和reader结尾的是**字符流**，专用对普通文本操作，可以[直接进行String的写出](IO流.md)\n\n# 流的分类\n\n1. 流的方向：输入流、输出流\n2. 读取数据的方式：字节流、字符流\n\n## IO四大家族\n\n1. `java.io.InputStream` 字符输入流\n2. `java.io.OutputStream` 字符输出流\n3. `java.io.reader` 字符输入流\n4. `java.io.writer` 字符输出流\n\n# 四大家族：需要掌握的流\n\n以下的读取就是输入，写出就是输出。\n\n**前两个是最常用的**\n\n```java\n//文件专属\njava.io.FileInputStream//读取字节流\njava.io.FileOutputStream//写出字节流\njava.io.FileReader//读取字符流\njava.io.FileWriter//写出字符流\n//转换流 字节流--\u003e字符流\njava.io.InputStreamReader//字节流--》字符流\njava.io.OutputStreamWriter//字节流--》字符流\n//缓冲专属 带有缓冲区\njava.io.BufferedInputStream //字节流，读取\njava.io.BufferedOutputStream//字节流，写入\njava.io.BufferedReader//字符包装流，传入FileReader，读取\njava.io.BufferedWriter//字符写入流，传入FileWriter，写入\n//数据流专属\njava.io.DataInputStream\njava.io.DataOutputStream\n//对象专属流  通常用于序列化\njava.io.ObjectInputStream\njava.io.ObjectOutputStream\n//标准输出流\njava.io.PrintStream\njava.io.PrintWriter\n```\n\n## 注意\n\n1. 类名以`Stream`结尾的是字节流，以`reader/writer`结尾的是字符流\n2. 所有的流都有`close()`关闭，用完之后要关闭，避免浪费资源\n3. 所有的**输出流**都有`flush()`方法，所有的***输出流用完之后要记得刷新*。**刷新表示将管道中的剩余未输出数据强行输出完，作用就是**清空管道   写操作必须要`flush`**\n    1. 缓冲区太大，输出流，输出流就可能偷懒，没有写入，使用flush就会强制把没有填满缓冲区的部分全部输出\n\n## FileInputStram\n\n### 第一种，一个字节一个字节的读\n\n```java\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\n\npublic class FileInputStreamTest01 {\n    public static void main(String[] args) {\n//创建字节流对象\nFileInputStream fis=null;\n        try {\n            fis=new FileInputStream(\"E:\\\\javaAdvanced\\\\ioTest\\\\src\\\\tmp\");//引入文件，可能有文件未找到的异常需要考虑\nint readData=0;\n//读取文件，可能会有io异常\nwhile((readData=fis.read())!=-1){\n\n                System.out.println(readData);\n            }\n\n        }catch (FileNotFoundException e){\n            e.printStackTrace();\n        }catch (IOException e){\n            e.printStackTrace();\n        }finally {\n            if (fis!=null) {\n                try {\n                    fis.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n}\n\n```\n\n![Untitled](../../../../asset/Untitled%2023.png)\n\n效率低\n\n### (重点)第二种，传入一个数组去读取\n\n```java\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\n\npublic class FileInputStramTest03{\n    public static void main(String[] args) {\n    //    创建一个字节流对象\n        FileInputStream fis=null;\n        try {\n            fis=new FileInputStream(\"ioTest/src/gushi\");//有个FileNotFountException异常需要捕获\n        //    创建一个字节数组，每次读取4个\n            byte[] bytes=new byte[4];\n            int readCount=0;//每次读取的数量\n            while ((readCount= fis.read(bytes))!=-1){//read有IOException需要捕获\n                //String可以将数组转换成字符，String（数组，起始值，需要多少个）\n                System.out.print(new String(bytes,0,readCount));\n            }\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n![Untitled](../../../../asset/Untitled%201%204.png)\n\n## FileOutputStream\n\n```java\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\n\npublic class FileOutputStreamTest01 {\n    public static void main(String[] args) {\n        FileOutputStream fis=null;\n        try {\n//FileOutputStream fis=new FileOutputStream(\"ioTest/src/写入.txt\",true);//追加的方式写入\nfis=new FileOutputStream(\"ioTest/src/写入.txt\");//覆盖的方式写入\nbyte[] bytes={97,98,99,100};\n            fis.write(bytes);//第一种，写入一个数组\nfis.write(98);//写入一个字节\nfis.write(bytes,0,3);//写入数组的一部分\nfis.flush();\n            String s=\"我是你爸爸\";\n            fis.write(s.getBytes());//字符转换成数组写入\n\nfis.flush();//之后必做的一部分，刷新\n\n} catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if (fis!=null)\n            try {\n                fis.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n    }\n}\n\n```\n\n![Untitled](../../../../asset/Untitled%202%203.png)\n\n### 输入输出流复制文件\n\n```java\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\n\npublic class CopyTest01 {\n    public static void main(String[] args) {\n    //     输入流对象\n        FileInputStream fis=null;\n    //    输出流对象\n        FileOutputStream fos=null;\n        try {\n            fis=new FileInputStream(\"C:\\\\Users\\\\22305\\\\Downloads\\\\tiddlers.html\");//要复制的文件\n            fos=new FileOutputStream(\"C:\\\\Users\\\\22305\\\\Desktop\\\\复制的文件.html\");//复制的文件路径\n            byte[] bytes=new byte[1024*1024];//每次拷贝1MB\n            int readCount;//每次读取到的字节数\n            while ((readCount=fis.read(bytes))!=-1){\n                fos.write(bytes,0,readCount);//写入读取到的字节数\n            }\n            fos.flush();//写入文件必备的一部，刷新缓冲区，清空管道\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if (fis!=null){\n                try {\n                    fis.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (fos!=null){\n                try {\n                    fos.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n\noutput:别问，问就是成功了的\n\n## FileReader 读取字符，字符流\n\n```java\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class FileReaderTest01 {\n    public static void main(String[] args) {\n        FileReader fr=null;//字符流对象\n        try {\n            fr=new FileReader(\"ioTest/src/a.txt\");\n            char[] chars=new char[4];//一次读取四个字符\n            int readCount=0;\n            while ((readCount=fr.read(chars))!=-1){\n                System.out.print(new String(chars,0,readCount));//读几个，输出几个\n            }\n\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if (fr!=null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n\n![Untitled](../../../../asset/Untitled%203%203.png)\n\n## FileWriter 字符写入流\n\n```java\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class FileWriterTest01 {\n    public static void main(String[] args) {\n        FileWriter fiw=null;\n        try {\n            fiw=new FileWriter(\"ioTest/src/普通文本写入.txt\");\n//采用char数组的方式写入\nchar[] chars={'我','是','大','帅','比'};\n            fiw.write(chars);//整个写入\nfiw.write(chars,2,3);//部分写入\nfiw.write(\"\\n字符串的方式写入\");\n            fiw.flush();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if (fiw!=null){\n                try {\n                    fiw.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n\n    }\n}\n\n```\n\n![Untitled](../../../../asset/Untitled%204%203.png)\n\n### 复制普通文本文件FileReader FileWriter\n\n```java\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class CopyTest02 {\n    public static void main(String[] args) {\n        FileReader in=null;\n        FileWriter out=null;\n        try {\n            in=new FileReader(\"ioTest/src/普通文本写入.txt\");//被复制的普通文本文件\n            out=new FileWriter(\"ioTest/src/复制的文本文件.txt\");\n            char[] chars=new char[1024*512];//1MB\n            int readCount=0;//读取的字符数\n            //读取的字符数不小于0，就写入\n            while ((readCount=in.read(chars))!=-1){\n                out.write(chars,0,readCount);//读几个字符，就写几个字符\n            }\n            //写完之后，避免遗漏，需要flush\n            out.flush();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if (in!=null){\n                try {\n                    in.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (out!=null){\n                try {\n                    out.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n\n## BufferedReader 带有缓冲区的字符流\n\n`BufferedReader`的对象叫**包装流**，或者叫**处理流**\n\n传入的参数叫**节点流**\n\n### 书写注意点\n\n1. readLine()可以一次读一行，末尾的换行符不算在内，所以建议采用println\n2. **只能传字符流，不能传字节流** 末尾只能是`Reader`或者`Writer`，所以可以转换流，再传入\n3. 传入的`FileReader`参数不需要`close`，会自动`close`，只需要`close()`BufferedReader对象就好了\n\n### BufferReader使用eg\n\n```java\nimport java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class BufferedReaderTest01 {\n    public static void main(String[] args) {\n        BufferedReader br=null;\n        FileReader in= null;\n        try {\n            in = new FileReader(\"ioTest/src/a.txt\");\n            br=new BufferedReader(in);//传入一个FileReader对象\n            String s=null;\n\n            //String readLine=br.readLine();//一次读取一行\n            while((s=br.readLine())!=null){\n                System.out.println(s);\n            }\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if (br!=null){\n                try {\n                    br.close();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n        }\n    }\n}\n```\n\n![Untitled](../../../../asset/Untitled%205%202.png)\n\n### BufferedReader传入的参数必须是字符流，不是就要转换成字符流\n\n```java\nimport java.io.BufferedReader;\nimport java.io.FileInputStream;\nimport java.io.InputStreamReader;\n\npublic class BufferedReaderTest02{\n    public static void main(String[] args) throws Exception{//声明了异常，就不用catch了\n        //字节流\n        FileInputStream fis=new FileInputStream(\"ioTest/src/a.txt\");\n        //通过转换流，将字节流--\u003e字符流，因为BufferedReader只能传入字符流\n        InputStreamReader in=new InputStreamReader(fis);\n        //将字符流传入到BufferedrReader作为参数\n        BufferedReader reader=new BufferedReader(in);\n        //BufferedReader reader=new BufferedReader(new InputStreamReader(new FileInputStream(\"ioTest/src/a.txt\")));//合并起来写\n        String readLine=null;//一行\n        while ((readLine=reader.readLine())!=null){\n            System.out.println(readLine);\n        }\n\t\t\t\treader.close();//关闭处理流\n\n    }\n}\n```\n\n![Untitled](../../../../asset/Untitled%206%202.png)\n\n## BufferedWriter 写入包装流\n\n```java\nimport java.io.*;\n\npublic class BufferedWriterTest01 {\n    public static void main(String[] args) throws Exception{\n//这么嵌套的长串读的时候还好，写起来真脑瘫，眼睛看瞎\nBufferedWriter out=new BufferedWriter(new OutputStreamWriter(new FileOutputStream(\"ioTest/src/字符包装流写入.txt\")));\n//开始写\nout.write(\"我是你爸爸\\n\");\n        out.write(\"who are the most handsome person in the world?\");\n        out.write(\"\\nis me\");\n        out.flush();//清空管道\nout.close();//关闭\n}\n}\n\n```\n\n![Untitled](../../../../asset/Untitled%207%202.png)\n\n## DataInputStream和DataOutputStream\n\n### 知识点\n\n1. `DataInputStream`写入的文件不是普通文档，不能直接打开，需要通过`DataOutputStream`按照写入的方式读取\n2. 传入的参数都是字节流 `FileInputStream`或者`FileOutputSteam`\n\n```java\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\n\npublic class Test06 {\n    public static void main(String[] args) throws Exception {\n//数据专属输出流对象\nDataOutputStream dataout=new DataOutputStream(new FileOutputStream(\"ioTest/src/data.data\"));\n//写数据\nint i=123;\n        short s=153;\n        long l=23L;\n        float f=2.34F;\n        double d=3.23413541;\n        boolean b=true;\n        char c='d';\n\n//写\ndataout.writeInt(i);\n        dataout.writeShort(s);\n        dataout.writeLong(l);\n        dataout.writeDouble(d);\n        dataout.writeBoolean(b);\n        dataout.writeChar(c);\n\n        dataout.flush();//刷新\ndataout.close();//关闭包装流\n\n//数据专属输入流对象\n/*分开写\n        FileInputStream fis=new FileInputStream(\"ioTest/src/data.data\");\n        DataInputStream datain=new DataInputStream(fis);*/\n        //合并写\nDataInputStream datain=new DataInputStream(new FileInputStream(\"ioTest/src/data.data\"));\n//读取\nSystem.out.println(datain.readInt());\n        System.out.println(datain.readShort());\n        System.out.println(datain.readLong());\n        System.out.println(datain.readDouble());\n        System.out.println(datain.readBoolean());\n        System.out.println(datain.readChar());\n    }\n}\n\n```\n\n![Untitled](../../../../asset/Untitled%208%202.png)\n\n## PrintStream 标准输出流\n\n### 书写注意点\n\n1. 不需要关闭close()\n\n### 使用标准输出流，写日志文件方法，或者不输出到控制台\n\n```java\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.PrintStream;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\npublic class PrintStreamTest02 {\n    public static void main(String[] args) {\n        logger.log(\"测试日志\");\n        System.out.println(\"大帅比\");\n\n    }\n}\n\nclass logger {\n    public static void log(String s) {\n//指向的日志文件\n\nPrintStream out = null;\n        try {\n            out = new PrintStream(new FileOutputStream(\"ioTest/src/log.log\",true));//追加的方式写入\n\n//改变输出方向\nSystem.setOut(out);\n//系统当前日期时间\nDate nowDate = new Date();\n            SimpleDateFormat geshi = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss SSS\");//设置日期格式化格式\nString strnow = geshi.format(nowDate);//使用指定格式格式化当前时间\nSystem.out.println(strnow + \": \" + s);\n        } catch (FileNotFoundException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n```\n\n![Untitled](../../../../asset/Untitled%209%202.png)\n\n大帅比为什么会没有输出到控制台，因为`System.setOut`已经改变了输出的方式，指向了文件\n\n# `File`类\n\n包类：`java.io.File`\n\n1. 和[四大家族](IO流.md)没有关系，**不能进行文件读写**\n2. File对象代表的是**文件路径**或者是**文件**\n\n## 常用方法\n\n```java\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\npublic class FileTest01 {\n    public static void main(String[] args) throws Exception {\n        File f1 = new File(\"fileTest/src/mulu\");\n        System.out.println(f1.getAbsoluteFile() + (f1.exists() ? \"   :存在\" : \"   :不存在\"));\n        //如果不存在就创建这个文件\n        if (!f1.exists()) {\n            //f1.createNewFile();//创建文件\n            f1.mkdir();//创建目录\n            System.out.println(f1.getAbsoluteFile() + (f1.exists() ? \"   :存在\" : \"   :不存在\"));\n        }\n\n        //    创建多级目录\n        File f2 = new File(\"D:/a/b/c/d/e/f\");\n        if (!f2.exists()) {\n\n            f2.mkdirs ();\n            System.out.println(\"f2\" + f2.exists());\n        }\n\n        //    常用方法的使用\n        File f3 = new File(\"filetest/src/Filetest01.java\");\n        //    获取文件父路径\n        String parentPath = f3.getPath();\n        System.out.println(\"父路径：\" + parentPath);\n        //    获取绝对路径\n        File f4 = f3.getAbsoluteFile();\n        System.out.println(f4);\n        System.out.println(f4.getParent());\n        //    获取文件或者目录名\n        System.out.println(f1.getName());\n        //    判断是否是一个文件\n        System.out.println(\"f1是文件吗？\" + f1.isFile());\n        //   判断是否是一个目录\n        System.out.println(\"f1是目录吗？\" + f1.isDirectory());\n        //    获取文件最后一次的修改时间\n        long haomiao = f3.lastModified();//获取修改时间的时间戳\n        Date time=new Date(haomiao);//转换成时间格式\n        SimpleDateFormat geshi=new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss SSS\");//格式\n        String modifiedTime=geshi.format(time);//转换格式，字符串处理\n        System.out.println(f3+\" 最后的修改时间是：\"+modifiedTime);\n        System.out.println(\"文件大小：\"+f3.length()+\"Bytes\");//获取文件大小：单位字节\n\n        //获取当前目录下的所有文件或目录\n        File f5=new File(\"fileTest\");\n        File[] files=f5.listFiles();\n        for (File f:files\n             ) {\n            System.out.println(f.getName());\n        }\n    }\n}\n```\n\n![Untitled](../../../../asset/Untitled%2010%202.png)\n\n## 拷贝目录下的所有文件\n\n这个代码目前存在的问题\n\n因为`exists`没有考虑是否是文件还是目录，所以可能存在一些拷贝的时候判断出错，导致创建文件或目录出现异常\n\n因为考虑单个文件的时候不会创建目录，而且文件有问题\n\n```java\nimport javax.print.attribute.DocAttributeSet;\nimport java.io.*;\n\npublic class CopyAllTest {\n    public static void main(String[] args) throws IOException {\n        File f1 = new File(\"C:\\\\Users\\\\22305\\\\Desktop\\\\nf2\\\\类统一化\\\\共享.md\");\n        File f2 = new File(\"C:\\\\Users\\\\22305\\\\Desktop\\\\10\");\n        copyAll(f1, f2);\n\n    }\n\n    /**\n     * 复制 一个目录下的所有文件和目录到另一个目录下\n     * @param src 源目录\n     * @param dest 目标目录\n     * @throws IOException\n     */\n    private static void copyAll(File src, File dest) throws IOException {\n        if (src.isDirectory()) {\n            //目标目录是否存在，不存在创建\n            if (!dest.exists()) {\n                dest.mkdirs();\n            }\n            String[] files = src.list();//源文件的目录\n            for (String file : files) {\n                //    创建目标File对象\n                File srcDir = new File(src, file);\n                System.out.println(\"源文件：\\t\"+srcDir);\n                File destDir = new File(dest, file);\n                System.out.println(\"后文件：\\t\"+destDir);\n                //    递归\n                copyAll(srcDir, destDir);\n            //\n\n            }\n\n            // 文件复制\n        } else {\n            FileInputStream in=new FileInputStream(src);\n            FileOutputStream out=new FileOutputStream(dest);\n            System.out.println(\"srcfile:\\t\"+src);\n            System.out.println(\"destfil:\\t\"+dest);\n            System.out.println();\n            //字节数组\n            byte[] bytes=new byte[1024];\n            int readCount=0;\n            while ((readCount=in.read(bytes))!=-1){\n                out.write(bytes,0,readCount);\n            }\n            out.flush();//清空管道\n            in.close();\n            out.close();\n        }\n    }\n\n}\n```\n\n# 序列化\n\n## 书写注意点\n\n1. **参与序列化或反序列化的对象类必须要实现`Serializable`**，*否则会出现`NotSerialzableException`异常*\n2. **建议将序列化版本号写出来**\n    \n    ```java\n    static final long serialVersionUID = -6430539691155161871L;\n    ```\n    \n3. `Serializable`是一个标志性接口，JVM会对实现了这个接口的特殊处理，会自动生成一个序列化版本号，标识这个类\n4. JVM判断一个类，是先对比类名，再对比序列化版本号\n5. 不想序列化的属性可以使用`transient`修饰 ，HashMap中就有此种属性\n\n## 图解\n\n![Untitled](../../../../asset/Untitled%2011%202.png)\n\n## 简述\n\n1. 类似于网络分片\n2. `Serialize`序列化：内存中的java对象分片放到硬盘\n3. `DeSerialize`  反序列化：分片的java对象从硬盘恢复到内存中\n\n## eg 序列化对象\n\n```java\nimport jdk.management.resource.internal.inst.SocketOutputStreamRMHooks;\n\nimport java.io.*;\n\npublic class SerializeTest01 {\n    public static void main(String[] args) throws Exception{\n//序列化\n    //    创建Student对象\n        Student s1=new Student(\"张三\",12);\n    //    序列化对象创建\n        ObjectOutputStream oos=new ObjectOutputStream(new FileOutputStream(\"student序列化文件\"));\n    //    序列化对象\n        oos.writeObject(s1);\n    //    因为是out，所以要记得flush 关闭管道\n        oos.flush();\n    //     关闭字节流\n        oos.close();\n//反序列化\n    //  反序列化对象\n        ObjectInputStream ois=new ObjectInputStream(new FileInputStream(\"student序列化文件\"));\n    //    反序列化\n        Object s2=ois.readObject();\n    //    输出\n        System.out.println(s2);\n    //    关闭字节流\n        ois.close();\n\n    }\n}\nclass Student implements Serializable {//序列化必须要继承serialzable接口，否则会出现NotSerialzableException异常\n    private String name;\n    private int age;\n\n    public Student() {\n    }\n\n    public Student(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    @Override\n    public String toString() {\n        return \"name:\"+name+\",age\"+age;\n    }\n}\n```\n\n![序列化文件](../../../../asset/Untitled%2012%201.png)\n\n序列化文件\n\n![反序列化的输出](../../../../asset/Untitled%2013%201.png)\n\n反序列化的输出\n\n## 反序列化集合\n\n```java\nimport org.omg.CosNaming.NamingContextPackage.NotFoundReasonHelper;\n\nimport java.io.*;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class SerializableTest02 {\n    public static void main(String[] args) throws Exception {\n//创建集合\nList\u003cUser\u003e userList=new ArrayList\u003c\u003e();\n//添加节点元素\nuserList.add(new User(\"zhangsan\",15));\n        userList.add(new User(\"wanghai\",46));\n        userList.add(new User(\"caixukun\",45));\n        userList.add(new User(\"mahuateng\",87));\n//创建序列化对象\nObjectOutputStream out=new ObjectOutputStream(new FileOutputStream(\"序列化文件\"));\n//序列化集合对象\nout.writeObject(userList);//参与序列化的对象都要实现Serializable,User实现了的，ArrayList也继承了的09\nout.flush();\n        out.close();\n\n//反序列化\n//创玩反序列化对象\nObjectInputStream in=new ObjectInputStream(new FileInputStream(\"序列化文件\"));\n//反序列化\nObject s2=in.readObject();\n        System.out.println(s2);\n//强制转换类型\nList\u003cUser\u003e users=(List\u003cUser\u003e) s2;\n//打印输出\nfor (User u:users\n             ) {\n            System.out.println(u);\n        }\n    }\n}\n\n/**\n *用户类\n*/\nclass User implements Serializable {\n    private String name;\n    private int age;\n\n    @Override\n    public String toString() {\n        return \"User[\"+name+\"\\t\"+age+\"]\";\n    }\n\n//封装\npublic User() {\n    }\n\n    public User(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n}\n```\n\n![Untitled](../../../../asset/Untitled%2014%201.png)\n\n# 配置文件：IO+Properties的联合应用\n\n类似于`KEY=value`的文件叫配置文件，可以通过IO+PRopertes联合应用，读取本地硬盘的配置文件，就不用一直保存在内存中，每次都需要重新运行配置\n\n比如主题文件，设置文件等等，都可以采用这样的方式\n\n## 作用\n\n将经常改变的数据，单独写到一个文件中进行读取写入\n\n一般是**配置文件**，文件后缀建议：`.properties` idea会识别这种配置文件\n\n## eg\n\n创建配置文件\n\n![Untitled](../../../../asset/Untitled%2015%201.png)\n\n敲代码读取配置文件\n\n**采用相对路径时，根目录在项目的根目录下，不是模块根**\n\n```java\nimport java.io.FileReader;\nimport java.util.Properties;\nimport java.util.Set;\n\npublic class IOpropertiesTest01 {\n    public static void main(String[] args) throws Exception{\n//新建流对象\nFileReader reader=new FileReader(\"配置.properties\");\n//新建Map属性集合\nProperties pro=new Properties();\n//使用pro的load将文件中的数据加载到Map集合中\npro.load(reader);//传入，进行写入到map\n    //读取配置文件\n//通过key来获取对应的value\nString name=pro.getProperty(\"name\");\n        System.out.println(name);\n//当然，还可以转成list等别的类型集合进行遍历\n}\n}\n\n```\n\n![Untitled](../../../../asset/Untitled%2016%201.png)","lastmodified":"2022-09-20T05:41:07.266338579Z","tags":null},"/Java%E4%BB%A3%E7%A0%81%E5%9D%97%E6%A8%A1%E6%9D%BF":{"title":"","content":"```java\n\n```","lastmodified":"2022-09-20T05:41:06.47432571Z","tags":null},"/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%9B%AE%E5%BD%95":{"title":"Java学习笔记目录","content":"```dataview \nTABLE file.name\nFROM \"\"\nWHERE file.name\n```","lastmodified":"2022-09-20T05:41:07.266338579Z","tags":null},"/MYSQL%E5%AD%A6%E4%B9%A0%E6%A8%A1%E6%9D%BF":{"title":"","content":"","lastmodified":"2022-09-20T05:41:07.266338579Z","tags":null},"/Obsidian%E7%9F%A5%E8%AF%86%E5%BA%93%E7%AC%94%E8%AE%B0%E7%9B%B8%E5%85%B3":{"title":"Obsidian知识库笔记相关注意事项","content":"## 关于内容\n1. 尤其需要注意的是，在每片文章中书写一个yaml头，其中yaml头包括了`title`字段，用来标识这篇文章的标题，当然，如果没有也没有太大的问题，只是不能显示这个标题，但一般还是建议有一个\n2. 如果每次添加比较麻烦，你可以配合Obsidan中的`Templater`插件进行生成，当然，你还可以为其设置一个专属的快捷键，那会让你更“快”的。（下面放置了一个基本的Templater模板，yaml字段采用`#`号注释）\n所有字段都可以不用，但是建议保留title字段，字段名和字段值中间采用`:`隔开，**分号后面有一个空格，需要注意**\n```\n---\ncomments: false   #该字段可以不要，因为采用了gittalk的评论区，貌似已经不起作用了\ndate created: \u003c% tp.date.now() %\u003e  #采用Templater生成的文档创建时间\ndate modified: 2022-08-20          #此处我没有找到自动化的东西，是因为我觉得自动化的不如我自己手动修改\nid:                                #开源者继承下来的字段，我不知道啥作用\nlayout: page                    #布局格式，与网站的搜索方式有关\ntags: \u003c% tp.file.folder() %\u003e    #tag标签，我采用的是用父文件夹名，因为我一般都用文件夹进行归类\ntitle: \"\u003c% tp.file.title %\u003e    #文件名\"\n---\n```\n---\n## 关于博客相互之间引用的链接\n这个不不属于markdown的标准语法，而是属于wiki语法，而且在这个云知识库中似乎也不是标准的，值得庆幸的是，Obsidian对语法格式极其开放，比如markdown的图片链接，即使你只写一个文件名放到括号中，并不是正确的路径，他依旧回去帮你找那个图片并显示出来。（就T*尼普）\n\n\n博客之前相互引用的方式为`[[]]`中间只放文件名，所以尽量不要有重复的文件名，但事实上并不太可能，所以我也没有其他比较好的解决办法，值得庆幸的是，我的文件名几乎都有标识符编号\n\n---\n## 关于图片链接\n是在是没有搞清楚这个图片链接的形式是如何的，我看了一下源作者的博客链接 [Oldwinter](https://garden.oldwinter.top/HOMEPAGE#:~:text=%E4%B8%BB%E9%A1%B5%E5%85%B6%E5%AE%9E%E4%B9%9F%E6%98%AF%E4%B8%80/)，图片也是挂了很多。\n经过尝试，我发现了链接的可行性方案\n1. 将在知识库根文件夹下创建一个文件夹，比如我的知识库是obzsk，那么就在下面创建一个pic文件夹，然后在ob里面分别设置附件位置为这个文件夹，其次，**还需要关闭ob中的附件链接基于相对路径**![](../asset/Pasted%20image%2020220918102408.png)\n2. 将所有图片上传到云端，采用图床的方式，这是通用的\n3. 采用base64引入的方式作为图片数据，经过测试，不行。\n\n## 关于标准Markdown语法\n\u003e[!info] 这个知识库采用的是部分标准的markdown语法，这意味着你的换行采用两个换行符才能有换行的效果。","lastmodified":"2022-09-20T05:41:07.266338579Z","tags":null},"/README":{"title":"","content":"# Obzhishiku\n我的Obsiidan知识库\n 项目地址: [example](ob.tianzhongs.ml) ","lastmodified":"2022-09-20T05:41:06.47432571Z","tags":null},"/a%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%E9%97%AE%E9%A2%98":{"title":"","content":"## 手写不熟练的代码\n1. 整个文件夹复制\n## 写不来的\n1. [[手写单向链表结构]]\n2. [[手写学生信息系统]]\n3. 奇数偶数轮流输出多线程，同步锁      ","lastmodified":"2022-09-20T05:41:06.454325385Z","tags":null},"/day24-%E6%AD%A6%E5%99%A8%E4%BD%9C%E4%B8%9A%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93":{"title":"","content":"1. 没有基本的结构\n2. 没有想到异常处理\n3. 容易忘记在方法上写 throws 异常\n4. 在throw new的时候放在了for里面，这非常纸张。导致的情况是，添加了一个武器就添加不进去了，还找了半天的问题","lastmodified":"2022-09-20T05:41:06.454325385Z","tags":null},"/java%E9%93%BA%E5%9E%AB%E7%9B%AE%E5%BD%95":{"title":"java铺垫目录","content":"\n```dataview\ntable\nfile.etags as 标签\nFrom  \"搞机相关\"\nsort file.name\n```","lastmodified":"2022-09-20T05:41:07.266338579Z","tags":null},"/java-%E7%9B%AE%E5%BD%95":{"title":"","content":"# 目录\n```dataview\ntable\nfile.etags as 标签\nFrom  \"Java\"\nsort file.name\n```","lastmodified":"2022-09-20T05:41:06.454325385Z","tags":null},"/mysql%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95":{"title":"","content":"13\n36","lastmodified":"2022-09-20T05:41:06.454325385Z","tags":null},"/test":{"title":"","content":"","lastmodified":"2022-09-20T05:41:06.454325385Z","tags":null},"/tset":{"title":"","content":"\t","lastmodified":"2022-09-20T05:41:06.438325125Z","tags":null}}