<!-- set data/config yaml file based on website language -->
{{/* {{ $config := cond (eq $.Site.Language.Lang "en") "config" (printf "config.%s" $.Site.Language.Lang) }}
{{ $data := index $.Site.Data $config }}

<!-- Contact Info -->
<div id="contact_buttons">
    <footer>
        {{ $name := $data.name | default $.Site.Data.config.name }}
        {{ $year := dateFormat "2006" now }}
        <p>{{ i18n "copyright" (dict "name" $name "year" $year) | safeHTML}}</p>
        <ul>
            {{ if not .IsHome }}
            <li><a href="{{ $.Site.BaseURL}}">{{ i18n "home" }}</a></li>
            {{end}}
            {{- range $data.links | default $.Site.Data.config.links -}}
            <li><a href="{{.link}}">{{.link_name}}</a></li>
            {{- end -}}
        </ul>
    </footer>
</div> */}}
<hr />

<!-- ä»¥ä¸‹ä¸ºä½ éœ€è¦é…ç½®çš„è¯„è®ºåŒºï¼Œä»¥ä¸‹éƒ¨åˆ†å¯ä»¥åˆ é™¤ -->
<!-- å¼•å…¥ -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js">
</script>
<!-- è§£å†³issueçš„labelé•¿åº¦ä¸èƒ½è¶…è¿‡äº”åçš„é—®é¢˜ -->
<script src="alittlejs/md5.min.js"></script>
<!-- æ·»åŠ ä¸€ä¸ªå®¹å™¨-->
<div id="gitalk-container"></div>

<!-- ç”Ÿæˆ gitalk æ’ä»¶-->
<script>
    var gitalk = new Gitalk({
        clientID: 'b3d1e82d398c36a4a587', //Client ID è‡ªå·±é…ç½®

        clientSecret: '973b351e5ad4ff9ea6d93e7db3f431beef48dc2d', //Client Secret è‡ªå·±é…ç½®

        repo: 'ObPublish',//ä»“åº“åç§°  è‡ªå·±é…ç½®
        owner: 'tianzhongs',//ä»“åº“æ‹¥æœ‰è€…  è‡ªå·±é…ç½®
        admin: ['Tianzhongs'],
        id: location.href,      // Ensure uniqueness and length less than 50
        distractionFreeMode: false  // Facebook-like distraction free mode
    })

    gitalk.render('gitalk-container')
</script>

<!-- æ¬¡æ•°ç»Ÿè®¡ start -->
<style>
    * {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

    .word {
  display: flex;
  flex-direction: row;
  gap: var(--cell-size);
}
</style>
<!-- <center> -->
    <script>
    var caution = false
            function setCookie(name, value, expires, path, domain, secure) {
                var curCookie = name + "=" + escape(value) + ((expires) ? "; expires=" + expires.toGMTString() : "") + ((path) ? "; path=" + path : "") + ((domain) ? "; domain=" + domain : "") + ((secure) ? "; secure" : "")
                if (!caution || (name + "=" + escape(value)).length <= 4000)
                    document.cookie = curCookie
                else if (confirm("Cookie exceeds 4KB and will be cut!"))
                    document.cookie = curCookie
            }
            function getCookie(name) {
                var prefix = name + "="
                var cookieStartIndex = document.cookie.indexOf(prefix)
                if (cookieStartIndex == -1)
                    return null
                var cookieEndIndex = document.cookie.indexOf(";", cookieStartIndex + prefix.length)
                if (cookieEndIndex == -1)
                    cookieEndIndex = document.cookie.length
                return unescape(document.cookie.substring(cookieStartIndex + prefix.length,
                    cookieEndIndex))
            }
            function deleteCookie(name, path, domain) {
                if (getCookie(name)) {
                    document.cookie = name + "=" + ((path) ? "; path=" + path : "") + ((domain) ? "; domain=" + domain : "") + "; expires=Thu, 01-Jan-70 00:00:01 GMT"
                }
            }
            function fixDate(date) {
                var base = new Date(0)
                var skew = base.getTime()
                if (skew > 0)
                    date.setTime(date.getTime() - skew)
            }
            var now = new Date()
            fixDate(now)
            now.setTime(now.getTime() + 730 * 24 * 60 * 60 * 1000)
            var visits = getCookie("counter")
            if (!visits)
                visits = 1
            else
                visits = parseInt(visits) + 1
            setCookie("counter", visits, now)
            document.write("<font class='word' size=2>è®¿é—®é‡ğŸ‘‹ï¼š" + visits + "</font>")
            //
// Animate 7x5 pixel letters with random colors for each cell
//
// This would work for any word on the ".word" element, as long as there is a "letter definition" for each letter of the word (currently only for the letters in "bazinga")

// Settings
const lettersDefinitions = {
  a: [
    0, 0, 1, 0, 0,
    0, 1, 0, 1, 0,
    1, 0, 0, 0, 1,
    1, 1, 1, 1, 1,
    1, 0, 0, 0, 1,
    1, 0, 0, 0, 1,
    1, 0, 0, 0, 1,
  ],
  b: [
    1, 1, 1, 1, 0,
    1, 0, 0, 0, 1,
    1, 0, 0, 0, 1,
    1, 1, 1, 1, 0,
    1, 0, 0, 0, 1,
    1, 0, 0, 0, 1,
    1, 1, 1, 1, 0,
  ],
  g: [
    0, 1, 1, 1, 0,
    1, 0, 0, 0, 1,
    1, 0, 0, 0, 0,
    1, 0, 0, 0, 0,
    1, 0, 1, 1, 1,
    1, 0, 0, 0, 1,
    0, 1, 1, 1, 0,
  ],
  i: [
    0, 1, 1, 1, 0,
    0, 0, 1, 0, 0,
    0, 0, 1, 0, 0,
    0, 0, 1, 0, 0,
    0, 0, 1, 0, 0,
    0, 0, 1, 0, 0,
    0, 1, 1, 1, 0,
  ],
  n: [
    1, 0, 0, 0, 1,
    1, 0, 0, 0, 1,
    1, 1, 0, 0, 1,
    1, 0, 1, 0, 1,
    1, 0, 0, 1, 1,
    1, 0, 0, 0, 1,
    1, 0, 0, 0, 1,
  ],
  z: [
    1, 1, 1, 1, 1,
    0, 0, 0, 0, 1,
    0, 0, 0, 1, 0,
    0, 0, 1, 0, 0,
    0, 1, 0, 0, 0,
    1, 0, 0, 0, 0,
    1, 1, 1, 1, 1,
  ],
	u: [
    1, 0, 0, 0, 1,
    1, 0, 0, 0, 1,
    1, 0, 0, 0, 1,
    1, 0, 0, 0, 1,
    1, 0, 0, 0, 1,
    1, 0, 0, 0, 1,
    1, 1, 1, 1, 1,
  ],
	m: [
    1, 0, 0, 0, 1,
    1, 0, 0, 0, 1,
    1, 1, 0, 1, 1,
    1, 0, 1, 0, 1,
    1, 0, 1, 0, 1,
    1, 0, 0, 0, 1,
    1, 0, 0, 0, 1,
  ],
}
const cellSettings = {
  height: 7,
  width: 5,
}
const colors = [
  '#f44336',
  '#e91e63',
  '#9c27b0',
  '#673ab7',
  '#3f51b5',
  '#2196f3',
  '#03a9f4',
  '#00bcd4',
  '#009688',
  '#4caf50',
  '#8bc34a',
  '#cddc39',
  '#ffeb3b',
  '#ffc107',
  '#ff9800',
  '#ff5722',
  '#795548',
  '#9e9e9e',
  '#607d8b'
]

// DOM Elements
const wordEl = document.querySelector('.word');

// constants
const word = wordEl.textContent.trim().toLowerCase();
const letters = word.split('');
const cellsPerLetter = cellSettings.width * cellSettings.height;

// Start animation
function initAnimation() {
  wordEl.textContent = '';
  populate();
}

// Create each word letter (with correct content)
function populate() {
  letters.forEach((letter) => {
    letterEl = createLetter(letter);
    wordEl.appendChild(letterEl);
  });
}

// Create a single letter (with grid)
function createLetter(letter) {
  const letterEl = document.createElement('span');
  letterEl.classList.add('letter');
  letterEl.grid = createLetterGrid(letter, letterEl);
  return letterEl;
}

// Create a letter grid (with cell instances)
function createLetterGrid(letter, letterEl) {
  for (let i = 0; i < cellsPerLetter; i ++) {
    const cellEl = document.createElement('span');
    cellEl.classList.add('cell');
    cellEl.cell = new Cell(cellEl, lettersDefinitions[letter][i] === 1);
    letterEl.appendChild(cellEl);
  }
  return;
}

// Cell which changes background color randomly and random intervals
class Cell {
  // Constants
  minUpdateInterval = 250;
  maxUpdateInterval = 1000;
  
  constructor(cellEl, hasColor) {
    this.cellEl = cellEl;
    this.hasColor = hasColor;
        
    this.addColor();
  }
  
  // Change cell color
  addColor() {
    this.cellEl.style.backgroundColor = this.hasColor
      ? this.getRandomColor()
      : 'transparent';
    
    // Change color again at a random interval
    setTimeout(this.addColor.bind(this), this.generateUpdateInterval());
  }
  
  // Get a random color from the colors array
  getRandomColor() {
    return colors[Math.floor(Math.random() * colors.length)];
  }
  
  // Generate a random interval
  generateUpdateInterval() {
    const difference = this.maxUpdateInterval - this.minUpdateInterval;
    let randomNumber = Math.random();
    randomNumber = Math.floor(randomNumber * difference);
    randomNumber = randomNumber + this.minUpdateInterval;
    return randomNumber;
  }
}

initAnimation();
            

        </script>
        <!-- </center> -->
    <!-- æ¬¡æ•°ç»Ÿè®¡ over -->
