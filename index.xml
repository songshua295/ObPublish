<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>知识Cool😊 on</title><link>https://ob.tianzhongs.ml/</link><description>Recent content in 知识Cool😊 on</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://ob.tianzhongs.ml/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://ob.tianzhongs.ml/2115_%E5%85%AB%E7%A7%8D%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8BInteger%E7%AD%89%E7%AD%89/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2115_%E5%85%AB%E7%A7%8D%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8BInteger%E7%AD%89%E7%AD%89/</guid><description>包: java.long
[!tip]+ 八种包装类型存在的意义
因为8种基本数据类型不够用。所以SUN又提供对应的8种包装类型。 在调用方法等等时候,传入的参数如果是对象,那么基本数据类型不满足条件的时候,就可以传入包装类型就好了 基本数据类型向引用数据类型的转换 对照 基本数据类型 包装类型 父类 byte java.</description></item><item><title/><link>https://ob.tianzhongs.ml/day24_%E6%AD%A6%E5%99%A8%E4%BD%9C%E4%B8%9A%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/day24_%E6%AD%A6%E5%99%A8%E4%BD%9C%E4%B8%9A%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</guid><description> 没有基本的结构 没有想到异常处理 容易忘记在方法上写 throws 异常 在throw new的时候放在了for里面，这非常纸张。导致的情况是，添加了一个武器就添加不进去了，还找了半天的问题</description></item><item><title/><link>https://ob.tianzhongs.ml/%E5%9B%BE%E5%BA%8A%E4%B8%8A%E4%BC%A0%E6%B5%8B%E8%AF%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E5%9B%BE%E5%BA%8A%E4%B8%8A%E4%BC%A0%E6%B5%8B%E8%AF%95/</guid><description>图床上传测试 2 4. 123</description></item><item><title/><link>https://ob.tianzhongs.ml/%E6%A0%BC%E9%9B%B7%E5%B7%B4%E6%97%85%E9%A6%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E6%A0%BC%E9%9B%B7%E5%B7%B4%E6%97%85%E9%A6%86/</guid><description/></item><item><title/><link>https://ob.tianzhongs.ml/%E6%B5%8B%E8%AF%95yaml%E5%A4%B4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E6%B5%8B%E8%AF%95yaml%E5%A4%B4/</guid><description>1 2 3 4 5 6 7 8 comments:falsedate created:2022-10-03date modified:2022-10-03id:layout:pagecategory:tags:title:&amp;#34;测试yaml头&amp;#34; 测试yaml头 测试一下yaml头</description></item><item><title>000-远程仓库一般流程</title><link>https://ob.tianzhongs.ml/000-%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E4%B8%80%E8%88%AC%E6%B5%81%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/000-%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E4%B8%80%E8%88%AC%E6%B5%81%E7%A8%8B/</guid><description>000-远程仓库一般流程 配置好用户凭据以及 [[001-安装之后的配置#设置个人名称和邮箱 veaiyshu|用户邮箱]]
复制仓库链接![[../../asset/Pasted image 20220624141828.png]]
1 2 3 4 5 6 7 cho &amp;#34;# hanguang&amp;#34; &amp;gt;&amp;gt; README.</description></item><item><title>0000_总结基本要点</title><link>https://ob.tianzhongs.ml/0000_%E6%80%BB%E7%BB%93%E5%9F%BA%E6%9C%AC%E8%A6%81%E7%82%B9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0000_%E6%80%BB%E7%BB%93%E5%9F%BA%E6%9C%AC%E8%A6%81%E7%82%B9/</guid><description>0000_总结基本要点 jdbc的作用，是啥 jdbc开发的步骤：导包jar， 开发6部分 为了避免sql注入，statement以及PreparedStatement使用的区别 使用资源绑定器，采用类反射机制等等，降低程序耦合度，可以通过配置文件来修改相应的设置等等 0007 通过资源绑定器获取属性文件 事物机制</description></item><item><title>00012_事务</title><link>https://ob.tianzhongs.ml/0012_%E4%BA%8B%E5%8A%A1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0012_%E4%BA%8B%E5%8A%A1/</guid><description>00012_事务 什么是事务？
一个事务是一个完整的业务逻辑单元，不可再分。 要想保证以上的两条DML语句同时成功或者同时失败，那么就需要使用数据库的“事务机制”。 和事务相关的语句只有：DML语句。（insert delete update）
为什么？因为它们这三个语句都是和数据库表当中的“数据”相关的。 事务的存在是为了保证数据的**完整性**，**安全性**。 [!faq]+ 事务的特性？ 事务包括四大特性：ACID A: 原子性：事务是最小的工作单元，不可再分。 C: 一致性：事务必须保证多条DML语句同时成功或者同时失败。 I：隔离性：事务A与事务B之间具有隔离。 D：持久性：持久性说的是最终数据必须持久化到硬盘文件中，事务才算成功的结束。</description></item><item><title>0001_JDBC基本概念</title><link>https://ob.tianzhongs.ml/0001_JDBC%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0001_JDBC%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</guid><description>0001_JDBC基本概念 Java DataBase Connectivity（Java语言连接数据库）
JDBC的本质是什么？
JDBC是SUN公司制定的一套接口（interface）java.sql.\*; (这个软件包下有很多接口。) 面向接口编程可以降低程序耦合度，提高程序扩展力，多态机制就是典型的抽象编程。（Animal a=new CAt();） sun制定JDBC接口的原因：
每一个数据库的底层实现原理不一样，每一个产品有自己独特的实现原理，所以就需要数据库产品自己去写jdbc中接口的实现方式，供用户调用。</description></item><item><title>0001_概述</title><link>https://ob.tianzhongs.ml/0001_%E6%A6%82%E8%BF%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0001_%E6%A6%82%E8%BF%B0/</guid><description>0001_概述 概述 忘记root密码怎么解决？ 关闭正在运行的ySQL服务。 打开Dos窗口，转到nysql\bin目录。 输入mysqld-skip-grant-tables回车。&amp;ndash;skip-grant-tables的意思是启动ysQL服务的时候跳过权限表认证。 再开一个Dos窗口(因为刚才那个Dos窗口己经不能动了)，转到mysg1\bin目录。 输入mysg1回车，如果成功，将出现MySQL提示符
。 连接权限数据库：use mysq1;. 改密码：update user set password-=password(&amp;ldquo;123&amp;rdquo;)where user:=&amp;ldquo;root&amp;rdquo;;（别忘了最后加分号）。 刷新权限（必须步骤）：f1 ush privileges; 退出guit.</description></item><item><title>0002_JDBC开发基本使用</title><link>https://ob.tianzhongs.ml/0002_JDBC%E5%BC%80%E5%8F%91%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0002_JDBC%E5%BC%80%E5%8F%91%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</guid><description>0002_JDBC开发基本使用 开发前的准备 在对应的数据库官网下载jar包（这个jar中包括了的jdbc接口的具体实现方式） 如果是cmd窗口运行的话，就需要将其配置到 环境变量classpath中，一般需要设置两个东西，一个是.，表示当前路径，一个是jar包的具体位置，比如C:\Users\22305\Documents\MySql Connector Java 5.1.23\mysql-connector-java-5.1.23-bin.jar () 如果是idea的话，就需要导包，具体方法为两种 File&amp;ndash;&amp;gt;Project Structure&amp;mdash;Moudles&amp;ndash;&amp;gt;选择你对应的模块，然后在右侧的编辑窗口中点击+号，选择对应的jar包&amp;ndash;&amp;gt;导入之后，勾选上&amp;mdash;-&amp;gt;点击应用即可</description></item><item><title>0002_SQL语句的分类</title><link>https://ob.tianzhongs.ml/0002_SQL%E8%AF%AD%E5%8F%A5%E7%9A%84%E5%88%86%E7%B1%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0002_SQL%E8%AF%AD%E5%8F%A5%E7%9A%84%E5%88%86%E7%B1%BB/</guid><description>0002_SQL语句的分类 SQL语句的分类 DQL（数据查询语言）：查询语句，凡是selecti语句都是DQL. DML（数据操作语言)：insert delete update,对表当中的数据进行增删改。 DDL（数据定义语言）：create drop alter,对表结构的增删改。 TCL（事务控制语言）：commit提交事务，rollback回滚事务。 DCL（数据控制语言）：grant授权、revoke撤销权限等。</description></item><item><title>0003_JDBC开发6步</title><link>https://ob.tianzhongs.ml/0003_JDBC%E5%BC%80%E5%8F%916%E6%AD%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0003_JDBC%E5%BC%80%E5%8F%916%E6%AD%A5/</guid><description>0003_JDBC开发6步 注册驱动，两种方式 获取连接 建立SQL数据库操作对象 执行SQL语句 处理结果集 释放资源（java与数据库之间属于进程之间的通信）（一般在finally语句中，编辑的时候建议需要关闭的对象放在try外面设置为null，之后，释放资源代码写了之后再开始选择编辑）</description></item><item><title>0003_mysql基本命令使用</title><link>https://ob.tianzhongs.ml/0003_mysql%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0003_mysql%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/</guid><description>0003_mysql基本命令使用 作用 命令 相关 登录mysql数据库管理系统 mysql -u root -p password 查看有哪些数据库 show databases; 创建数据库 bash create database 数据库名称; 选择要使用的数据库 use 数据库名称 查看当前数据库中的表 show tables; 初始化数据 source sql文件路径 初始化之后的三张表（sql类型的文件叫sql脚本） 删除数据库 drop database 数据库名称; 查看某个表结构 desc 表名; 查看某个数据表的所有记录 select * from 表名* 查看当前使用的数据库 select database(); 查看当前的mysql版本 select version(); 结束一条语句 \c 退出mysql exit quit \q 终止一条正在编写的语句 键入\c 查看其他库中的表 show tables from &amp;lt;database name&amp;gt;; 查看表的创建语句 show create table &amp;lt;table name&amp;gt;;</description></item><item><title>0004_Statement和PreparedStatement的区别</title><link>https://ob.tianzhongs.ml/0004_Statement%E5%92%8CPreparedStatement%E7%9A%84%E5%8C%BA%E5%88%AB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0004_Statement%E5%92%8CPreparedStatement%E7%9A%84%E5%8C%BA%E5%88%AB/</guid><description>0004_Statement和PreparedStatement的区别 Statement存在SQL注入问题，而PreparedStatement解决了SQL注入问题 Statement存在安全编译时的类型检查问题，而PreparedStetement因为是采用setxxx的方式，可以在编译的时候做安全检查 Statement每次执行都需要编译一次，PreparedStatement编译一次，执行多次。 PreparedStatement因为是先发送给DBMS一个sql语句架子，DMBS进行了编译，然后再通过setxxx进行传值，最后再执行。以后每一次执行，PreparedStatement就不会再编译了，传值就可以直接传值执行，所以PreParedStatement执行效率更高。 综合：PreparedStatement使用较多
使用PreparedStatement之后传值，值中的特殊符号都会转义，所以避免了sql注入
1 com.mysql.jdbc.JDBC4PreparedStatement@5ce81285:select*fromt_userwhereloginName=&amp;#39;z&amp;#39;andloginPassword=&amp;#39;z\&amp;#39;or\&amp;#39;1\&amp;#39;=\&amp;#39;1&amp;#39; 什么时候采用Statement，需要用户注入sql语句的时候就需要用到，或者不包括安全问题的时候也可以用，参数不用单引号引起来的也需要用到</description></item><item><title>0004_查询语句相关</title><link>https://ob.tianzhongs.ml/0004_%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E7%9B%B8%E5%85%B3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0004_%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E7%9B%B8%E5%85%B3/</guid><description>0004_查询语句相关 like like：模糊查询，支持%和下划线匹配 % 代表多个任意字符（包括0个） _ 代表一个任意字符 like 后面的字符串必须放在单引号 &amp;rsquo;&amp;rsquo; 中 order by 升降序： order by asc表示升序，desc表示降序 多个排序条件，在多个条件中间逗号隔开即可 当有where时，必须放在where后面</description></item><item><title>0005_JDBC案例：给SQL数据库插入数据</title><link>https://ob.tianzhongs.ml/0005_JDBC%E6%A1%88%E4%BE%8B%E7%BB%99SQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0005_JDBC%E6%A1%88%E4%BE%8B%E7%BB%99SQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE/</guid><description>0005_JDBC案例：给SQL数据库插入数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 import java.</description></item><item><title>0005_连接</title><link>https://ob.tianzhongs.ml/0005_%E8%BF%9E%E6%8E%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0005_%E8%BF%9E%E6%8E%A5/</guid><description>0005_连接 根据连接方式来分类 内连接：inner join xxx on 条件 等值连接 非等值连接 自连接：通过自己来建立连接 外连接： left/right outer join xxx on 条件 ：主表的所有不满足条件的也会显示出来 左外连接（左连接） 示例 ： left outer join xxx on 条件 outer可以省略 右外连接（右连接） 示例 示例： 多张表连接查询 全连接（这个不讲，很少用！）</description></item><item><title>0006__嵌套子查询</title><link>https://ob.tianzhongs.ml/0006__%E5%B5%8C%E5%A5%97%E5%AD%90%E6%9F%A5%E8%AF%A2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0006__%E5%B5%8C%E5%A5%97%E5%AD%90%E6%9F%A5%E8%AF%A2/</guid><description>0006__嵌套子查询 嵌套子查询 where后面嵌套 from后面 select中使用子查询作为字段</description></item><item><title>0006_采用`Class.forName`方式注册驱动</title><link>https://ob.tianzhongs.ml/0006_%E9%87%87%E7%94%A8Class.forName%E6%96%B9%E5%BC%8F%E6%B3%A8%E5%86%8C%E9%A9%B1%E5%8A%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0006_%E9%87%87%E7%94%A8Class.forName%E6%96%B9%E5%BC%8F%E6%B3%A8%E5%86%8C%E9%A9%B1%E5%8A%A8/</guid><description>0006_采用Class.forName方式注册驱动 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 import java.</description></item><item><title>0007_union</title><link>https://ob.tianzhongs.ml/0007_union/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0007_union/</guid><description>0007_union 合并集合（相加）</description></item><item><title>0007_通过资源绑定器获取属性文件</title><link>https://ob.tianzhongs.ml/0007_%E9%80%9A%E8%BF%87%E8%B5%84%E6%BA%90%E7%BB%91%E5%AE%9A%E5%99%A8%E8%8E%B7%E5%8F%96%E5%B1%9E%E6%80%A7%E6%96%87%E4%BB%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0007_%E9%80%9A%E8%BF%87%E8%B5%84%E6%BA%90%E7%BB%91%E5%AE%9A%E5%99%A8%E8%8E%B7%E5%8F%96%E5%B1%9E%E6%80%A7%E6%96%87%E4%BB%B6/</guid><description>0007_通过资源绑定器获取属性文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 import java.</description></item><item><title>0008_limit</title><link>https://ob.tianzhongs.ml/0008_limit/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0008_limit/</guid><description>0008_limit 是sql语句最后执行的一个环节 limit m,n 从第m个开始取，取n个记录 limit n 取n个记录</description></item><item><title>0008_完成第五步，处理结果集</title><link>https://ob.tianzhongs.ml/0008_%E5%AE%8C%E6%88%90%E7%AC%AC%E4%BA%94%E6%AD%A5%E5%A4%84%E7%90%86%E7%BB%93%E6%9E%9C%E9%9B%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0008_%E5%AE%8C%E6%88%90%E7%AC%AC%E4%BA%94%E6%AD%A5%E5%A4%84%E7%90%86%E7%BB%93%E6%9E%9C%E9%9B%86/</guid><description>0008_完成第五步，处理结果集 #书写注意点 在集合中的resultSet.getInt()等方法中的参数，select语句中有as的话，填写的是as之后的字段，而不是sql语句中的原有字段名称
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 import java.</description></item><item><title>0009_DML（数据操作语言）</title><link>https://ob.tianzhongs.ml/0009_DML%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E8%AF%AD%E8%A8%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0009_DML%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E8%AF%AD%E8%A8%80/</guid><description>0009_DML（数据操作语言） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 createtabletableName(columnNamedataType(length),……………….</description></item><item><title>0009_案例：连接数据库，验证用户登录(可被sql注入）</title><link>https://ob.tianzhongs.ml/0009_%E6%A1%88%E4%BE%8B%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E9%AA%8C%E8%AF%81%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E5%8F%AF%E8%A2%ABsql%E6%B3%A8%E5%85%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0009_%E6%A1%88%E4%BE%8B%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E9%AA%8C%E8%AF%81%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E5%8F%AF%E8%A2%ABsql%E6%B3%A8%E5%85%A5/</guid><description>0009_案例：连接数据库，验证用户登录(可被sql注入） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 import java.</description></item><item><title>001-安装之后的配置</title><link>https://ob.tianzhongs.ml/001-%E5%AE%89%E8%A3%85%E4%B9%8B%E5%90%8E%E7%9A%84%E9%85%8D%E7%BD%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/001-%E5%AE%89%E8%A3%85%E4%B9%8B%E5%90%8E%E7%9A%84%E9%85%8D%E7%BD%AE/</guid><description>001-安装之后的配置 初始化 1 git init 设置个人名称和邮箱 ^veaiyshu 1 2 $ git config --global user.name &amp;#34;runoob&amp;#34; $ git config --global user.</description></item><item><title>0010_约束(Constraint)</title><link>https://ob.tianzhongs.ml/0010_%E7%BA%A6%E6%9D%9FConstraint/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0010_%E7%BA%A6%E6%9D%9FConstraint/</guid><description>0010_约束(Constraint) 概述 什么是约束？常见的约束有哪些呢？ 在创建表的时候，可以给表的字段添加相应的约束， 添加约束的目的是为了保证表中数据的合法性、有效性、完整性。 常见的约束有哪些呢？ 非空约束(not null)：约束的字段不能为NULL 唯一约束(unique)：约束的字段不能重复 ** 但可以为NULL **。 主键约束(primary key)：约束的字段既不能为NULL，也不能重复（简称PK） 外键约束(foreign key)：&amp;hellip;（简称FK） 检查约束(check)：注意Oracle数据库有check约束，但是mysql没有，目前mysql不支持该约束。 实操例子 非空约束eg 建表 测试</description></item><item><title>0010_解决sql注入问题的PreparedStatement</title><link>https://ob.tianzhongs.ml/0010_%E8%A7%A3%E5%86%B3sql%E6%B3%A8%E5%85%A5%E9%97%AE%E9%A2%98%E7%9A%84PreparedStatement/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0010_%E8%A7%A3%E5%86%B3sql%E6%B3%A8%E5%85%A5%E9%97%AE%E9%A2%98%E7%9A%84PreparedStatement/</guid><description>0010_解决sql注入问题的PreparedStatement 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 import java.</description></item><item><title>0011_事务机制</title><link>https://ob.tianzhongs.ml/0011_%E4%BA%8B%E5%8A%A1%E6%9C%BA%E5%88%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0011_%E4%BA%8B%E5%8A%A1%E6%9C%BA%E5%88%B6/</guid><description>0011_事务机制 事务机制的作用 JDBC中默认事务机制是：执行一条，提交一条。 但是在实际应用开发中，有时候需要多条DML语句共同联合完成或者失败来决定是否提交到数据库，所以就需要事物机制。 比如：转账，需要两个语句中的转出和转入都要成功，或者总共的钱就会有缺失或者多余
关闭事物提交：获取连接的对象.setAutoCommit(true); 进行提交：xx.commit(); 回滚：xx.rollback();一般写在异常中，用于DML语句中出现了异常就回滚事务
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 import jdbc.</description></item><item><title>0011_存储引擎</title><link>https://ob.tianzhongs.ml/0011_%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0011_%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</guid><description>0011_存储引擎 完整的建表语句
1 2 3 CREATETABLE`t_x`(`id`int(11)DEFAULTNULL)ENGINE=InnoDBDEFAULTCHARSET=utf8; mysql默认使用的存储引擎是InnoDB方式。 默认采用的字符集是UTF8
什么是存储引擎呢？
存储引擎这个名字只有在mysql中存在。（Oracle中有对应的机制，但是不叫做存储引擎。Oracle中没有特殊的名字，就是“表的存储方式”） mysql支持很多存储引擎，每一个存储引擎都对应了一种不同的存储方式。 每一个存储引擎都有自己的优缺点，需要在合适的时机选择合适的存储引擎。 查看当前mysql支持的存储引擎？ show engines \G</description></item><item><title>0012_JBMC封装类</title><link>https://ob.tianzhongs.ml/0012_JBMC%E5%B0%81%E8%A3%85%E7%B1%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0012_JBMC%E5%B0%81%E8%A3%85%E7%B1%BB/</guid><description>0012_JBMC封装类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 package jdbc; import java.</description></item><item><title>0013_MySQL数据库相关的基本使用</title><link>https://ob.tianzhongs.ml/0013_MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0013_MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</guid><description>0013_MySQL数据库相关的基本使用 准备MySQL 安装MySQL，老是出现安不上的问题，nt软件，重新多安几次
Navicat的基本使用 没啥说的
设计数据库表 下载PowerDesigner工具 打开之后，选择create model&amp;ndash;&amp;gt;model types&amp;ndash;&amp;gt;physical data model 在下面的DBMS中选择mysql的对应版本，比如mysql5.0 ，点击ok 设计表 保存sql脚本,你可以将保存的sql脚本继续进行优化修改 cmd登录mysql后，可以采用source xxx.</description></item><item><title>0013_索引</title><link>https://ob.tianzhongs.ml/0013_%E7%B4%A2%E5%BC%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0013_%E7%B4%A2%E5%BC%95/</guid><description>0013_索引 什么是索引？有什么用？ 索引就相当于一本书的目录，通过目录可以快速的找到对应的资源。 在数据库方面，查询一张表的时候有两种检索方式：
第一种方式：全表扫描 第二种方式：根据索引检索（效率很高） 索引为什么可以提高检索效率呢？ 其实最根本的原理是缩小了扫描的范围。 索引虽然可以提高检索效率，但是不能随意的添加索引，因为索引也是数据库当中 的对象，也需要数据库不断的维护。是有维护成本的。比如，表中的数据经常被修改 这样就不适合添加索引，因为数据一旦修改，索引需要重新排序，进行维护。
添加索引是给某一个字段，或者说某些字段添加索引。
举例 select ename,sal from emp where ename = 'SMITH'; 当ename字段上没有添加索引的时候，以上sql语句会进行全表扫描，扫描ename字段中所有的值。 当ename字段上添加索引的时候，以上sql语句会根据索引扫描，快速定位。 怎么创建索引对象？怎么删除索引对象？ 创建索引对象：</description></item><item><title>0014_悲观锁（行级锁）以及乐观锁基本认识</title><link>https://ob.tianzhongs.ml/0014_%E6%82%B2%E8%A7%82%E9%94%81%E8%A1%8C%E7%BA%A7%E9%94%81%E4%BB%A5%E5%8F%8A%E4%B9%90%E8%A7%82%E9%94%81%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0014_%E6%82%B2%E8%A7%82%E9%94%81%E8%A1%8C%E7%BA%A7%E9%94%81%E4%BB%A5%E5%8F%8A%E4%B9%90%E8%A7%82%E9%94%81%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86/</guid><description>0014_悲观锁（行级锁）以及乐观锁基本认识 悲观锁： select语句后面加上for update 比如
1 2 3 selectcnamefromdeptwhereno=12forupdate`那么查询出来的数据，就会被加锁，直到释放之前，都不能都被别的线程使用修改简单的理解就是：线程同步锁，嘎嘎好理解 查询出出来的语句会被锁上，别的线程无法修改其中的数据 事务需要排队执行，类似于同步线程，要修改的数据需要事务一个一个的排队
乐观锁 支持并发，需要修改的数据，每次读取都有一个版本号 事务不需要排队，每次读取都有一个版本号（比如1.1），提交的时候核对版本号是否和读取的一样（1.1） 一样就提交，并修改成新的版本号（1.2） 不一样就回滚，不提交，重新读取</description></item><item><title>0014视图(view)</title><link>https://ob.tianzhongs.ml/0014%E8%A7%86%E5%9B%BEview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0014%E8%A7%86%E5%9B%BEview/</guid><description>0014视图(view) 什么是视图？ 站在不同的角度去看到数据。（同一张表的数据，通过不同的角度去看待）。
怎么创建视图？怎么删除视图？ create view myview as select empno,ename from emp; drop view myview;
注意：只有DQL语句才能以视图对象的方式创建出来。
对视图进行增删改查，会影响到原表数据。（通过视图影响原表数据的，不是直接操作的原表） 可以对视图进行CRUD操作。</description></item><item><title>0015_DBA命令</title><link>https://ob.tianzhongs.ml/0015_DBA%E5%91%BD%E4%BB%A4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0015_DBA%E5%91%BD%E4%BB%A4/</guid><description>0015_DBA命令 将数据库当中的数据导出 在windows的dos命令窗口中执行：（导出整个库） mysqldump bjpowernode&amp;gt;D:\bjpowernode.sql -uroot -p333
在windows的dos命令窗口中执行：（导出指定数据库当中的指定表） mysqldump bjpowernode emp&amp;gt;D:\bjpowernode.sql -uroot –p123
导入数据 create database bjpowernode; use bjpowernode; source D:\bjpowernode.</description></item><item><title>0016_数据库设计三范式</title><link>https://ob.tianzhongs.ml/0016_%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E4%B8%89%E8%8C%83%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0016_%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E4%B8%89%E8%8C%83%E5%BC%8F/</guid><description>0016_数据库设计三范式 什么是设计范式？
设计表的依据。按照这个三范式设计的表不会出现数据冗余。
三范式都是哪些？ 第一范式：任何一张表都应该有主键，并且每一个字段原子性不可再分。 第二范式：建立在第一范式的基础之上，所有非主键字段完全依赖主键，不能产生部分依赖。 第三范式：建立在第二范式的基础之上，所有非主键字段直接依赖主键，不能产生传递依赖。
两张表，多的表加外键</description></item><item><title>0017_一对一怎么设计？</title><link>https://ob.tianzhongs.ml/0017_%E4%B8%80%E5%AF%B9%E4%B8%80%E6%80%8E%E4%B9%88%E8%AE%BE%E8%AE%A1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0017_%E4%B8%80%E5%AF%B9%E4%B8%80%E6%80%8E%E4%B9%88%E8%AE%BE%E8%AE%A1/</guid><description>0017_一对一怎么设计？ 一对一设计有两种方案：主键共享 1 2 3 4 5 6 7 8 9 10 11 &amp;gt;t_user_login 用户登录表 &amp;gt;id(pk) username password &amp;gt;-------------------------------------- &amp;gt;1 zs 123 &amp;gt;2 ls 456 &amp;gt; &amp;gt;t_user_detail 用户详细信息表 &amp;gt;id(pk+fk) realname tel .</description></item><item><title>0018_修改root密码</title><link>https://ob.tianzhongs.ml/0018_%E4%BF%AE%E6%94%B9root%E5%AF%86%E7%A0%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0018_%E4%BF%AE%E6%94%B9root%E5%AF%86%E7%A0%81/</guid><description>0018_修改root密码 方法1： 用SET PASSWORD命令 首先登录MySQL。 格式：mysql&amp;gt; set password for 用户名@localhost = password(&amp;lsquo;新密码&amp;rsquo;); 例子：mysql&amp;gt; set password for root@localhost = password(&amp;lsquo;123&amp;rsquo;);
方法2：用mysqladmin 格式：mysqladmin -u用户名 -p旧密码 password 新密码 例子：mysqladmin -uroot -p123456 password 123</description></item><item><title>001_JDK、JRE、JVM的关系</title><link>https://ob.tianzhongs.ml/001_JDKJREJVM%E7%9A%84%E5%85%B3%E7%B3%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/001_JDKJREJVM%E7%9A%84%E5%85%B3%E7%B3%BB/</guid><description>001_JDK、JRE、JVM的关系 JDK：java开发工具包 JRE：java运行环境 JVM：java虚拟机 软件需要JRE才能跑起来 jDK包括jRE，JVM JRE包括JVM JDK以及JRE不能跨平台，不同平台需要安装不同平台的对应包 Java程序最终运行在JVM上 java体系技术的分类
JavaSE：标准版 JavaEE：J企业版 JavaME：微型版</description></item><item><title>001_部署Obsidian静态知识库网站</title><link>https://ob.tianzhongs.ml/001_%E9%83%A8%E7%BD%B2Obsidian%E9%9D%99%E6%80%81%E7%9F%A5%E8%AF%86%E5%BA%93%E7%BD%91%E7%AB%99/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/001_%E9%83%A8%E7%BD%B2Obsidian%E9%9D%99%E6%80%81%E7%9F%A5%E8%AF%86%E5%BA%93%E7%BD%91%E7%AB%99/</guid><description>部署 基本结构 1 2 3 4 5 6 7 8 9 graph BT zck(子模块_笔记仓库) fckhugo(父仓库hugo分支) fckmaster(父仓库master分支)--&amp;gt;wz(你vercel部署的网站) zck.-通过推送workflows+TOKEN推送到.-&amp;gt;fckhugo fckhugo.-通过转换为gitpage的workflows+TOKEN转换到 .-&amp;gt;fckmaster 仓库设置以及部署 父仓库（用于发布仓库：fork） fork我的的ObPublish仓库，然后使用git工具克隆clone到本地。</description></item><item><title>002-查看配置信息</title><link>https://ob.tianzhongs.ml/002-%E6%9F%A5%E7%9C%8B%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/002-%E6%9F%A5%E7%9C%8B%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF/</guid><description>002-查看配置信息 1 git config --list 文件放置在~/.gitconfig 或 /etc/gitconfig 使用命令vim ~/.gitconfig可以查看和进行编辑 查看单个环境变量可以采用 git config user.name就可以只查看name变量 ![[../../asset/Pasted image 20220624132723.png]]</description></item><item><title>002_Java运行与加载</title><link>https://ob.tianzhongs.ml/002_Java%E8%BF%90%E8%A1%8C%E4%B8%8E%E5%8A%A0%E8%BD%BD/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/002_Java%E8%BF%90%E8%A1%8C%E4%B8%8E%E5%8A%A0%E8%BD%BD/</guid><description>002_Java运行与加载 [TOC]
两个阶段： 编译 javac *.java
java将源代码执行，生成JVM可以识别的字节码 源代码不能直接执行 一次编译到处运行 运行 java 类名(不要加文件后缀名)
源代码文件：.</description></item><item><title>002_知识库更新日志</title><link>https://ob.tianzhongs.ml/002_%E7%9F%A5%E8%AF%86%E5%BA%93%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/002_%E7%9F%A5%E8%AF%86%E5%BA%93%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/</guid><description>002_知识库更新日志 1 2 3 4 5 6 7 8 9 10 11 journey title 知识库更新日志 section 2022-09-30 添加药品:5:me section 2022-09-28 添加影片:5:me 添加影片模板:5:me section 2022-09-27 创建知识库目录看板:5:me 整理笔记格式:5:me 看板目录的使用:2:me</description></item><item><title>003-更新内容一般流程</title><link>https://ob.tianzhongs.ml/003-%E6%9B%B4%E6%96%B0%E5%86%85%E5%AE%B9%E4%B8%80%E8%88%AC%E6%B5%81%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/003-%E6%9B%B4%E6%96%B0%E5%86%85%E5%AE%B9%E4%B8%80%E8%88%AC%E6%B5%81%E7%A8%8B/</guid><description>003-更新内容一般流程 comments: false date created: 2022-09-25 date modified: 2022-09-25 id: layout: page tags: Git学习笔记 title: &amp;ldquo;003.更新内容一般流程&amp;rdquo; 003.更新内容一般流程 1 2 3 git add .</description></item><item><title>003_Obsidian知识库笔记相关注意事项</title><link>https://ob.tianzhongs.ml/003_Obsidian%E7%9F%A5%E8%AF%86%E5%BA%93%E7%AC%94%E8%AE%B0%E7%9B%B8%E5%85%B3%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/003_Obsidian%E7%9F%A5%E8%AF%86%E5%BA%93%E7%AC%94%E8%AE%B0%E7%9B%B8%E5%85%B3%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</guid><description>关于内容（包含title字段的yaml头） 尤其需要注意的是，在每片文章中书写一个yaml头，其中yaml头包括了title字段，用来标识这篇文章的标题，当然，如果没有也没有太大的问题，只是不能显示这个标题，但一般还是建议有一个 如果每次添加比较麻烦，你可以配合Obsidan中的Templater插件进行生成，当然，你还可以为其设置一个专属的快捷键，那会让你更“快”的。（下面放置了一个基本的Templater模板，yaml字段采用#号注释） 所有字段都可以不用，但是建议保留title字段，字段名和字段值中间采用:隔开，分号后面有一个空格，需要注意 1 2 3 4 5 6 7 8 9 --- comments: false #该字段可以不要，因为采用了gittalk的评论区，貌似已经不起作用了 date created: &amp;lt;% tp.</description></item><item><title>003_环境变量</title><link>https://ob.tianzhongs.ml/003_%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/003_%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</guid><description>003_环境变量 三种方法 win+R，运行窗口中输入sysdm.cpl 打开资源管理，右击此电脑-属性-高级系统设置-高级 搜索环境变量</description></item><item><title>004-查看历史版本</title><link>https://ob.tianzhongs.ml/004-%E6%9F%A5%E7%9C%8B%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/004-%E6%9F%A5%E7%9C%8B%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/</guid><description>004-查看历史版本 git log &amp;ndash;oneline 查看过去提交的
回退 git reset &amp;ndash;hard 版本号 git reset &amp;ndash;soft 版本号 （软回退）
git reflog 查看操作历史，用来查看自己是否成功回退</description></item><item><title>004_Yaml字段配置</title><link>https://ob.tianzhongs.ml/004_Yaml%E5%AD%97%E6%AE%B5%E9%85%8D%E7%BD%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/004_Yaml%E5%AD%97%E6%AE%B5%E9%85%8D%E7%BD%AE/</guid><description>Yaml字段配置 1 2 3 4 5 6 7 8 9 comments:falsedate created:&amp;lt;% tp.date.now() %&amp;gt;date modified:&amp;lt;% tp.date.now() %&amp;gt;id:layout:pagecategory:看板tags:&amp;lt;% tp.file.folder() %&amp;gt;title:&amp;#34;&amp;lt;% tp.</description></item><item><title>004_注释方法</title><link>https://ob.tianzhongs.ml/004_%E6%B3%A8%E9%87%8A%E6%96%B9%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/004_%E6%B3%A8%E9%87%8A%E6%96%B9%E6%B3%95/</guid><description>004_注释方法 多行注释 1 2 3 /* 注释内容 */ `` 单行注释 1 // 文档注释，用于javadoc生成文档 1 2 3 4 /** * content * content */ ``</description></item><item><title>005-代码合并的不同方式</title><link>https://ob.tianzhongs.ml/005-%E4%BB%A3%E7%A0%81%E5%90%88%E5%B9%B6%E7%9A%84%E4%B8%8D%E5%90%8C%E6%96%B9%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/005-%E4%BB%A3%E7%A0%81%E5%90%88%E5%B9%B6%E7%9A%84%E4%B8%8D%E5%90%8C%E6%96%B9%E5%BC%8F/</guid><description>005-代码合并的不同方式 强制推送 git push --force origin master
删除主机分支 git push origin --delete master
下载远程仓库与本地合并 git pull 命令用于从远程获取代码并合并本地的版本。
1 git pull &amp;lt;远程主机名&amp;gt; &amp;lt;远程分支名&amp;gt;:&amp;lt;本地分支名&amp;gt; eg:git pull origin master</description></item><item><title>005_public_class和class的区别</title><link>https://ob.tianzhongs.ml/005_public_class%E5%92%8Cclass%E7%9A%84%E5%8C%BA%E5%88%AB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/005_public_class%E5%92%8Cclass%E7%9A%84%E5%8C%BA%E5%88%AB/</guid><description>005_public_class和class的区别 一个源文件中可以定一个多个class类 定义public类名的时候，需要与源文件名一样 public类最多只能有一个，但不是必须的 只要有一个class文件的定义，就必然会生成一个class文件 ![[../../../../asset/test9.png]] 以上通过javac会生成三个class文件（T1 T2 T3)，需要进入哪个，就java哪个类</description></item><item><title>005_看板目录的使用</title><link>https://ob.tianzhongs.ml/005_%E7%9C%8B%E6%9D%BF%E7%9B%AE%E5%BD%95%E7%9A%84%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/005_%E7%9C%8B%E6%9D%BF%E7%9B%AE%E5%BD%95%E7%9A%84%E4%BD%BF%E7%94%A8/</guid><description>005_看板目录的使用 为了能够实现知识库的目录使用，所以使用插件的方式，去进行了目录的生成。
生成 下载obsidian的看板（kanban）插件， ，需要注意的是看板的makrodwn语法格式，除了看板的yaml头以及末尾，内容部分如图，是根据##来判断集合的 1 2 3 4 5 6 7 ## set - [ ] [[001_部署Obsidian静态知识库网站]] - [ ] [[002_知识库更新日志]] - [ ] [[003_Obsidian知识库笔记相关注意事项]] - [ ] [[004_Yaml字段配置]] - [ ] [[005_看板目录的使用]] 生成目录 采用java命令或者是quicker的动作，生成你需要生成的文件夹下面的目录，然后通过vscode之类的编辑工具，将额外的部分替换成标准的kanban的语法格式 新建一个看板，将目录的内容复制进去就OK了 因为如果全部目录在一个文件中，就会显得很复杂，所以我采用的还是树层结构，一是方便能够之后再创建文件的时候直接在看板视图中新建笔记，二是为了能够有更好的层次结构</description></item><item><title>006-克隆仓库</title><link>https://ob.tianzhongs.ml/006-%E5%85%8B%E9%9A%86%E4%BB%93%E5%BA%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/006-%E5%85%8B%E9%9A%86%E4%BB%93%E5%BA%93/</guid><description>006-克隆仓库 强制推送 git push --force origin master
删除主机分支 git push origin --delete master
下载远程仓库与本地合并 git pull 命令用于从远程获取代码并合并本地的版本。
1 git pull &amp;lt;远程主机名&amp;gt; &amp;lt;远程分支名&amp;gt;:&amp;lt;本地分支名&amp;gt; eg:git pull origin master</description></item><item><title>006_搭建书架教程</title><link>https://ob.tianzhongs.ml/006_%E6%90%AD%E5%BB%BA%E4%B9%A6%E6%9E%B6%E6%95%99%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/006_%E6%90%AD%E5%BB%BA%E4%B9%A6%E6%9E%B6%E6%95%99%E7%A8%8B/</guid><description>006_搭建书架教程 相关 豆瓣图书 准备工具 相关工具资料 Banners Dataview QuickAdd Style Settings Templater 步骤 页面 建立相应文件夹，将对应的文件移到相应文件夹里 模板文件夹 书架文件夹 修改个人css，头部信息隐藏 user.</description></item><item><title>007_obsidian相关</title><link>https://ob.tianzhongs.ml/007_obsidian%E7%9B%B8%E5%85%B3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/007_obsidian%E7%9B%B8%E5%85%B3/</guid><description>007_obsidian相关 内容 URL callout https://zhuanlan.zhihu.com/p/494647464 https://help.obsidian.md/How+to/Use+callouts [templater文档 ] ( https://silentvoid13.github.io/Templater/internal-functions/internal-modules/date-module.html) [dataview 文档] ( https://blacksmithgu.</description></item><item><title>010_符号定义</title><link>https://ob.tianzhongs.ml/010_%E7%AC%A6%E5%8F%B7%E5%AE%9A%E4%B9%89/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/010_%E7%AC%A6%E5%8F%B7%E5%AE%9A%E4%B9%89/</guid><description>010_符号定义 标识符 程序员有权利自己命名的单词 通常用于设置方法名、接口名、常量名、等等 一般采用驼峰命名 StudentName
关键字 具有特殊含义的单词，比如Public, static ![[Pasted image 20220623184204.png]]</description></item><item><title>011_javadoc的使用</title><link>https://ob.tianzhongs.ml/011_javadoc%E7%9A%84%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/011_javadoc%E7%9A%84%E4%BD%BF%E7%94%A8/</guid><description>011_javadoc的使用 先在源文件中进行javadoc注释
![](asset/Pasted image 20220623190413.png)
使用命令javadoc执行生成文档 命令格式为
1 javadoc -d 生成文档放入的目录 -附件参数（比如作者author等等） java源文件 !</description></item><item><title>012_不同数据数类型占用大小</title><link>https://ob.tianzhongs.ml/012_%E4%B8%8D%E5%90%8C%E6%95%B0%E6%8D%AE%E6%95%B0%E7%B1%BB%E5%9E%8B%E5%8D%A0%E7%94%A8%E5%A4%A7%E5%B0%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/012_%E4%B8%8D%E5%90%8C%E6%95%B0%E6%8D%AE%E6%95%B0%E7%B1%BB%E5%9E%8B%E5%8D%A0%E7%94%A8%E5%A4%A7%E5%B0%8F/</guid><description>012_不同数据数类型占用大小 类型 占用字节数量 byte 1 short 2 int 4 long 8 &amp;ndash; &amp;ndash; float 4 doubl 8 boolean 1 char 2</description></item><item><title>013_接收键盘输入</title><link>https://ob.tianzhongs.ml/013_%E6%8E%A5%E6%94%B6%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/013_%E6%8E%A5%E6%94%B6%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5/</guid><description>013_接收键盘输入 接收方法 导包方式 1 import java.util.Scanner; `` 定义键盘扫描对象 1 2 3 4 5 6 7 Scanner s=new Scanner(System.</description></item><item><title>014_方法的调用</title><link>https://ob.tianzhongs.ml/014_%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/014_%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8/</guid><description>014_方法的调用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class Tmp { public static void main(String[] args) { Dayin.</description></item><item><title>015_break和return的区别</title><link>https://ob.tianzhongs.ml/015_break%E5%92%8Creturn%E7%9A%84%E5%8C%BA%E5%88%AB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/015_break%E5%92%8Creturn%E7%9A%84%E5%8C%BA%E5%88%AB/</guid><description>015_break和return的区别 break用于停止循环和switch return用于返回一个方法的返回值，用即停止这个方法，不会执行后面的语句
return 不负责运行程序，只负责讲道理。对于不能百分之百能够返回值的方法，都会编译错误</description></item><item><title>016_方法执行时内存变化</title><link>https://ob.tianzhongs.ml/016_%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E5%8F%98%E5%8C%96/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/016_%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E5%8F%98%E5%8C%96/</guid><description>016_方法执行时内存变化 基本 局部变量 只在方法体重有效，方法借宿之后，局部变量就释放了。局部变量一般在循环中或者方法函数中。 JVM中有三块主要的内存：栈内存、堆内存、方法区内存 堆
栈 栈：方法函数调用的时候，方法所需要的内存在栈中进行分配。!
![[Pasted image 20220628094821.png]] 如图，由于栈是先进后出，所以在依次嵌套的方法函数调用的时候，最先调用的函数，最后结束，符合栈的先进后出
调用的时候在栈中分配空间，叫压栈push 结束的时候，内存释放，叫弹栈pop</description></item><item><title>017_方法重载overload</title><link>https://ob.tianzhongs.ml/017_%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BDoverload/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/017_%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BDoverload/</guid><description>017_方法重载overload 用途 主要用在多个具有相似功能的方法函数中 通过将方法函数名称设置为相同，由java自己通过参数列表去判断执行具体的哪一个方法 让代码更加美观
执行重载的条件 方法名称相同 参数列表不同 （也就是形参列表） 参数的个数不同 参数的顺序不同 参数的****不同
只要能够让java编译器能够区分具体执行哪个方法的参数列表就行</description></item><item><title>021_递归</title><link>https://ob.tianzhongs.ml/021_%E9%80%92%E5%BD%92/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/021_%E9%80%92%E5%BD%92/</guid><description>021_递归 递归方法必须有结束条件，否则就会栈溢出错误，因为没有结束的条件，递归会一直不断地执行新的自己的方法，导致栈溢出。 递归有结束条件，但也会发生栈溢出，因为递归太深了，自身的栈内存不够用了，一直不断地压栈。 递归不断的循环，可能会导致JVM死掉，非常耗费内存 能用for或者while替换，尽量不用递归 书写思路 如何进入循环的，比如阶乘，是根据此一个值去乘以-1之后的方法，然后再加上自己自己本身，sum(n-1)+1 更重要的是停止方法的条件，如何将自己停止，一般是需要返回值，特殊的条件是什么样的，返回什么值。 1 2 3 4 5 if(a!=0) { sum(a); } `` 如果栈溢出怎么解决</description></item><item><title>022_面向对象和面向过程</title><link>https://ob.tianzhongs.ml/022_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/022_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/</guid><description>022_面向对象和面向过程 常见语言 C是面向过程 C++是一般面向过程，一般面向对象 java是完全面向对象
面向过程 面向过程注重步骤，注重实现这个功能的因果关系，每一步之间的因果关系，联系形成子模块，耦合度高，扩展能力就差 对于小型项目，面向过程方便直接开发，效率高，快速开发 面向对象 面向对象符合人类的思维方式，将世界分割成不同的单元形成驱动，然后驱动各个对象，形成一个系统 耦合度低，扩展能力强 三大特征：封装 继承 多态 ^sandatezheng 有了封装才能说继承，有了继承，才能说多态 ^c344fe 当我们采用面向对象的方式贯穿系统，需要 OOA 面向对象分析 OOD 面向对象设计 OOP 面向对象编程</description></item><item><title>023_对象和类</title><link>https://ob.tianzhongs.ml/023_%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/023_%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/</guid><description>023_对象和类 简要 类是抽象的概念，好像一个模板 对象是一个实际存在的个体，对象的另一个名称就是**“实例”** 通过类创建对象的过程，称为**“实例化”** 根据多个对象的共同属性抽取形成的概念，叫做**“抽象”**
1 2 3 4 5 graph LR l1(对象) l2(类) l1--抽象--&amp;gt;l2 l2--实例化--&amp;gt;l1 举例 eg</description></item><item><title>024_对象的创建</title><link>https://ob.tianzhongs.ml/024_%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/024_%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA/</guid><description>024_对象的创建 创建对象 通过new来创建一个对象 对象存储在**“堆”**当中
堆内存中存储对象，以及对象的实例变量 实例变量就是对象变量，也就是对象的属性，例如student.name
局部变量存储在栈内存中
1 类名 变量名=new 类名(); Java中所有的类，都是一个数据类型，且都是引用数据类型 一般在进行调用的时候，是调用的对象的地址，而不是对象本身。 比如 在Student s=new Student();中，进行调用s的时候，是对其s的对象地址进行调用，而不是对象本身，所以类都是引用数据类型的。</description></item><item><title>025_空指针异常</title><link>https://ob.tianzhongs.ml/025_%E7%A9%BA%E6%8C%87%E9%92%88%E5%BC%82%E5%B8%B8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/025_%E7%A9%BA%E6%8C%87%E9%92%88%E5%BC%82%E5%B8%B8/</guid><description>025_空指针异常 基本 “空引用”访问实例（对象相关）的数据，都会出现空指针异常。 当一个java对象没有任何的引用指向该对象时，垃圾回收期GC就会将该垃圾数据释放回收掉。 垃圾回收主要针对与堆内存的数据进行回收
举例 定义一个垃圾类，创建垃圾对象l1，对l1进行引用置空，出现空指针异常
创建类Laji 1 2 3 4 5 package a001对象的创建; public class Laji { int id; String name; } `` 创建垃圾对象l1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 package a001对象的创建; public class LajiTest { public static void main(String[] args) { Laji l1=new Laji(); l1.</description></item><item><title>026_方法调用时的参数传递</title><link>https://ob.tianzhongs.ml/026_%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E6%97%B6%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/026_%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E6%97%B6%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/</guid><description>026_方法调用时的参数传递 形式参数 1 2 3 4 5 6 7 8 9 10 11 public class Cscd { public static void main(String[] args) { int i=10; add(i); System.</description></item><item><title>031-构造方法</title><link>https://ob.tianzhongs.ml/031-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/031-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/</guid><description>031-构造方法 概念 构造方法的作用：
构造方法就是用来构造对象，并对对象属性进行初始化赋值的特殊方法
比较特殊的方法 构造方法是一个比较特殊的方法，通过构造方法可以完成对象的创建，以及实例变量的初始化 作用相当于使用函数去创建对象，同时对实例化对象进行赋值 方法就类似于函数，不要在其中添加class 构造方法可以有多个，当参数列表不同，支持方法重载 格式 构造方法语法格式：
1 2 3 修饰符列表 方法名(形式参数){ 方法体; } 使用new 方法名进行调用</description></item><item><title>031_构造方法</title><link>https://ob.tianzhongs.ml/031_%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/031_%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/</guid><description>031_构造方法 概念 构造方法的作用：
构造方法就是用来构造对象，并对对象属性进行初始化赋值的特殊方法
比较特殊的方法 构造方法是一个比较特殊的方法，通过构造方法可以完成对象的创建，以及实例变量的初始化 作用相当于使用函数去创建对象，同时对实例化对象进行赋值 方法就类似于函数，不要在其中添加class 构造方法可以有多个，当参数列表不同，支持方法重载 格式 构造方法语法格式：
1 2 3 修饰符列表 方法名(形式参数){ 方法体; } 使用new 方法名进行调用</description></item><item><title>032_注意事项</title><link>https://ob.tianzhongs.ml/032_%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/032_%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</guid><description>032_注意事项 注意 修饰符列表目前统一使用public,不要使用public static 构造方法名与类名保持一致 构造方法不需要指定返回值类型 当一个类中手动的提供了有参数的构造方法，那么系统就不再提供无参数的构造方法 5.当一个类中没有提供任何构造方法，系统会提供一个默认的构造方法 1 System.out.println(new Student()); `` 输出显示 1 a003构造方法.Student@7de26db8 `` 没有定义student()构造方法，但是依旧会有默认的缺省构造器可以使用 ^2dca02 在编译的时候，如果构造方法的名称和类名不一致，那么编译器会认为其是普通方法，但是没有写返回值，会报错。 [!</description></item><item><title>033_构造方法举例</title><link>https://ob.tianzhongs.ml/033_%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E4%B8%BE%E4%BE%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/033_%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E4%B8%BE%E4%BE%8B/</guid><description>033_构造方法举例 构造方法的作用
创建对象，同时将对象的属性进行赋值
对无参数构造方法进行赋值 user类
1 2 3 4 5 public class User { int id; String name; int age; } id,age的默认值是0，name的默认值是null，</description></item><item><title>034_夫妻结婚</title><link>https://ob.tianzhongs.ml/034_%E5%A4%AB%E5%A6%BB%E7%BB%93%E5%A9%9A/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/034_%E5%A4%AB%E5%A6%BB%E7%BB%93%E5%A9%9A/</guid><description>034_夫妻结婚 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 package day14作业; public class Handw { public static void main(String[] args) { // 创建丈夫对象蔡徐坤 Husband cxk = new Husband(&amp;#34;1234&amp;#34;,&amp;#34;蔡徐坤&amp;#34;,&amp;#34;1998年8月2日&amp;#34;,null); // 创建妻子对象篮球 Wife basketball=new Wife(&amp;#34;1235&amp;#34;,&amp;#34;篮球&amp;#34;,&amp;#34;1928年5月2日&amp;#34;,null); //开始结婚 cxk.</description></item><item><title>041_封装</title><link>https://ob.tianzhongs.ml/041_%E5%B0%81%E8%A3%85/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/041_%E5%B0%81%E8%A3%85/</guid><description>041_封装 [[../02基本/022.面向对象和面向过程#^c344fe|封装]]的作用 [!作用] 保证内部结构的安全性 屏蔽复杂，暴露简单
怎么进行封装 ^zmfg 属性私有化private 创建简单的访问入口:对外提供公开的set和get方法作为实例方法,一个属性对外提供两个实例方法（get和set），同时可以对其的set实例方法设立关卡，满足什么条件才set。 ^cjjddfwrk get方法： java public 返回值类型 get+属性名首字母大写(无参数){ return xxx; } set方法： java public void set+属性名首字母大写(类型 xxx){ this.</description></item><item><title>042_实例方法</title><link>https://ob.tianzhongs.ml/042_%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/042_%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95/</guid><description>042_实例方法 [!概要] 与实例相关的有：实例变量，实例方法 实例变量就是对象变量，实例方法就是对象方法 实例相关的都需要先new对象，通过引用的方式进行访问 实例变量相当于一个对象，需要我们自己创建一个对象实例来对其进行引用，才能够使用。每次创建一个实例变量，JVM就会为实例变量分配内存 也就是实例方法必须通过实例对象.去进行调用
语法格式 相当于普通方法去掉static修饰符
1 2 3 public void 方法名(){ 方法体 } 举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class Shilifangfa { public static void main(String[] args) { // 在进行普通方法调用时，通过.</description></item><item><title>043_书写格式</title><link>https://ob.tianzhongs.ml/043_%E4%B9%A6%E5%86%99%E6%A0%BC%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/043_%E4%B9%A6%E5%86%99%E6%A0%BC%E5%BC%8F/</guid><description>043_书写格式 Java的封装[[041b-封装#^zmfg|格式]]举例 对java对象的属性进行私有化 1 2 3 4 pulic class Person{ private int age;//private私有化修饰符 private String name; } [[041b-封装#^e24f40|对外提供get和set公开入口]] 1 2 3 4 5 6 7 8 9 10 11 pulic class Person{ private int age;//private私有化修饰符 public int getAge(){//获取，需要返回值 return age; } public void setAge(int nianLing){//修改，不需要返回值 age=nianLing; } } 以上的get和set方法都没有加static修饰符，因为其为实例方法，需要依赖于生成的对象，没有对象，就不知道设置谁的属性了，这样才符合规律。没有person对象，设置年龄没用。</description></item><item><title>0512_static变量</title><link>https://ob.tianzhongs.ml/0512_static%E5%8F%98%E9%87%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0512_static%E5%8F%98%E9%87%8F/</guid><description>0512_static变量 不声明static时 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public class a02Chinese { public static void main(String[] args) { Chinese c1=new Chinese(&amp;#34;521&amp;#34;,&amp;#34;张三&amp;#34;,&amp;#34;Chinese&amp;#34;); Chinese c2=new Chinese(&amp;#34;522&amp;#34;,&amp;#34;李四&amp;#34;,&amp;#34;Chinese&amp;#34;); //输出 System.</description></item><item><title>0514_实例代码块</title><link>https://ob.tianzhongs.ml/0514_%E5%AE%9E%E4%BE%8B%E4%BB%A3%E7%A0%81%E5%9D%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0514_%E5%AE%9E%E4%BE%8B%E4%BB%A3%E7%A0%81%E5%9D%97/</guid><description>0514_实例代码块 语法格式 1 2 3 { java 语句; } 作用 [!作用] sun公司为程序员准备的特殊时机：对象创建时机； 实例代码块，会在构造方法前执行，只要构造方法创建对象，就会在对象创建之前执行实例代码块； 如果每个构造方法中都有相同的部分，可以将相同的部分放在实例代码块中，这样每次执行new对象的时候，都可以通过实例代码块执行内容。
eg 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package a005StaticAndthis; public class a05ShiliDaimakuai { public static void main(String[] args) { System.</description></item><item><title>0515_静态方法和实例方法</title><link>https://ob.tianzhongs.ml/0515_%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0515_%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95/</guid><description>0515_静态方法和实例方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 public class a01Statictest { public static void main(String[] args) { daYin1();//直接调用 // 实例方法 a01Statictest dd = new a01Statictest();//创建该类的实例化对象 dd.</description></item><item><title>0516_空指针访问静态不会空指针</title><link>https://ob.tianzhongs.ml/0516_%E7%A9%BA%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E9%9D%99%E6%80%81%E4%B8%8D%E4%BC%9A%E7%A9%BA%E6%8C%87%E9%92%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0516_%E7%A9%BA%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E9%9D%99%E6%80%81%E4%B8%8D%E4%BC%9A%E7%A9%BA%E6%8C%87%E9%92%88/</guid><description>0516_空指针访问静态不会空指针 ![[../../../../../asset/Pasted image 20220702164751.png]] 即使将对象置空，引用静态变量，依旧不会出现空指针异常， 因为静态变量不依赖于对象的建立，而是类级别的，类相关的</description></item><item><title>0517_实例方法的调用</title><link>https://ob.tianzhongs.ml/0517_%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0517_%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8/</guid><description>0517_实例方法的调用 调用实例方法的原则 类=属性+方法
实例变量，需要对象 所以当方法需要由对象触发，就需要定义为实例方法
相关 ![[042b-实例方法]]</description></item><item><title>0518_不同代码块执行顺序</title><link>https://ob.tianzhongs.ml/0518_%E4%B8%8D%E5%90%8C%E4%BB%A3%E7%A0%81%E5%9D%97%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0518_%E4%B8%8D%E5%90%8C%E4%BB%A3%E7%A0%81%E5%9D%97%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</guid><description>0518_不同代码块执行顺序 代码
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package a005StaticAndthis; public class A06DaimaShunxu { // 静态代码块 static{ System.</description></item><item><title>051_static</title><link>https://ob.tianzhongs.ml/051_static/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/051_static/</guid><description>051_static static翻译“静态” static修饰的都是类相关的，class级别的 static修饰的，都可以直接采用类名.进行访问 static修饰的变量：静态变量 static修饰的方法：[[052.静态方法和实例方法|静态方法]] [!变量的分类] 根据声明的位置分为 &amp;gt;1. 方法体中的变量：局部变量 &amp;gt;2. 方法体外的变量：成员变量 &amp;gt;成员变量又分为： &amp;gt;实例变量：需要通过[[../../02基本/024.对象的创建|创建对象]]来进行调用 &amp;gt;静态变量：可以直接使用，没有空指针异常的情况发生</description></item><item><title>051_静态代码块</title><link>https://ob.tianzhongs.ml/0512_%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0512_%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97/</guid><description>051_静态代码块 执行 类加载时执行，在main方法前执行 只执行一次 常常用于记录程序类加载到JVM中的日志 自上而下执行 允许多个静态代码块 是一个特殊时机：类加载时机 语法格式 1 2 3 4 static{ java 语句; java 语句; } eg !</description></item><item><title>0521_this的内存结构</title><link>https://ob.tianzhongs.ml/0521_this%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0521_this%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</guid><description>0521_this的内存结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package a005StaticAndthis.</description></item><item><title>0522_this总结</title><link>https://ob.tianzhongs.ml/0522_this%E6%80%BB%E7%BB%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0522_this%E6%80%BB%E7%BB%93/</guid><description>0522_this总结 基本 this用于在实例对象中，表示当前对象
this不能用在静态方法中，因为静态方法是类级别的，不是对象级别的
静态方法中不存在当前对象，采用类.的方式使用静态方法
主要作用 在实例方法或者构造方法中 区分实例变量与局部变量 在构造方法中，可以 通过this在无参数构造方法去调用本类的有参数构造方法</description></item><item><title>0523_this例子</title><link>https://ob.tianzhongs.ml/0523_this%E4%BE%8B%E5%AD%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0523_this%E4%BE%8B%E5%AD%90/</guid><description>0523_this例子 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 package day15作业; public class Homework01 { public static void main(String[] args) { Book book1 = new Book(&amp;#34;高三数学&amp;#34;,126); System.</description></item><item><title>0524_变量的分布</title><link>https://ob.tianzhongs.ml/0524_%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%86%E5%B8%83/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0524_%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%86%E5%B8%83/</guid><description>0524_变量的分布 局部变量、实例变量、静态变量在内存中的分配</description></item><item><title>0525_this无参调有参构造方法</title><link>https://ob.tianzhongs.ml/0525_this%E6%97%A0%E5%8F%82%E8%B0%83%E6%9C%89%E5%8F%82%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0525_this%E6%97%A0%E5%8F%82%E8%B0%83%E6%9C%89%E5%8F%82%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/</guid><description>0525_this无参调有参构造方法 1 2 3 4 5 6 7 8 9 10 11 12 public Date(){ // year=1982; // month=12; // day=3; //等同于通过this去调用这个对象的有参数构造方法 this(1982,12,3); } public Date(int year,int month,int day){ this.</description></item><item><title>0525_方法定义static</title><link>https://ob.tianzhongs.ml/0525_%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89static/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0525_%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89static/</guid><description>0525_方法定义static ```java public static void jiecheng(int a) {  int aa=1;
 for (int i = 1; i &amp;lt;= a; i++) {</description></item><item><title>0526_this的内存结构</title><link>https://ob.tianzhongs.ml/0526_this%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0526_this%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</guid><description>0526_this的内存结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package a005StaticAndthis.</description></item><item><title>0529_变量的分布</title><link>https://ob.tianzhongs.ml/0529_%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%86%E5%B8%83/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0529_%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%86%E5%B8%83/</guid><description>0529_变量的分布 局部变量、实例变量、静态变量在内存中的分配</description></item><item><title>052_静态方法和实例方法</title><link>https://ob.tianzhongs.ml/052_%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/052_%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95/</guid><description>052_静态方法和实例方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 public class a01Statictest { public static void main(String[] args) { daYin1();//直接调用 // 实例方法 a01Statictest dd = new a01Statictest();//创建该类的实例化对象 dd.</description></item><item><title>053_空指针访问静态不会空指针</title><link>https://ob.tianzhongs.ml/053_%E7%A9%BA%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E9%9D%99%E6%80%81%E4%B8%8D%E4%BC%9A%E7%A9%BA%E6%8C%87%E9%92%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/053_%E7%A9%BA%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E9%9D%99%E6%80%81%E4%B8%8D%E4%BC%9A%E7%A9%BA%E6%8C%87%E9%92%88/</guid><description>053_空指针访问静态不会空指针 ![[../../../../../asset/Pasted image 20220702164751.png]] 即使将对象置空，引用静态变量，依旧不会出现空指针异常， 因为静态变量不依赖于对象的建立，而是类级别的，类相关的</description></item><item><title>054_实例方法的调用</title><link>https://ob.tianzhongs.ml/054_%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/054_%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8/</guid><description>054_实例方法的调用 调用实例方法的原则 类=属性+方法
实例变量，需要对象 所以当方法需要由对象触发，就需要定义为实例方法
相关 ![[042b-实例方法]]</description></item><item><title>055_不同代码块执行顺序</title><link>https://ob.tianzhongs.ml/055_%E4%B8%8D%E5%90%8C%E4%BB%A3%E7%A0%81%E5%9D%97%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/055_%E4%B8%8D%E5%90%8C%E4%BB%A3%E7%A0%81%E5%9D%97%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</guid><description>055_不同代码块执行顺序 代码
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package a005StaticAndthis; public class A06DaimaShunxu { // 静态代码块 static{ System.</description></item><item><title>061_继承基本概念</title><link>https://ob.tianzhongs.ml/061_%E7%BB%A7%E6%89%BF%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/061_%E7%BB%A7%E6%89%BF%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</guid><description>061_继承基本概念 重要 除了构造方法，其余的子类都继承，包括实例方法和get set方法都可以继承 在进行重新构造构造器的时候，可以通过super关键字快速完成，this.xx=xxx;的语句，比如
1 2 3 4 5 class A extends B{ public A(String name,int age){ super(name,age); } } 需要注意的是，super语句只能放在构造器内部的第一行</description></item><item><title>062_super关键字</title><link>https://ob.tianzhongs.ml/062_super%E5%85%B3%E9%94%AE%E5%AD%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/062_super%E5%85%B3%E9%94%AE%E5%AD%97/</guid><description>062_super关键字 在继承关系中，由于在子类的构造方法中，第一条语句默认为调用父类的无参构造方法（即默认为 super();，一般这行代码省略了）。
简单的来说，要想使用父类的那个构造方法，就super它的形参按顺序放进来
1 2 3 4 5 6 7 8 9 public class Person { public Person(String name, int age) { } public Person(String name, int age, String sex) { } } z</description></item><item><title>063_什么时候可以使用继承</title><link>https://ob.tianzhongs.ml/063_%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E7%BB%A7%E6%89%BF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/063_%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E7%BB%A7%E6%89%BF/</guid><description>063_什么时候可以使用继承 凡是可以用“is a”来描述的，都可以考虑采用继承
eg 猪是一个动物 信用卡是一个银行账户 [!注意] 即使两个类中有相同的代码，也不一定要采用继承 比如客户和产品中都有名字，不适合继承的，一是因为不符合常理，难以理解两者的关系，二是因为如果后续在父类中添加字段等等，那么子类也会受到奇怪的牵连</description></item><item><title>0711_方法覆盖override</title><link>https://ob.tianzhongs.ml/0711_%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96override/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0711_%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96override/</guid><description>0711_方法覆盖override 什么时候使用 子类继承父类之后，当继承的方法无法满足当前子类的业务需求，子类有权利对这个方法进行重新编写，进行方法覆盖。override
语法格式 编写的结论 两个类必须要有继承关系 重写之后的方法必须满足的条件**（除了修饰符列表可以不同，其他必须完全一样）** 相同的返回值类型 相同的方法名称 相同的形式参数列表 子类的访问权限不能更低，可以更高，比如父类是public,那么子类就不能是protected受保护的，但是相反则可以 覆盖之后的方法不能比之前的方法抛出更多的异常，可以更少或者没有。 注意事项 方法覆盖只针对方法，和属性（实例对象的属性，就是你定义的那几个字段）无关 私有方法（private）无法覆盖 构造方法不能继承，所以构造方法不能被覆盖 方法覆盖只能针对实例方法，静态方法无法覆盖 相关： 017.</description></item><item><title>0712_覆盖eg</title><link>https://ob.tianzhongs.ml/0712_%E8%A6%86%E7%9B%96eg/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0712_%E8%A6%86%E7%9B%96eg/</guid><description>0712_覆盖eg 举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 package a007方法覆盖和多态; public class Dongwu1 { public static void main(String[] args) { System.</description></item><item><title>0713_方法覆盖经典例子</title><link>https://ob.tianzhongs.ml/0713_%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96%E7%BB%8F%E5%85%B8%E4%BE%8B%E5%AD%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0713_%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96%E7%BB%8F%E5%85%B8%E4%BE%8B%E5%AD%90/</guid><description>0713_方法覆盖经典例子 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 package a007方法覆盖和多态; public class Speak { public static void main(String[] args) { People p1=new People(&amp;#34;人&amp;#34;); p1.</description></item><item><title>0714_例子toString方法覆盖</title><link>https://ob.tianzhongs.ml/0714_%E4%BE%8B%E5%AD%90toString%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0714_%E4%BE%8B%E5%AD%90toString%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96/</guid><description>0714_例子toString方法覆盖 要求 定义一个日期类 输出日期对象的时候，直接输出日期对象的值
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 public class ToString1 { public static void main(String[] args) { Date d1=new Date(2019, 12, 2); System.</description></item><item><title>0721_多态</title><link>https://ob.tianzhongs.ml/0721_%E5%A4%9A%E6%80%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0721_%E5%A4%9A%E6%80%81/</guid><description>0721_多态 基本概念 多动态，就是多种形态，多种状态。
简单的来说，就是java程序在 编译阶段 和执行阶段 所真正参与的是不同的对象，所以叫多态。 父类型引用执行子类型对象，包括编译阶段和执行阶段 编译阶段 ：静态绑定父类的方法（方法区） ^jtbd 执行阶段：动态绑定子类的方法（堆内存）</description></item><item><title>0722_多态举例</title><link>https://ob.tianzhongs.ml/0722_%E5%A4%9A%E6%80%81%E4%B8%BE%E4%BE%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0722_%E5%A4%9A%E6%80%81%E4%B8%BE%E4%BE%8B/</guid><description>0722_多态举例 eg 定义Animal、Cat、Dog类用来定义对象 动物
1 2 3 4 5 6 7 package a007方法覆盖和多态; public class Animal { public void move(){ System.</description></item><item><title>0723_向下转型</title><link>https://ob.tianzhongs.ml/0723_%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0723_%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B/</guid><description>0723_向下转型 向上转型和向下转型 java中允许 向上转型，也允许向下转型（不要说自动类型转换和强制类型转换，那是基本变量类型转换，上图只是为了能够更好地理解） 不论是向上转型还是向下转型，都必须有继承关系（没有继承关系，那么不能转型） 向上转型： Anlimal a=new Cat() 向下转型：Cat b=(Cat)a
什么时候使用向下转型 不要随便做强制转换
当你访问的是一个父类中没有，子类对象中所“特有”的方法，此时必须向下转型 当然，你也可以在父类中补充这个方法，那样就是方法覆盖了，就不用向下转型了 原因是 虽然aa3运行是猫对象，但是由于底层是狗对象，而且Cat和Dog两个之间没有相互继承关系，所以无法向下转型，抛出异常，可以通过if判断和instanceof判断来避免这种错误 eg 在Cat类中增加猫抓老鼠的方法 1 2 3 public void catchMouse(){ System.</description></item><item><title>0724_instanceof运算符</title><link>https://ob.tianzhongs.ml/0724_instanceof%E8%BF%90%E7%AE%97%E7%AC%A6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0724_instanceof%E8%BF%90%E7%AE%97%E7%AC%A6/</guid><description>0724_instanceof运算符 [!作用] 用于判断 某对象实例 是否动态指向 一个类 ，或者由一个类直接或间接创建的
重要结论 左边是实例对象，右边是类 只要左边的实际对象 是右边类的 继承树 以下的类或刚好一样的类，就是true 判断 判断方法： 可以通过判断是否与实例对象的底层对象在 同一底层类 上进行判断 实例对象 “蔡徐坤” 是否是某个类 直接或者间接创建的，比如 person cxk=new chinse，“人类”下有“中国人”和“美国人”两个子类，，那么 蔡徐坤 instanceof 中国人或者蔡徐坤 instanceof 人就为true，而蔡徐坤 instanceof 美国人就为false !</description></item><item><title>0725_多态例子a主人喂宠物</title><link>https://ob.tianzhongs.ml/0725_%E5%A4%9A%E6%80%81%E4%BE%8B%E5%AD%90a%E4%B8%BB%E4%BA%BA%E5%96%82%E5%AE%A0%E7%89%A9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0725_%E5%A4%9A%E6%80%81%E4%BE%8B%E5%AD%90a%E4%B8%BB%E4%BA%BA%E5%96%82%E5%AE%A0%E7%89%A9/</guid><description>0725_多态例子a主人喂宠物 代码
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 package a007方法覆盖和多态.</description></item><item><title>0726_宠物养猫优化</title><link>https://ob.tianzhongs.ml/0726_%E5%AE%A0%E7%89%A9%E5%85%BB%E7%8C%AB%E4%BC%98%E5%8C%96/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/0726_%E5%AE%A0%E7%89%A9%E5%85%BB%E7%8C%AB%E4%BC%98%E5%8C%96/</guid><description>0726_宠物养猫优化 相关 类继承：猫狗与宠物之间的继承关系 向下继承：向下继承，如果需要调用子类独有的方法（pig的睡觉方法，在pet中没有），需要强制转换类型，前提是两个类继承关系，且[[077.向下转型|向下转型]]才必须强制转型 独有实例方法的调用 向上继承的创建对象：Pet p2=new Pig(); 多态：宠物的多个具体事物，有不同的吃的方法，主人通过调用喂养方法，去访问宠物的吃 方法覆盖override：由于子类有不同的eat方法，在实际调用的时候，会访问其具体对象的eat方法 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 package a007方法覆盖和多态.</description></item><item><title>081_静态方法不存在方法覆盖</title><link>https://ob.tianzhongs.ml/081_%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%8D%E5%AD%98%E5%9C%A8%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/081_%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%8D%E5%AD%98%E5%9C%A8%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96/</guid><description>081_静态方法不存在方法覆盖 对象之间，有了继承之后，才有方法的覆盖和多态。 方法覆盖只是针对于“实例方法”，“静态方法”没有方法意义，因为其与对象无关，只和类有关。
code
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 package a008遗留问题; import a007方法覆盖和多态.</description></item><item><title>082_私有方法无法覆盖</title><link>https://ob.tianzhongs.ml/082_%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95%E6%97%A0%E6%B3%95%E8%A6%86%E7%9B%96/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/082_%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95%E6%97%A0%E6%B3%95%E8%A6%86%E7%9B%96/</guid><description>082_私有方法无法覆盖 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package a008遗留问题; public class A { private void do(){ System.</description></item><item><title>083_关于方法覆盖时的返回值类型</title><link>https://ob.tianzhongs.ml/083_%E5%85%B3%E4%BA%8E%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96%E6%97%B6%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/083_%E5%85%B3%E4%BA%8E%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96%E6%97%B6%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B/</guid><description>083_关于方法覆盖时的返回值类型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 public class OverrideTest07{ public static void main(String[] args){ // 一般重写的时候都是复制粘贴。不要动。不要改。 } } class Animal{ /* public double sum(int a, int b){ return a + b; } */ /* public long sum(int a, int b){ return a + b; } */ /* public int sum(int a, int b){ return a + b; } */ } class Cat extends Animal{ // 重写 // 错误: Cat中的sum(int,int)无法覆盖Animal中的sum(int,int) /* public int sum(int a, int b){ return a + b; } */ /* public double sum(int a, int b){ return a + b; } */ //错误: Cat中的sum(int,int)无法覆盖Animal中的sum(int,int) /* public long sum(int a, int b){ return a + b; } */ } // 父类 class MyClass1{ public Animal getAnimal(){ return null; } } // 子类 class MyClass2 extends MyClass1{ // 重写父类的方法 /* public Animal getAnimal(){ return null; } */ // 重写的时候返回值类型由Animal变成了Cat，变小了。（可以，java中允许） /* public Cat getAnimal(){ return null; } */ // 重写的时候返回值类型由Animal变成了Object。变大了。（不行，java中不允许） /* public Object getAnimal(){ return null; } */ } 结论：学习了多态之后你会发现 方法覆盖的返回值类型在基本数据类型必须一样，而在引用类型中（就是你class的那些类的对象），可以是你class的子类树上的类</description></item><item><title>091_suepr关键字</title><link>https://ob.tianzhongs.ml/091_suepr%E5%85%B3%E9%94%AE%E5%AD%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/091_suepr%E5%85%B3%E9%94%AE%E5%AD%97/</guid><description>091_suepr关键字 重要的结论： 当一个构造方法第一行：既没有this()又没有super()的话，默认会有一个super();表示通过当前子类的构造方法调用父类的无参数构造方法。所以必须保证父类的无参数构造方法是存在的。
super和this this() 通过当前的构造方法去调用“本类”中其它的构造方法 super() 通过当前的构造方法去调用“父类”中的构造方法（相当于把父类的构造方法代码部分复制过来），目的是：创建子类对象的时候，先初始化父类型特征，父类的构造方法是一定会执行的,所以object的构造方法一定会执行 由于this和super都只能出现在构造方法第一行，所以不能同时出现在一个构造方法中 都能出现在实例方法和构造方法中。 不能使用在静态方法中。 目的都是：代码复用。 super后面必须跟.，和this不同，super不保存内存地址，只是表示了父对象的一部分特征，this可以直接打印输出内存地址，而super不行，必须super.xxxx的方式使用，或者super()的方式使用。 [!super()] 表示通过子类的构造方法调用父类的构造方法。 模拟现实世界中的这种场景：要想有儿子，需要先有父亲。 父类的构造方法一定是会执行的</description></item><item><title>092_构造方法执行顺序</title><link>https://ob.tianzhongs.ml/092_%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/092_%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</guid><description>092_构造方法执行顺序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 /* 判断程序的输出结果 1 3 6 5 4 在java语言中不管是是new什么对象，最后老祖宗的Object类的无参数构造方法 一定会执行。（Object类的无参数构造方法是处于“栈顶部”） 栈顶的特点： 最后调用，但是最先执行结束。 后进先出原则。 大家要注意： 以后写代码的时候，一个类的无参数构造方法还是建议大家手动的写出来。 如果无参数构造方法丢失的话，可能会影响到“子类对象的构建”。 */ public class SuperTest02{ public static void main(String[] args){ new C(); } } /* class Object{ public Object(){ } } */ class A extends Object{ static{ System.</description></item><item><title>093_使用super调用父类方法</title><link>https://ob.tianzhongs.ml/093_%E4%BD%BF%E7%94%A8super%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E6%96%B9%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/093_%E4%BD%BF%E7%94%A8super%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E6%96%B9%E6%B3%95/</guid><description>093_使用super调用父类方法 super不仅可以调用父类的属性，还可以调用父类的方法。
super.属性名 访问父类的属性 super.方法名(实参) 访问父类的方法 super(实参) 调用父类的构造方法
eg 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 /* 判断程序的输出结果 1 3 6 5 4 在java语言中不管是是new什么对象，最后老祖宗的Object类的无参数构造方法 一定会执行。（Object类的无参数构造方法是处于“栈顶部”） 栈顶的特点： 最后调用，但是最先执行结束。 后进先出原则。 大家要注意： 以后写代码的时候，一个类的无参数构造方法还是建议大家手动的写出来。 如果无参数构造方法丢失的话，可能会影响到“子类对象的构建”。 */ public class SuperTest02{ public static void main(String[] args){ new C(); } } public static void main(String[] args){ /* Cat move!</description></item><item><title>100-方法定义static</title><link>https://ob.tianzhongs.ml/053_%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89static/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/053_%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89static/</guid><description>100-方法定义static ```java public static void jiecheng(int a) {  int aa=1;
 for (int i = 1; i &amp;lt;= a; i++) {</description></item><item><title>101_学习总结</title><link>https://ob.tianzhongs.ml/101_%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/101_%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</guid><description>101_学习总结 前序 通过大致17天的学习，学习了javase的基础，让我对java的一些基本特点或者使用有了轮廓。 接下来将要学习java进阶，所以就目前的学习做一下总结。
一、理论 在理论方面学习了
java开发工具包JDK，包括了JREJava运行环境（包括了JVM虚拟机） 学习了java程序的执行过程：源代码执行，生成字节码，JVM解释为二进制文件，交给操作系统，操作系统与硬件进行交互 基本的环境变量设置：sysdm.cpl 三种注释方法 public class和class的区别：一个文件最多一个public class，但可以有无数个class，public的class必须和文件名一致 二、铺垫 变量名定义：驼峰命名；基本的关键字50个 javadoc的基本使用：需要配合文档注释 不同数据类型所占用的字节大小：1248 4812 （byte short int long；float double boolean char） Scanner的使用，基本的导包方式（和那个python好像一样） 方法的调用：在一个类中，可以直接写想要调用的方法，如果不在一个类中，则采用：类名.</description></item><item><title>111_Idea的基本使用</title><link>https://ob.tianzhongs.ml/111_Idea%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/111_Idea%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</guid><description>111_Idea的基本使用 .1. module：模块的创建
dae的快捷键 作用 快捷键 新建class 选中文件夹 alt +insert（笔记本需要按住fn） 打开设置set ctrl+alt+s 最大窗口 ctrl+shift+F12 构造器，get、set方法 alt+insert 折叠打开代码块 alt+←或者→ 切换窗口 alt + 标号数字 提示方法的参数 ctrl + p 注释 单行注释：ctrl + / 多行注释：ctrl + shift + / 复制一行 ctrl + d 删除行 ctrl +y 纠错 alt+Enter 查看一个类的属性和方法 ctrl + F12 光标停留在红色，创建方法 alt +enter，（方法默认是private，可以修改一下）</description></item><item><title>112_java相关帮助文档</title><link>https://ob.tianzhongs.ml/112_java%E7%9B%B8%E5%85%B3%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/112_java%E7%9B%B8%E5%85%B3%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3/</guid><description>112_java相关帮助文档 [!bug]+ java帮助文档
好用的 http://www.matools.com/api/java8 英文版本 https://tool.oschina.net/apidocs/api#A 看不懂的 https://www.w3cschool.cn/java/dict 效果不错的 https://itmyhome.com/java-api/ W3c的 https://www.w3cschool.cn/java/dict UML ![[../22u异常处理/222.UML 统一建模语言]]</description></item><item><title>121_final</title><link>https://ob.tianzhongs.ml/121_final/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/121_final/</guid><description>121_final final是一个关键字，表示最终的、不可变的。 final一般用来修饰变量，方法，类
作用 final修饰的局部变量只能赋一次值（局部变量必须[[../../../../asset/Pasted image 20220712105836.png|手动赋值]]） final修饰的方法，无法被覆盖、被重写 final修饰的类，无法被继承 final修饰的实例变量，系统不负责赋默认值，需要你自己赋值，要么在定义的时候赋值，要么在构造方法中进行赋值 final上修饰的实例变量一般和static联合使用是，成为常量，存储在方法区，所有的实例公用一份。 1 public static final double PI=3.1415926; ``</description></item><item><title>122_final修饰的引用型变量</title><link>https://ob.tianzhongs.ml/122_final%E4%BF%AE%E9%A5%B0%E7%9A%84%E5%BC%95%E7%94%A8%E5%9E%8B%E5%8F%98%E9%87%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/122_final%E4%BF%AE%E9%A5%B0%E7%9A%84%E5%BC%95%E7%94%A8%E5%9E%8B%E5%8F%98%E9%87%8F/</guid><description>122_final修饰的引用型变量 实例化的对象的变量是一个引用型变量，这个变量所指向的是这个对象在堆内存中的地址 通过final对其进行修饰，那么这个引用型变量将不能再指向新的对象地址，但是通过set方法区修改这个引用型变量所指向对象的内部属性
1 2 3 4 5 6 7 8 9 10 public class FinalTest01 { public static void main(String[] args) { final User u1=new User(); u1.</description></item><item><title>123_final修饰实例变量</title><link>https://ob.tianzhongs.ml/123_final%E4%BF%AE%E9%A5%B0%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/123_final%E4%BF%AE%E9%A5%B0%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F/</guid><description>123_final修饰实例变量 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class FinalTest03 { public static void main(String[] args) { User1 u3=new User1(); System.</description></item><item><title>131_抽象类</title><link>https://ob.tianzhongs.ml/131_%E6%8A%BD%E8%B1%A1%E7%B1%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/131_%E6%8A%BD%E8%B1%A1%E7%B1%BB/</guid><description>131_抽象类 ![[../../../../asset/Pasted image 20220712170300.png]]
什么是抽象类？ 类和类之前具有共同特征，把共同特征提取出来，形成的就是抽象类。抽象类本身不存在，所以抽象类无法创建对象，无法实例化。 抽象类的数据类型 引用数据类型 抽象类是用来继承的，所以final和abstract不能结合使用 抽象类的子类可以是抽象类 抽象类无法实例化，但是可以有构造方法，这个构造方法是供子类使用的 定义的语法 1 2 3 [修饰符列表] abstract class 类名{ 类体; }</description></item><item><title>132_抽象方法</title><link>https://ob.tianzhongs.ml/132_%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/132_%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95/</guid><description>132_抽象方法 抽象方法表示没有实现的方法，没有方法体的方法 1 public abstract void doSome(); `` 抽象类不一定有抽象方法，但是抽象方法只能出现在抽象类中。 一个非抽象的类继承抽象类，必须将抽象类中的抽象方法覆盖，进行实现。（因为抽象方法只能卸载抽象类中，所以才需要这样）</description></item><item><title>133_例子</title><link>https://ob.tianzhongs.ml/133_%E4%BE%8B%E5%AD%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/133_%E4%BE%8B%E5%AD%90/</guid><description>133_例子 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class AbstractTest01 { public static void main(String[] args) { Animal c1=new Cat();//向上转型 c1.</description></item><item><title>134_面试题</title><link>https://ob.tianzhongs.ml/134_%E9%9D%A2%E8%AF%95%E9%A2%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/134_%E9%9D%A2%E8%AF%95%E9%A2%98/</guid><description>134_面试题 [!java语言中凡是没有方法体的方法都是抽象方法吗？] 错误。 Object类中的很多方法都没有方法体，都是以“；”结尾。但是他们都不是抽象方法。 比如public native int hashCode(); 这个方法底层调用了C++写的动态链接库程序，前面修饰符列表中没有abstract，有一个native，表示调用JVM本地程序</description></item><item><title>141_接口</title><link>https://ob.tianzhongs.ml/141_%E6%8E%A5%E5%8F%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/141_%E6%8E%A5%E5%8F%A3/</guid><description>141_接口 语法格式 1 2 3 [修饰符列表] interface 接口名{ } 基础语法 接口等于常量+抽象方法 接口也是一种“引用数据类型”，编译之后，也是一个class字节码文件 接口是完全抽象的（抽象类是半抽象的），也可以说接口是特殊的抽象类 接口支持继承，且支持多继承 接口中只包含两部分内容：1. 常量；2.抽象方法 接口中的所有元素都是public修饰的 public abstract可以省略不写 接口中都是抽象方法，所以不能有方法体 接口中的常量 public static final也可以省略不写 接口的使用 类和接口之间叫做实现，可以看做继承 继承用extens关键字完成 实现用implement关键字完成 接口中不能有方法体 接口可以继承多个接口 当一个非抽象的类实现接口的话，必须对接口中的抽象方法进行 方法覆盖，同时进行方法覆盖的要求和继承中方法覆盖的要求一样，访问权限只能更高 ，不能更低，一般是public 接口可以继承接口，类可以实现接口，抽象类不可以继承接口 一个类可以实现多个接口（弥补了java中类和类只支持单继承的缺陷，类似于多继承） 接口与接口之间没有继承关系，也可以强制类型转换，编译没错，但是陨星的时候可能 会出现ClassCastException异常，建议接口转型之前进行instanceof进行判断 extends和implements可以共存，extends在前，implements在后 [[044.</description></item><item><title>142_接口eg1</title><link>https://ob.tianzhongs.ml/142_%E6%8E%A5%E5%8F%A3eg1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/142_%E6%8E%A5%E5%8F%A3eg1/</guid><description>142_接口eg1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class Test { public static void main(String[] args) { //调用接口中的常量, System.</description></item><item><title>143_一个类实现多个接口</title><link>https://ob.tianzhongs.ml/143_%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%B8%AA%E6%8E%A5%E5%8F%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/143_%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%B8%AA%E6%8E%A5%E5%8F%A3/</guid><description>143_一个类实现多个接口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public class Test01 { public static void main(String[] args) { D d1=new D(); d1.</description></item><item><title>144_extends和implements同时出现</title><link>https://ob.tianzhongs.ml/144_extends%E5%92%8Cimplements%E5%90%8C%E6%97%B6%E5%87%BA%E7%8E%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/144_extends%E5%92%8Cimplements%E5%90%8C%E6%97%B6%E5%87%BA%E7%8E%B0/</guid><description>144_extends和implements同时出现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 public class Test02 { public static void main(String[] args) { Flyable c1=new Cat();//创建对象，父类型指向子对象。多态 c1.</description></item><item><title>145_接口在开发中的作用</title><link>https://ob.tianzhongs.ml/145_%E6%8E%A5%E5%8F%A3%E5%9C%A8%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/145_%E6%8E%A5%E5%8F%A3%E5%9C%A8%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8/</guid><description>145_接口在开发中的作用 作用 将调用者和实现者解耦合。 调用者面向接口调用，实现者面向接口编写实现。</description></item><item><title>146_is_a、has_a、like_a</title><link>https://ob.tianzhongs.ml/146_is_ahas_alike_a/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/146_is_ahas_alike_a/</guid><description>146_is_a、has_a、like_a 凡是满足“has a”来描述的，表示“关联关系”，统一以属性的方式存在。 1 2 3 class A{ B b } `` 1 2 3 4 class Custer{ //每个顾客手里都有一个菜单，菜单就是另一个接口类，包含了很多的做菜方法 FootMenu footMenu;//顾客有一个菜单，所以设置为属性 } 凡是满足“is a”来描述的，表示可以设置为继承。 1 class A extend B `` 1 2 class Cat extends Animal{ } `` 翻译满足“like a”，表示实现关系，通常是类实现接口。 1 2 class A implements B{ } `` 1 2 3 4 class ChineseCooker implements FoodMenu{ //厨师像一个菜单一样，实现了菜单中的具体方法，所以可以通过类实现接口中的方法 public void cook(){} }</description></item><item><title>147_抽象类和接口的区别</title><link>https://ob.tianzhongs.ml/147_%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/147_%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB/</guid><description>147_抽象类和接口的区别 抽象：抽象类是半抽象的；接口是完全抽象的 构造方法：抽象类中有构造方法；接口中没有构造方法 继承：类与类之间只能单继承；接口与接口之间支持多继承。 实现与继承：一个类可以同时实现（implements）多个接口；一个抽象类只能继承（extends）一个类（单继承） 定义：接口中只允许常量和抽象方法 使用频率：一般接口比抽象类多，抽象类使用的少。接口一般是对行为的抽象，接口就是为了扩展能力。</description></item><item><title>148_接口实现eg2厨师炒菜</title><link>https://ob.tianzhongs.ml/148_%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0eg2%E5%8E%A8%E5%B8%88%E7%82%92%E8%8F%9C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/148_%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0eg2%E5%8E%A8%E5%B8%88%E7%82%92%E8%8F%9C/</guid><description>148_接口实现eg2厨师炒菜 书写接口方法，用来描写具体的做菜方法 1 2 3 4 5 6 //菜单 //用来描述具体的菜单做的东西 public interface FootMenu { void Yuxiangrousi(); void Fanqiechaodan(); } 用类去实现接口中的具体方法 1 2 3 4 5 6 7 8 9 //定义厨师类去具体实现菜单接口中的方法 public class ChineseCooker implements FootMenu{ public void Yuxiangrousi(){ System.</description></item><item><title>151_package</title><link>https://ob.tianzhongs.ml/151_package/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/151_package/</guid><description>151_package 作用 package是java中的包机制，包机制的作用是为了方便程序的管理。不同功能的类分别存放在不同的包下。 package的使用 package是一个IE关键字，后面加包名 只允许出现在java源代码第一行 package com.bkd.jase.chapter17 包名的命名规范 公司域名倒序+项目名+模块名+功能名 对于package的程序，Java程序的运行过程 编译 和以前一样 javac -d 文件名 运行 在项目的根文件夹，采用 包名.</description></item><item><title>152_import机制的使用</title><link>https://ob.tianzhongs.ml/152_import%E6%9C%BA%E5%88%B6%E7%9A%84%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/152_import%E6%9C%BA%E5%88%B6%E7%9A%84%E4%BD%BF%E7%94%A8/</guid><description>152_import机制的使用 当两个类不在一个包内，当 需要调用另一个包的文件时，就需要使用import导入别的包 特殊：java.lang这个包下的类不需要使用，因为他默认是自动导入的
eg ![[../../../../asset/Pasted image 20220713153048.png]]
运行output ![[../../../../asset/Pasted image 20220713153625.png]]
如果不导包，可以采用
1 包名.类名 名称=new 包名.类名 来使用别的包的类</description></item><item><title>161_访问控制权限</title><link>https://ob.tianzhongs.ml/161_%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E6%9D%83%E9%99%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/161_%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E6%9D%83%E9%99%90/</guid><description>161_访问控制权限 四种权限 private 私有的
只能在本类中使用，可以通过封装的方式让外部进行访问 public 公开的
任何位置都可以访问 默认，什么都不写
只能在本类或同包下访问 protected 受保护的</description></item><item><title>171_Object类中的常用方法</title><link>https://ob.tianzhongs.ml/171_Object%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/171_Object%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</guid><description>171_Object类中的常用方法 JDK库的根类：Object
怎么去查找：
源代码中找 查阅java 帮助文档，可以通过javadoc来生成 ![[../../../../asset/Pasted image 20220713193605.png]] 额外知识：
[!API] 应用程序编程接口。（Application Program Interface) 整个JDK的类库就是一个javase的API.</description></item><item><title>172_重写equals方法eg</title><link>https://ob.tianzhongs.ml/172_%E9%87%8D%E5%86%99equals%E6%96%B9%E6%B3%95eg/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/172_%E9%87%8D%E5%86%99equals%E6%96%B9%E6%B3%95eg/</guid><description>172_重写equals方法eg 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 import com.</description></item><item><title>181_匿名内部类</title><link>https://ob.tianzhongs.ml/181_%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/181_%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB/</guid><description>181_匿名内部类 tag: 装逼 注意 ![[182.匿名内部类eg#^8442de]] ![[182.匿名内部类eg#^85d701]]</description></item><item><title>182_匿名内部类eg</title><link>https://ob.tianzhongs.ml/182_%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BBeg/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/182_%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BBeg/</guid><description>182_匿名内部类eg 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 /* 匿名内部类： 1、什么是内部类？ 内部类：在类的内部又定义了一个新的类。被称为内部类。 2、内部类的分类： 静态内部类：类似于静态变量 实例内部类：类似于实例变量 局部内部类：类似于局部变量 3、使用内部类编写的代码，可读性很差。能不用尽量不用。 4、匿名内部类是局部内部类的一种。 因为这个类没有名字而得名，叫做匿名内部类。 5、学习匿名内部类主要是让大家以后在阅读别人代码的时候，能够理解。 并不代表以后都要这样写。因为匿名内部类有两个缺点： 缺点1：太复杂，太乱，可读性差。 缺点2：类没有名字，以后想重复使用，不能用。 6、不理解算了，你只要记住这种写法就行。 */ class Test01{ // 静态变量 static String country; // 该类在类的内部，所以称为内部类 // 由于前面有static，所以称为“静态内部类” static class Inner1{ } // 实例变量 int age; // 该类在类的内部，所以称为内部类 // 没有static叫做实例内部类。 class Inner2{ } // 方法 public void doSome(){ // 局部变量 int i = 100; // 该类在类的内部，所以称为内部类 // 局部内部类。 class Inner3{ } public void doOther(){ // doSome()方法中的局部内部类Inner3，在doOther()中不能用。 } // main方法，入口 public static void main(String[] args){ // 调用MyMath中的mySum方法。 MyMath mm = new MyMath(); /* Compute c = new ComputeImpl(); mm.</description></item><item><title>191_数组</title><link>https://ob.tianzhongs.ml/191_%E6%95%B0%E7%BB%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/191_%E6%95%B0%E7%BB%84/</guid><description>191_数组 概述 Java语言中的数组是一种引用数据类型。不属于基本数据类型。数组的父类是Object。 数组可以同时容纳多个元素。（数组是一个数据的集合。） 数组当中可以存储“基本数据类型”的数据，也可以存储“引用数据类型”的数据。 数组因为是引用类型，数组是存储在堆中的 数组当中如果存储的是“java对象”的话，实际上存储的是对象的引用（内存地址），数组中不能直接存储java对象。 数组一旦创建，数组长度不可变 数组的分类：一维数组. 二维数组. 三维数组. 多维数组&amp;hellip;（一维数组较多，二维数组偶尔使用！） 采用length用来获取数组中元素的个数。 java中的数组要求数组中元素的类型统一。比如int类型数组只能存储int类型，Person类型数组只能存储Person类型。 例如：超市购物，购物袋中只能装苹果，不能同时装苹果和橘子。（数组中存储的元素类型统一） 数组在内存方面存储的时候，存储的每一个元素都是连续的，内存地址连续。数组实际上是一种简单的数据结构。 11.数组中首元素的内存地址作为整个数组对象的内存地址。 数组中每一个元素都是有下标的，下标从0开始，以1递增。最后一个元素的下标是length - 1 存取元素都是通过下标来进行的。 [!</description></item><item><title>192_main方法上面的String_args</title><link>https://ob.tianzhongs.ml/192_main%E6%96%B9%E6%B3%95%E4%B8%8A%E9%9D%A2%E7%9A%84String_args/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/192_main%E6%96%B9%E6%B3%95%E4%B8%8A%E9%9D%A2%E7%9A%84String_args/</guid><description>192_main方法上面的String_args [!tip]+ 作用 这个数组是留给用户的，用户可以在控制台上输入参数，这个参数自动会被转换为“String[] args”
解释 JVM调用main方法的时候，会自动传一个String数组过来。 这个方法程序员负责写出来，JVM负责调用。JVM调用的时候一定会传一个String数组过来。 默认长度：0 ! [[../../../../asset/Pasted image 20220715192618.png|400]]
输入参数 输入会变成一个数组，空格分开各个参数，不是逗号 第一种： 1. 打开run的这个 !</description></item><item><title>193_引用数据类型数组</title><link>https://ob.tianzhongs.ml/193_%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%95%B0%E7%BB%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/193_%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%95%B0%E7%BB%84/</guid><description>193_引用数据类型数组 [!info]+ 总结 数组中可以将引用类型的类型实例作为元素 元素可以是这个元素的类本身的对象，也可以是他的继承对象，即子类型的对象 还可以通过遍历的方式去使用其中的方法
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 public class Test03 { public static void main(String[] args) { // 创建一个Animal类型的数组 Animal[] an={new Animal(),new Cat(),new Dog(),new DogSon()}; for (int i=0;i&amp;lt;an.</description></item><item><title>194_数组扩容</title><link>https://ob.tianzhongs.ml/194_%E6%95%B0%E7%BB%84%E6%89%A9%E5%AE%B9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/194_%E6%95%B0%E7%BB%84%E6%89%A9%E5%AE%B9/</guid><description>194_数组扩容 先新建一个大容量的数组，然后将小容量数组中的数据一个一个拷贝到大数组当中。
[!tip]+ 注意 如果数组的元素是引用，那么数组中存储的其对象的内存地址 所以，拷贝的时候实际是拷贝的内存地址
结论：数组扩容效率较低。因为涉及到拷贝的问题。所以在以后的开发中请注意：尽可能少的进行数组的拷贝。 可以在创建数组对象的时候预估计以下多长合适，最好预估准确，这样可以减少数组的扩容次数。提高效率。
[!bug]+ 数组拷贝方法：arrarycopy() arraycopy() 方法位于 java.lang.System 类中
语法格式
1 System.</description></item><item><title>195_二维数组</title><link>https://ob.tianzhongs.ml/195_%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/195_%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/</guid><description>195_二维数组 概述 二维数组其实是一个特殊的一维数组，特殊在这个数组当中的每一个元素是一个一维数组。 三维数组同理，每一个元素都是一个二维数组 初始化 静态初始化 1 int[][] array = {{1,1,1},{2,3,4,5},{0,0,0,0},{2,3,4,5},{2,3,4,5},{2,3,4,5},{2,3,4,5}}; 动态初始化 1 nt[][] array = new int[3][4]; [!</description></item><item><title>196_eg1_模拟压栈</title><link>https://ob.tianzhongs.ml/196_eg1_%E6%A8%A1%E6%8B%9F%E5%8E%8B%E6%A0%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/196_eg1_%E6%A8%A1%E6%8B%9F%E5%8E%8B%E6%A0%88/</guid><description>196_eg1_模拟压栈 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 /* 编写程序，使用一维数组，模拟栈数据结构。 要求： 1、这个栈可以存储java中的任何引用类型的数据。 2、在栈中提供push方法模拟压栈。（栈满了，要有提示信息。） 3、在栈中提供pop方法模拟弹栈。（栈空了，也有有提示信息。） 4、编写测试程序，new栈对象，调用push pop方法来模拟压栈弹栈的动作。 5、假设栈的默认初始化容量是10.</description></item><item><title>197_eg2_酒店</title><link>https://ob.tianzhongs.ml/197_eg2_%E9%85%92%E5%BA%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/197_eg2_%E9%85%92%E5%BA%97/</guid><description>197_eg2_酒店 思路 [!tip]+ 怎么个思路
搭建一个酒店，需要考虑其基本的组成 一个酒店的基本单位是房间，所以需要一个room类，房间有三个状态。 房间号，由层数和房间号组成 空闲与否，boolean 房间类型：单人间、标准间、豪华间 房间需要考虑是否是一个房间，以及如何进行输出。所以需要考虑重写equals和toString方法 hotel类由许多的房间组成，所以hotel的属性就是room类型的二维数组 需要的方法 打印房间情况的方法 订房的方法 退房的方法 一个主类对方法进行测试 建酒店，new 一个hotel if判断用户需求 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 public class Room { //test /* public static void main(String[] args) { Room r=new Room(12,&amp;#34;单人间&amp;#34;,true); System.</description></item><item><title>201_排序与查找</title><link>https://ob.tianzhongs.ml/201_%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%9F%A5%E6%89%BE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/201_%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%9F%A5%E6%89%BE/</guid><description>201_排序与查找 排序的内置方法java.util.Arrays eg
1 java.util.Arrays(数组名); output ![[../../../../asset/Pasted image 20220720101424.png]]
[[202.冒泡排序方法]] [[203.选择排序]] [[204.顺序查找]] [[205.二分查找]] [[207.数组工具类java.util.Arrays]]</description></item><item><title>202_冒泡排序方法</title><link>https://ob.tianzhongs.ml/202_%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/202_%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95/</guid><description>202_冒泡排序方法 [!tip]+ 讲解
从第一个开始，依次向右比较，左边比右边的数大，就交换两个数字 第一轮可以把最大的数字放到最左边，第二轮依次 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class Test02 { public static void main(String[] args) { int[] b={1,54,6,7,6,464,78,12,46}; int[] c=sorta(b); for (int i = 0; i &amp;lt; c.</description></item><item><title>203_选择排序</title><link>https://ob.tianzhongs.ml/203_%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/203_%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</guid><description>203_选择排序 [!tip]+ 讲解 假设第一个数字为最小的数min，然后依次在这个数字后面找更小的数 如果找到了就记录最小数的下标，然后再把这个数与参与排序的第一个数相互交换 再假设第二个数为最小的数，在其后找最小的数交换 注意：与冒泡排序循环次数一样，都是(n-1)? 阶加次 时间复杂度： O(n²) 演示 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 public class Test03 { public static void main(String[] args) { int[] c=sorta(new int[]{2,3,38,5,47,15,36,26,27,44,46,38,47,50,48}); for (int i = 0; i &amp;lt; c.</description></item><item><title>204_顺序查找</title><link>https://ob.tianzhongs.ml/204_%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/204_%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE/</guid><description>204_顺序查找 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public class SearchTest01 { public static void main(String[] args) { int[] arr={1,5,45,5,64,8}; /* for (int i = 0; i &amp;lt;arr.</description></item><item><title>205_二分查找</title><link>https://ob.tianzhongs.ml/205_%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/205_%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</guid><description>205_二分查找 必要条件:**必须要在排序的基础上 ** 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public class ArraySearch02 { public static void main(String[] args) { int[] arr={1,45,56,78,89,455,1254,4546}; int index=arrBinSearch(arr,78); System.</description></item><item><title>207_数组工具类java_util_Arrays</title><link>https://ob.tianzhongs.ml/207_%E6%95%B0%E7%BB%84%E5%B7%A5%E5%85%B7%E7%B1%BBjava_util_Arrays/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/207_%E6%95%B0%E7%BB%84%E5%B7%A5%E5%85%B7%E7%B1%BBjava_util_Arrays/</guid><description>207_数组工具类java_util_Arrays eg
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import java.</description></item><item><title>2111_String类</title><link>https://ob.tianzhongs.ml/2111_String%E7%B1%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2111_String%E7%B1%BB/</guid><description>2111_String类 String基本 [!tip]+ 关于Java JDK中内置的一个类：java.lang.String
String表示字符串，属于引用数据类型，不属于基本数据类型。 在java中随便使用双引号括起来的都是String对象。例如：&amp;ldquo;abc&amp;rdquo;，&amp;ldquo;def&amp;rdquo;，&amp;ldquo;hello world!&amp;quot;，这是3个String对象。 java中规定，双引号括起来的字符串，是不可变的，也就是说&amp;quot;abc&amp;quot;自出生到最终死亡，不可变，不能变成&amp;quot;abcd&amp;rdquo;，也不能变成&amp;quot;ab&amp;quot; 在JDK当中双引号括起来的字符串，例如：&amp;ldquo;abc&amp;rdquo; &amp;ldquo;def&amp;quot;都是直接存储在“方法区”的“字符串常量池”当中的。因为这些字符串需要频繁的进行使用,垃圾回收器是不会回收常量的 不管是直接用双引号定义的字符串变量,还是new出来的字符串,双引号字符串都是存储在方法区中的常量池的,new出来的,会在堆中存放一个指向这个常量池的内存地址 eg1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class StringTest01 { public static void main(String[] args) { // 这两行代码表示底层创建了3个字符串对象，都在字符串常量池当中。 String s1 = &amp;#34;abcdef&amp;#34;; String s2 = &amp;#34;abcdef&amp;#34; + &amp;#34;xy&amp;#34;; // 分析：这是使用new的方式创建的字符串对象。这个代码中的&amp;#34;xy&amp;#34;是从哪里来的？ // 凡是双引号括起来的都在字符串常量池中有一份。 // new对象的时候一定在堆内存当中开辟空间。 String s3 = new String(&amp;#34;xy&amp;#34;); // i变量中保存的是100这个值。 int i = 100; // s变量中保存的是字符串对象的内存地址。 // s引用中保存的不是&amp;#34;abc&amp;#34;，是0x1111 // 而0x1111是&amp;#34;abc&amp;#34;字符串对象在“字符串常量池”当中的内存地址。 String s = &amp;#34;abc&amp;#34;; } } !</description></item><item><title>2112_String常用方法</title><link>https://ob.tianzhongs.ml/2112_String%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2112_String%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</guid><description>2112_String常用方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 public class Test03 { public static void main(String[] args) { //charAt 返回字符串指定下标的字符 String a=&amp;#34;我是一个中国人&amp;#34;; System.</description></item><item><title>2113_字符串拼接StringBuffer</title><link>https://ob.tianzhongs.ml/2113_%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5StringBuffer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2113_%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5StringBuffer/</guid><description>2113_字符串拼接StringBuffer 在java.lang中 帮助文档 : https://www.matools.com/file/manual/jdk_api_1.8_google/java/lang/StringBuffer.html
概述 [!tip]+ 使用原因
使用+号来对字符串拼接,会在方法区常量池中占用大量的内存,造成方法区的压力(每次拼接都会新建一个字符串在常量池中) 使用StringBuffer可以创建字符串缓冲区对象,缓解常量池压力 默认是创建16byte的数组作为字符串缓冲区对象![[../../../../../asset/Pasted image 20220723102153.png]] ![[../../../../../asset/Pasted image 20220723102210.png]] [!</description></item><item><title>2114_字符串拼接StringBuilder</title><link>https://ob.tianzhongs.ml/2114_%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5StringBuilder/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2114_%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5StringBuilder/</guid><description>2114_字符串拼接StringBuilder 帮助文档: StringBuilder
StringBuilder和[[214.字符串拼接StringBuffer|StringBuffer]]的区别 StringBuilder没有synchronized关键字修饰,所以在多线程环境下是不安全的,而**[[214.字符串拼接StringBuffer|StringBuffer]]在多线程下是安全的** (StringBuilder非线程安全,StringBuffer线程安全) 1 2 3 4 5 6 7 8 9 public class StringBuilderTest01 { public static void main(String[] args) { StringBuilder s1=new StringBuilder(100);//初始化容量 s1.</description></item><item><title>2116_String_int_Integer之间的相互转换</title><link>https://ob.tianzhongs.ml/2116_String_int_Integer%E4%B9%8B%E9%97%B4%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2116_String_int_Integer%E4%B9%8B%E9%97%B4%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/</guid><description>2116_String_int_Integer之间的相互转换 ![[../../../../../asset/005-String Integer int三种类型的互相转换.png]]
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class Test04 { public static void main(String[] args) { //String --&amp;gt; int String s1=&amp;#34;123&amp;#34;; int i1=Integer.</description></item><item><title>2121_java对日期的处理</title><link>https://ob.tianzhongs.ml/2121_java%E5%AF%B9%E6%97%A5%E6%9C%9F%E7%9A%84%E5%A4%84%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2121_java%E5%AF%B9%E6%97%A5%E6%9C%9F%E7%9A%84%E5%A4%84%E7%90%86/</guid><description>2121_java对日期的处理 获取时间以及时间相互转换 包名:- java.util.Date 帮助文档:https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/Date.html
日期格式化SimpleDateFormat帮助文档:https://www.matools.com/file/manual/jdk_api_1.8_google/java/text/SimpleDateFormat.html
获取当前时间 对时间进行格式化输出 文本转换成Date格式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import java.</description></item><item><title>2131_关于数字的格式化</title><link>https://ob.tianzhongs.ml/2131_%E5%85%B3%E4%BA%8E%E6%95%B0%E5%AD%97%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2131_%E5%85%B3%E4%BA%8E%E6%95%B0%E5%AD%97%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96/</guid><description>2131_关于数字的格式化 java.text.DecimalFormat 作用 对数字进行格式化,添加千分位,补位等等 包:https://www.matools.com/file/manual/jdk_api_1.8_google/java/text/DecimalFormat.html eg:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import java.</description></item><item><title>221_异常</title><link>https://ob.tianzhongs.ml/221_%E5%BC%82%E5%B8%B8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/221_%E5%BC%82%E5%B8%B8/</guid><description>221_异常 帮助文档:https://www.matools.com/file/manual/jdk_api_1.8_google/java/lang/Exception.html
概述 异常是一种类,[[#eg2 new异常对象|可以new对象]] 通过处理异常,增加程序的健壮性 eg1 1 2 3 4 5 6 7 8 public class Test01 { public static void main(String[] args) { int c=10/0; /* 代码执行到此处,会出现异常,然后 就会new一个异常对象:Exception in thread &amp;#34;main&amp;#34; java.</description></item><item><title>222_UML_统一建模语言</title><link>https://ob.tianzhongs.ml/222_UML_%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/222_UML_%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/</guid><description>222_UML_统一建模语言 语法来源 使用Mermaid创建类图 帮助文档:http://soft.xiaoshujiang.com/docs/grammar/feature/mermaid/#e7b1bbe59bbe_36 建议博客版本:https://www.cnblogs.com/mybdss/p/14958781.html
[[使用Mermaid语法画UML类图]]</description></item><item><title>223_异常的继承结构</title><link>https://ob.tianzhongs.ml/223_%E5%BC%82%E5%B8%B8%E7%9A%84%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/223_%E5%BC%82%E5%B8%B8%E7%9A%84%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84/</guid><description>223_异常的继承结构 总结 编译阶段异常是不会出现的,编译时异常和运行时异常都是发生在运行阶段 因为异常需要new对象,只有程序运行才会new对象 编译时异常是因为必须在编写代码阶段预先处理,不然编译器就会报错而得名 Object下有Throwable(可抛出) Throwable下有两个分支: Error:错误,不可以处理,终止程序执行,直接退出JVM Exception:异常,可以处理 尽量避免Error,在Exception时就对其进行处理 编译时异常发生概率相对较高 继承结构图 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 classDiagram Object&amp;lt;|--Throwable Throwable:不管是错误还是异常,都是可以抛出的 Throwable&amp;lt;|--Error Error:所有的错误只要发生,java程序都会终止执行,退出JVM Error&amp;lt;|--IOError Error&amp;lt;|--VirtualMachineError Throwable&amp;lt;|--Exception Exception&amp;lt;|--ExceptionSubClass:编译时异常 ExceptionSubClass:不是编译时发生的 ExceptionSubClass:编写程序的时候事先对其进行异常处理 ExceptionSubClass:如果不处理,编译器就会报错 Exception&amp;lt;|--RuntimeException:运行时异常 RuntimeException:运行时异常, RuntimeException:你可以处理,也可以不处理 RuntimeException&amp;lt;|--NullPointerException RuntimeException&amp;lt;|--ClassCastException RuntimeException&amp;lt;|--IllegalArgumentException IllegalArgumentException&amp;lt;|--NumberFormatException %% 写起来还是挺简单的</description></item><item><title>224_异常处理的原理</title><link>https://ob.tianzhongs.ml/224_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E5%8E%9F%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/224_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E5%8E%9F%E7%90%86/</guid><description>224_异常处理的原理 [!tip]+ 强调 所有异常都是发生在运行阶段.
异常处理方法 java对异常的处理有两种方式: 上抛(上报)和捕获
[!tip]+ 异常的两种处理方式
在方法声明的位置上,使用throws关键字,抛给上一级,谁调用我,就抛给谁 [[#eg1 第一种异常处理 添加throws关键字]] 使用try{} catch{}语句进行异常捕获,异常发生了,谁都不知道,但是我抓住了. 相关: [[#第二种异常处理 使用try catch捕获异常]] [[225.</description></item><item><title>225_异常对象的常用方法</title><link>https://ob.tianzhongs.ml/225_%E5%BC%82%E5%B8%B8%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/225_%E5%BC%82%E5%B8%B8%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</guid><description>225_异常对象的常用方法 1 2 3 4 //获取异常的描述信息 String msg=excepiton.getMessage(); //打印异常的堆栈信息 exception.printStackTrace(); 使用printStackTrace不会让程序停止,只是输出堆栈异常信息,程序很健壮
eg1 1 2 3 4 5 6 7 public class Test05 { public static void main(String[] args) { NullPointerException e=new NullPointerException(&amp;#34;空指针异常~&amp;#34;); String msg=e.</description></item><item><title>226_finally语句</title><link>https://ob.tianzhongs.ml/226_finally%E8%AF%AD%E5%8F%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/226_finally%E8%AF%AD%E5%8F%A5/</guid><description>226_finally语句 finally语句通常用于释放资源,这非常有必要. finally中的语句是一定会执行的,除非你退出JVMSystem.exe(0); finally可以不要catch,只要try finally 即使try里面有return,finally中的语句依然会执行 try不能单独使用 ![[225.异常对象的常用方法#eg2]] eg第三点 1 2 3 4 5 6 7 8 9 10 public class Test07 { public static void main(String[] args) { try { System.</description></item><item><title>227_finally面试题</title><link>https://ob.tianzhongs.ml/227_finally%E9%9D%A2%E8%AF%95%E9%A2%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/227_finally%E9%9D%A2%E8%AF%95%E9%A2%98/</guid><description>227_finally面试题 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 package com.</description></item><item><title>228_final,finally,finalize()的区别</title><link>https://ob.tianzhongs.ml/228_finalfinallyfinalize%E7%9A%84%E5%8C%BA%E5%88%AB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/228_finalfinallyfinalize%E7%9A%84%E5%8C%BA%E5%88%AB/</guid><description>228_final,finally,finalize()的区别 [!faq]+ final,finally,finalize()的区别
final,finally是一个关键字, final用于修饰变量,类等等,表示最终的不可变的 finally是用于异常处理try catch,无论异常是否发生,finally中的语句都会发生 finalize是Object中的一个方法,是一个标识符,不是关键字,由JVM的GC垃圾回收器负责调用</description></item><item><title>2291_异常实际例子</title><link>https://ob.tianzhongs.ml/2291_%E5%BC%82%E5%B8%B8%E5%AE%9E%E9%99%85%E4%BE%8B%E5%AD%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2291_%E5%BC%82%E5%B8%B8%E5%AE%9E%E9%99%85%E4%BE%8B%E5%AD%90/</guid><description>2291_异常实际例子 总结 [!tip]+ 书写方法注意点
首先异常类 继承RuntimeException或者Exception 两个方法，一个无参，一个String 其次写栈类：主要用来new对象，以及对异常的抛出 在方法中throws抛出异常 判断if什么情况需要抛出异常throw new StatckOperationException(&amp;quot;异常信息&amp;quot;); 最后测试类 注意try对象的判断，异常情况抛出的e的堆栈信息、异常信息描述是否需要打印 [[225.异常对象的常用方法]] eg1 栈操作 栈操作异常类</description></item><item><title>2292_继承的方法覆盖和异常</title><link>https://ob.tianzhongs.ml/2292_%E7%BB%A7%E6%89%BF%E7%9A%84%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96%E5%92%8C%E5%BC%82%E5%B8%B8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2292_%E7%BB%A7%E6%89%BF%E7%9A%84%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96%E5%92%8C%E5%BC%82%E5%B8%B8/</guid><description>2292_继承的方法覆盖和异常 ![[../../../../asset/Pasted image 20220726163010.png]] 总结： 子类继承父类的时候，方法覆盖的异常不能大于父类的异常，不能比父类异常多。 简单的描述：子类的异常只能是父类异常的子异常或者同等异常，要么就不写 相关：[[../../爪哇基础/07方法覆盖和多态/01方法覆盖/071.方法覆盖override]]
没有异常&amp;gt;父类异常&amp;gt;子类异常 不写就是默认的父类的异常</description></item><item><title>229_如何自定义异常(自己编写异常)</title><link>https://ob.tianzhongs.ml/229_%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E8%87%AA%E5%B7%B1%E7%BC%96%E5%86%99%E5%BC%82%E5%B8%B8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/229_%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E8%87%AA%E5%B7%B1%E7%BC%96%E5%86%99%E5%BC%82%E5%B8%B8/</guid><description>229_如何自定义异常(自己编写异常) 步骤 定义一个异常,继承Exception或者RuntimeException 提供两个方法,一个有参数的,一个String参数的 eg 定义异常
1 2 3 4 5 6 7 8 9 public class MyException extends RuntimeException{ public MyException(){ } public MyException(String s) { super(s); } }</description></item><item><title>2301_集合list概述</title><link>https://ob.tianzhongs.ml/2301_%E9%9B%86%E5%90%88list%E6%A6%82%E8%BF%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2301_%E9%9B%86%E5%90%88list%E6%A6%82%E8%BF%B0/</guid><description>2301_集合list概述 包类: java.util
概述 数组就是以一个集合，但是集合可以容纳不同数据类型的数据 是一个容器，可以一次容纳多个对象 集合存储的是java对象的内存地址，是引用，引用对象本身的内存地址。并不是对象本身。不能存储基本数据类型，也不能存储对象。![[../../../../asset/Pasted image 20220727164431.png]] 不同的集合，底层会对应不同的数据结构，往不同的集合中存储数据，相当于放到了不同的数据结构中 集合分类 Java中集合分为两类：
单个方式存储元素，超级父接口为：java.util.Collection 键值对方式存储元素，超级父接口为：java.util.Map</description></item><item><title>2302集合继承结构图1_Collection</title><link>https://ob.tianzhongs.ml/2302%E9%9B%86%E5%90%88%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84%E5%9B%BE1_Collection/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2302%E9%9B%86%E5%90%88%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84%E5%9B%BE1_Collection/</guid><description>2302集合继承结构图1_Collection 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 classDiagram class Iterable{ &amp;lt;&amp;lt;interface&amp;gt;&amp;gt; +iterator() 所有集合元素都是可以迭代的， 可以遍历的 } class Collection{ &amp;lt;&amp;lt;interface&amp;gt;&amp;gt; Collection } Collection--&amp;gt;Iterator:关联，has a Collection--|&amp;gt;Iterable:泛化，继承，is a class Iterator{ &amp;lt;&amp;lt;interface&amp;gt;&amp;gt; 集合的迭代器对象 +hasNext() +next() +remove() } class List{ &amp;lt;&amp;lt;interface&amp;gt;&amp;gt; 有序可重复 有下标 } %%有序说的是，存进去什么顺序，取出来还是什么顺序，不是大小的排序%% List--|&amp;gt;Collection:泛化 class ArrayList{ 非线程安全 数据结构：数组 } ArrayList.</description></item><item><title>2303集合继承结构图2_Map</title><link>https://ob.tianzhongs.ml/2303%E9%9B%86%E5%90%88%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84%E5%9B%BE2_Map/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2303%E9%9B%86%E5%90%88%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84%E5%9B%BE2_Map/</guid><description>2303集合继承结构图2_Map 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 classDiagram class Map{ &amp;lt;&amp;lt;interface&amp;gt;&amp;gt; } class HashMap{ 非线程安全 数据结构：哈希表 } HashMap.</description></item><item><title>2304_Collection中常用的方法</title><link>https://ob.tianzhongs.ml/2304_Collection%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2304_Collection%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95/</guid><description>2304_Collection中常用的方法 [!faq]+ java.util.collection中能够存放的元素
没有使用泛型，collection中可以存放Object中的所有子类型 使用泛型之后，collection中只能存放某种具体的类型 集合中不能直接存储基本数据类型，也不能存储java对象，存储的只是**java对象的内存地址 eg 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 import java.</description></item><item><title>2305_Collection迭代器的使用Iterator</title><link>https://ob.tianzhongs.ml/2305_Collection%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8Iterator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2305_Collection%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8Iterator/</guid><description>2305_Collection迭代器的使用Iterator [!tip]+ 迭代器遍历步骤
获取集合的迭代器对象itorator Iterator it=xxx.iterator(); 进行迭代器遍历 1 2 3 4 //判断是否有下一个元素，有的话就执行输出，没有就停止循环 while (it.hasNext()){ System.out.println(it.next()); } eg 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import java.</description></item><item><title>2306__Collection的contains</title><link>https://ob.tianzhongs.ml/2306__Collection%E7%9A%84contains/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2306__Collection%E7%9A%84contains/</guid><description>2306__Collection的contains 总结 contains底层调用的是通过equals方法去对内容进行比对，查看查看集合中是否包含，如果是String方法的话，因为已经被重写，所以是比较的字符内容是否包含。 放在集合中的内容，如果要使用contains()或者[[23.07.remove方法|remove()]]，那么必须要重写equals方法 源代码 ![[../../../../asset/Pasted image 20220729090025.png]]
eg 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import java.</description></item><item><title>2307_remove方法</title><link>https://ob.tianzhongs.ml/2307_remove%E6%96%B9%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2307_remove%E6%96%B9%E6%B3%95/</guid><description>2307_remove方法 和contains一样，底层也使用了equals方法去对比，然后删除集合中的对应元素，所以需要重写equals方法 在迭代器迭代的过程中，要使用 迭代器.remove()的方法去删除元，因为集合.remove()会改变集合结构，需要构造new迭代器，不然会出现异常</description></item><item><title>2308_List特有的方法</title><link>https://ob.tianzhongs.ml/2308_List%E7%89%B9%E6%9C%89%E7%9A%84%E6%96%B9%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2308_List%E7%89%B9%E6%9C%89%E7%9A%84%E6%96%B9%E6%B3%95/</guid><description>2308_List特有的方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 import com.</description></item><item><title>2309_ArrayList和Vector</title><link>https://ob.tianzhongs.ml/2309_ArrayList%E5%92%8CVector/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2309_ArrayList%E5%92%8CVector/</guid><description>2309_ArrayList和Vector 属性 ArrayList Vector 默认容量 10 10 扩容容量 1.5倍 2倍 底层 数组 数组 底层 非线程安全 线程安全 优点 检索快 增删快 怎么得到一个线程安全的List： Collections.</description></item><item><title>2310_LinkedList双向链表</title><link>https://ob.tianzhongs.ml/2310_LinkedList%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2310_LinkedList%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</guid><description>2310_LinkedList双向链表 特点 LinkedList没有初始化容量，最初的链表中first和last都是null 增删效率高 不能通过数学表达式计算被查找元素的内存地址，每一次查找都是从头节点开始遍历 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 import javax.</description></item><item><title>2311_LinkedList</title><link>https://ob.tianzhongs.ml/2311_LinkedList/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2311_LinkedList/</guid><description>2311_LinkedList 需要做的： 1. [ ] 手写linkedlist数据结构 2. [ ] 其优点与缺点 3. [ ] 转换成线程安全的方法colllections工具类里面的sync 4. [ ] 泛型机制 5. [ ] 类型自动推断：钻石表达式</description></item><item><title>2311_Vector</title><link>https://ob.tianzhongs.ml/2311_Vector/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2311_Vector/</guid><description>2311_Vector 底层是数组 默认容量10，扩容2倍（ArrayList扩容是1.5倍） 线程安全，但是效率会低 可以采用Collections.synchronizedList(ArrayList);的方法将ArrayList转换为Vector的线程安全 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import java.</description></item><item><title>2312_HashSet和TreeSet</title><link>https://ob.tianzhongs.ml/2312_HashSet%E5%92%8CTreeSet/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2312_HashSet%E5%92%8CTreeSet/</guid><description>2312_HashSet和TreeSet 两个set存入的数据都不会重复 TreeSet存入的数据会自动排序，可排序集合 TreeSet无序可排序，无序值得是存进去和取出来的数据顺序不一样 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import java.</description></item><item><title>2313_Map接口的常用方法</title><link>https://ob.tianzhongs.ml/2313_Map%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2313_Map%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</guid><description>2313_Map接口的常用方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 import java.</description></item><item><title>2314_Map的两种遍历方式</title><link>https://ob.tianzhongs.ml/2314_Map%E7%9A%84%E4%B8%A4%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2314_Map%E7%9A%84%E4%B8%A4%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F/</guid><description>2314_Map的两种遍历方式 Map的两种遍历 Created: July 30, 2022 4:56 PM Tags: 遍历 类别: Map
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 import java.</description></item><item><title>2315_HashMap</title><link>https://ob.tianzhongs.ml/2315_HashMap/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2315_HashMap/</guid><description>2315_HashMap HashMap Created: July 30, 2022 5:18 PM Tags: 实现原理 类别: HashMap
内存图
简述 HashMap：加载因子0.75，默认容量16，初始化容量必须是2的倍数
💡 HashMap类似于由**单向链表组成的数组 数据结构：哈希表** 哈希表的特点： 结合了数组和链表各自的优点，相当于由一个个单向链表组成的数组</description></item><item><title>2316_HashSet重写equals和hashCode方法</title><link>https://ob.tianzhongs.ml/2316_HashSet%E9%87%8D%E5%86%99equals%E5%92%8ChashCode%E6%96%B9%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2316_HashSet%E9%87%8D%E5%86%99equals%E5%92%8ChashCode%E6%96%B9%E6%B3%95/</guid><description>2316_HashSet重写equals和hashCode方法 HashSet重写equals和hashCode方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 import java.</description></item><item><title>2317_HashMap和HashTable的区别</title><link>https://ob.tianzhongs.ml/2317_HashMap%E5%92%8CHashTable%E7%9A%84%E5%8C%BA%E5%88%AB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2317_HashMap%E5%92%8CHashTable%E7%9A%84%E5%8C%BA%E5%88%AB/</guid><description>2317_HashMap和HashTable的区别 HashMap允许key为null，HashTable不允许key和value为null HashTable有线程安全，但是对线程处理效率低，使用较少 HashTable的初始化容量是11，默认加载因子0.75（加载因子：当使用的容量达到这个比率就会进行扩容）；HashMap的初始化容量是16，默认加载因子也是0.75，当链表节点数量大于8，变成红黑树，小于6，变回单向链表 Hashtable的扩容：原容量*2+1</description></item><item><title>2318_Hashtable的Properties属性类</title><link>https://ob.tianzhongs.ml/2318_Hashtable%E7%9A%84Properties%E5%B1%9E%E6%80%A7%E7%B1%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2318_Hashtable%E7%9A%84Properties%E5%B1%9E%E6%80%A7%E7%B1%BB/</guid><description>2318_Hashtable的Properties属性类 帮助文档： Properties
Properties是一个Map集合，继承Hashtable，Properties的key和value都是String类型 被称为属性类对象 两个基本的方法 setProperty()相当于put，getProperty()相当于get
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import java.</description></item><item><title>2319_TreeSet关于排序：实现comparable接口或使用比较器Compartor</title><link>https://ob.tianzhongs.ml/2319_TreeSet%E5%85%B3%E4%BA%8E%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0comparable%E6%8E%A5%E5%8F%A3%E6%88%96%E4%BD%BF%E7%94%A8%E6%AF%94%E8%BE%83%E5%99%A8Compartor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2319_TreeSet%E5%85%B3%E4%BA%8E%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0comparable%E6%8E%A5%E5%8F%A3%E6%88%96%E4%BD%BF%E7%94%A8%E6%AF%94%E8%BE%83%E5%99%A8Compartor/</guid><description>2319_TreeSet关于排序：实现comparable接口或使用比较器Compartor 💡 Comparable和Comparator怎么选择呢？ 当比较规则不会发生改变的时候，或者说**当比较规则只有1个的时候，建议实现Comparable接口。**因为这个要去实现，没下面那个方便，下面那个方便，但是每次都要作为参数传进去 如果比较规则有多个，并且需要多个比较规则之间频繁切换，建议使用Comparator接口。
第一种：实现comparable接口 关于TreeSet自定义类的排序，书写代码时需要注意 继承Comparable接口 override compareTo``方法 有必要的话，把toString方法也override compareTo的比较规则怎么写 通过对象的属性进行比较，比如是String，可以用它本身就实现了的compareTo去进行比较，返回的一个数值能够代表他的数值 通过数值大小比较 使用if结合起来比较 无论怎么写，返回的都是一个数值，通过这个数值进行比较，一般是升序 原因 TreeSet中存入的数据会默认的排序，因为String和Integer都是默认实现了Comparable接口，对排序的规则已经进行了一定，所以不用再写了。 但是，别的自己定义的类，没有定义规则，所以需要实现Comparable接口，不然无法排序，添加节点元素就会报错Customer cannot be cast to java.</description></item><item><title>2320_自平衡二叉树数据结构</title><link>https://ob.tianzhongs.ml/2320_%E8%87%AA%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2320_%E8%87%AA%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid><description>2320_自平衡二叉树数据结构 自平衡二叉树数据结构 原则：遵循左小右大
存放的过程就是排序的过程，取出来就是顺序
三种遍历方式 顺序说的是根的位置
前序遍历：根左右 中序遍历：左根右 TreeSet / TreeMap / Iterator迭代器 后序遍历：左右根 TreeSet和TreeMap采用的是中序遍历
中序表达式画图的例子
取出</description></item><item><title>2321_Collections工具类</title><link>https://ob.tianzhongs.ml/2321_Collections%E5%B7%A5%E5%85%B7%E7%B1%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2321_Collections%E5%B7%A5%E5%85%B7%E7%B1%BB/</guid><description>2321_Collections工具类 基本的使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 import java.</description></item><item><title>241_泛型</title><link>https://ob.tianzhongs.ml/241_%E6%B3%9B%E5%9E%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/241_%E6%B3%9B%E5%9E%8B/</guid><description>241_泛型 泛型这种语法机制，只在程序编译阶段起作用，只是给编译器参考的。 编译器规范了集合的中存储数据的类型，比如就只能存储animal 子类特有方法依旧需要向下转型 泛型必须是引用数据类型，不能是基本数据类型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 import com.</description></item><item><title>242_泛型方法的使用</title><link>https://ob.tianzhongs.ml/242_%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/242_%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8/</guid><description>242_泛型方法的使用 定义
定义方法时同时定义了泛型的方法就是泛型方法 泛型方法的格式 1 2 3 public &amp;lt;T&amp;gt; void show(T name){ 方法体; } 实例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package test; public class Test02 { public static void main(String[] args) { String[] strings={&amp;#34;linsa&amp;#34;,&amp;#34;kanda&amp;#34;,&amp;#34;ondel&amp;#34;,&amp;#34;enter&amp;#34;}; Integer[] integers={2,34,53,5353,53}; // 使用函数进行打印 printArrs(strings); printArrs(integers); } /** * 打印任意类型数组的所有元素 * * @param arrs 泛型的数组 */ public static &amp;lt;T&amp;gt; void printArrs(T[] arrs){ if (arrs!</description></item><item><title>25_foreach</title><link>https://ob.tianzhongs.ml/25_foreach/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/25_foreach/</guid><description>25_foreach 缺点：没有下标，不能及时反馈下标 语法结构
1 2 3 4 For(数据类型 元素：数组或者集合 ){ 带元素的语句; } eg基本使用 1 2 3 4 5 6 7 8 9 public class Test02 { public static void main(String[] args) { int[] arr1={3,45,45,6,4,31,1,31,3,13,13}; for (int num:arr1 ) { System.</description></item><item><title>2801_反射机制</title><link>https://ob.tianzhongs.ml/2801_%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2801_%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</guid><description>2801_反射机制 Created: August 8, 2022 9:23 PM Date: August 8, 2022 类别: 反射机制
包类：java.lang.reflect.*
作用：操作字节码文件
相关的重要类 java.lang.Class 代表整个字节码，整个类型 java.</description></item><item><title>2802_反射机制补充</title><link>https://ob.tianzhongs.ml/2802_%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E8%A1%A5%E5%85%85/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/2802_%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E8%A1%A5%E5%85%85/</guid><description>2802_反射机制补充 反射机制的作用 可以获取类文件（直接操作字节码文件） 可以破坏封装性（打破封装） 可以破坏泛型的约束（因为泛型只是在编译阶段出现异常，编译之后的字节码文件是不存在泛型的，所以可以通过直接操作字节码文件，来达到绕过泛型约束的作用） 更适合于做Java高级框架 采用反射机制 保存对象的所有成员变量值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 package reflectTest; import java.</description></item><item><title>3101_注解</title><link>https://ob.tianzhongs.ml/3101_%E6%B3%A8%E8%A7%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/3101_%E6%B3%A8%E8%A7%A3/</guid><description>3101_注解 Created: August 10, 2022 8:13 PM
[!faq]+ 作用 对Java中类、方法、成员变量做标记，进行特殊处理
基本 注解，或者叫做注释类型，英文单词是：Annotation
注解Annotation是一种引用数据类型。编译之后也是生成xxx.class文
定义 1 2 3 [修饰符列表] @interface 注解名{ public 属性类型 属性名() default 默认值; } 总结 有且只有value属性，可以直接写属性值 设置了default默认值的属性，使用时可以不写属性值，其他属性全都需要写 属性=属性值 注解的属性可以是 byte short int long float double boolean char String Class 枚举类型 以及以上每一种的数组形式。 使用： 注解的使用格式是</description></item><item><title>3102_注解补充</title><link>https://ob.tianzhongs.ml/3102_%E6%B3%A8%E8%A7%A3%E8%A1%A5%E5%85%85/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/3102_%E6%B3%A8%E8%A7%A3%E8%A1%A5%E5%85%85/</guid><description>3102_注解补充 ![faq]+ 解析注解的技巧 注解在哪个成分上，就拿哪个成分对象 比如注解作用于成员方法，就获取成员方法对应的method对象，再拿注解
注解解析案例 eg1 题目
代码
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 package annotationTest; import org.</description></item><item><title>3201_单例设计模式【补充】</title><link>https://ob.tianzhongs.ml/3201_%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A1%A5%E5%85%85/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/3201_%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A1%A5%E5%85%85/</guid><description>3201_单例设计模式【补充】 单例必须将构造器私有化
单例：只需要一个对象即可
饿汉单例模式 使用情况：
在用类获取对象的时候，对象已经提前为你创建好了（提前创建所需要的对象）
设计步骤 定义一个类，构造器私有化 定义一个静态变量存储这个new的类的对象 1 2 3 4 5 6 7 8 9 10 /** a、定义一个单例类 */ public class SingleInstance { /** c.</description></item><item><title>3202_Calendar日历类使用【补充】</title><link>https://ob.tianzhongs.ml/3202_Calendar%E6%97%A5%E5%8E%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E8%A1%A5%E5%85%85/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/3202_Calendar%E6%97%A5%E5%8E%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E8%A1%A5%E5%85%85/</guid><description>3202_Calendar日历类使用【补充】 注意，calendar不能直接new对象，需要通过懒汉单例
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 package test; import sun.</description></item><item><title>3203_Lambda表达式</title><link>https://ob.tianzhongs.ml/3203_Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/3203_Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid><description>3203_Lambda表达式 只能简化函数式接口的匿名内部类的写法
必须是接口，有且只有一个抽象方法 一般这个接口上会加函数式接口的注解@FunctionalInterface 作用
简化匿名内部类的代码写法（Java8的一个新特性)
书写格式 1 2 3 (匿名内部类的被重写的形参列表)-&amp;gt;{ 被重写的方法体; }; 书写格式进一步简化 括号的形参类型可以不写 如果只有一个参数，参数类型可以省略，同时()可以省略 如果Lambda的方法体只有一行代码，可以省略大括号不写，同时需要省略分号； 如果只有一行代码，且是return语句，可以省略return不写，分号也需要省略 实例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 package LambdaTest; import java.</description></item><item><title>3203_正则表达式</title><link>https://ob.tianzhongs.ml/3203_%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/3203_%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid><description>3203_正则表达式 用于匹配字符规则
1 2 3 4 5 6 7 8 9 10 11 12 package d6_regex; public class RegexTest01 { public static void main(String[] args) { System.</description></item><item><title>3204_二叉树、平衡二叉树、红黑树</title><link>https://ob.tianzhongs.ml/3204_%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%BA%A2%E9%BB%91%E6%A0%91/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/3204_%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%BA%A2%E9%BB%91%E6%A0%91/</guid><description>3204_二叉树、平衡二叉树、红黑树 二叉树，查找二叉树（可能会变成瘸子，导致一边高一边低）
平衡二叉树 左右子节点的度数不超过1,
[!faq]+ 平衡二叉树添加元素的过程中出现了不平衡怎么解决
左左：右旋 右右：左旋 左右：找到问题子树，将其左旋，然后将根树进行右旋 右左：找到问题子树，将其右旋，然后将根树进行左旋 红黑树 优点：增删改查性能都很好
规则 根节点必须是黑色，每一个节点是红色或者黑色 每一个节点没有子节点或者父节点，就将其设置为黑色的Nil（大致就是null） 红色节点的子节点必须是黑色，不能出现两个红色父子节点相连的情况 每一个节点，从该节点到所有子节点的简单路径上的黑色节点数是相同的</description></item><item><title>3205_日志技术</title><link>https://ob.tianzhongs.ml/3205_%E6%97%A5%E5%BF%97%E6%8A%80%E6%9C%AF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/3205_%E6%97%A5%E5%BF%97%E6%8A%80%E6%9C%AF/</guid><description>3205_日志技术 常用的日志规范 日志规范一般是一些接口，常用的有
Commons Logging Simple Logging facade for Java 常用的日志框架 Log4j Logback(性能好) Logback日志框架 组成部分 由三部分组成</description></item><item><title>3206_IO流的补充</title><link>https://ob.tianzhongs.ml/3206_IO%E6%B5%81%E7%9A%84%E8%A1%A5%E5%85%85/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/3206_IO%E6%B5%81%E7%9A%84%E8%A1%A5%E5%85%85/</guid><description>3206_IO流的补充 【案例】文件搜索 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 import java.</description></item><item><title>3207_喝酒与瓶子的问题</title><link>https://ob.tianzhongs.ml/3207_%E5%96%9D%E9%85%92%E4%B8%8E%E7%93%B6%E5%AD%90%E7%9A%84%E9%97%AE%E9%A2%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/3207_%E5%96%9D%E9%85%92%E4%B8%8E%E7%93%B6%E5%AD%90%E7%9A%84%E9%97%AE%E9%A2%98/</guid><description>3207_喝酒与瓶子的问题 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 /** * 目标：啤酒2元1瓶，4个盖子可以换一瓶，2个空瓶可以换一瓶， * 请问10元钱可以喝多少瓶酒，剩余多少空瓶和盖子。 * 答案：15瓶 3盖子 1瓶子 */ public class Test02 { public static int totalNumber;//喝酒总数 public static int lastBottleNumber;//最后的空瓶数量 public static int lastCoverNumber;//最后的盖子数量 public static int i=1; public static void main(String[] args) { buy(10); System.</description></item><item><title>3301_单元测试</title><link>https://ob.tianzhongs.ml/3301_%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/3301_%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</guid><description>3301_单元测试 单元测试框架：JUnit
优点： 1. 灵活选择执行哪些方法，也可以一键执行全部的方法。 2. 一键生成测试报告 3. 每个方法独立运行，不会影响其他的方法测试
JUnit的使用方法 导包，一般idea都是自带了该框架（如果没有，就进行导包或者在idea中对测试方法进行注解@Test的时候，alt+enter的弹出框中进行下载导入 ） 1 2 hamcrest-core-1.3.jar junit-4.13.1.jar `` 编写测试代码：必须是公共无参数无返回值的非静态方法 在测试方法上进行注解，标注@Test该方法是测试方法 在测试方法中完成被测试方法的正确性测试 选中测试方法，选择JUnit测试，绿色良好，红色失败 JUnit常用注解 开始执行的方法，用来初始化资源 执行完之后的方法，用来结束资源 4.</description></item><item><title>3401_动态代理</title><link>https://ob.tianzhongs.ml/3401_%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/3401_%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</guid><description>3401_动态代理</description></item><item><title>ADB命令</title><link>https://ob.tianzhongs.ml/ADB%E5%91%BD%E4%BB%A4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/ADB%E5%91%BD%E4%BB%A4/</guid><description>ADB命令 线刷相关 1 2 3 4 5 6 7 adb version #查看adb版本 adb devices #查看连接的手机 adb sideload file.zip #刷zip包到手机 adb reboot #重启 adb reboot fastboot #重启到fastboot adb reboot bootloader #重启到bootloader界面 fast模式下</description></item><item><title>Clash不代理列表</title><link>https://ob.tianzhongs.ml/Clash%E4%B8%8D%E4%BB%A3%E7%90%86%E5%88%97%E8%A1%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/Clash%E4%B8%8D%E4%BB%A3%E7%90%86%E5%88%97%E8%A1%A8/</guid><description>Clash不代理列表 1 com.tencent.mobileqq com.tencent.token com.jingdong.app.mall com.ss.android.ugc.aweme com.sohu.inputmethod.sogou com.taobao.taobao com.netease.cloudmusic com.wuba com.AiQiangGuo com.mmjang.ankihelper com.hpbr.bosszhipin net.csdn.csdnplus ganwu.doing com.estrongs.android.pop com.sangfor.vpn.client.phone org.geometerplus.zlibrary.ui.android com.lerist.fakelocation idm.</description></item><item><title>Git的基本使用</title><link>https://ob.tianzhongs.ml/Git%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/Git%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</guid><description>Git的基本使用 设置代理 1 git config --global http.proxy http://127.0.0.1:7890 提交三部曲 1 2 3 git add . git commit -m &amp;#34;提交内容&amp;#34; git push #提交到远程仓库中 git配置方面 1 2 3 4 5 6 7 git config --global http.</description></item><item><title>HTTP权威手册</title><link>https://ob.tianzhongs.ml/HTTP%E6%9D%83%E5%A8%81%E6%89%8B%E5%86%8C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/HTTP%E6%9D%83%E5%A8%81%E6%89%8B%E5%86%8C/</guid><description>HTTP权威手册 [!summary]+ HTTP权威手册
key value 作者 涓 / 赵振平 标签 网络 阅读时间 2022-10-01 relation null other null [!</description></item><item><title>IO流</title><link>https://ob.tianzhongs.ml/IO%E6%B5%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/IO%E6%B5%81/</guid><description>IO流 IO流 Created: August 1, 2022 8:50 AM 类别: IO
包：java.io
书写注意点 创建流对象的时候异常： 写入对象会有IOException需要捕获，因为你输出输出数据了 读取对象会有FileNotFoundException 需要捕获，因为你读取文件路径要找文件 流关闭的时候会有IOException，同理，你要找文件把它关闭了 先创建的流对象要赋值null，放在try外面，try里面在对文件路径进行赋值，避免在finally关闭的时候找不到变量 output操作一定要记得flush Stream结尾的是字节流，什么文件都可以操作；但是writer和reader结尾的是字符流，专用对普通文本操作，可以 直接进行String的写出 流的分类 流的方向：输入流、输出流 读取数据的方式：字节流、字符流 IO四大家族 java.</description></item><item><title>java学习路程</title><link>https://ob.tianzhongs.ml/java%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/java%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%A8%8B/</guid><description>第一 JavaSE内容： 环境搭建，基础语法，面向 对象，数组，集合，常用API ，IO流，反射机制，多线程，网络编程 学习要求：利用这些基础知识，写出一个soket聊天室和打字游戏，基础不牢地动山摇。
第二 数据库:搞定MYSQL 学习要求：多练SQL，特别是select
第三 前端:
三大核心技术 HTML CSS JavaScript(外带两个框架jQuery,Bootstrap) 学习要求：手写出一个静态页面(模仿一个页面)
第四 后端：
HML,MVC架构模式,Servlet,Filter,JSP,ELSE,JSTL,AJAX,代理模式,工厂模式，数据库连接池 学习要求：1.深刻理解MVC架构模式 2.</description></item><item><title>listyaml</title><link>https://ob.tianzhongs.ml/listyaml/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/listyaml/</guid><description>listyaml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 files: - time: 1661589708617.</description></item><item><title>nextjs-notion-blog</title><link>https://ob.tianzhongs.ml/nextjs-notion-blog/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/nextjs-notion-blog/</guid><description>nextjs-notion-blog Created: September 5, 2022 4:52 PM Tags: 全块适配, 响应快, 悬浮目录 特点: 响应速度快，基本都能在3秒内更新。几乎全部block都可以正常显示。 缺点是无评论区，过于宽的表格在手机上好像没有适配（不好横向翻） 预览url: https://transitivebullsh.it/nextjs-notion-starter-kit
预览 准备 github项目位置</description></item><item><title>On doing nothing</title><link>https://ob.tianzhongs.ml/On-doing-nothing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/On-doing-nothing/</guid><description>On doing nothing [!summary]+ On doing nothing
key value 作者 Roman Muradov 标签 故事 阅读时间 2022-10-01 relation null other null [!</description></item><item><title>README</title><link>https://ob.tianzhongs.ml/README/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/README/</guid><description>Obzhishiku 我的Obsiidan知识库 项目地址: example</description></item><item><title>test</title><link>https://ob.tianzhongs.ml/test/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/test/</guid><description>test |距离下次更新|&amp;lt;%+ 0-(tp.date.now(&amp;ldquo;DDDD&amp;rdquo;)-tp.date.now(&amp;ldquo;DDDD&amp;rdquo;, 0,tp.date.now(&amp;ldquo;YYYY-MM-DD&amp;rdquo;, 7, tp.frontmatter[&amp;ldquo;date modified&amp;rdquo;], &amp;ldquo;YYYY-MM-DD&amp;rdquo;), &amp;ldquo;YYYY-MM-DD&amp;rdquo;))+&amp;ldquo;天&amp;rdquo; %&amp;gt;| 用于记录下次更新时间的</description></item><item><title>test2</title><link>https://ob.tianzhongs.ml/test2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/test2/</guid><description>test2 俄亥俄州的魔鬼 (2022) 名侦探柯南 [[咒怨]] [[四海]] [[国王排名]] [[天国与地狱]] [[../日常/追剧/奇异博士2：疯狂多元宇宙]] [[妙先生]] [[开棺]] [[斗破苍穹年番]] [[机器战警2]] [[某一天]] [[浪客剑心]] [[海上钢琴师]] [[火影忍者]] [[特殊病人]] [[瑞灵顿凶案]] [[米德威奇布谷鸟]] [[纸钞屋西班牙版]] [[纸钞屋韩版]] [[绝密跟踪]] [[虚构安娜]] [[蜘蛛侠]] [[西行纪第四部]] [[误杀]] [[调音师]] [[迷雾 The Mist‎ (2007)]] [[.</description></item><item><title>testkanban</title><link>https://ob.tianzhongs.ml/testkanban/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/testkanban/</guid><description>testkanban 测试看板 关于链接其他文章的
[[006-克隆仓库]] [[../Git学习笔记/005-代码合并的不同方式]] [[../Git学习笔记/005-代码合并的不同方式]] 005-代码合并的不同方式 006-克隆仓库 005-代码合并的不同方式 [[005-代码合并的不同方式]] [[测试看板|扥扥]] 005-代码合并的不同方式 测试看板 005-代码合并的不同方式 [[.</description></item><item><title>Vercel自定义域名</title><link>https://ob.tianzhongs.ml/Vercel%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/Vercel%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D/</guid><description>Vercel自定义域名 Created: September 5, 2022 5:20 PM
准备 域名 vercel已经部署好的网站 步骤 点击vercel中已经部署好的项目，点击set domain中添加已经购买的域名，简单域名和子域名都可以，举例：www.[zhangsan.ml](http://zhangsan.ml) zhangsan.ml 在购买的网站中设置域名解析 在购买的域名服务提供商中填写解析 域名解析填写</description></item><item><title>【项目1】图书管理系统</title><link>https://ob.tianzhongs.ml/%E9%A1%B9%E7%9B%AE1%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E9%A1%B9%E7%9B%AE1%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</guid><description>【项目1】图书管理系统 1. 导包 导入图书管理的包到idea 选择src目录，设置为source root 设置编码为gbk，设置jdk为8或者以上 2. 初始化用户数据 具体步骤 将User实现Serializable，添加序列化号 添加util工具包，添加initdatautil，添加初始化数据的方法 写出initdata通用方法，以及在主函数main方法中，写入具体的持久化user对象的方法，将对象写入到本地硬盘中，具体代码如下 注意：存入本地的对象都需要添加序列号，常用的路径可以加入到常量类中，pathConstant中的user对象存放路径 主要代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 package com.</description></item><item><title>【项目2】多线程下载器步骤</title><link>https://ob.tianzhongs.ml/%E9%A1%B9%E7%9B%AE2%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E8%BD%BD%E5%99%A8%E6%AD%A5%E9%AA%A4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E9%A1%B9%E7%9B%AE2%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E8%BD%BD%E5%99%A8%E6%AD%A5%E9%AA%A4/</guid><description>【项目2】多线程下载器步骤 main方法中写对下载链接进行基本的变量准备，以及输入变量 在工具类util中创建HTTP工具类，其中写下两个静态方法 getHttpURLConnection(String url)：用于获取HttpURLConnection的对象 getHttpFileName(String url) core类 不想写了，主要是对于多线程的使用 通过多线程划分（比如8个线程），将要下载的文件分成8份，异步下载到本地之后，存放在以序号排列的temp临时文件（后缀名可以自定义），然后最后通过每个临时文件的序号按照顺序进行重新写入到一个文件中。 需要注意的是下载的这个每个片段的起始值是在上一个end值上加1</description></item><item><title>【项目3】电影票购票系统</title><link>https://ob.tianzhongs.ml/%E9%A1%B9%E7%9B%AE3%E7%94%B5%E5%BD%B1%E7%A5%A8%E8%B4%AD%E7%A5%A8%E7%B3%BB%E7%BB%9F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E9%A1%B9%E7%9B%AE3%E7%94%B5%E5%BD%B1%E7%A5%A8%E8%B4%AD%E7%A5%A8%E7%B3%BB%E7%BB%9F/</guid><description>【项目3】电影票购票系统 知识点 集合的各种数据类型 查询 Lambda表达式 日志的使用 步骤 进行基本的配置 Logback的jar导入，放到项目的模块目录下，作为as library 配置xml文件，在src目录下 系统角色分析：bean层书写基本的角色类代码，注意各类之间的继承关系 首页设计：对首页的基本功能进行设计，主要包括了商家界面和客户界面 功能设计： 商家 影片库查看 影片上架 影片下架 修改影片信息 客户 查看所有的影片 根据电影名称购买电影票：需要筛选商家，因为不同商家可能都有这部电影 退票：通过用户购票记录进行查询</description></item><item><title>人类交换规律与人类行为准则的发展</title><link>https://ob.tianzhongs.ml/%E4%BA%BA%E7%B1%BB%E4%BA%A4%E6%8D%A2%E8%A7%84%E5%BE%8B%E4%B8%8E%E4%BA%BA%E7%B1%BB%E8%A1%8C%E4%B8%BA%E5%87%86%E5%88%99%E7%9A%84%E5%8F%91%E5%B1%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E4%BA%BA%E7%B1%BB%E4%BA%A4%E6%8D%A2%E8%A7%84%E5%BE%8B%E4%B8%8E%E4%BA%BA%E7%B1%BB%E8%A1%8C%E4%B8%BA%E5%87%86%E5%88%99%E7%9A%84%E5%8F%91%E5%B1%95/</guid><description>人类交换规律与人类行为准则的发展 key value 作者 赫尔曼﹒海因里希﹒戈森 标签 经济 规律 行为 阅读时间 2022-10-01 relation null other 评分低不是因为它本身低，而是因为我看不太懂，讲述了关于人类与经济之前的相互影响，但是就其概括面来说，我很难懂。 [!</description></item><item><title>代理链接</title><link>https://ob.tianzhongs.ml/%E4%BB%A3%E7%90%86%E9%93%BE%E6%8E%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E4%BB%A3%E7%90%86%E9%93%BE%E6%8E%A5/</guid><description>代理链接 基本 v2rayng
1 https://openit.daycat.space/long clash
1 https://openit.daycat.space/clash 可查阅频道链接 TX链接可以去掉tx中的x试试
Name tx链接 tg链接 ✈️ 机场观测 • 白嫖无罪 https://tx.</description></item><item><title>你是我三十六度的风</title><link>https://ob.tianzhongs.ml/%E4%BD%A0%E6%98%AF%E6%88%91%E4%B8%89%E5%8D%81%E5%85%AD%E5%BA%A6%E7%9A%84%E9%A3%8E/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E4%BD%A0%E6%98%AF%E6%88%91%E4%B8%89%E5%8D%81%E5%85%AD%E5%BA%A6%E7%9A%84%E9%A3%8E/</guid><description>“你是我三十九度的风 &amp;quot;
01 - 世间两种罪恶：你笑是一种，你不笑是另外一种。
——@mokilmq
02 - 夜阑卧听风吹雨，铁马是你，冰河也是你 君问归期未有期，巴山是你，夜雨也是你，月落乌啼霜满天。
江枫是你，渔火也是你，玲珑骰子安红豆，入骨是你，相思也是你 山有木兮木有枝，心悦是你，不知也是你。
——@弹得一手棉花
03 - 你是我最爱的一杯酒，喝完我就走。</description></item><item><title>俄亥俄州的魔鬼 (2022)</title><link>https://ob.tianzhongs.ml/%E4%BF%84%E4%BA%A5%E4%BF%84%E5%B7%9E%E7%9A%84%E9%AD%94%E9%AC%BC-2022/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E4%BF%84%E4%BA%A5%E4%BF%84%E5%B7%9E%E7%9A%84%E9%AD%94%E9%AC%BC-2022/</guid><description>俄亥俄州的魔鬼 (2022) [!summary]+ 俄亥俄州的魔鬼 (2022)
key value 周几更新 Invalid date 标签 剧情 / 悬疑 / 惊悚 / 恐怖 主演 艾米丽·丹斯切尔 语言 英语 上次更新时间 null 下次更新时间 Invalid date 进度 已看 8 总集数 8 other undefined [!</description></item><item><title>信封</title><link>https://ob.tianzhongs.ml/%E4%BF%A1%E5%B0%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E4%BF%A1%E5%B0%81/</guid><description>信封 你
要相信世界上一定会有一个你的爱人，
无论你此刻正被光芒环绕，
被掌声淹没，
还是那时你正孤独地走在寒冷的街道上被大雨淋湿，
无论是飘着小雪的微凉清晨，
还是被热浪炙烤的薄暮黄昏，
他一定会穿越这个世界上汹涌的人群，他一一地走过他们，怀着一颗用力跳动的心脏走向你。
他一定会捧着满腔的热和目光里沉甸甸的爱，走向你、抓紧你。
他会迫不及待地走到你的身边，
如果他年轻，
那他一定会像顽劣的孩童霸占着自己的玩具不肯与人分享般的拥抱你。
如果他已经不再年轻，
那他一定会像披荆斩棘归来的猎人，
在你身旁燃起篝火。
然后拥抱着你疲惫而放心地睡去。
他一定会找到你。你要等。</description></item><item><title>关于命名规范的标识符</title><link>https://ob.tianzhongs.ml/009_%E5%85%B3%E4%BA%8E%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%E7%9A%84%E6%A0%87%E8%AF%86%E7%AC%A6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/009_%E5%85%B3%E4%BA%8E%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%E7%9A%84%E6%A0%87%E8%AF%86%E7%AC%A6/</guid><description>009_关于命名规范的标识符 一个知识库的文件如何对各个文件进行命名</description></item><item><title>博人传</title><link>https://ob.tianzhongs.ml/%E5%8D%9A%E4%BA%BA%E4%BC%A0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E5%8D%9A%E4%BA%BA%E4%BC%A0/</guid><description>博人传 [!summary]+ 博人传
key value 周几更新 星期日 标签 动画 / 冒险 主演 三瓶由布子 / 菊池心 语言 日语 上次更新时间 2022-09-25 下次更新时间 2022-10-02 进度 已看 263 总集数 280 other null [!</description></item><item><title>占用的文件夹</title><link>https://ob.tianzhongs.ml/%E5%8D%A0%E7%94%A8%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%B9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E5%8D%A0%E7%94%A8%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%B9/</guid><description>占用的文件夹</description></item><item><title>名侦探柯南</title><link>https://ob.tianzhongs.ml/%E5%90%8D%E4%BE%A6%E6%8E%A2%E6%9F%AF%E5%8D%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E5%90%8D%E4%BE%A6%E6%8E%A2%E6%9F%AF%E5%8D%97/</guid><description>名侦探柯南 [!summary]+ 名侦探柯南
key value 周几更新 星期六 标签 日本 / 动作 / 动画 / 悬疑 主演 高山南 / 山崎和佳奈 / 小山力也 / 高木涉 / 汤屋敦子 语言 日语 上次更新时间 2022-09-24 下次更新时间 2022-10-01 进度 已看 1112 总集数 1120 other null [!</description></item><item><title>咒怨</title><link>https://ob.tianzhongs.ml/%E5%92%92%E6%80%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E5%92%92%E6%80%A8/</guid><description>咒怨 [!summary]+ 咒怨
key value 周几更新 星期三 标签 悬疑 恐怖 主演 奥菜惠 / 伊东美咲 语言 日语 上次更新时间 2022-09-28 下次更新时间 2022-10-05 进度 已看 2 总集数 2 other null [!</description></item><item><title>四海</title><link>https://ob.tianzhongs.ml/%E5%9B%9B%E6%B5%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E5%9B%9B%E6%B5%B7/</guid><description>四海 [!summary]+ 四海
key value 周几更新 Invalid date 标签 喜剧 / 动作 / 爱情 主演 刘昊然 / 刘浩存 语言 中文 上次更新时间 null 下次更新时间 Invalid date 进度 已看 1 总集数 1 other null [!</description></item><item><title>国王排名</title><link>https://ob.tianzhongs.ml/%E5%9B%BD%E7%8E%8B%E6%8E%92%E5%90%8D/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E5%9B%BD%E7%8E%8B%E6%8E%92%E5%90%8D/</guid><description>国王排名 [!summary]+ 国王排名
key value 周几更新 Invalid date 标签 剧情 / 动画 / 冒险 主演 日向未南 / 村瀬步 / 梶裕贵 / 佐藤利奈 / 江口拓也 语言 日语 上次更新时间 null 下次更新时间 Invalid date 进度 已看 23 总集数 23 other null [!</description></item><item><title>图片测试</title><link>https://ob.tianzhongs.ml/%E5%9B%BE%E7%89%87%E6%B5%8B%E8%AF%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E5%9B%BE%E7%89%87%E6%B5%8B%E8%AF%95/</guid><description>第一种 ![[../../asset/QQ截图20220921111413.png]] 第二种 ![[QQ截图20220921111413.png]]
测试一下双链 makrodwn: java学习路程 wiki：[[Atlas/java学习路程]] wiki2：[[Atlas/java学习路程]] wiki3：[[Atlas/java学习路程]]
双链测试2 [[009_关于命名规范的标识符]] 009_关于命名规范的标识符 [[Obsidian/009_关于命名规范的标识符.md]] [[Obsidian/009_关于命名规范的标识符]]</description></item><item><title>圣经故事与美国文学作品赏析</title><link>https://ob.tianzhongs.ml/%E5%9C%A3%E7%BB%8F%E6%95%85%E4%BA%8B%E4%B8%8E%E7%BE%8E%E5%9B%BD%E6%96%87%E5%AD%A6%E4%BD%9C%E5%93%81%E8%B5%8F%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E5%9C%A3%E7%BB%8F%E6%95%85%E4%BA%8B%E4%B8%8E%E7%BE%8E%E5%9B%BD%E6%96%87%E5%AD%A6%E4%BD%9C%E5%93%81%E8%B5%8F%E6%9E%90/</guid><description>圣经故事与美国文学作品赏析 [!summary]+ 圣经故事与美国文学作品赏析
key value 作者 null 标签 null 阅读时间 2022-10-01 relation null other null [!</description></item><item><title>多线程</title><link>https://ob.tianzhongs.ml/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</guid><description>多线程 多线程 Created: August 4, 2022 8:42 AM Date: August 4, 2022 类别: 多线程
书写注意点 方法一 继承 编写一个类，继承Thread（java.lang.Thread），重写run方法 启动线程：在main中new对象，然后使用线程的start()，开辟线程栈空间 方法二 实现 建议 采用这种方式，面向接口编程，更灵活，只能继承一个类，但是接口没有限制</description></item><item><title>天国与地狱</title><link>https://ob.tianzhongs.ml/%E5%A4%A9%E5%9B%BD%E4%B8%8E%E5%9C%B0%E7%8B%B1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E5%A4%A9%E5%9B%BD%E4%B8%8E%E5%9C%B0%E7%8B%B1/</guid><description>天国与地狱 [!summary]+ 天国与地狱
key value 周几更新 Invalid date 标签 悬疑 / 犯罪 主演 绫濑遥 / 高桥一生 / 北村一辉 语言 日语 上次更新时间 null 下次更新时间 Invalid date 进度 已看 10 总集数 10 other null [!</description></item><item><title>奇异博士2：疯狂多元宇宙</title><link>https://ob.tianzhongs.ml/%E5%A5%87%E5%BC%82%E5%8D%9A%E5%A3%AB2%E7%96%AF%E7%8B%82%E5%A4%9A%E5%85%83%E5%AE%87%E5%AE%99/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E5%A5%87%E5%BC%82%E5%8D%9A%E5%A3%AB2%E7%96%AF%E7%8B%82%E5%A4%9A%E5%85%83%E5%AE%87%E5%AE%99/</guid><description># 奇异博士2：疯狂多元宇宙 [!summary]+ 奇异博士2：疯狂多元宇宙
key value 周几更新 Invalid date 标签 null 主演 本尼迪克特·康伯巴奇 语言 英语 上次更新时间 null 下次更新时间 Invalid date 进度 已看 1 总集数 1 other null [!</description></item><item><title>如何写出令人心动的个人陈述</title><link>https://ob.tianzhongs.ml/%E5%A6%82%E4%BD%95%E5%86%99%E5%87%BA%E4%BB%A4%E4%BA%BA%E5%BF%83%E5%8A%A8%E7%9A%84%E4%B8%AA%E4%BA%BA%E9%99%88%E8%BF%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E5%A6%82%E4%BD%95%E5%86%99%E5%87%BA%E4%BB%A4%E4%BA%BA%E5%BF%83%E5%8A%A8%E7%9A%84%E4%B8%AA%E4%BA%BA%E9%99%88%E8%BF%B0/</guid><description>如何写出令人心动的个人陈述 ![[../../../asset/Pasted image 20220827170501.png]] ![[../../../asset/Pasted image 20220827170534.png]] ![[../../../asset/Pasted image 20220827170545.png]] ![[../../../asset/Pasted image 20220827170549.png]] ![[../../../asset/Pasted image 20220827170553.png]] ![[../../../asset/Pasted image 20220827170557.png]] ![[../../../asset/Pasted image 20220827170600.</description></item><item><title>如何提高工作效率</title><link>https://ob.tianzhongs.ml/%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E5%B7%A5%E4%BD%9C%E6%95%88%E7%8E%87/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E5%B7%A5%E4%BD%9C%E6%95%88%E7%8E%87/</guid><description>如何提高工作效率 [!summary]+ 如何提高工作效率
key value 作者 徐伟 标签 效率 阅读时间 2022-10-01 relation null other null [!</description></item><item><title>妙先生</title><link>https://ob.tianzhongs.ml/%E5%A6%99%E5%85%88%E7%94%9F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E5%A6%99%E5%85%88%E7%94%9F/</guid><description>妙先生 [!summary]+ 妙先生
key value 周几更新 Invalid date 标签 null 主演 小连杀 / 宝木中阳 语言 中文 上次更新时间 null 下次更新时间 Invalid date 进度 已看 1 总集数 1 other null [!</description></item><item><title>学校直播的内容</title><link>https://ob.tianzhongs.ml/%E5%AD%A6%E6%A0%A1%E7%9B%B4%E6%92%AD%E7%9A%84%E5%86%85%E5%AE%B9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E5%AD%A6%E6%A0%A1%E7%9B%B4%E6%92%AD%E7%9A%84%E5%86%85%E5%AE%B9/</guid><description>学校直播的内容 创立 7k 拓尔思 5k-10k 主要方向 人工智能 兴致 四方伟业</description></item><item><title>实例：账户取钱</title><link>https://ob.tianzhongs.ml/054%E5%AE%9E%E4%BE%8B%E8%B4%A6%E6%88%B7%E5%8F%96%E9%92%B1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/054%E5%AE%9E%E4%BE%8B%E8%B4%A6%E6%88%B7%E5%8F%96%E9%92%B1/</guid><description>实例：账户取钱 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 package day15作业; /* 写一个名为Account的类模拟账户。 该类的属性和方法如下所示。 该类包括的属性：账户id，余额balance，年利率annualInterestRate； 包含的方法：各属性的set和get方法。取款方法withdraw()，存款方法deposit() 写一个测试程序 （1）创建一个Customer，名字叫Jane Smith，他有一个账号为1000，余额为2000，年利率为1.</description></item><item><title>开棺</title><link>https://ob.tianzhongs.ml/%E5%BC%80%E6%A3%BA/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E5%BC%80%E6%A3%BA/</guid><description>开棺 [!summary]+ 开棺
key value 周几更新 Invalid date 标签 null 主演 韩栋 语言 中文 上次更新时间 null 下次更新时间 Invalid date 进度 已看 1 总集数 1 other null [!</description></item><item><title>情镌三分木，相思万骨书</title><link>https://ob.tianzhongs.ml/%E6%83%85%E9%95%8C%E4%B8%89%E5%88%86%E6%9C%A8%E7%9B%B8%E6%80%9D%E4%B8%87%E9%AA%A8%E4%B9%A6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E6%83%85%E9%95%8C%E4%B8%89%E5%88%86%E6%9C%A8%E7%9B%B8%E6%80%9D%E4%B8%87%E9%AA%A8%E4%B9%A6/</guid><description>情镌三分木，相思万骨书
醉、倾城
　几渚梁梦杯中尽，独影朱阁泪成诗？万里婵娟银河坠，星辰似海踏歌来。故梦千里清铃响，静候梵音斩红尘。——题记。
　那一世，你在这场缠绵的夜雨江南中为他悄悄的撑起那把泛青的油伞；我亦在烽台烛台望你千年之余，我曾听闻你为寻他走遍了千迢万里，踏过了雨雪绯林；而今离他只有那短短的一步之遥。看见你为了他在雨中温柔静候，那眼角滑落下的液体伴随着倾赋予他的漫天思念；静静的洒满这座城市的每一个角落。而我就这样静静的站在你们身后，多余的像极了一幅煞乱风景的残墨；顷刻间充斥着幸福流淌过的每一条暖流。但你是否曾知晓？那雨水从天而降肆无忌惮的在我的脸颊划落；泪水也参杂在雨水里紧附着思念随波逐流的晕开视线里残留下的最后一幅画面。也许你永远都不会知道，今生的我为了等候你那不轻易的回首；似乎比你等他的时间还要长。
　听人说一个人的时候，温起壶中酒；独倚拜月楼，望着庭中盛放的满院流光；凄冷的冬风定会静静的摇落下一地的相思，只为承载起那些忧伤孤独的过往，在岁月的年轮中不停的刻圈成画；却始终画不到那个所谓的终点。有你的曾经一直潜藏在故事里蔓延着最为凄美的片段，梦中的枯藤已千年不绿；被风吹干后的答案；夺走了彼此记忆中最为动人的拥抱。那些禁锢在心底深处的怅然，冲淡了相聚时的喜悦与快乐；难以掩盖的忧伤中载满了无法清点不舍与难过。
　人生短短十数载，梁月何时绕梦中？当彼此的相遇早已为离别埋下了深深的伏笔，当插肩而过时也不会在为过客不留的画面挽留下最后一丝温存；回忆总是美的让人心碎，曾经的过往依旧使人这般沉吟至今。或许那般留恋本不应该赖在记忆中，转进我心里霸占着每一寸缝隙。
　冬日春雨几月寒，半阕红豆怎续情？望穿了奈何秋水，我们终究还是等不到那不期而遇的再见。少了梦里梦外的花开，你说着曾经的相遇是如此的云淡风轻，我想着坐拥过着有你的岁月铅华；那时的我梦中藤萝不香醒，梦醒时节花落西厢。敛一轮皓月星空，抒一卷痴情惘然。怎奈文字铺垫的岁月里依旧美轮美奂，不禁让人再次心涌执念；荡漾起那假睡着的海誓山盟。我曾想待你拂去我眉宇间的忧愁，我愿牵起你的手浪迹天涯。最为灿烂的爱情，过界后也不过是烟花转瞬繁落一季。真正的爱情必然是经得起流年锦瑟的厮守，相伴过帘卷云舒的夕霞；也会共赏着烟雨散尽后的那一池澄碧。而此时的冬风枯叶镌落下一</description></item><item><title>手写代码问题</title><link>https://ob.tianzhongs.ml/%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%E9%97%AE%E9%A2%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%E9%97%AE%E9%A2%98/</guid><description>手写代码问题 手写不熟练的代码 整个文件夹复制,已熟练 写不来的 [[手写单向链表结构]] [[手写学生信息系统]] 奇数偶数轮流输出多线程，同步锁</description></item><item><title>手写单向链表结构</title><link>https://ob.tianzhongs.ml/%E6%89%8B%E5%86%99%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E6%89%8B%E5%86%99%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84/</guid><description>手写单向链表结构 编写程序实现单向链表数据结构： public class Node { Object data; Node next; } public class MyLinkedList{ Node header; &amp;hellip;. // 添加数据的方法 // 删除数据的方法 // 修改数据的方法 // 查找数据的方法 // 打印集合中每个元素的方法 }</description></item><item><title>手写学生信息系统</title><link>https://ob.tianzhongs.ml/%E6%89%8B%E5%86%99%E5%AD%A6%E7%94%9F%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E6%89%8B%E5%86%99%E5%AD%A6%E7%94%9F%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F/</guid><description>手写学生信息系统 1、请使用序列化和反序列化机制，完成学生信息管理系统。
系统打开时显示以下信息： 欢迎使用学生信息管理系统，请认真阅读以下使用说明： 请输入不同的功能编号来选择不同的功能： [1]查看学生列表 [2]保存学生 [3]删除学生 [4]查看某个学生详细信息
学生信息列表展示 学号 姓名 性别 1 zhangsan 男 2 lisi 女 &amp;hellip;.</description></item><item><title>投票系统程序设计缺陷分析</title><link>https://ob.tianzhongs.ml/%E6%8A%95%E7%A5%A8%E7%B3%BB%E7%BB%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BC%BA%E9%99%B7%E5%88%86%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E6%8A%95%E7%A5%A8%E7%B3%BB%E7%BB%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BC%BA%E9%99%B7%E5%88%86%E6%9E%90/</guid><description>投票系统程序设计缺陷分析 🔗MetaURL: https://www.mozhe.cn/bug/detail/anBmazJ1NWIvcnZmcldxMnUvdzZKQT09bW96aGUmozhe
背景介绍 年终了，公司组织了各单位&amp;quot;文明窗口&amp;quot;评选网上投票通知。
实训目标 1、了解浏览器插件的使用； 2、了解开发程序员对IP地址获取方式； 3、了解网络协议软件的使用，如burpsuite等；
解题方向 点击ggg投票进行抓包
添加X-Forwarded-For字段</description></item><item><title>搜索功能</title><link>https://ob.tianzhongs.ml/%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/</guid><description>搜索功能 1 tag:皮肤</description></item><item><title>斗破苍穹年番</title><link>https://ob.tianzhongs.ml/%E6%96%97%E7%A0%B4%E8%8B%8D%E7%A9%B9%E5%B9%B4%E7%95%AA/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E6%96%97%E7%A0%B4%E8%8B%8D%E7%A9%B9%E5%B9%B4%E7%95%AA/</guid><description>斗破苍穹年番 [!summary]+ 斗破苍穹年番
key value 周几更新 星期日 标签 undefined 主演 不一 语言 中文 上次更新时间 2022-09-25 下次更新时间 2022-10-02 进度 已看 11 总集数 12 other null [!</description></item><item><title>月光骑士</title><link>https://ob.tianzhongs.ml/%E6%9C%88%E5%85%89%E9%AA%91%E5%A3%AB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E6%9C%88%E5%85%89%E9%AA%91%E5%A3%AB/</guid><description>月光骑士 [!summary]+ 月光骑士
key value 周几更新 Invalid date 标签 动作 / 奇幻 / 冒险 主演 奥斯卡·伊萨克 / 伊桑·霍克 语言 英语 上次更新时间 null 下次更新时间 Invalid date 进度 已看 6 总集数 6 other null [!</description></item><item><title>机器战警2</title><link>https://ob.tianzhongs.ml/%E6%9C%BA%E5%99%A8%E6%88%98%E8%AD%A62/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E6%9C%BA%E5%99%A8%E6%88%98%E8%AD%A62/</guid><description>机器战警2 [!summary]+ 机器战警2
key value 周几更新 Invalid date 标签 动作 / 科幻 / 惊悚 / 犯罪 主演 彼得·威勒 语言 英语 上次更新时间 null 下次更新时间 Invalid date 进度 已看 1 总集数 2 other null [!</description></item><item><title>某一天</title><link>https://ob.tianzhongs.ml/%E6%9F%90%E4%B8%80%E5%A4%A9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E6%9F%90%E4%B8%80%E5%A4%A9/</guid><description>某一天 [!summary]+ 某一天
key value 周几更新 Invalid date 标签 null 主演 null 语言 韩语 上次更新时间 null 下次更新时间 Invalid date 进度 已看 8 总集数 8 other null [!</description></item><item><title>测试使用子模块的方式</title><link>https://ob.tianzhongs.ml/hello-world/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/hello-world/</guid><description>Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.</description></item><item><title>测试看板</title><link>https://ob.tianzhongs.ml/%E6%B5%8B%E8%AF%95%E7%9C%8B%E6%9D%BF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E6%B5%8B%E8%AF%95%E7%9C%8B%E6%9D%BF/</guid><description>测试看板 [[../Git学习笔记/001-安装之后的配置]] [[../Git学习笔记/003-更新内容一般流程]] [[004-查看历史版本]] [[004-查看历史版本]] [[../Git学习笔记/005-代码合并的不同方式]] [[../Git学习笔记/005-代码合并的不同方式]] [[006-克隆仓库]] 2 AboutTheGarden [[testkanban]] [[../README]] [[Git的基本使用]] - 电影 名侦探 ^iuqny1 [[000.</description></item><item><title>浪客剑心</title><link>https://ob.tianzhongs.ml/%E6%B5%AA%E5%AE%A2%E5%89%91%E5%BF%83/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E6%B5%AA%E5%AE%A2%E5%89%91%E5%BF%83/</guid><description>浪客剑心 [!summary]+ 浪客剑心
key value 周几更新 Invalid date 标签 剧情 / 动作 / 冒险 主演 佐藤健 语言 日语 上次更新时间 null 下次更新时间 Invalid date 进度 已看 66 总集数 6 other null [!</description></item><item><title>海上钢琴师</title><link>https://ob.tianzhongs.ml/%E6%B5%B7%E4%B8%8A%E9%92%A2%E7%90%B4%E5%B8%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E6%B5%B7%E4%B8%8A%E9%92%A2%E7%90%B4%E5%B8%88/</guid><description>海上钢琴师 [!summary]+ 海上钢琴师
key value 周几更新 Invalid date 标签 剧情 / 音乐 主演 蒂姆·罗斯 语言 英语 / 法语 / 意大利语 上次更新时间 null 下次更新时间 Invalid date 进度 已看 1 总集数 1 other null [!</description></item><item><title>火影忍者</title><link>https://ob.tianzhongs.ml/%E7%81%AB%E5%BD%B1%E5%BF%8D%E8%80%85/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E7%81%AB%E5%BD%B1%E5%BF%8D%E8%80%85/</guid><description>火影忍者 [!summary]+ 火影忍者
key value 周几更新 Invalid date 标签 冒险 主演 竹内顺子 语言 日语 上次更新时间 null 下次更新时间 Invalid date 进度 已看 720 总集数 720 other null [!</description></item><item><title>特殊病人</title><link>https://ob.tianzhongs.ml/%E7%89%B9%E6%AE%8A%E7%97%85%E4%BA%BA/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E7%89%B9%E6%AE%8A%E7%97%85%E4%BA%BA/</guid><description>特殊病人 [!summary]+ 特殊病人
key value 周几更新 星期二 标签 剧情 / 悬疑 / 惊悚 主演 史蒂夫·卡瑞尔 语言 英语 上次更新时间 2022-09-27 下次更新时间 2022-10-04 进度 已看 5 总集数 10 other null [!</description></item><item><title>犹太教：一种生活之道</title><link>https://ob.tianzhongs.ml/%E7%8A%B9%E5%A4%AA%E6%95%99%E4%B8%80%E7%A7%8D%E7%94%9F%E6%B4%BB%E4%B9%8B%E9%81%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E7%8A%B9%E5%A4%AA%E6%95%99%E4%B8%80%E7%A7%8D%E7%94%9F%E6%B4%BB%E4%B9%8B%E9%81%93/</guid><description>犹太教：一种生活之道 [!summary]+ 犹太教：一种生活之道
key value 作者 美国 科亨 标签 宗教 阅读时间 2022-10-01 relation null other null [!</description></item><item><title>瑞灵顿凶案</title><link>https://ob.tianzhongs.ml/%E7%91%9E%E7%81%B5%E9%A1%BF%E5%87%B6%E6%A1%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E7%91%9E%E7%81%B5%E9%A1%BF%E5%87%B6%E6%A1%88/</guid><description>瑞灵顿凶案 [!summary]+ 瑞灵顿凶案
key value 周几更新 Invalid date 标签 剧情 主演 蒂姆·罗斯 语言 英语 上次更新时间 null 下次更新时间 Invalid date 进度 已看 3 总集数 3 other null [!</description></item><item><title>电脑的配置</title><link>https://ob.tianzhongs.ml/%E7%94%B5%E8%84%91%E7%9A%84%E9%85%8D%E7%BD%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E7%94%B5%E8%84%91%E7%9A%84%E9%85%8D%E7%BD%AE/</guid><description>电脑的配置 程序安装 epic 阿里云盘（旧版本） 百度网盘 git anki potplayer idm idea vscode everything quicker 秋之盒 safeInClouda9w39zx22n6hhd49 calibre 火绒 geek tg vm 搜狗 网易云音乐</description></item><item><title>目录测试</title><link>https://ob.tianzhongs.ml/%E7%9B%AE%E5%BD%95%E6%B5%8B%E8%AF%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E7%9B%AE%E5%BD%95%E6%B5%8B%E8%AF%95/</guid><description>目录测试 00理论 [[001-JDK、JRE、JVM的关系]]
[[002-Java运行与加载]]
[[003-环境变量]]
[[004-注释方法]]
[[005-public class和class的区别]]
01铺垫 [[010-符号定义]]
[[011-javadoc的使用]]
[[012-不同数据数类型占用大小]]
[[013-接收键盘输入]]
[[014-方法的调用]]
[[015-break和return的区别]]
[[016-方法执行时内存变化]]
[[017-方法重载overload]]
02基本 [[021-递归]]
[[022-面向对象和面向过程]]</description></item><item><title>秘密森林</title><link>https://ob.tianzhongs.ml/%E7%A7%98%E5%AF%86%E6%A3%AE%E6%9E%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E7%A7%98%E5%AF%86%E6%A3%AE%E6%9E%97/</guid><description>秘密森林 [!summary]+ 秘密森林
key value 周几更新 Invalid date 标签 剧情 / 悬疑 / 惊悚 / 犯罪 主演 曹承佑 / 裴斗娜 / 李浚赫 语言 韩语 上次更新时间 null 下次更新时间 Invalid date 进度 已看 16 总集数 16 other null [!</description></item><item><title>空格</title><link>https://ob.tianzhongs.ml/%E7%A9%BA%E6%A0%BC/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E7%A9%BA%E6%A0%BC/</guid><description>空格 四大浮动着森撒</description></item><item><title>算法之美</title><link>https://ob.tianzhongs.ml/%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/</guid><description>算法之美 [!summary]+ 算法之美
key value 作者 Brian ChristianTom Griffiths 标签 算法 生活 阅读时间 2022-10-01 relation null other null [!</description></item><item><title>米德威奇布谷鸟</title><link>https://ob.tianzhongs.ml/%E7%B1%B3%E5%BE%B7%E5%A8%81%E5%A5%87%E5%B8%83%E8%B0%B7%E9%B8%9F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E7%B1%B3%E5%BE%B7%E5%A8%81%E5%A5%87%E5%B8%83%E8%B0%B7%E9%B8%9F/</guid><description>米德威奇布谷鸟 [!summary]+ 米德威奇布谷鸟
key value 周几更新 Invalid date 标签 剧情 / 科幻 / 悬疑 / 惊悚 主演 大卫·法尔 / 萨莎·黑尔斯 / 劳拉·洛马斯 / 纳姆西·汗 / 约翰·温德姆 语言 英语 上次更新时间 null 下次更新时间 Invalid date 进度 已看 7 总集数 7 other null [!</description></item><item><title>类加载器</title><link>https://ob.tianzhongs.ml/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</guid><description>类加载器 类加载器 Created: August 9, 2022 1:53 PM Tags: 类加载
概述 专门负责加载类的命令/工具。 ClassLoader
分类 JDK中自带了3个类加载器
启动类加载器:rt.jar 扩展类加载器:ext/*.jar 应用类加载器:classpath （你设置的那个环境变量） 解释 String s = &amp;ldquo;abc&amp;rdquo;;</description></item><item><title>纸钞屋西班牙版</title><link>https://ob.tianzhongs.ml/%E7%BA%B8%E9%92%9E%E5%B1%8B%E8%A5%BF%E7%8F%AD%E7%89%99%E7%89%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E7%BA%B8%E9%92%9E%E5%B1%8B%E8%A5%BF%E7%8F%AD%E7%89%99%E7%89%88/</guid><description>纸钞屋西班牙版 [!summary]+ 纸钞屋西班牙版
key value 周几更新 Invalid date 标签 动作 / 悬疑 / 犯罪 主演 乌苏拉·科尔维罗 语言 西班牙语 上次更新时间 null 下次更新时间 Invalid date 进度 已看 5 总集数 5 other null [!</description></item><item><title>纸钞屋韩版</title><link>https://ob.tianzhongs.ml/%E7%BA%B8%E9%92%9E%E5%B1%8B%E9%9F%A9%E7%89%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E7%BA%B8%E9%92%9E%E5%B1%8B%E9%9F%A9%E7%89%88/</guid><description>纸钞屋韩版 [!summary]+ 纸钞屋韩版
key value 周几更新 Invalid date 标签 剧情 / 动作 / 悬疑 / 惊悚 / 犯罪 主演 刘智泰 / 金允珍 / 朴海秀 语言 韩语 上次更新时间 null 下次更新时间 Invalid date 进度 已看 2 总集数 2 other null [!</description></item><item><title>绝密跟踪</title><link>https://ob.tianzhongs.ml/%E7%BB%9D%E5%AF%86%E8%B7%9F%E8%B8%AA/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E7%BB%9D%E5%AF%86%E8%B7%9F%E8%B8%AA/</guid><description>绝密跟踪 [!summary]+ 绝密跟踪
key value 周几更新 Invalid date 标签 动作 / 犯罪 主演 薛景求 / 郑雨盛 / 韩孝周 语言 韩语 上次更新时间 null 下次更新时间 Invalid date 进度 已看 1 总集数 1 other null [!</description></item><item><title>考研记</title><link>https://ob.tianzhongs.ml/%E8%80%83%E7%A0%94%E8%AE%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E8%80%83%E7%A0%94%E8%AE%B0/</guid><description>考研记 [!summary]+ 考研记
key value 作者 小莫 标签 考研 阅读时间 2022-10-01 relation null other null [!</description></item><item><title>莫名很喜欢这个文案</title><link>https://ob.tianzhongs.ml/%E8%8E%AB%E5%90%8D%E5%BE%88%E5%96%9C%E6%AC%A2%E8%BF%99%E4%B8%AA%E6%96%87%E6%A1%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E8%8E%AB%E5%90%8D%E5%BE%88%E5%96%9C%E6%AC%A2%E8%BF%99%E4%B8%AA%E6%96%87%E6%A1%88/</guid><description>莫名很喜欢这个文案 [莫名很喜欢这个文案：
你知道，我有很多朋友。
你介意过，我有很多朋友。
我天生长袖善舞，如果愿意，可以把结识的所有人结交成朋友。
除了你。
我永远不想，和你做朋友。
我永远不会再主动发消息给你，
永远不会再和朋友提起你，
永远会控制自己，不再想到你。
你永远在我联系人的最末一位。
和第一位隔了五十三页。
所以有时候我想起你，就一点一点向下翻。
翻到了,就不再那么想你了。
你知道吗?
我的,好朋友。</description></item><item><title>虚构安娜</title><link>https://ob.tianzhongs.ml/%E8%99%9A%E6%9E%84%E5%AE%89%E5%A8%9C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E8%99%9A%E6%9E%84%E5%AE%89%E5%A8%9C/</guid><description>虚构安娜 [!summary]+ 虚构安娜
key value 周几更新 Invalid date 标签 剧情 主演 朱莉娅·加纳 / 安娜·克拉姆斯基 语言 英语 上次更新时间 null 下次更新时间 Invalid date 进度 已看 9 总集数 9 other null [!</description></item><item><title>西行纪第四部</title><link>https://ob.tianzhongs.ml/%E8%A5%BF%E8%A1%8C%E7%BA%AA%E7%AC%AC%E5%9B%9B%E9%83%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E8%A5%BF%E8%A1%8C%E7%BA%AA%E7%AC%AC%E5%9B%9B%E9%83%A8/</guid><description>西行纪第四部 [!summary]+ 西行纪第四部
key value 周几更新 Invalid date 标签 动画 / 奇幻 / 冒险 主演 null 语言 中文 上次更新时间 null 下次更新时间 Invalid date 进度 已看 4 总集数 5 other null [!</description></item><item><title>记忆宫殿</title><link>https://ob.tianzhongs.ml/%E8%AE%B0%E5%BF%86%E5%AE%AB%E6%AE%BF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E8%AE%B0%E5%BF%86%E5%AE%AB%E6%AE%BF/</guid><description>记忆宫殿 [!summary]+ 记忆宫殿
key value 作者 宁梓亦 标签 记忆 效率 阅读时间 2022-10-01 relation null other null [!</description></item><item><title>误杀</title><link>https://ob.tianzhongs.ml/%E8%AF%AF%E6%9D%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E8%AF%AF%E6%9D%80/</guid><description>误杀 [!summary]+ 误杀
key value 周几更新 Invalid date 标签 剧情 / 悬疑 / 犯罪 主演 肖央 / 谭卓 / 陈冲 语言 中文 上次更新时间 null 下次更新时间 Invalid date 进度 已看 2 总集数 2 other null [!</description></item><item><title>调音师</title><link>https://ob.tianzhongs.ml/%E8%B0%83%E9%9F%B3%E5%B8%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E8%B0%83%E9%9F%B3%E5%B8%88/</guid><description>调音师 [!summary]+ 调音师
key value 周几更新 Invalid date 标签 喜剧 / 悬疑 / 惊悚 / 犯罪 主演 阿尤斯曼·库拉纳 / 塔布 / 拉迪卡·艾普特 语言 印度语 英语 上次更新时间 null 下次更新时间 Invalid date 进度 已看 1 总集数 1 other null [!</description></item><item><title>路径的移植性问题</title><link>https://ob.tianzhongs.ml/%E8%B7%AF%E5%BE%84%E7%9A%84%E7%A7%BB%E6%A4%8D%E6%80%A7%E9%97%AE%E9%A2%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E8%B7%AF%E5%BE%84%E7%9A%84%E7%A7%BB%E6%A4%8D%E6%80%A7%E9%97%AE%E9%A2%98/</guid><description>路径的移植性问题 路径的移植性问题 Created: August 9, 2022 2:10 PM
文件路径的移植性问题：根据src获取文件的绝对路径 关键语句
获取路径： String path=Thread.currentThread().getContextClassLoader().getResource(&amp;quot;com/reflect/t1/test.txt&amp;quot;).getPath();
流的方式返回（方便获取配置文件）：InputStream reader=Thread.*currentThread*().getContextClassLoader().getResourceAsStream(&amp;quot;peizhi.properties&amp;quot;);
比如是在类根文件夹下的文件才可以（src目录会复制到out的project目录下）
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import java.</description></item><item><title>迷雾 The Mist‎ (2007)</title><link>https://ob.tianzhongs.ml/%E8%BF%B7%E9%9B%BE-The-Mist-2007/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E8%BF%B7%E9%9B%BE-The-Mist-2007/</guid><description>迷雾 The Mist‎ (2007) [!summary]+ 迷雾 The Mist‎ (2007)
key value 周几更新 Invalid date 标签 科幻 / 惊悚 / 恐怖 主演 托马斯·简 语言 英语 上次更新时间 null 下次更新时间 Invalid date 进度 已看 1 总集数 1 other null [!</description></item><item><title>钢琴家</title><link>https://ob.tianzhongs.ml/%E9%92%A2%E7%90%B4%E5%AE%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E9%92%A2%E7%90%B4%E5%AE%B6/</guid><description>钢琴家 [!summary]+ 钢琴家
key value 周几更新 Invalid date 标签 剧情 / 音乐 / 传记 / 战争 主演 艾德里安·布洛迪 语言 英语 / 德语 / 俄语 上次更新时间 null 下次更新时间 Invalid date 进度 已看 1 总集数 1 other null [!</description></item><item><title>雄狮少年</title><link>https://ob.tianzhongs.ml/%E9%9B%84%E7%8B%AE%E5%B0%91%E5%B9%B4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E9%9B%84%E7%8B%AE%E5%B0%91%E5%B9%B4/</guid><description>雄狮少年 [!summary]+ 雄狮少年
key value 周几更新 Invalid date 标签 剧情 / 喜剧 / 动画 主演 大昕 / 大雄 语言 中文 上次更新时间 null 下次更新时间 Invalid date 进度 已看 1 总集数 1 other null [!</description></item><item><title>鬼吹灯之昆仑神宫(2022)</title><link>https://ob.tianzhongs.ml/%E9%AC%BC%E5%90%B9%E7%81%AF%E4%B9%8B%E6%98%86%E4%BB%91%E7%A5%9E%E5%AE%AB2022/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E9%AC%BC%E5%90%B9%E7%81%AF%E4%B9%8B%E6%98%86%E4%BB%91%E7%A5%9E%E5%AE%AB2022/</guid><description>鬼吹灯之昆仑神宫(2022) [!summary]+ 鬼吹灯之昆仑神宫(2022)
key value 周几更新 星期三 标签 剧情 / 动作 / 冒险 主演 潘粤明 / 张雨绮 语言 中文 上次更新时间 2022-09-28 下次更新时间 2022-10-05 进度 已看 4 总集数 16 other null [!</description></item><item><title>魔女2</title><link>https://ob.tianzhongs.ml/%E9%AD%94%E5%A5%B32/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E9%AD%94%E5%A5%B32/</guid><description>魔女2 [!summary]+ 魔女2
key value 周几更新 Invalid date 标签 undefined 主演 undefined 语言 undefined 上次更新时间 undefined 下次更新时间 Invalid date 进度 已看 undefined 总集数 undefined other undefined [!</description></item><item><title>黑色五叶草</title><link>https://ob.tianzhongs.ml/%E9%BB%91%E8%89%B2%E4%BA%94%E5%8F%B6%E8%8D%89/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E9%BB%91%E8%89%B2%E4%BA%94%E5%8F%B6%E8%8D%89/</guid><description>黑色五叶草 [!summary]+ 黑色五叶草
key value 周几更新 Invalid date 标签 动画 / 奇幻 / 冒险 主演 梶原岳人 语言 日语 上次更新时间 null 下次更新时间 Invalid date 进度 已看 170 总集数 170 other 烂尾了，服了 [!</description></item><item><title>黑鸟</title><link>https://ob.tianzhongs.ml/%E9%BB%91%E9%B8%9F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E9%BB%91%E9%B8%9F/</guid><description>黑鸟 [!summary]+ 黑鸟
key value 周几更新 Invalid date 标签 剧情 / 犯罪 主演 塔伦·埃哲顿 语言 英语 上次更新时间 null 下次更新时间 Invalid date 进度 已看 6 总集数 6 other null [!</description></item><item><title>🌸追剧dataview</title><link>https://ob.tianzhongs.ml/%E8%BF%BD%E5%89%A7dataview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E8%BF%BD%E5%89%A7dataview/</guid><description>🌸追剧dataview 在看 1 2 3 4 5 6 7 8 table WITHOUT ID file.link as 名称, file.link.watchedNumber as 最新观看, &amp;#34;!</description></item><item><title>🌸追剧dataview所有影片</title><link>https://ob.tianzhongs.ml/%E8%BF%BD%E5%89%A7dataview%E6%89%80%E6%9C%89%E5%BD%B1%E7%89%87/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E8%BF%BD%E5%89%A7dataview%E6%89%80%E6%9C%89%E5%BD%B1%E7%89%87/</guid><description>🌸追剧dataview所有影片 1 2 3 4 5 6 7 table WITHOUT ID file.link as 名称, &amp;#34;![fm|40](&amp;#34; +file.link.cover+&amp;#34;)&amp;#34; as 封面, &amp;#34;![](https://progress-bar.dev/&amp;#34; +(round((watchedNumber/totalNumber)*100)) + &amp;#34;)&amp;#34; as 进度 From &amp;#34;日常/追剧&amp;#34; where file.</description></item><item><title>📊Git学习笔记看板</title><link>https://ob.tianzhongs.ml/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%9C%8B%E6%9D%BF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%9C%8B%E6%9D%BF/</guid><description>set [[000-远程仓库一般流程]] [[001-安装之后的配置]] [[002-查看配置信息]] [[003-更新内容一般流程]] [[004-查看历史版本]] [[005-代码合并的不同方式]] [[006-克隆仓库]] %% kanban:settings
1 {&amp;#34;kanban-plugin&amp;#34;:&amp;#34;basic&amp;#34;} %%</description></item><item><title>📊Git实用笔记看板</title><link>https://ob.tianzhongs.ml/Git%E5%AE%9E%E7%94%A8%E7%AC%94%E8%AE%B0%E7%9C%8B%E6%9D%BF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/Git%E5%AE%9E%E7%94%A8%E7%AC%94%E8%AE%B0%E7%9C%8B%E6%9D%BF/</guid><description>set [[Git的基本使用]] %% kanban:settings
1 {&amp;#34;kanban-plugin&amp;#34;:&amp;#34;basic&amp;#34;} %%</description></item><item><title>📊Java作业看板</title><link>https://ob.tianzhongs.ml/Java%E4%BD%9C%E4%B8%9A%E7%9C%8B%E6%9D%BF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/Java%E4%BD%9C%E4%B8%9A%E7%9C%8B%E6%9D%BF/</guid><description>set [[day24_武器作业问题总结]] %% kanban:settings
1 {&amp;#34;kanban-plugin&amp;#34;:&amp;#34;basic&amp;#34;} %%</description></item><item><title>📊Java基础看板</title><link>https://ob.tianzhongs.ml/Java%E5%9F%BA%E7%A1%80%E7%9C%8B%E6%9D%BF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/Java%E5%9F%BA%E7%A1%80%E7%9C%8B%E6%9D%BF/</guid><description>00理论 [[001_JDK、JRE、JVM的关系]] [[002_Java运行与加载]] [[003_环境变量]] [[004_注释方法]] [[005_public_class和class的区别]] 01铺垫 [[010_符号定义]] [[011_javadoc的使用]] [[012_不同数据数类型占用大小]] [[013_接收键盘输入]] [[014_方法的调用]] [[015_break和return的区别]] [[016_方法执行时内存变化]] [[017_方法重载overload]] 02基本 [[021_递归]] [[022_面向对象和面向过程]] [[023_对象和类]] [[024_对象的创建]] [[025_空指针异常]] [[026_方法调用时的参数传递]] 03构造方法 [[031-构造方法]] [[031_构造方法]] [[032_注意事项]] [[033_构造方法举例]] [[034_夫妻结婚]] 04封装 [[041_封装]] [[042_实例方法]] [[043_书写格式]] 05this和static关键字 [[0512_static变量]] [[0512_静态代码块]] [[0514_实例代码块]] [[0515_静态方法和实例方法]] [[0516_空指针访问静态不会空指针]] [[0517_实例方法的调用]] [[0518_不同代码块执行顺序]] [[051_static]] [[0521_this的内存结构]] [[0522_this总结]] [[0523_this例子]] [[0524_变量的分布]] [[0525_this无参调有参构造方法]] [[0525_方法定义static]] [[0526_this的内存结构]] [[0529_变量的分布]] [[052_静态方法和实例方法]] [[053_方法定义static]] [[053_空指针访问静态不会空指针]] [[054_实例方法的调用]] [[054实例：账户取钱]] [[055_不同代码块执行顺序]] 06继承 [[061-继承基本概念-docx [[061_继承基本概念]] [[062_super关键字]] [[063_什么时候可以使用继承]] 07方法覆盖和多态 [[0711_方法覆盖override]] [[0712_覆盖eg]] [[0713_方法覆盖经典例子]] [[0714_例子toString方法覆盖]] [[0721_多态]] [[0722_多态举例]] [[0723_向下转型]] [[0724_instanceof运算符]] [[0725_多态例子a主人喂宠物]] [[0726_宠物养猫优化]] 08遗留问题 [[081_静态方法不存在方法覆盖]] [[082_私有方法无法覆盖]] [[083_关于方法覆盖时的返回值类型]] 09super [[091_suepr关键字]] [[092_构造方法执行顺序]] [[093_使用super调用父类方法]] 10总结 [[101_学习总结]] %% kanban:settings</description></item><item><title>📊Java学习笔记看板</title><link>https://ob.tianzhongs.ml/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%9C%8B%E6%9D%BF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%9C%8B%E6%9D%BF/</guid><description>set [[📊存在的问题看板]] [[📊Java基础看板]] [[📊Java进阶看板]] [[📊Java作业看板]] [[📊JDBC看板]] [[📊MYSQL看板]] [[📊Java项目看板]] d [[📊Java项目看板]] %% kanban:settings
1 {&amp;#34;kanban-plugin&amp;#34;:&amp;#34;basic&amp;#34;} %%</description></item><item><title>📊Java进阶看板</title><link>https://ob.tianzhongs.ml/Java%E8%BF%9B%E9%98%B6%E7%9C%8B%E6%9D%BF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/Java%E8%BF%9B%E9%98%B6%E7%9C%8B%E6%9D%BF/</guid><description>set 11Idea的使用 [[111_Idea的基本使用]] [[112_java相关帮助文档]] 12final关键字 [[121_final]] [[122_final修饰的引用型变量]] [[123_final修饰实例变量]] 13抽象类abstract [[131_抽象类]] [[132_抽象方法]] [[133_例子]] [[134_面试题]] 14接口interface [[141_接口]] [[142_接口eg1]] [[143_一个类实现多个接口]] [[144_extends和implements同时出现]] [[145_接口在开发中的作用]] [[146_is_a、has_a、like_a]] [[147_抽象类和接口的区别]] [[148_接口实现eg2厨师炒菜]] 15package和import机制 [[151_package]] [[152_import机制的使用]] 16访问控制权限 [[161_访问控制权限]] 17根类Object [[171_Object类中的常用方法]] [[172_重写equals方法eg]] 18匿名内部类 [[181_匿名内部类]] [[182_匿名内部类eg]] 19数组 [[191_数组]] [[192_main方法上面的String_args]] [[193_引用数据类型数组]] [[194_数组扩容]] [[195_二维数组]] [[196_eg1_模拟压栈]] [[197_eg2_酒店]] 20排序 [[201_排序与查找]] [[202_冒泡排序方法]] [[203_选择排序]] [[204_顺序查找]] [[205_二分查找]] [[207_数组工具类java_util_Arrays]] 21常用类的使用 [[2111_String类]] [[2112_String常用方法]] [[2113_字符串拼接StringBuffer]] [[2114_字符串拼接StringBuilder]] [[2115_八种包装类型Integer等等]] [[2116_String_int_Integer之间的相互转换]] [[2121_java对日期的处理]] [[2131_关于数字的格式化]] 22异常处理 [[221_异常]] [[222_UML_统一建模语言]] [[223_异常的继承结构]] [[224_异常处理的原理]] [[225_异常对象的常用方法]] [[226_finally语句]] [[227_finally面试题]] [[228_final,finally,finalize()的区别]] [[2291_异常实际例子]] [[2292_继承的方法覆盖和异常]] [[229_如何自定义异常(自己编写异常)]] 23集合 [[2301_集合list概述]] [[2302集合继承结构图1_Collection]] [[2303集合继承结构图2_Map]] [[2304_Collection中常用的方法]] [[2305_Collection迭代器的使用Iterator]] [[2306__Collection的contains]] [[2307_remove方法]] [[2308_List特有的方法]] [[2309_ArrayList和Vector]] [[2310_LinkedList双向链表]] [[2311_LinkedList]] [[2311_Vector]] [[2312_HashSet和TreeSet]] [[2313_Map接口的常用方法]] [[2314_Map的两种遍历方式]] [[2315_HashMap]] [[2316_HashSet重写equals和hashCode方法]] [[2317_HashMap和HashTable的区别]] [[2318_Hashtable的Properties属性类]] [[2319_TreeSet关于排序：实现comparable接口或使用比较器Compartor]] [[2320_自平衡二叉树数据结构]] [[2321_Collections工具类]] 24泛型 [[241_泛型]] [[242_泛型方法的使用]] 25foreach [[25_foreach]] 26IO流 [[IO流]] 27多线程 [[多线程]] 28反射机制 [[28反射机制/2801_反射机制]] [[2802_反射机制补充]] 29类加载器 [[类加载器]] 30路径的移植性问题 [[路径的移植性问题]] 31注解 [[3101_注解]] [[3102_注解补充]] 32补充 [[3201_单例设计模式【补充】]] [[3202_Calendar日历类使用【补充】]] [[3203_Lambda表达式]] [[3203_正则表达式]] [[3204_二叉树、平衡二叉树、红黑树]] [[3205_日志技术]] [[3206_IO流的补充]] [[3207_喝酒与瓶子的问题]] 33单元测试 [[3301_单元测试]] 34动态代理 [[34动态代理/3401_动态代理]] %% kanban:settings</description></item><item><title>📊Java项目看板</title><link>https://ob.tianzhongs.ml/Java%E9%A1%B9%E7%9B%AE%E7%9C%8B%E6%9D%BF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/Java%E9%A1%B9%E7%9B%AE%E7%9C%8B%E6%9D%BF/</guid><description>set [[【项目1】图书管理系统]] [[【项目2】多线程下载器步骤]] [[【项目3】电影票购票系统]] %% kanban:settings
1 {&amp;#34;kanban-plugin&amp;#34;:&amp;#34;basic&amp;#34;} %%</description></item><item><title>📊JDBC看板</title><link>https://ob.tianzhongs.ml/JDBC%E7%9C%8B%E6%9D%BF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/JDBC%E7%9C%8B%E6%9D%BF/</guid><description>set [[0000_总结基本要点]] [[0001_JDBC基本概念]] [[0002_JDBC开发基本使用]] [[0003_JDBC开发6步]] [[0004_Statement和PreparedStatement的区别]] [[0005_JDBC案例：给SQL数据库插入数据]] [[0006_采用Class.forName方式注册驱动]] [[0007_通过资源绑定器获取属性文件]] [[0008_完成第五步，处理结果集]] [[0009_案例：连接数据库，验证用户登录(可被sql注入）]] [[0010_解决sql注入问题的PreparedStatement]] [[0011_事务机制]] [[0012_JBMC封装类]] [[0013_MySQL数据库相关的基本使用]] [[0014_悲观锁（行级锁）以及乐观锁基本认识]] [[??JDBC看板]] %% kanban:settings</description></item><item><title>📊MYSQL看板</title><link>https://ob.tianzhongs.ml/MYSQL%E7%9C%8B%E6%9D%BF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/MYSQL%E7%9C%8B%E6%9D%BF/</guid><description>set [[0001_概述]] [[0002_SQL语句的分类]] [[0003_mysql基本命令使用]] [[0004_查询语句相关]] [[0005_连接]] [[0006__嵌套子查询]] [[0007_union]] [[0008_limit]] [[0009_DML（数据操作语言）]] [[0010_约束(Constraint)]] [[0011_存储引擎]] [[0012_事务]] [[0013_索引]] [[0014视图(view)]] [[0015_DBA命令]] [[0016_数据库设计三范式]] [[0017_一对一怎么设计？]] [[0018_修改root密码]] %% kanban:settings</description></item><item><title>📊Obsidian看板</title><link>https://ob.tianzhongs.ml/Obsidian%E7%9C%8B%E6%9D%BF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/Obsidian%E7%9C%8B%E6%9D%BF/</guid><description>set [[001_部署Obsidian静态知识库网站]] [[002_知识库更新日志]] [[003_Obsidian知识库笔记相关注意事项]] [[004_Yaml字段配置]] [[005_看板目录的使用]] 006_搭建书架教程 007_obsidian相关 009_关于命名规范的标识符 %% kanban:settings
1 {&amp;#34;kanban-plugin&amp;#34;:&amp;#34;basic&amp;#34;} %%</description></item><item><title>📊存在的问题看板</title><link>https://ob.tianzhongs.ml/%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98%E7%9C%8B%E6%9D%BF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98%E7%9C%8B%E6%9D%BF/</guid><description>set [[手写代码问题]] [[手写单向链表结构]] [[手写学生信息系统]] %% kanban:settings
1 {&amp;#34;kanban-plugin&amp;#34;:&amp;#34;basic&amp;#34;} %%</description></item><item><title>📊工作看板</title><link>https://ob.tianzhongs.ml/%E5%B7%A5%E4%BD%9C%E7%9C%8B%E6%9D%BF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E5%B7%A5%E4%BD%9C%E7%9C%8B%E6%9D%BF/</guid><description>set [[学校直播的内容]] %% kanban:settings
1 {&amp;#34;kanban-plugin&amp;#34;:&amp;#34;basic&amp;#34;} %%</description></item><item><title>📊搞机看板</title><link>https://ob.tianzhongs.ml/%E6%90%9E%E6%9C%BA%E7%9C%8B%E6%9D%BF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E6%90%9E%E6%9C%BA%E7%9C%8B%E6%9D%BF/</guid><description>set [[代理链接]] [[ADB命令]] [[Clash不代理列表]] %% kanban:settings
1 {&amp;#34;kanban-plugin&amp;#34;:&amp;#34;basic&amp;#34;} %%</description></item><item><title>📊摘取看板</title><link>https://ob.tianzhongs.ml/%E6%91%98%E5%8F%96%E7%9C%8B%E6%9D%BF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E6%91%98%E5%8F%96%E7%9C%8B%E6%9D%BF/</guid><description>set [[莫名很喜欢这个文案]] [[你是我三十六度的风]] [[情镌三分木，相思万骨书]] [[如何写出令人心动的个人陈述]] [[信封]] %% kanban:settings
1 {&amp;#34;kanban-plugin&amp;#34;:&amp;#34;basic&amp;#34;} %%</description></item><item><title>📊追剧看板</title><link>https://ob.tianzhongs.ml/%E8%BF%BD%E5%89%A7%E7%9C%8B%E6%9D%BF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E8%BF%BD%E5%89%A7%E7%9C%8B%E6%9D%BF/</guid><description>最近在看 [[博人传]] [[秘密森林]] 名侦探柯南 [[斗破苍穹年番]] 鬼吹灯之昆仑神宫(2022) set [[调音师]] [[钢琴家]] [[海上钢琴师]] [[机器战警2]] [[开棺]] [[浪客剑心]] [[某一天]] [[奇异博士2：疯狂多元宇宙]] [[四海]] 奈飞 [[月光骑士]] 俄亥俄州的魔鬼 (2022) [[咒怨]] [[天国与地狱]] [[特殊病人]] [[瑞灵顿凶案]] [[米德威奇布谷鸟]] [[纸钞屋西班牙版]] [[纸钞屋韩版]] [[绝密跟踪]] [[虚构安娜]] [[误杀]] [[魔女2]] [[迷雾 The Mist‎ (2007)]] [[黑鸟]] 动漫 [[国王排名]] [[妙先生]] [[火影忍者]] [[西行纪第四部]] [[雄狮少年]] [[黑色五叶草]] %% kanban:settings</description></item><item><title>📊阅读看板</title><link>https://ob.tianzhongs.ml/%E9%98%85%E8%AF%BB%E7%9C%8B%E6%9D%BF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ob.tianzhongs.ml/%E9%98%85%E8%AF%BB%E7%9C%8B%E6%9D%BF/</guid><description>已看 [[犹太教：一种生活之道]] [[算法之美]] [[On doing nothing]] [[圣经故事与美国文学作品赏析]] [[考研记]] [[HTTP权威手册]] [[人类交换规律与人类行为准则的发展]] [[如何提高工作效率]] [[记忆宫殿]] [[格雷巴旅馆]] [[脑力触发：记忆冠军的大脑训练术]] [[认识自我]] [[科学，改写人类发展史]] [[思维导图]] [[人脸识别原理及算法 动态人脸识别系统研究]] [[最强大脑]] [[高效记忆的技术]] [[Detachment prequel]] %% kanban:settings</description></item></channel></rss>